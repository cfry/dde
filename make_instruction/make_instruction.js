
var MakeInstruction = class MakeInstruction{
   //utilities


    //this is a lousy test. It presumes the src is valid JS and that
    //it is generated by MakeInstruction, so it just filters out
    //the few items you can make with MakeInstruction that
    //aren't valid on a do_list
    static src_looks_like_valid_instruction(src){
       if(starts_with_one_of(src, ["new Dexter(", "new Serial("])){
           return false
       }
       else { return true }
    }

    static dialog_contains_move_all_joints_with_joints(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_all_joints_family)){
            let id = this.arg_name_to_dom_elt_id("joint1")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }
    static dialog_contains_move_to_with_separate_xyzs(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(MiIns.instruction_name_in_family_class(instruction_name, MiIns.move_to_family)){
            let id = this.arg_name_to_dom_elt_id("x")
            let elt = window[id]
            if(elt) { return true }
            else    { return false }
        }
        else { return false }
    }

    static call_obj_arg_obj_with_name(call_obj, arg_name){
        for(let arg_obj of call_obj.args){
            if(arg_obj.name == arg_name) { return arg_obj }
        }
        dde_error("call_obj_arg_obj_with_name couldn't find: " + arg_name + " in: " + call_obj)
    }


    //you can pass "instruction_name" even though its not really an "arg"
    static arg_name_to_dom_elt_id(arg_name){
        if(arg_name.startsWith("mi_arg_")) { return arg_name }
        //if(arg_name.startsWith("...")){ arg_name = arg_name.substring(3) }
        return "mi_arg_" + arg_name + "_id"
    }

    //return a string of the source code of the named arg in the MI dialog
    //returns null if no such name
    static arg_name_to_src_in_mi_dialog(name){
       let elt = window[this.arg_name_to_dom_elt_id(name)]
       if(elt) {
           return elt.value
       }
       else { return null }
    }

    static dom_elt_id_to_arg_name(dom_elt_id){
        let end_pos = dom_elt_id.length - 3
        return dom_elt_id.substring(7, end_pos)
    }

    //the default color is dark gray, meaning its value is ok
    static set_border_color_of_arg(arg_name, color="rgb(238, 238, 238)"){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        let elt = window[id]
        if(elt){
          elt.style.borderColor = color
        }
    }

    static clean_instruction_name(instruction_name){
        if(instruction_name.startsWith("new ")){
            instruction_name = instruction_name.substring(4).trim()
        }
        return instruction_name
    }
    //end utilities

    static find_arg_val_src_in_arg_name_val_src_pairs(arg_name, arg_name_src_pairs){
        for(let pair of arg_name_src_pairs) { if(arg_name == pair[0]) { return pair[1] } }
        return undefined
    }


    //top level fn, called when user option-clicks in editor, passed the selected src.
    //first arg can be a string of js src, or a call obj (used by MakeInstruction.run
    static show(instruction_call_src=null, show_doc=true, set_misc_pane_menu_label=true){
        if(set_misc_pane_menu_label){
            set_misc_pane_menu_selection("Make Instruction")
        }
        let call_obj
        if(typeof(instruction_call_src) == "string"){ //don't use pipeline because we don't want to merge in prev_vals when coming from the editor, just instrudtion def defaults overlayed with src values
            call_obj = MiIns.make_from_instruction_source_no_args(instruction_call_src). //just fill in instruction name
                       merge_in_from_instruction_def().
                       merge_in_src(instruction_call_src)  //do not merge in special_defaults nor prev_values
        }
        else if (instruction_call_src == null){
            call_obj = MiIns.make_from_instruction_name_no_args("Dexter.move_all_joints")
            for(let i = 1; i < 8; i++) {  //not quite the same as merge_in_special_defaults
                let arg_name = "joint" + i
                call_obj.args_obj[arg_name] = "0"
            }
        }
        else {call_obj = instruction_call_src }

        sim_pane_content_id.innerHTML =
            "<div style='background-color:#EEEEEE;margin-bottom:10px;'>" +
                "<div style='font-size:14px;font-weight:700;margin-left:50px;'>" +
                  "<a href='#' onclick='open_doc(make_instruction_pane_doc_id)' style='color:black;'>" + "Make Instruction" +
                  "</a></div>" +
                //this.make_job_robots_select_html(selected_robot_full_name) +
                "<div style='white-space:nowrap;'>" +  //white-space:nowrap;
                    this.make_instruction_menu_html() +
                    this.make_instruction_name_html() +
                "</div>" +
                "<div id='mi_args_id'></div>" +
                this.replace_args_wrapper_html(call_obj) + //"<br/>" +
                "<div style='display:inline-block;vertical-align:50%;'><input id='mi_insert_default_args_id' type='checkbox' style='margin-left:10px;'> Insert default args</input></div><br/>" +
                this.bottom_buttons_html() +
                MiRecord.make_html() +
            "</div>"
        $("#mi_instruction_menu_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
        $("#mi_instruction_menu_id").jqxMenu('setItemOpenDirection', 'mi_instruction_id', 'right', 'up');
        $("#mi_instruction_instance_name_id").jqxComboBox({width: '90px', height: '20px'})
        MiState.init() //if MiState.job_instance is active, (typically suspended, it stops the job, then sets
                       //MiState.job_instance to null, ensuring that, if we're bringing in a new Job def with
                       //this call to show, that new job_def will get used.
        MiRecord.init() //also calls MiState.init(), but does it with the cur MiState.job_instance which is why
                       //we needed to call MiState.init()  first. Its quick, so ok if somewhat redundant.
        MakeInstruction.update_instruction_name_and_args(call_obj, show_doc) //because call_obj isn't for a job,
                //this call won't call  MiRecord.init()
    }

    static is_shown(){
        if(window["mi_instruction_menu_id"]) { return true }
        else { return false }
    }

    /*static onchange_job_robot(event){
       let rob = value_of_path(event.target.value) ///might not be a dexter
       if(rob instanceof Dexter) { Dexter.default = rob }
       else { Dexter.default = Dexter.dexter0 } //yes, I *could* have just
         //left the Dexter.default be its last value.
         //BUT then user would have to remember that,
         //AND that's not what default_dexter()  does (it returns dexter0
         //if the robot in the select widget is NOT a dexter.
         //So beware, changing the select widget from "dex2" to "brain1"
         //will also change Dexter.default to dexter0.
       if(this.get_instruction_name_from_ui() == "new Job"){
           window[this.arg_name_to_dom_elt_id("robot")].value = default_dexter_full_name()
       }
    }
    */
    static make_instruction_menu_item_html(label_array){
      let result = "<li>" + label_array[0] + "<ul>"
      for(let i = 1; i < label_array.length; i++){
         let label = label_array[i]  //setting the width below fails. usingn title lets you see long menu items
         let title
         if (label == "function") { title = "Make a new function definition." }
         else if (label == "function*") { title = "Make a new generator definition."}
         else if (label == "new Dexter") { title = "Make a new Dexter instance.&#013;Beware: this is not a valid do_list item." }
         else if (label == "new Serial") { title = "Make a new Serial instance.&#013;Beware: this is not a valid do_list item." }
         else { title = label}
         result += "<li style='width:300px;' title='" + title + "' onclick='MakeInstruction.instruction_menu_click(event)'>" + label + "</li>"
      }
      result += "</ul></li>"
      return result
    }
    static make_instruction_menu_html(){
       let result = `<div title='Choose the class of instruction to make.' id='mi_instruction_menu_id' class='dde_menu' style="display:inline-block;height:15px;padding:0px;margin-top:5px;">
                      <ul style="display:inline-block;padding:0;margin-top:0px;">
                        <li id="mi_instruction_id" style="display:inline-block;padding-left:3px;padding-right:0px;">Instruction&#9660;<ul>`
       for(let labels of this.menu_hierarchy){
           result += this.make_instruction_menu_item_html(labels)
       }
       result += "</ul></li></ul></div>"
       return result
    }
    static instruction_menu_item_parent(label){
       for(let submenu_array of MakeInstruction.menu_hierarchy){
           if(submenu_array.includes(label)) { return submenu_array[0] }
       }
    }
    static instruction_menu_item_prefix(label){
        let parent_label = this.instruction_menu_item_parent(label)
        if      (parent_label.startsWith("Control")){ return "Control."}
        else if (parent_label.startsWith("Dexter")) { return "Dexter."}
        else if (parent_label.startsWith("Human"))  { return "Human."}
        else if (parent_label.startsWith("IO"))     { return "IO."}
        else if (parent_label.startsWith("Robot"))  { return "Robot."}
        else if (parent_label.startsWith("Serial")) { return "Serial."}
        else { return "" }
    }

    static instruction_menu_click(event){
        let instruction_class_name = event.target.innerText // ie "move_all_joints"
        let instruction_superclass_name = this.instruction_menu_item_prefix(instruction_class_name) //ie "Dexter."
        let superclass_dot_class_name = instruction_superclass_name + instruction_class_name
        this.update_instruction_name_and_args(superclass_dot_class_name)
    }

    static make_instruction_name_html() {
        let instruction_superclass_html = "<input id='mi_instruction_superclass_name_id' title='Instruction Robot superclass'               onchange='MakeInstruction.update_instruction_name_and_args()' style='width:50px;margin-left:5px;vertical-align:25%;font-size:14px;'/>"
        let instruction_instance_html   = "<div   id='mi_instruction_instance_name_id'   title='Instruction Robot instance\nUsually empty.' onchange='MakeInstruction.update_instruction_name_and_args()' style='margin-left:0px;vertical-align:0%;font-size:14px;display:inline-block;'></div>" //set width in "show" method in jqxComboBox init
        let instruction_class_html      = "<input id='mi_instruction_class_name_id'      title='Instruction Robot class'                    onchange='MakeInstruction.update_instruction_name_and_args()' style='width:200px;margin-left:0px;vertical-align:25%;font-size:14px;'/>"
        return instruction_superclass_html + " <span style='font-size:25px;'>.</span>\n" +
               instruction_instance_html   + " <span style='font-size:25px;'>.</span>\n" +
               instruction_class_html + "\n"
    }

    static disable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = ""
        mi_instruction_instance_name_id.onchange = ""
        mi_instruction_class_name_id.onchange = ""
    }
    static enable_instruction_name_onchange(){
        mi_instruction_superclass_name_id.onchange = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_instance_name_id.onchange   = 'MakeInstruction.update_instruction_name_and_args()'
        mi_instruction_class_name_id.onchange      = 'MakeInstruction.update_instruction_name_and_args()'
    }
    static update_instruction_name_ui(instruction_name=""){ //instruction_name looks like "Dexter.move_all_joints" or "Dexter.dexter0.move_all_joints"
        this.disable_instruction_name_onchange() //if I don't do this, I get an infinite loop
        let arr = MiIns.instruction_name_to_array_of_3(instruction_name)
        if(instruction_name == "") {
            mi_instruction_superclass_name_id.value = ""
            mi_instruction_class_name_id.value = ""
        }
        else {
            mi_instruction_superclass_name_id.value = arr[0]
            mi_instruction_class_name_id.value = arr[2]
        }
        this.update_instruction_name_robot_instance_choices(arr[1])
        this.enable_instruction_name_onchange()
    }

    static update_instruction_name_robot_instance_choices(instance_name = ""){
        $("#mi_instruction_instance_name_id").jqxComboBox('clear')
        $("#mi_instruction_instance_name_id").jqxComboBox('addItem', "")
        let superclass_name = this.get_superclass_name_from_ui()
        let rob_superclass = value_of_path(superclass_name)
        if((rob_superclass) && (Array.isArray(rob_superclass.all_names))){
            for(let rob_instance_name of rob_superclass.all_names){
                $("#mi_instruction_instance_name_id").jqxComboBox('addItem', rob_instance_name)
            }
        }
        $("#mi_instruction_instance_name_id").jqxComboBox('selectItem', instance_name)
    }
    //returns true or false. If false, it also prints an error message.
    static validate_instruction_name_ui(instruction_name="get_from_ui"){
        if(instruction_name == "get_from_ui") { instruction_name = this.get_instruction_name_from_ui() }
        let superclass_name  = this.get_superclass_name_from_ui()
        let instance_name    = this.get_instance_name_from_ui() //usually ""
        let class_name       = this.get_class_name_from_ui()
        let is_valid_instruction_name = MiIns.valid_instruction_name(instruction_name)
        if(superclass_name != ""){
            if (!window[superclass_name]){
                this.set_border_color_of_arg("mi_instruction_superclass_name_id", "red")
                out("<span style='color:red'>Error: </span>" +
                    "The instruction superclass name: <code>" + superclass_name + "</code> can't be evaluated.<br/>" +
                    "Please correct errors and try again.")
                return false
            }
            else { //superclass is present and ok
                if (Robot.is_valid_robot_class_name(superclass_name) &&
                    !Robot.robot_instances_exist_for_running_instructions_of_superclass(superclass_name)){
                    warning("No instance of Robot class: <code style='color:black;'>" + superclass_name + "</code> exists.<br/>" +
                            "You'll have to create one before running instructions on it.<br/>" +
                            "The <button>Instruction&#9660;</button> menu, <b style='color:black;'>Misc</b> submenu<br/>" +
                            "contains items to create Robot instances.")
                }
                if (instance_name != "")
                    if(!value_of_path(superclass_name + "." + instance_name)){
                        this.set_border_color_of_arg("mi_instruction_instance_name_id", "red")
                        out("<span style='color:red'>Error: </span>" +
                            "The instruction instance name: <code>" + instance_name + "</code> isn't in " + superclass_name + ".<br/>" +
                            "Please correct errors and try again.")
                        return false
                    }
                    else {
                        if(class_name != "") { //got all 3, first 2 ok
                           if(!is_valid_instruction_name){
                                this.error_for_class_name(class_name)
                                return false
                            }
                        }
                    }
                else { //superclass_name present and ok, no instance_name
                    if(class_name != "") {
                        if(!is_valid_instruction_name){
                            this.error_for_class_name(class_name)
                            return false
                        }
                    }
                }
            }
        }
        else{ //no superclass, presumably no instance_name
            if(class_name != "") {
                if(!is_valid_instruction_name) {
                    this.error_for_class_name(class_name)
                    return false
                }
            }
        }
        //if we haven't returned by now, all is good
        this.set_border_color_of_arg("mi_instruction_superclass_name_id")
        this.set_border_color_of_arg("mi_instruction_instance_name_id")
        this.set_border_color_of_arg("mi_instruction_class_name_id")
        return true
    }

    static error_for_class_name(class_name){
        this.set_border_color_of_arg("mi_instruction_class_name_id", "red")
        out("<span style='color:red'>Error: </span>" +
            "The class name: <code>" + class_name +
            "</code> is not valid.<br/>" +
            "Correct errors and try again.")
    }

   //returns format of "Dexter.dexter0.move_all_joints",
   //"Dexter.move_all_joints"
   //"some_fn"
    static get_instruction_name_from_ui(){
        let superclass_name = this.get_superclass_name_from_ui()
        let instance_name   = this.get_instance_name_from_ui()
        let class_name      = this.get_class_name_from_ui()
        return MiIns.make_instruction_name(superclass_name, instance_name, class_name)
    }

    static get_superclass_name_from_ui(){
        return mi_instruction_superclass_name_id.value
    }

    static get_instance_name_from_ui(){
        let result = $("#mi_instruction_instance_name_id").jqxComboBox("getSelectedItem")
        if ((result === null) || (result === undefined)) { return "" }
        else { return result.label }
    }

    static get_class_name_from_ui(){
        return mi_instruction_class_name_id.value
    }

    // call_obj can be just a string of the fn name,
    // or a call_obj with an instruction_name
    // or undefined (as when user types ENTER when in the instruction name field
    //called when the instruction name is changed.
    //beware sometimes happens automagically.
    static update_instruction_name_and_args(call_obj_or_instruction_name, show_doc=true){
        let old_call_object = this.make_call_obj_from_ui() //beware, this might have new instruction name, but we're just using this for its args
        //MiIns.prev_defaults.merge_in(old_call_object)
        let old_fam_class = get_class_of_instance(old_call_object)
        old_fam_class.save_prev_call_obj_of_name(old_call_object)
        let instruction_name, call_obj
        if (call_obj_or_instruction_name === undefined) {
            call_obj_or_instruction_name = this.get_instruction_name_from_ui()
        }
        if (typeof(call_obj_or_instruction_name) == "string"){
            instruction_name = call_obj_or_instruction_name
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
            call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_pipeline()
            if(call_obj_or_instruction_name == "new Job") {
                call_obj.args_obj.name = '"' + Job.generate_default_name() + '"'
            }
            else if(call_obj_or_instruction_name == "new Dexter") {
                call_obj.args_obj.name = '"' + Dexter.generate_default_name() + '"'
            }
        }
        else if (typeof(call_obj_or_instruction_name) == "object"){
            call_obj = call_obj_or_instruction_name
            instruction_name = call_obj.get_instruction_name()
            if(!this.validate_instruction_name_ui(instruction_name)) {  //shows error messages, displays red ret
                return false
            }
        }
        else { shouldnt("in update_instruction_name_and_args passed invalid: " + call_obj_or_instruction_name) }
        //now instruction_name and call_obj set with call_obj having a name and all its args.
        this.update_instruction_name_ui(instruction_name)
        //this.validate_instruction_name_ui() //alread done above
        //this.update_instruction_name_robot_instance_choices(call_obj.instance_name) //needs to be after update & validate instruction_name
        //this probably never happens:  if (!call_obj.args_obj) { this.fill_in_call_obj_args_from_name(call_obj) }
        this.update_instruction_args(call_obj)
        this.install_replace_args_menu_items()
        if(show_doc){
            if(instruction_name.startsWith("new ")){
                instruction_name = instruction_name.substring(4)
            }
            let id = instruction_name + "_doc_id"
            if(window[id]) { open_doc(id) }
        }
        if (instruction_name == "Job") {
            window[this.arg_name_to_dom_elt_id("robot")].value = default_dexter_full_name()
            mi_run_id.title = "Start the job defined by the above fields."
            MiRecord.init_with_job_in_dialog()
        }
        else { mi_run_id.title = 'Make a job with the instruction in it\nand start the job.'}
    }

    static update_instruction_args_for_function_html(call_obj){
        let id = this.arg_name_to_dom_elt_id("name")
        let name_src  = call_obj.args_obj.name
        let name_html = "<div style='margin:5px;white-space:nowrap;'>name: <input class='mi_arg_val_src' placeholder='do_list functions don&apos;t need names.' style='width:300px;font-size:13px;' id='" + id + "' value='" + name_src + "'/></div>"
        id = this.arg_name_to_dom_elt_id("...params")
        let params_src  = call_obj.args_obj["...params"]
        let params_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>...params:</span>\n" +
            "<textarea class='mi_arg_val_src' rows='2' placeholder='Ex: arg_name1, arg_name2=default_value\nbut do_list functions aren&apos;t passed arguments.' style='width:300px;font-size:13px;' id='" +
            id + "'>" + params_src + "</textarea>\n" +
            "</div>"
        id = this.arg_name_to_dom_elt_id("body")
        let body_src  = call_obj.args_obj.body
        let body_html = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>body:</span>\n" +
            `<textarea class='mi_arg_val_src' rows='4' placeholder='When a function definition in a do_list is called,\nthe "this" variable is bound to the job.' style='width:300px;font-size:13px;' id='` +
            id + "'>" + body_src + "</textarea>\n" +
            "</div>"
        let args_html = name_html + params_html + body_html
        return  args_html
    }

    static update_instruction_args(call_obj){
        let args_html = ""
        let instruction_name = call_obj.get_instruction_name()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        if (family_class == MiIns.function_family){
            args_html = this.update_instruction_args_for_function_html(call_obj)
        }
        else if((family_class == MiIns.move_all_joints_family) &&
                 call_obj.args_obj.hasOwnProperty("joint1")){
            for(let j=1; j < 8; j++){
                let arg_name = "joint" + j
                let arg_val_src = call_obj.args_obj[arg_name]
                if(arg_val_src === undefined) { arg_val_src = "0" }
                args_html += this.make_arg_html(instruction_name, arg_name, arg_val_src)
            }
        }
        else { //handles the 1 arg case of move_all_joints and most other instructions
            let prop_names = Object.getOwnPropertyNames(call_obj.args_obj)
            for(let arg_name of prop_names){
                //handles xyz arg of move_to family
                if(((arg_name == "xyz") || (arg_name == "delta_xyz")) &&
                    call_obj.args_obj.hasOwnProperty("x")) {
                    for(let arg_name of ["x", "y", "z"]){
                        let arg_val_src = call_obj.args_obj[arg_name]
                        if(arg_val_src === undefined) { arg_val_src = "0" }
                        args_html += this.make_arg_html(instruction_name, arg_name, arg_val_src)
                    }
                }
                //handles most args
                else {
                    let arg_val_src = call_obj.args_obj[arg_name]
                    if(arg_val_src === undefined) { arg_val_src = "" }
                    let suffix = ""
                    if(instruction_name == "new Job"){
                        if (arg_name == "do_list") {
                            suffix = "<details><summary><i>more args...</i></summary>\n"
                        }
                        else if (arg_name == last(prop_names)){
                            suffix = "</details>"
                        }
                    }
                    args_html += this.make_arg_html(instruction_name, arg_name, arg_val_src) +
                                 suffix
                }
            }
        }
        mi_args_id.innerHTML = args_html
    }

    static make_arg_html(instruction_name, arg_name, arg_val_src){
        let id = this.arg_name_to_dom_elt_id(arg_name)
        if(arg_name.startsWith("...") ||
           ["do_list", "body"].includes(arg_name) ||
           arg_val_src.includes("\n")){
           let placeholder = 'Separate rest args with a comma.'
           if (arg_name == "body") { placeholder = "separate statements with newline or semicolon."}
           let rows = 4
           if(arg_name == "...params") { rows = 2 }
           let result = "<div style='margin:5px;white-space:nowrap;'><span style='vertical-align:top;'>" + arg_name + ":</span>\n" +
                         "<textarea class='mi_arg_val_src' rows='" + rows + "' placeholder='" + placeholder + "' oninput='MiState.invalidate_job_instance()'" +
                            " onclick='Editor.show_identifier_info_for_type_in(event)' " +
                            " style='width:300px;font-size:13px;' id='" + id + "'>" +
                             arg_val_src + "</textarea>\n" +
                          "</div>"
           return result
        }
        /*else if((instruction_name == "Dexter.set_parameter") &&
                 arg_name == "name"){
            let result = "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <select class='mi_arg_val_src' id='" + id + "'>\n"
            for(let name of Series.id_to_series("series_set_parameter_name_id").array){
                let sel_html = ""
                if(name == arg_val_src.substring(1, arg_val_src.length - 1)) { //strip the extra quotes off of arg_val_src for the comparision
                    sel_html = " selected='selected' "
                }
                let val_html = ` value='"` + name + `"' `
                let opt_html = "<option " + val_html + sel_html + " >" + name + "</option>\n"
                result += opt_html
            }
            result += "</select></div>"
            return result
        }*/
        else if((instruction_name == "Dexter.set_parameter") &&
                 (arg_name == "name")){ //got a combobox
            let array_of_possible_values_raw = Series.id_to_series("series_set_parameter_name_id").array
            let array_of_possible_values = []
            for(let name of array_of_possible_values_raw) {
                array_of_possible_values.push('"' + name + '"')
            }
            let sel_index = array_of_possible_values.indexOf(arg_val_src) ////might return -1 but that's ok, it will just be blank type in
            //let the_arg_val_src = ((sel_index == -1) ? "" : arg_val_src)
            //out("arg_val_src: " + arg_val_src + " sel_index: " + sel_index)
            if(sel_index == -1) { sel_index = 0 } //sill get the default set_parameter nname of "Acceleration"
            setTimeout(function() {
                    $(window[id]).jqxComboBox({ source: array_of_possible_values,
                        width: '210px',
                        height: '16px',
                        selectedIndex: sel_index})  //default
                    //if(sel_index == -1){
                    //    $(window[id]).jqxComboBox("val", the_arg_val_src)
                    //}
                },
                200)
            return  "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <div style='display:inline-block' id='" + id + "' class='mi_arg_val_src combo_box'/></div>"
        }
        else if(["Dexter.move_to", "Dexter.move_to_straight", "Dexter.pid_move_to"].includes(instruction_name) &&
                 (arg_name == "config")){ //got a combobox
            let array_of_possible_values = Series.id_to_series("series_robot_config_id").array
            let sel_index = array_of_possible_values.indexOf(arg_val_src) ////might return -1 but that's ok, will just be blank type in
            let the_arg_val_src = arg_val_src
            out("arg_val_src: " + arg_val_src + " sel_index: " + sel_index)
            setTimeout(function() {
                        $(window[id]).jqxComboBox({ source: array_of_possible_values,
                                                    width: '210px',
                                                    height: '16px',
                                                    selectedIndex: sel_index})  //default Dexter.RIGHT_UP_OUT
                        if(sel_index == -1){
                            $(window[id]).jqxComboBox("val", the_arg_val_src)
                        }
                      },
                      200)
            return  "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <div style='display:inline-block' id='" + id + "' class='mi_arg_val_src combo_box'/></div>"
        }
        else {
            return "<div style='margin:5px;white-space:nowrap;'>" + arg_name + ": <input class='mi_arg_val_src' oninput='MiState.invalidate_job_instance()' style='width:300px;font-size:13px;' id='" + id + "' value='" + arg_val_src + "'/></div>"
        }
    }

    //_______replace args_________
    static replace_args_wrapper_html(call_obj){
        return "<div id='mi_replace_args_wrapper_id' style='display:inline-block'></div>"
    }

    static install_replace_args_menu_items(){
        let instruction_name = this.get_instruction_name_from_ui()
        let family_class = MiIns.instruction_name_to_family_class(instruction_name)
        let the_html = this.make_menu_item_html("Defaults",         "MakeInstruction.replace_arg_vals_with_defaults()", "Values from the insruction's defaults.")
        if(family_class == MiIns.move_all_joints_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_maj_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_maj_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_maj_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_to", "MakeInstruction.replace_arg_vals_maj_convert_to_mt()", "make a move_to instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_all_joints specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_maj_get_from_dexter()", "Joint angles from Dexter's current position.")
        }
        else if(family_class == MiIns.move_to_family){
            the_html += this.make_menu_item_html("HOME",            "MakeInstruction.replace_arg_vals_mt_angles(Dexter.HOME_ANGLES)",    "Straight up.")
            the_html += this.make_menu_item_html("NEUTRAL",         "MakeInstruction.replace_arg_vals_mt_angles(Dexter.NEUTRAL_ANGLES)", "Between HOME and PARKED.")
            the_html += this.make_menu_item_html("PARKED",          "MakeInstruction.replace_arg_vals_mt_angles(Dexter.PARKED_ANGLES)",  "Folded compactly.")

            the_html += this.make_menu_item_html("convert to move_all_joints", "MakeInstruction.replace_arg_vals_mt_convert_to_maj()", "make a move_all_joints instruction\nwith args that cause Dexter\nto move to the same position\nthat this move_to specifies.")
            the_html += this.make_menu_item_html("get from Dexter", "MakeInstruction.replace_arg_vals_mt_get_from_dexter()")
        }
        //replace_args_menu_items_id.innerHTML = the_html //fails
        let html_wrapper =  "<div id='mi_replace_args_id' " +
                                 "class='dde_menu' " +
                                 "style='display:inline-block;height:10px;padding:0px;margin-top:5px;'>" +
                                 "<ul style='display:inline-block;padding:0;margin-top:0px;'>" +
                                                        "<li id='mi_replace_args_label_id'>Replace Arg Values With ...&#9660;" +
                                                            "<ul id='replace_args_menu_items_id'>" +
                                                            the_html +
                            "</ul></li></ul></div>"
        mi_replace_args_wrapper_id.innerHTML = html_wrapper

        setTimeout(function(){
                    $("#mi_replace_args_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' })
                    $("#mi_replace_args_id").jqxMenu('setItemOpenDirection', 'mi_replace_args_label_id', 'right', 'up')
                   },
                   200)
    }

    //if action_string has inner quotes, they must be single quotes
    static make_menu_item_html(label_string, action_string, tooltip=""){
        return `<li title="` + tooltip + `" onclick="` + action_string + `">` + label_string + "</li>"
    }

    //______All the replace menu items that go on all families_______
    //the action for the "Defaults" menu item.
    static replace_arg_vals_with_defaults(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name).
                       merge_in_from_instruction_def()
        this.update_instruction_args(call_obj)
    }

    //______All the replace menu items that go on move_all_joints_family_______
    static replace_arg_vals_maj_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_maj_get_from_dexter(){
        let job_wrapper_robot = Dexter.default
        new Job({name: "get_from_dexter",
                 robot: job_wrapper_robot,
                 when_stopped: function(){
                                 let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                                 let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                                 let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(instruction_name, angles)
                                 MakeInstruction.update_instruction_args(call_obj)
                 }
        }).start()
    }
    static replace_arg_vals_maj_convert_to_mt(){
        let new_instruction_name = "Dexter.move_to"
        let old_call_obj = this.make_call_obj_from_ui()
        let angles = old_call_obj.get_angle_array()
        let job_wrapper_robot = Dexter.default
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    //______All the replace menu items that go on move_to_family_______
    static replace_arg_vals_mt_angles(angles){
        let instruction_name = this.get_instruction_name_from_ui()
        let job_wrapper_robot = Dexter.default
        let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
       /* let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        let [xyz, J5_direction, config] =
            Kin.J_angles_to_xyz(angles, job_wrapper_robot.pose)
        call_obj.args_obj.xyz            = to_source_code({value: xyz})
        call_obj.args_obj.J5_direction   = to_source_code({value: J5_direction})
        call_obj.args_obj.config         = to_source_code({value: config})
        call_obj.args_obj.workspace_pose = to_source_code({value: job_wrapper_robot.pose})
        call_obj.args_obj.j6_angle       = to_source_code({value: angles[6 - 1]})
        call_obj.args_obj.j7_angle       = to_source_code({value: angles[7 - 1]})
        */
        MakeInstruction.update_instruction_args(call_obj)
    }
    static replace_arg_vals_mt_get_from_dexter(){
        let job_wrapper_robot = Dexter.default
        new Job({name: "get_from_dexter",
            robot: job_wrapper_robot,
            when_stopped: function(){
                let instruction_name = MakeInstruction.get_instruction_name_from_ui()
                let angles = new RobotStatus({robot_status: last(this.rs_history)}).measured_angles(7)
                let call_obj = MiIns.move_to_family.make_from_instruction_name_and_angles(instruction_name, angles, job_wrapper_robot)
                MakeInstruction.update_instruction_args(call_obj)
            }
        }).start()
    }

    static replace_arg_vals_mt_convert_to_maj(){
        let new_instruction_name = "Dexter.move_all_joints"
        let old_call_obj = this.make_call_obj_from_ui().merge_in_from_instruction_def_only_if_empty() //a move_to family
        if(old_call_obj.args_obj.j6_angle == "[0]") { old_call_obj.args_obj.j6_angle = "" } //both mean the same thing bug empty looks simpler in the dialog.
        if(old_call_obj.args_obj.j7_angle == "[0]") { old_call_obj.args_obj.j7_angle = "" }

        let xyz_src = old_call_obj.args_obj.xyz
        if(!xyz_src) {
            xyz_src = "[" + old_call_obj.args_obj.x + ", " +
                            old_call_obj.args_obj.y + ", " +
                            old_call_obj.args_obj.z +
                      "]"
        }
        let xyz
        try{ xyz = window.eval(xyz_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                     xyz_src + " errored with: " + err.message) }
        if(!Array.isArray(xyz)) {
            dde_error("While converting move_to to move_all_joints, evaling xyz source of: " +
                       xyz_src + " returned a non-array of: " + xyz)
        }

        let j5_direction_src = old_call_obj.args_obj.J5_direction
        let j5_direction
        try{ j5_direction = window.eval(j5_direction_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                                j5_direction_src + " errored with: " + err.message) }
        if(!Array.isArray(j5_direction)) {
            dde_error("While converting move_to to move_all_joints, evaling J5_direction source of: " +
                      j5_direction_src + " returned a non-array of: " + j5_direction)
        }

        let config_src = old_call_obj.args_obj.config
        let config
        try{ config = window.eval(config_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling config source of: " +
                                config_src + " errored with: " + err.message) }
        if(!Array.isArray(config)) {
            dde_error("While converting move_to to move_all_joints, evaling config_src source of: " +
                config_src + " returned a non-array of: " + config)
        }

        let angles = Kin.xyz_to_J_angles(xyz, j5_direction, config)

        let j6_angle_src = old_call_obj.args_obj.j6_angle
        let j6_angle
        if(j6_angle_src != "") { try{ j6_angle = window.eval(j6_angle_src)}
                            catch(err) { dde_error("While converting move_to to move_all_joints, evaling j6_angle source of: " +
                                j6_angle_src + " errored with: " + err.message) }
                         }
         else j6_angle = undefined
        angles.push(j6_angle)

        let j7_angle_src = old_call_obj.args_obj.j7_angle
        let j7_angle
        if(j7_angle_src != "") { try{ j7_angle = window.eval(j7_angle_src)}
        catch(err) { dde_error("While converting move_to to move_all_joints, evaling j7_angle source of: " +
                                j7_angle_src + " errored with: " + err.message) }
        }
        else j7_angle = undefined
        angles.push(j7_angle)

        angles.push(old_call_obj.args_obj.j6_angle)
        let job_wrapper_robot = Dexter.default
        let call_obj = MiIns.move_all_joints_family.make_from_instruction_name_and_angles(new_instruction_name, angles, job_wrapper_robot)
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    static bottom_buttons_html(){
        return  "<div style='white-space:nowrap;' ><button style='margin:3px;' onclick='MakeInstruction.eval_instruction()' " +
            "title='Eval the instruction.&#013;This is a good (but incomplete) test&#013;of the validity of the arguments.'>Eval Instr</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.run()' id='mi_run_id'" +
            "title='Make a job with the instruction in it&#013;and start the job.'>Run</button>" +

            //"<button style='margin:3px;' onclick='MakeInstruction.insert_job()' " +
            //"title='Into the Editor,&#013;insert the definition of a job&#013;with the instruction in it.'>Insert Job</button>" +
            "<button style='margin:3px;' onclick='MakeInstruction.wrap_in_job()' " +
            "title='Change the instruction to new Job&#013;and stick the current instruction&#013;into the new Job&apos;s do_list.'>Wrap in Job</button>" +

            "<button style='margin:3px;' onclick='MakeInstruction.insert_instruction()' " +
            "title='If there is a selection in the Editor,&#013;replace it,&#013;otherwise just insert the instruction.'>Insert</button>" +
            "</div>"
    }

    static make_call_obj_from_ui(){
        let instruction_name = this.get_instruction_name_from_ui()
        let call_obj = MiIns.make_from_instruction_name_no_args(instruction_name)
        /*let param_names = this.param_names_from_ui(instruction_name)
        for(let param_name of param_names){ //fails when we call this method from after instructio_name\
            //is changed in the UI, but before the args are set as we need to when grabbing prev values
            let id = this.arg_name_to_dom_elt_id(param_name)
            let elt = window[id]
            let arg_val_src = elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            call_obj.args_obj[param_name] = arg_val_src
        }
        */
        for(let elt of mi_args_id.getElementsByClassName('mi_arg_val_src')){
            let arg_name = this.dom_elt_id_to_arg_name(elt.id)
            let arg_val_src
            if(elt.classList.contains("combo_box")) {
                   arg_val_src = $(elt).val()
            }
            else { arg_val_src = elt.value }//.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            //if((arg_val_src === undefined) && (arg_name == "config")){ //might be a jqxcombobox
            //    arg_val_src = $(elt).val()
            //}
            call_obj.args_obj[arg_name] = arg_val_src
        }
        return call_obj
    }

    //obsolete feb 21, 2019
    static param_names_from_ui(instruction_name){
        if(this.dialog_contains_move_all_joints_with_joints()){
            return ["joint1", "joint2", "joint3","joint4","joint5","joint6","joint7"]
        }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = []
        for(let pair of arg_name_val_src_pairs) { param_names.push(pair[0]) }
        let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
        if (mt_separate_xyzs){
            if(param_names[0] == "xyz") { param_names.shift() }
            else { shouldnt("no first 'xyz' param in dialog_to_instruction_src with instruction: " + instruction_name +
                " and param_names: " + param_names) }
            param_names.unshift("z")
            param_names.unshift("y")
            param_names.unshift("x")

        }
        if(starts_with_one_of(instruction_name, ["Dexter.", "Serial."]) && (last(param_names) == "robot")) {
            param_names.pop() //user should be using robot instance as subject, not as last arg
            //else { shouldnt("no last 'robot' param_name in dialog_to_instruction_src with instruction: " + instruction_name +
            //                " and param_names: " + param_names)  }
        }
        return param_names
    }

    //if eval_args is true, test the instruction name and arg src.
    //by evaling it. If it errors, print a good error message,
    //highlight the approirate field in the dialog,
    //and return null, otherwise return a string of valid src for the instruction.
    static dialog_to_instruction_src(eval_args=false){
        if(!this.validate_instruction_name_ui()) { return false } //error messages are printed by this
        let call_obj = this.make_call_obj_from_ui()
        return this.call_obj_to_instruction_src(eval_args, call_obj)
    }
    //called by insert job code as well
    ////return null if there's an error, else a string
    static call_obj_to_instruction_src(eval_args=false, call_obj){
        let family_class = call_obj.get_family_class()
        if(family_class == MiIns.function_family) {
          return this.call_obj_to_instruction_src_for_function(eval_args, call_obj)
        }
        else if(family_class == MiIns.array_family){
            return this.call_obj_to_instruction_src_for_array(eval_args, call_obj)
        }
        else { return this.call_obj_to_instruction_src_for_normal(eval_args, call_obj) }
    }

    //return null if there's an error, else a string
    static call_obj_to_instruction_src_for_normal(eval_args=false, call_obj){
        let family_of_instruction = call_obj.get_family_class()
        let instruction_name = call_obj.get_instruction_name()
        let result = instruction_name + "("
        let maj_with_joints  = this.dialog_contains_move_all_joints_with_joints()
        if(maj_with_joints) { result += "[" }
        let fn = call_obj.get_instruction_class()
        let fn_is_keyword = fn_is_keyword_fn(fn)
        if(fn_is_keyword) { result += "{\n" }
        let arg_name_val_src_pairs = function_param_names_and_defaults_array(instruction_name, true)
        let param_names = Object.getOwnPropertyNames(call_obj.args_obj)
        let src_before_undefined = result
        //we want do_list to go at the end, so, if present, move it to the end of param_names.
        let do_list_index = param_names.indexOf("do_list")
        if(do_list_index != -1) {
            param_names.splice(do_list_index, 1)
            param_names.push("do_list")
        }
        for(let param_name of param_names){
            let arg_default_val_src = this.find_arg_val_src_in_arg_name_val_src_pairs(param_name, arg_name_val_src_pairs)
            if((family_of_instruction == MiIns.move_all_joints_family) &&
               param_name.startsWith("joint") &&
               (arg_default_val_src == undefined)) {
                arg_default_val_src = ""
            }
            //let id = this.arg_name_to_dom_elt_id(param_name)
            //let elt = window[id]
            let arg_val_src = call_obj.args_obj[param_name] //elt.value //.trim() //bad, esp for textareas and preserivng initial whitespace on rest args
            if(eval_args){
                if(!this.validate_arg_ui(instruction_name, param_name, arg_val_src)) { return null }
            }
            let arg_val_is_default = false
            if (arg_val_src === "") { //typein is empty so use the default val
                arg_val_src = arg_default_val_src
                arg_val_is_default = true
            }
            else if(arg_val_src == arg_default_val_src) { arg_val_is_default = true }
            else if(arg_val_src == "undefined")         { arg_val_is_default = true }
            if(["name", "do_list"].includes(param_name)) { arg_val_is_default = false } //we always want to print out these
            let did_insert_arg   = true
            let mt_separate_xyzs = this.dialog_contains_move_to_with_separate_xyzs()
            if (mt_separate_xyzs && (param_name == "x")) {
                if(fn_is_keyword)                            { result += "xyz: [" + arg_val_src }
                else                                         { result += "[" + arg_val_src }
            }
            else if(mt_separate_xyzs && (param_name == "y")) { result += arg_val_src }
            else if(mt_separate_xyzs && (param_name == "z")) { result += arg_val_src + "]"}
            else if(fn_is_keyword){
                    if(!arg_val_is_default || mi_insert_default_args_id.checked)  {
                       if(param_name == "do_list"){
                           arg_val_src = "\n        " + arg_val_src.trim() //8 spaces (2 tabs)
                       }
                                                                    result += "    " + param_name + ": " + arg_val_src
                    }
                    else { did_insert_arg = false }                                         //insert nothing
            }
            else  {                                                 result += arg_val_src }
            if (!(last(param_names) == param_name) && did_insert_arg) {
                if(fn_is_keyword) { result += ",\n" }
                else              { result += ", " }
            }
            if(!arg_val_is_default || mi_insert_default_args_id.checked) {
                src_before_undefined = result   //don't include in src trailing undefineds
            }
        }
        //get rid of extra whitespace and comma at the end, otherwise option-click fails on parsing, even though now js ok with extra comma.
        src_before_undefined = trim_end(src_before_undefined)
        if(src_before_undefined.endsWith(",")) {
            src_before_undefined = src_before_undefined.substring(0, src_before_undefined.length - 1)
        }
        if(maj_with_joints) {
            src_before_undefined += "]"
        }
        if(fn_is_keyword) { src_before_undefined += "}" }
        result = src_before_undefined + ")"
        return result
    }

    static validate_arg_ui(instruction_name, param_name, arg_val_src){
        if ((instruction_name == "new Job") && (param_name == "do_list")){
            let ast
            try{ ast = MiParser.string_to_ast(arg_val_src)}
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                let short_arg_val_src = ((arg_val_src.length > 60) ? arg_val_src.substring(0, 60) + "..." : arg_val_src)
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                    "with source of: " +
                    "<code style='padding:3px;'>" + short_arg_val_src + "</code><br/>" +
                    "errored because <span style='color:red;'>" + err.message +
                    "</span><br/>Correct errors and try again.")
                return false
            }
            let body0_expression_ast = ast.body[0].expression
            if(body0_expression_ast.type == "ArrayExpression"){
                let elts_array = body0_expression_ast.elements
                for(let i = 0; i < elts_array.length; i++){
                    let elt_ast = elts_array[i]
                    let elt_src = arg_val_src.substring(elt_ast.range[0], elt_ast.range[1])
                    try{
                        if(starts_with_one_of(elt_src, ["function(", "function (", "function*"])){
                            elt_src = "(" + elt_src + ")" //fixes JS design bug
                        }
                        let do_list_item = window.eval(elt_src)
                        if(!Instruction.is_do_list_item(do_list_item)){
                            this.set_border_color_of_arg(param_name, "red")
                            out("<span style='color:red'>Error: </span>" +
                                "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                                "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                                "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                                "errored because it evaled to: " + do_list_item + "<br/>" +
                                "and <span style='color:red;'> that is not a valid do_list item." +
                                "</span><br/>Correct errors and try again.")
                            open_doc(job_param_do_list_doc_id)
                            return false
                        }
                    }
                    catch(err){
                        this.set_border_color_of_arg(param_name, "red")
                        out("<span style='color:red'>Error: </span>" +
                            "In <i>Make Instruction</i>, while evaling the <b>" + param_name + ",</b><br/>" +
                            "element " + i + " (zero based) of " + elts_array.length + " with source of:<br/>" +
                            "<code style='padding:3px;'>" + elt_src + "</code><br/>" +
                            "errored because:" + "<span style='color:red;'> " + err.message +
                            "</span><br/>Correct errors and try again.")
                        return false
                    }
                }
            }
        }
        else {
            try{
                window.eval(arg_val_src)
                this.set_border_color_of_arg(param_name)
            }
            catch(err){
                this.set_border_color_of_arg(param_name, "red")
                out("<span style='color:red'>Error: </span>" +
                    "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source of:<br/>" +
                    "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                    "<span style='color:red;'> " + err.message +
                    "</span><br/>Correct errors and try again.")
                return false
            }
        }
        return true //everything ok
    }

    //instruction_name is either "function" or "function*"
    //note that this method ignores eval_args because
    //none of the "args" are really evalable.
    static call_obj_to_instruction_src_for_function(eval_args=false){
        let instruction_name = this.get_instruction_name_from_ui()
        let id
        let elt
        id = this.arg_name_to_dom_elt_id("name")
        elt = window[id]
        let the_name_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("...params")
        elt = window[id]
        let the_params_src = elt.value.trim()
        id = this.arg_name_to_dom_elt_id("body")
        elt = window[id]
        let the_body_src  = elt.value.trim()
        the_body_src = "\n" + the_body_src
        the_body_src = replace_substrings(the_body_src, "\n", "\n    ")

        let result = ((the_name_src == "") ? instruction_name: instruction_name + " " + the_name_src )
        result += "(" + the_params_src + "){" + the_body_src + "\n}\n"
        return result
    }

    static call_obj_to_instruction_src_for_array(eval_args=false){
        let param_name = "...elts"
        let id = this.arg_name_to_dom_elt_id(param_name)
        let elt = window[id]
        let args_val_src = elt.value.trim()
        if(eval_args){
            let arg_val_src_array = args_val_src.split(",")
            for(let i = 0; i < arg_val_src_array.length; i++){
                let arg_val_src = arg_val_src_array[i]
                try{
                    window.eval(arg_val_src)
                    this.set_border_color_of_arg(param_name)
                }
                catch(err){
                    this.set_border_color_of_arg(param_name, "red")
                    out("<span style='color:red'>Error: </span>" +
                        "In <i>Make Instruction</i>, evaling the <b>" + param_name + "</b> source at index " + i + " of<br/>" +
                        "<code style='padding:3px;'>" + arg_val_src + "</code><br/>errored because:" +
                        "<span style='color:red;'> " + err.message +
                        "</span><br/>Correct errors and try again.")
                    return null
                }
            }
        }
        return "[" + args_val_src + "]"
    }

    static eval_instruction(){
        let src = this.dialog_to_instruction_src(true)
        if(src !== null) {
            src = this.fix_src_of_function_maybe(src)
            eval_js_part2(src)
        }
    }

    static fix_src_of_function_maybe(src) {
        let instruction_name = this.get_instruction_name_from_ui()
        if (MiIns.instruction_name_in_family_class(instruction_name, MiIns.function_family)) {
            src = "(" + src + ")" //due to js design mistake,
                                  //anonymous fn defs can't be evaled without
                                  //wrapping them in parens.
                                  //we might have a NAMED fn here, but the parens
                                  //are harmless for that.
        }
        return src
    }

    static run(){
        let call_obj = this.make_call_obj_from_ui() //don't reshow the inst_src because that goes through the pipelinne
           //which merges in prev values, etc. which we don't want.
        let inst_src = this.dialog_to_instruction_src()
        if(!this.src_looks_like_valid_instruction(inst_src)){
            if(starts_with_one_of(inst_src, "new Dexter(", "new Serial(")){
                warning("You've created a Robot in the Make Instruction dialog.<br/>" +
                    "A Robot isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            else {warning("The code you've created in the Make Instruction dialog<br/>" +
                    "isn't valid as a Job's do_list item.<br/>" +
                    "You can, however, Eval it and Insert it into the editor.")
            }
            return
        }
        inst_src = this.fix_src_of_function_maybe(inst_src)
        let the_inst = eval(inst_src)
        if(the_inst instanceof Job){
            if(Robot.simulate_or_both_selected()){
                show_in_misc_pane("Simulate Dexter")
                //to give user time to adjust to the sim pane
                let when_stopped_fn = function(){
                    setTimeout(function() { MakeInstruction.show(call_obj, false) },
                        2000)
                }
                setTimeout(function() { the_inst.start({when_stopped: when_stopped_fn}) }, //doesn't work to just set when_stopped on the instance because that won't make it into the orig_args storage
                    2000)
            }
            else {  the_inst.start() }
        }
        else {
            let robot_of_wrapper = Dexter.default
            let job_00
            if((this.get_instruction_name_from_ui() == "new Job") &&
                robot_of_wrapper == the_inst.robot) {
                warning("When using a Job as an instruction (to start it),<br/>" +
                        "its robot must be different than the Job its in.<br/>" +
                        "They are the same in this case so this use of the Run button<br/>" +
                        "didn't wrap the new Job instruction you specified in another Job before running it.")
                job_00 = the_inst
            }
            else {
                job_00 = new Job({name: "job_00",
                                  robot: robot_of_wrapper,
                                  do_list: [the_inst],
                                  when_stopped: function(){
                                                   setTimeout(function() { MakeInstruction.show(call_obj, false) },
                                                              2000)
                                                }
                         })
            }
            let true_or_error_mess = Instruction.can_instruction_run_on_robot(the_inst, robot_of_wrapper)
            if(typeof(true_or_error_mess) == "string") {
                dde_error(true_or_error_mess)
            }
            else if(Robot.simulate_or_both_selected()){
                show_in_misc_pane("Simulate Dexter")
                //to give user time to adjust to the sim pane
                setTimeout(function() { job_00.start() },
                           2000)
            }
            else {  job_00.start() } //don't switch to simulator if we're not simulating
        }
    }

    static wrap_in_job(){
        let old_call_object = this.make_call_obj_from_ui()
        let old_instruction_name = old_call_object.get_instruction_name()
        let old_instr_src
        if(old_instruction_name == "new Job"){
            let old_job_name = old_call_object.args_obj.name.trim()
            if (['""', "''", ""].includes(old_call_object.args_obj.name.trim())){
                dde_error("When inserting a Job as a do_list item in another Job,<br/>" +
                    "that inner job needs a name but this one doesn't have one.<br/>" +
                    "Also, the inner job should be inserted into a file<br/>" +
                    "so you can define it before this new Job is started.<br/>"
                    )
            }
            else {
                warning("For this new Job to work, the embedded job<br/>" +
                        "must be saved and defined before running this new Job.")
                old_instr_src = 'Control.include_job(' + old_job_name + ')'
            }
        }
        else { //a non "new job" old instruction
            old_instr_src = this.dialog_to_instruction_src(true)
            if (!old_instr_src) { return false } //some error in the instruction code so don't continue.
        }
        let call_obj = MiIns.make_from_instruction_name_no_args("new Job").
                       merge_in_pipeline()
        call_obj.args_obj.name = '"' + Job.generate_default_name() + '"'
        call_obj.args_obj.do_list = "[" + old_instr_src + "]"
        MakeInstruction.update_instruction_name_and_args(call_obj)
    }

    static insert_instruction(){
        let instruction_name = this.get_instruction_name_from_ui()
        if(instruction_name == "new Job") {
            this.show_insert_job_dialog()
        }
        else {
            let src = this.dialog_to_instruction_src()
            let suffix = ""
            if(Editor.is_selection()) { Editor.replace_selection(src)} //trailing comma ok inside of an array
            else {
                let suffix
                if(this.src_looks_like_valid_instruction(src)){ //these are not valid instructions, so can't be in a do_list, so shouldn't be followed by a comma
                    suffix = ",\n    "
                }
                else { suffix = "\n"}
                Editor.insert(src + suffix)
            }
        }
    }
    static handle_insert_job_dialog(vals){
        if(vals.clicked_button_value == "Insert"){
            MakeInstruction.insert_jobs()
        }
        else if (vals.clicked_button_value == "Preview..."){
            MakeInstruction.insert_jobs_preview()
            //SW.close_window(vals.window_index) //don't close as we want to see the
            //main insert dialog after we close the preview dialog
        }
    }

    static show_insert_job_dialog(){
        let job_name = window[this.arg_name_to_dom_elt_id("name")].value
        if(!is_string_a_literal_string(job_name) || (job_name.length <= 2)) {
            this.set_border_color_of_arg("name", "red")
            dde_error("The job name in the Make Instruction dialog<br/>must be a non-empty string.<br/>" +
                      'Example: <code>"my_job"</code>')
        }
        if (job_name == '""') { job_name = "recording" }
        else { job_name = job_name.substring(1, job_name.length - 1) }
        show_window({title: "Insert Job(s)",
            y:      180,
            width:  510,
            height: 340,
            background_color: "#E0E0E0",
            callback: "MakeInstruction.handle_insert_job_dialog",
            content:
            "<fieldset><legend>High Level Job</legend>" +
                "<input id='mi_job_insert_ref_none_radio_id' type='radio' name='mi_job_ref_radio' checked/> None<br/>" +
                "<input id='mi_job_insert_ref_refs_radio_id' type='radio' name='mi_job_ref_radio'        /> Reference to low-level Job only<br/>" +
                "<input id='mi_job_insert_ref_job_radio_id'  type='radio' name='mi_job_ref_radio'        /> new Job def containing reference " +
                "<i style='margin-left:23px'>name</i>: <input id='mi_job_insert_ref_job_name_id'  value='high_level'/><br/>" +
            "</fieldset><br/>" +

            "<fieldset><legend>Low Level Job</legend>" +
               "What: " +
                  "<input style='margin-left:27px;' id='mi_job_instrs_what_all_id'    type='radio' name='mi_job_instrs_what' checked/>all instructions &nbsp;&nbsp;" +
                  "<input                           id='mi_job_instrs_what_string_id' type='radio' name='mi_job_instrs_what'        />string instructions &nbsp;&nbsp;" +
                  "<input                           id='mi_job_instrs_what_none_id'   type='radio' name='mi_job_instrs_what'        />none " +
               "<br/>Wrapper: " +
                  "<input id='mi_job_instrs_wrapper_job_id'  type='radio' name='mi_job_instrs_wrapper' checked/>Job &nbsp;&nbsp;" +
                  "<input id='mi_job_instrs_wrapper_var_id'  type='radio' name='mi_job_instrs_wrapper' />var &nbsp;&nbsp;" +
                  "<input id='mi_job_instrs_wrapper_data_id' type='radio' name='mi_job_instrs_wrapper' />data " +

               "<i style='margin-left:10px;'>name</i>: <input id='mi_job_instrs_wrapper_name_id' value='" + job_name + "'/>" +
               "<br/>Where: " +
                  "<input style='margin-left:18px;' id='mi_job_instrs_where_editor_id' type='radio' name='mi_job_instrs_where' checked/>end of editor &nbsp;&nbsp;" +
                  "<input style='margin-left:16px;' id='mi_job_instrs_where_file_id'   type='radio' name='mi_job_instrs_where'        />file " +
               "<br/><i>Leave <b>name</b> blank to bring up a choose file dialog.</i>" +
        "</fieldset><br/>" +

            "<center><input type='button' title='Show the code to be inserted\nwhen you click Insert\without actually inserting it.' value='Preview...'/> &nbsp;" +
                    "<input type='button' title='Insert selected code into editor\nand close this window.' value='Insert'/>" + //this is really a submit that closes the window but DON'T use submit
                        //because that closes the window before the handler is run making the values in it in the global vars unavailable
            "</center>"
        })
    }
    static insert_jobs_preview(){
        let src = this.high_level_code()
        if((src.length > 0) && (src[0] == "\n")) { src = src.substring(1) } //cut off initial newline
        let seg_refs_code = src
        if (seg_refs_code == "") { seg_refs_code = "<i style='color:red;'>nothing to insert</i>" }

        let seg_jobs_code = this.low_level_code().substring(1) //cut off initial newline
        if (seg_jobs_code == "") { seg_jobs_code = "<i style='color:red;'>nothing to insert</i>" }
        else if (Array.isArray(seg_jobs_code)) { //got an error.
            seg_jobs_code = seg_jobs_code[0]
        }
        let where_description
        if(this.path_to_write_to()) {
            let prefix = (mi_job_instrs_wrapper_job_id.checked ? "The below Job definition" : "The below instructions")
            where_description = "<i>" + prefix + " will be written to file: " + this.path_to_write_to() + "</i>"
        }
        else {
            where_description = "<i>To be inserted at the end of the editor.</i>"
        }
        let additional_help = (mi_job_insert_ref_refs_radio_id.checked ?
                               "<br/><i>Position cursor in left column of empty line.<br/>Should be an instruction in a high-level Job's do_list.</i>" :
                               "")
        let content =   "<div style='font-size:16px; display:inline-block'><b>High Level Job</b><br/>" +
                        "<i>Replaces selection or inserted at the editor's cursor.</i>" +
                         additional_help +
                         "<pre><code>" +
                        seg_refs_code +
                        "</code></pre></div>" +
                        "<div style='font-size:16px;'><b>Low Level Job</b><br/>" +
                        where_description + "<br/>" +
                        "<i>Only top level instructions are included.</i><pre><code>" +
                        seg_jobs_code +
                        "</code></pre></div>"
        show_window({title: "Insert Job(s) Preview",
                    content: content,
                    x:10, y:40, width:600, height:500,
                    background_color: "#E0E0E0"
        })
    }

    static path_to_write_to() {
        if(mi_job_instrs_where_file_id.checked) { //writing to a file, even if we haven't chosen it yet
            let path = mi_job_instrs_wrapper_name_id.value
            if(path == "") { return "" }
            else {
                if (!path.includes(".")) {
                    path = path + ".dde"
                }
                return make_full_path(path)
            }
        }
        else { return null } //writing to end of buffer.
    }
    static insert_jobs(){
        let pos_after_top_insertion =  null
        let seg_ref_code = this.high_level_code()
        let seg_job_code = this.low_level_code()
        if(Array.isArray(seg_job_code)) { } //got an error, already been printed.
        else { //everything ok to insert
            if (seg_ref_code != "") {
                Editor.replace_selection(seg_ref_code)
                pos_after_top_insertion = Editor.selection_start() // still at where it was before insertion
                pos_after_top_insertion += seg_ref_code.length //now at end of insertion
                if(mi_job_insert_ref_job_radio_id.checked){ //backup so good for next ref insertion into the do_list
                    let last_newline = seg_ref_code.lastIndexOf("\n", seg_ref_code.length - 2)
                    let back_up_by = pos_after_top_insertion - last_newline - 1
                    pos_after_top_insertion -= back_up_by
                }
            }
            if (seg_job_code != "") {
                let path = this.path_to_write_to() //empty string means pop up choose file diaog,
                                                   //valid string means write file to it.
                                                   //null means insert code at end of buffer
                if(path == ""){
                    path = choose_save_file({title: "Choose file to save Job to",
                                             defaultPath: dde_apps_folder})
                }
                if(path){
                    write_file(path, seg_job_code)
                    out(mi_job_instrs_wrapper_name_id.value  + " definition written to: " + path)
                }
                else { Editor.insert(seg_job_code, "end") }
            }
            if((seg_ref_code == "") && (seg_job_code == "")) {
                warning("No code chosen for insertion.")
            }
            else if(pos_after_top_insertion) {
                Editor.select_javascript(pos_after_top_insertion, pos_after_top_insertion + 1)
            }
        }
    }

    static high_level_code(){
        //let selected_radio_button = document.querySelector('input[name="mi_job_ref_radio"]:checked').id
        let result = ""
        if(mi_job_insert_ref_none_radio_id.checked) { return "" }
        else  {
            let do_list_ref_string
            if      (mi_job_instrs_where_file_id.checked)  { do_list_ref_string =          mi_job_instrs_wrapper_name_id.value + ".dde" } //don't use full path_to_write_to() becasue we want the shorter vrsion AND allows the high level job to move to a different computer and run if the low level file is in dde_apps dir
            else if (mi_job_instrs_wrapper_job_id.checked) { do_list_ref_string = "Job." + mi_job_instrs_wrapper_name_id.value }
            else if (mi_job_instrs_wrapper_var_id.checked) { do_list_ref_string =          mi_job_instrs_wrapper_name_id.value }
            else if (mi_job_instrs_wrapper_data_id.checked){ do_list_ref_string =         "//data has no way to be referenced.\n                  //Consider using wrapper 'var'." }
            let ref
            if(mi_job_instrs_wrapper_job_id.checked){
                let options = '{start_if_robot_busy: true}'
                    ref= 'Control.start_job("' + do_list_ref_string + '", ' + options + ', "error", true),\n'
            }
            else if (mi_job_instrs_wrapper_var_id.checked ||
                     (mi_job_instrs_wrapper_data_id.checked &&
                      mi_job_instrs_where_file_id.checked)){
                    ref= 'Control.include_job("' + do_list_ref_string + '"),\n'
            }
            else if (mi_job_instrs_wrapper_data_id.checked){
                    ref= do_list_ref_string + '\n'
            }
            else { shouldnt("In MakeInstruction.high_level_code no wrapper radio button checked.") }

            if     (mi_job_insert_ref_refs_radio_id.checked){ return ref }
            else if(mi_job_insert_ref_job_radio_id.checked) {
                return '\n//A high-level Job that includes other jobs.\n' +
                     'new Job({\n' +
                     '    name: "' + mi_job_insert_ref_job_name_id.value + '",\n' +
                     '    do_list: [\n' +
                     '        ' + ref +
                     '    ]})\n'
            }
        }
        return result
    }

    //returns a string (which could be empty), if everything ok. Else retruns an array with
    //one elt, an error message
    static low_level_code(){
        if(mi_job_instrs_what_none_id.checked) { return "" }
        else {
            let target_job_name = mi_job_instrs_wrapper_name_id.value
            let src_job_name = window.eval(MakeInstruction.arg_name_to_src_in_mi_dialog("name")) //might not just be a literal, could be an expression!
            let job_instance = Job[src_job_name]
            let do_list_src = MakeInstruction.arg_name_to_src_in_mi_dialog("do_list")
            let do_list_to_mine = []
            let result_do_list  = []
            let begin_loc = MiRecord.get_begin_mark_loc()
            let end_loc   = MiRecord.get_end_mark_loc()
            let begin_top_loc
            let end_top_loc
            let has_non_top_levels
            let use_str_instrs = mi_job_instrs_what_string_id.checked
            if(!job_instance || (job_instance != MiState.job_instance) || !MiState.job_instance.do_list){ //not in sync so prefer the def in the dialog
                do_list_to_mine = window.eval(do_list_src)
                if(use_str_instrs) { do_list_to_mine = this.make_string_do_list_from_orig(do_list_to_mine, job_instance) }
                warning("Since the Job in the Make Instruction dialog hasn't been played,<br/>we're using its full original do_list.")
                has_non_top_levels = false
                begin_top_loc = begin_loc //there aren't any non-top levels generated
                end_top_loc   = end_loc
            }
            else { //use the already run do_list or job_instance.sent_instructions_strings
                if(use_str_instrs){
                       do_list_to_mine = this.make_string_do_list_from_sent_instr_strings(job_instance.sent_instructions_strings, job_instance)
                }
                else { do_list_to_mine = job_instance.do_list  }
                has_non_top_levels = true
                begin_top_loc  = job_instance.find_top_level_instruction_id_for_id(begin_loc)
                end_top_loc    = job_instance.find_top_level_instruction_id_for_id(end_loc)
            }
            if((begin_loc != begin_top_loc) || (end_loc != end_top_loc)){
                warning("Because your begin mark and/or end mark are not set to top level instructions,<br/>" +
                        "what is inserted will not match what is played perfectly.")
            }
            //the below IF-ELSE  computes do_list_to_use. After that, make its src code.
            if(MiRecord.get_play_middle()){ //includes begin_loc (if its top level), excludes end_loc.
                //the big dilemma: should I use begin_top_loc or begin_loc to initialize "i" to?
                //If I use begin_top_loc, then playing the ends may play some instrs that are also played
                //by middle. But using begin_loc, we may skip some instrs that are inside the middle
                //at its beginning but not top level.
                //Can't win here in giving the user and easy model.
                //If they set their begin and end marks to top level, the model is easy,
                //but not if they don't.
                for(let i = begin_loc; i < end_loc; i++){ //don't use end_top_loc because we are already filtering in the body of the for for top level so for end we get all the top leve linstrs up to bet not including end_loc
                    if(use_str_instrs || !has_non_top_levels || job_instance.is_top_level_do_list_item(i)) {
                        let instr_to_include = do_list_to_mine[i]
                        if(!Instruction.is_no_op_instruction(instr_to_include)){ //besides the usual no_ops on the do_list,
                                    //there can be undefined's because if we are just grapping the inserted strigs.
                                    //the do_list_to_mine will have lots of undefines on it
                                    //since that's what make_string_do_list_from_sent_instr_strings produces
                                    //by design
                            result_do_list.push(do_list_to_mine[i])
                        }
                    }
                }
            }
            else { //concatenate the ends together, leaving out the middle.
                   //excludes begin_top_loc, includes end top loc.
                //grab the head seg.
                for(let i = 0; i < begin_loc; i++){
                    if(use_str_instrs || job_instance.is_top_level_do_list_item(i)) {
                        let instr_to_include = do_list_to_mine[i]
                        if(!Instruction.is_no_op_instruction(instr_to_include)){
                            result_do_list.push(do_list_to_mine[i])
                        }
                    }
                }
                //grab the tail seg
                for(let i = end_loc; i < do_list_to_mine.length; i++){
                    if(use_str_instrs || job_instance.is_top_level_do_list_item(i)) {
                        let instr_to_include = do_list_to_mine[i]
                        if(!Instruction.is_no_op_instruction(instr_to_include)){
                            result_do_list.push(do_list_to_mine[i])
                        }
                    }
                }
            }
            if(MiRecord.get_play_middle() && (begin_top_loc == 0) &&
                ((end_top_loc == 0) || (end_top_loc == do_list_to_mine.length))) {} //we've never played the job, or at least we're not attempting to get just a segment of the do_list, so use the orig src.
                //note that if the src has something like Dexter.set_parameter(...), then that
                //will eval to an oplet array, and so attempting to get the evaled array
                //do_list_to_mine (or result_do_list) and doing to_source_code on it is NOT going to
                //return "Dexter.set_parameter(...)" but rather make_ins("S"...) which is not what we want,
                //so just use the orig src.
            else { do_list_src = to_source_code({value: result_do_list, one_line_per_array_elt:true, array_elt_max_chars: 100})}
            if(mi_job_instrs_wrapper_data_id.checked){
                //do_list_src = replace_substrings(do_list_src, "\n", "\n ") //indent 2nd thru nth lines just one space for the outer close square bracket
            }
            else {
                do_list_src = replace_substrings(do_list_src, "\n", "\n        ") //indent 2nd thru nth lines
            }
            do_list_src = do_list_src.trim() //get rid of extra whitespace at end

            let result
            if(mi_job_instrs_wrapper_job_id.checked) {
                if(!this.validate_instruction_name_ui()) { return ["Invalid Job source code in Make Instruction dialog."]} //error messages are printed by this
                let call_obj = this.make_call_obj_from_ui()
                call_obj.args_obj.name = '"' + target_job_name + '"'
                call_obj.args_obj.do_list = do_list_src
                result = this.call_obj_to_instruction_src(true, call_obj) //returns null if there's an error
            }
            else if(mi_job_instrs_wrapper_var_id.checked){ //var
                result = "var " + mi_job_instrs_wrapper_name_id.value + " = " + do_list_src
            }
            else if (mi_job_instrs_wrapper_data_id.checked){
                result = do_list_src
            }
            else {
                shouldnt("Im MakeInstruction.low_level_code, when inserting, didn't find a wrapper radio button checked.")
            }
            if (result == null) { return ["There's an error in the Job definition."] }
            else return "\n" + result
        }
    }

    static make_string_do_list_from_orig(orig_do_list, job_instance){
        let result = new Array(orig_do_list.length)
        for(let i = 0; i < orig_do_list.length; i++){
            let orig_instr = orig_do_list[i]
            if(job_instance && Instruction.is_data_array(orig_instr)) { //worth a shot and necessary for recording jobs which haven't been started
                orig_instr = job_instance.transform_data_array(orig_instr)
            }
            if((typeof(orig_instr) == "string") || Instruction.is_oplet_array(orig_instr)){
                let str = Socket.oplet_array_or_string_to_string(orig_instr)
                str = this.trim_prefix_off_instr_string(str)
                result[i] = str
            }
            //else can't convert it to a string so forget it.
        }
        return result
    }

    static make_string_do_list_from_sent_instr_strings(sent_instr_strings_array, job_instance){
       let result = new Array(job_instance.do_list.length)
       for(let instr_str of sent_instr_strings_array){
           let instr_id = Instruction.extract_instruction_id(instr_str)
           let trimmed_str = this.trim_prefix_off_instr_string(instr_str)
           result[instr_id] = trimmed_str
       }
       return result
    }

   // MakeInstruction.trim_prefix_off_instr_string("1  2  3333 undefined a 200 300;") =>
   // a 200 300;"
    //allows > 1 space between parts.
    static trim_prefix_off_instr_string(full_instr_string){
       let split_arr = full_instr_string.split(" ")
       let on_field = 0
       let last_char_was_space = false
       for(let i = 0; i < full_instr_string.length; i++) {
           let char = full_instr_string[i]
           if(char == " ") {
               if(last_char_was_space) {}
               else { last_char_was_space = true }
           }
           else if (last_char_was_space) {
               last_char_was_space = false
               on_field += 1
               if(on_field == Dexter.INSTRUCTION_TYPE){
                   let result = full_instr_string.substring(i)
                   return result
               }
           }
       }
    }

} //end MakeInstruction class



MakeInstruction.menu_hierarchy = [
    ["Dexter move",  "move_all_joints", "move_all_joints_relative",
                     "move_home",
                     "move_to", "move_to_relative", "move_to_straight",
                     "pid_move_all_joints", "pid_move_to"],
    ["Dexter mode",  "set_follow_me", "set_force_protect", "set_keep_position", "set_open_loop"],
    ["Dexter common", "draw_dxf", "empty_instruction_queue_immediately", "empty_instruction_queue",
                      "get_robot_status", "make_ins", "read_file",
                      "run_gcode", "set_parameter", "write_file"],
    ["Dexter rare", "calibrate_build_tables", "capture_ad", "capture_points", "cause_error", "dma_read", "dma_write", "exit",
                    "find_index", "load_tables",
                    "record_movement", "replay_movement",
                    "sleep",  "slow_move", "write"],
    ["Human",       "enter_choice", "enter_filepath", "enter_instruction", "enter_number",
                    "enter_position", "enter_text", "notify", "show_window", "speak", "task"],
    ["Control",     "break", "continue", "go_to", "loop", "label",
                      "suspend", "unsuspend", "sync_point", "wait_until"],
    ["Control Jobs", "include_job", "send_to_job", /*"sent_from_job" don't let user use this*/
                     "start_job", "stop_job"],
    ["Control bugs", "debugger", "error", "if_any_errors", "step_instructions"],
    ["IO",  "get_page", "grab_robot_status",  "out",
                   "show_picture", "show_video", "take_picture"],

    ["Serial",     "string_instruction"],
    ["Misc"      , "function", "function*",
                   //"null", don't have null on menu. its a valid instruction but does nothing, hard to support, and you wouldn't explicitly put one in a job's do_list
                    "new Array", "new Dexter", "new Job", "new Note", "new Phrase", "new Serial", "new TestSuite"
                   ]
]

var Socket = require("./core/socket.js") //used for string instruction processing
var esprima = require('esprima')
var {ends_with_one_of, fn_is_keyword_fn, replace_substrings, starts_with_one_of, trim_end} = require("./core/utils.js")
var {to_source_code} = require("./core/to_source_code.js")
var {file_exists, write_file, make_full_path} = require("./core/storage.js")
