// In DDE3, both "./nouislider.css" and "./nouislider_fry.css", from the below lines, are included before general "styles.css". We might want to make sure that this css inclusion order is maintained.
import "./nouislider.css"
import "./nouislider_fry.css"
import "./nouislider.js"

class MiRecord {
    static instruction_suffix_html(loc){
        let the_do_list = MiState.get_do_list_smart()
        let top_or_not = ""
        let instr_html = ""
        if (the_do_list){
            if(loc < the_do_list.length){
                top_or_not = this.instruction_props_html(loc)
                let instr  = the_do_list[loc]
                if (is_array_of_numbers(instr)){
                    instr = Vector.round(instr, 3)
                }
                instr_html = to_source_code({value: instr}).substr(0, 60)
            }
            else { instr_html = " beyond final instruction." }
        }
        else {
            instr_html = " not initialized."
        }
        let result = " at " + loc + " " + top_or_not + "&nbsp;is " + instr_html
        return result
    }

    static instruction_props_html(loc){
        let job_instance = MiState.job_instance
        let result = ""
        if(job_instance //&& job_instance.do_list
           //job_instance.highest_completed_instruction_id == (job_instance.do_list.length - 1) &&
           //job_instance.top_level_instruction_id_array
            ){
            if(job_instance.is_do_list_item_top_level_array &&
               (loc >= job_instance.is_do_list_item_top_level_array.length)){
                warning("shouldn't happen in instruction_props_html with loc: " + loc)
            }
            let is_top_level = (job_instance.is_top_level_do_list_item ? job_instance.is_top_level_do_list_item(loc) : true) //
                  //true because if no do_list, we'd be working off the orig_args.do_list in which every item is top level
            let ok_to_play   = MiState.ok_to_play_loc(loc)
            let word = (is_top_level ? "TOP" : "&nbsp;NT ")
            let bg   = (ok_to_play ? "background-color:#a8ff94;" : "background-color:#BBBBBB;") //same as noUi slider connect background colors
            let decoration = (ok_to_play   ? "" : "text-decoration: line-through red;")
            let tooltip    = (is_top_level ? "This instruction is a top level do_list item,\n" +
                                             "likely in the Job definition's original do_list.\n" :

                                             "This instruction is NOT a top level do_list item.\n" +
                                             "It was generated by the top level item before it.\n")
            if(is_top_level && ok_to_play) { tooltip += "It will be included when inserted into the editor." }
            else                           { tooltip += "It will NOT be inserted into the editor." }
            result = `<span title="` + tooltip + `" style="` + decoration + bg + `">` + word + `</span>`
        }
       return result
    }

    static set_highest_completed_instruction_ui(){
        let loc = "None"
        if(MiState.job_instance){
            if(MiState.job_instance.do_list) {
                loc = MiState.job_instance.highest_completed_instruction_id
                if (MiState.job_instance.do_list && (loc == (MiState.job_instance.do_list.length - 1))) {
                    loc = loc + " (whole do_list completed)"
                }
            }
        }
        mi_highest_completed_instruction_id.innerHTML = loc
    }

    //can take a long time so be careful when calling
    /*static compute_top_level_instruction_id_array_maybe(){
        if(MiState.job_instance &&
           MiState.job_instance.do_list &&
           (MiState.job_instance.highest_completed_instruction_id + 1) == MiState.job_instance.do_list.length) {
            MiState.job_instance.make_top_level_instruction_id_array()
        }
    }*/

    static get_play_loc(){
        return parseInt(mi_record_slider_id.value)
    }
    static set_play_loc(event_or_loc=null){ //event_or_loc, if not passed, defaults to
        //the current slider play_loc slider position. We do this when we want to
        //refresh the instruction_suffix_html because user has dragged and end or begin mark.
        //out("set_play_loc passed: " + event_or_loc)
        let job_instance = this.job_in_mi_dialog()
        let the_do_list  = MiState.get_do_list_smart()
        let loc
        if(event_or_loc === null)                  { loc = MiRecord.get_play_loc() }
        else if (typeof(event_or_loc) == "number") { loc = event_or_loc }
        else {                                       loc = parseInt(event_or_loc.value) }
        //out("set_play_loc passed: " + loc)
        if (loc < 0) { loc = 0 }
        if(job_instance){
            if(job_instance.highest_completed_instruction === undefined) {} //probably at beginning of running job_instance
            else if(loc > job_instance.highest_completed_instruction){
                warning("You can't start playing an instruction <br/>" +
                        "that's higher than the highest_completed_instruction.")
                loc = job_instance.highest_completed_instruction
            }
        }
        mi_record_slider_id.value = loc
        let suffix = this.instruction_suffix_html(loc)
        let new_text = "next instr fwd " + suffix
        //if (the_do_list && (loc == the_do_list.length)) { new_text = "next instr fwd at " + loc + " is beyond final instruction." }
        //else { new_text  = "next instr fwd at " + loc + " is " + instr } //show small forward arrow?
        mi_record_slider_pos_id.innerHTML = new_text
    }
    static record_slider_on_input(event){
        this.set_play_loc(event)
        let job_instance = this.job_in_mi_dialog()
        if(this.looks_like_recording(job_instance)){
            let new_loc
            if(event === null)                  { new_loc = MiRecord.get_play_loc() }
            else if (typeof(event_or_loc) == "number") { new_loc = event }
            else {                                       new_loc = parseInt(event.value) }
            if(this.play_enabled_for_loc(new_loc)){
                this.run_one_instruction(new_loc)
                /* below is a failed attempt jul 10. 2021 to get around the new
                   restriction that only one active Job can have a dexter instance
                   as its default robot.
                  if(new_loc > job_instance.program_counter) {

                    while(new_loc > job_instance.program_counter) {
                        this.step_play()
                    }
                }
                else if (new_loc < job_instance.program_counter) {
                    while(new_loc < new_loc < job_instance.program_counter){
                        this.step_reverse()
                    }
                }
                else {} //prev_loc == new_loc so do nothing
                */
            }
        }
    }

    static looks_like_recording(a_job){
        let the_do_list = MiState.get_do_list_smart()
        if((a_job instanceof Job) &&
            ((a_job.data_array_transformer == "P") ||
             (a_job.orig_args.data_array_transformer == "P"))){
           for(let inst of the_do_list){ //warning: expensive if its a long job
               if(!is_array_of_numbers(inst)) { return false }
           }
           return true
        }
        else { return false }
    }

    static run_one_instruction(loc){
        //let rob = Dexter.default
        if(!Job.run_one){
            MiRecord.run_one_instruction_make_new_job(loc)
        }
        /*else if (Job.run_one.robot != rob){
            if(["starting", "running", "suspended", "waiting"].includes(Job.run_one.status_code)){
                Job.run_one.stop_for_reason("interrupted", "run_one Job needs a different robot of: " + rob.name)
                setTimeout(function(){MiRecord.run_one_instruction_make_new_job(loc)},
                           100)
            }
            else {
                MiRecord.run_one_instruction_make_new_job(loc)
            }
        }*/
        else if(Job.run_one.status_code == "starting") {} //just forget about the instruction in loc.
        // when it finishes starting, it will run the first loc handed it,
        // and then start running subsequent dragged instructions. It may skip 2nd plus a few more insructions,
        // but not so bad.
        else if (Job.run_one.status_code == "running") {
            MiRecord.run_one_instruction_job_ready(loc)
        }
        else if (["not_started", "errored", "interrupted", "completed"].includes(Job.run_one.status_code)) { //job exists but is stopped.
            Job.run_one.start()
            setTimeout(function () { //give Job.run_one a chance to start up before
                                     //adding  the instruction as it has to
                                     //first copy its empty orig do list,
                                     //then it will be ready to get the new instr added.
                            MiRecord.run_one_instruction_job_ready(loc)
                        },
                        100)
        }
        else if(Job.run_one.status_code === "waiting"){
            MiRecord.run_one_instruction_job_ready(loc)
        }
        else {
            shouldnt("In run_one_instruction with unhandled ob.run_one.status_code of: " + ob.run_one.status_code)
        }
    }

    static run_one_instruction_make_new_job(loc){
        new Job({name: "run_one",
                 robot: new Brain({name: "brain_run_one"}), //Dexter.default
                    //had to change this too brain because the MAIN job for the record will
                    //have the default dexter Dexter as its robot DDE doesn't allow
                    //2 jobs to be active at once with the same Dexter instance.
                 show_instructions: false,
                 inter_do_item_dur: 0,
                 when_do_list_done: "wait"}).start()
        this.run_one_instruction_job_ready(loc)
    }

    static run_one_instruction_job_ready(loc){
        let job_instance = this.job_in_mi_dialog()
        let the_do_list  = MiState.get_do_list_smart()
        if(loc < the_do_list.length){
            let inst = the_do_list[loc]
            if(inst instanceof Instruction.Dexter){
                if(inst.robot === undefined){
                   if(job_instance.robot instanceof Dexter){
                        inst.robot = job_instance.robot
                   }
                   else { //this shouldn't be necessary, but is an extra precaution likely to work
                       inst.robot = Dexter.default
                   }
                }
            }
            else if(Instruction.is_data_array(inst)){ //normal case for a recording to have do_list items of data_arrays that need to be transformed
               inst = job_instance.transform_data_array(inst)
               if(Instruction.is_oplet_array(inst)){ //normal as when the data transformer is the default "P" as it is when recording a job
                   let last_elt = last(inst)
                   if (!(last_elt instanceof Robot)) { //this is the normal case
                       inst = inst.slice() //copy the array
                       inst.push(job_instance.robot) //now Job.send will know what robot to send this instruction to
                   }
               }
            }
            Job.run_one.insert_single_instruction(inst, false)
        }
        else {
            warning("run_one_instruction beyond final instruction: " + loc)
        }
    }

    static get_max_loc(){
      let the_do_list = MiState.get_do_list_smart()
      if (the_do_list) {
          let result = the_do_list.length
          if (result < 0) { return 0 }
          else { return result }
      }
      else { return 0 }
    }

    static set_max_loc()   {
        let max = this.get_max_loc()
        if(max != parseInt(mi_record_slider_id.max)) { //don't unnessarily do this
            mi_record_slider_id.max = max
            mi_record_slider_max_id.innerHTML = max
            mi_marks_slider_max_id.innerHTML  = max
            mi_marks_slider_id.noUiSlider.updateOptions({range: {min:-0.01, max:max}}) //noUiSlider requires max to be more than min or it will error
        }
    }

    static get_begin_mark_loc(){ return parseInt(mi_marks_slider_id.noUiSlider.get()[0]) }

    static set_begin_mark_loc(event_or_loc = null){ //event_or_loc, if not passed, defaults to
        let end_loc = this.get_end_mark_loc()
        let loc
        if      (typeof(event_or_loc) == "number") { loc = event_or_loc }
        else if (typeof(event_or_loc) == "string") { loc = parseFloat(event_or_loc) } //noUiSlider onslide passes in a float as a string. Must parse it as a float (not int) and round below
        else if (event_or_loc === null)            { loc = this.get_begin_mark_loc() } //we're just "refreshing" the suffix
        else                                       { loc = parseInt(event_or_loc.value) }
        if (loc < 0) { loc = 0 }
        if (loc > end_loc) {
            this.set_begin_mark_loc(end_loc)
            dde_error("You can't set the begin mark to after the end mark.<br/>" +
                      "Move the end mark further right first.")
        }
        loc = Math.round(loc) //the slider callback onslide returns a float
        //let the_do_list = MiState.get_do_list_smart()
        //let instr = ""
        //if(the_do_list) {
        //    instr = the_do_list[loc]
        //    instr = to_source_code({value: instr}).substr(0, 60)
        //}
        mi_marks_slider_id.noUiSlider.setHandle(0, loc)
        let suffix = this.instruction_suffix_html(loc)
        mi_begin_marks_slider_pos_id.innerHTML = "begin mark " + suffix //loc + " is " + instr
        this.set_play_loc() //updates the suffix maybe
    }

    static get_end_mark_loc()  { return parseInt(mi_marks_slider_id.noUiSlider.get()[1]) }

    static set_end_mark_loc(event_or_loc = null){ //event_or_loc, if not passed, defaults to
        let begin_loc = this.get_begin_mark_loc()
        let the_do_list = MiState.get_do_list_smart() //probably gets real do_lsit here.
        let loc
        if      (typeof(event_or_loc) == "number")     { loc = event_or_loc }
        else if (event_or_loc == "extend_maybe") { //passed by set_up_next_do
            let old_end_loc = this.get_end_mark_loc()
            if (old_end_loc == the_do_list.length - 2) { loc = the_do_list.length - 1 }
            else { return }  //no change to the loc.
        }
        else if (typeof(event_or_loc) == "string")     { loc = parseFloat(event_or_loc) }//noUiSlider onslide passes in a float as a string. Must parse it as a float (not int) and round below
        else if (event_or_loc === null)                { loc = this.get_end_mark_loc() } //we're just "refreshing" the suffix
        else                                           { loc = parseInt(event_or_loc.value) }
        if (loc < 0)                                   { loc = 0 }
        if (loc < begin_loc) {
            this.set_begin_mark_loc(begin_loc)
            dde_error("You can't set the end mark to before the begin mark.<br/>" +
                "Move the begin mark further left first.")
        }
        loc = Math.round(loc) //the slider callback onslide returns a float
        mi_marks_slider_id.noUiSlider.setHandle(1, loc)
        let suffix = this.instruction_suffix_html(loc)
        mi_end_marks_slider_pos_id.innerHTML = "end &nbsp;&nbsp;&nbsp;mark " + suffix //loc + " is " + instr
        this.set_play_loc() //updates the suffix maybe
    }

    static get_play_middle(){ return mi_play_middle_checkbox_id.checked  }

    static set_play_middle(true_or_false) { mi_play_middle_checkbox_id.checked = true_or_false }

    static is_job_in_mi_dialog(){ return MakeInstruction.get_instruction_name_from_ui() == "new Job" }

    static job_in_mi_dialog(){
        if(!this.is_job_in_mi_dialog()) { return null }
        let job_name = MakeInstruction.arg_name_to_src_in_mi_dialog("name")
        if (!is_string_a_literal_string(job_name)) { return false }
        job_name = job_name.substring(1, job_name.length - 1)
        if(job_name.length == 0) { return false }
        let job_instance = Job[job_name]
        if(job_instance instanceof Job) { return job_instance }
        else { return null }
    }



    //do_list now has the orig do_list in it,  but does it need to be run to be
    //used by the play buttons?
    /*static start_is_done_with_initial_g_and_paused(job_instance){
        if(Instruction.array_has_only_non_inserting_instructions(job_instance.do_list, job_instance)){
            job_instance.playable = true
            job_instance.disable_modify_do_list = true
            job_instance.dont_proceed_after_initial_g = false //not sure I should do this here.
            job_instance.stop_for_reason("interrupted", "Normal stopping of Job after initialization.")
            this.last_play_button_success_fn.apply(this)
        }
        else {
           warning("Job." + job_instance + " is defined.<br/>" +
                   "In order to use the play/step controls with this Job,<br/>" +
                   "you must run the Job once through completion.<br/>" +
                   'Click on <button>Run</button> in Make Instruction dialog to do this.')
        }
    }*/

    static start_record(){
        if(!this.is_job_in_mi_dialog()){
            MakeInstruction.update_instruction_name_and_args("new Job")
            let si_elt = MakeInstruction.arg_name_to_dom_elt_id("show_instructions")
            si_elt = window[si_elt]
            si_elt.value = "false"
        }
        else {
            window[MakeInstruction.arg_name_to_dom_elt_id("do_list")].value = "[]" //just cosmetic to let users
            // know we're creating a new recording when the user clicks the record button.
            //the do_list will be replaced when user click the record button to stop recording.
        }
        let job_name = MakeInstruction.arg_name_to_src_in_mi_dialog("name")
        job_name = job_name.trim()
        if (is_string_a_literal_string(job_name)) {
            job_name = job_name.substring(1, job_name.length - 1)
            if(job_name.length == 0) {
                sim_pane_content_id.scrollTop = 0
                MakeInstruction.set_border_color_of_arg("name", "red")
                let id = MakeInstruction.arg_name_to_dom_elt_id("name")
                let elt = window[id]
                elt.focus() //hmm, not working. maybe because doc pane is scrolling to the Job doc???
                elt.setSelectionRange(1, 1) //set cursor to between the two quote chars.
                out("The name in the Job field is an empty string.<br/>" +
                           'Please edit the Job name and click "Record" again.<br/>' +
                           "Preserve the quotes around the Job name.",
                           "red")
                return
            }
            else { //keep pane scrolled to bottom so that user can click on "record" button to stop
                sim_pane_content_id.scrollTop = 500
            }
        }
        else {
            sim_pane_content_id.scrollTop = 0
            MakeInstruction.set_border_color_of_arg("name", "red")
            let id = MakeInstruction.arg_name_to_dom_elt_id("name")
            let elt = window[id]
            elt.focus()
            MakeInstruction.set_border_color_of_arg("name", "red")
            dde_error("The name in the Job field, <code>&nbsp;" + elt.value + "&nbsp;</code>, is not a literal string.<br/>" +
                      "A literal string is surrounded with single or double quotes.<br/>" +
                      "To record, we must have a valid Job name.<br/>" +
                      'Please edit the Job name and click "Record" again.')
        }
        MakeInstruction.set_border_color_of_arg("name") //valid name so set it back to normal
        let job_instance = Job[job_name]
        if (!job_instance) {
            let inst_src = MakeInstruction.dialog_to_instruction_src(true)
            if (inst_src == null) { return null } //error message has already been printed by dialog_to_instruction_src
            try { job_instance = eval(inst_src) }
            catch(err){ //this should rarely happen because dialog_to_instruction_src catcnes most bad args.
                dde_error("The job in the dialog is invalid with: <br/>" +
                err.message +
                "<br/>Please edit its fields and try again.")
            }
        }
        MiState.job_instance = job_instance
        this.start_record_pre_aux()
    }

    static start_record_pre_aux() {
        let job_wrapper_robot = Dexter.default
        let active_jobs = job_wrapper_robot.active_jobs_using_this_robot()
        if(active_jobs.length > 0) {
            for(let a_job of active_jobs){
                a_job.stop_for_reason("interrupted", "Make Instruction stopped this job to do a recording using this Job's robot.") //just kill it, even if suspended
                a_job.set_up_next_do(0)
            }
            setTimeout(MiRecord.start_record_aux, MiState.job_instance.inter_do_item_dur + 100)
        }
        //if(job_instance.status_code == "suspended") {
        //    job_instance.unsuspend()
        //    setTimeout(MiRecord.start_record_aux, job_instance.inter_do_item_dur + 100)
        //}
        else { this.start_record_aux() }
    }

    static start_record_aux(){
        let job_instance = MiState.job_instance //closed over
        delete job_instance.do_list
        job_instance.orig_args.do_list = [] //might be a previous recording in there. lose it!
        //ok now we've got a valid job with job_instance.orig_args.do_list == []
        MiState.status = "recording"
        MiRecord.set_max_loc(0)
        MiRecord.set_end_mark_loc(0)
        MiRecord.set_begin_mark_loc(0)
        MiRecord.set_play_loc(0)

        MiRecord.set_record_state("active")
        MiRecord.set_pause_state("enabled")
        MiRecord.set_step_reverse_state("disabled")
        MiRecord.set_reverse_state("disabled")
        MiRecord.set_step_play_state("disabled")
        MiRecord.set_play_state("disabled")
        MiRecord.set_insert_recording_state("disabled")
        let job_wrapper_robot = Dexter.default //we want to use the
        //same robot for doing the recording as we will for running the job that is recorded.
        MiRecord.start_time_in_ms = Date.now()
        console.log("just before starting record job")
        new Job({
            name: "mi_record",
            robot: job_wrapper_robot,
            show_instructions: false,
            do_list: [
                function() {
                    if(this.robot.is_calibrated()) { return } //ok, proceed with recording
                    else if(confirm("To record, you must first calibrate " + this.robot.name + ".\n" +
                            "Clear the hemisphere around Dexter and\n" +
                            "click OK (takes 3 to 4 minutes) or\n" +
                            "click Cancel.")){
                            out("Now calibrating...")
                                return [ Dexter.set_parameter("RunFile", "Cal.make_ins"), //does calibration.
                                         Dexter.empty_instruction_queue(), //"F"
                                         function(){
                                             out("Calibration done.")
                                             if(!this.robot.is_calibrated()) {
                                                 warning(this.robot.name + " failed to calibrate correctly so recording is being stopped.")
                                                 MiRecord.stop_record(false) //false means: did not complete Job ok
                                             }
                                             else if(confirm(this.robot.name + " has been calibrated.\n" +
                                                       "Click OK to start recording.\n" +
                                                       "Click Cancel to not record.")){
                                                       return
                                             }
                                             else {
                                                 MiRecord.stop_record(false) //false means: did not complete Job ok. This stops the job
                                                 return //Control.stop_job(undefined, "User stopped Job after calibration.")
                                             }
                                         }
                                       ]
                    }
                    else {
                        MiRecord.stop_record(false) //false means did not complete Job ok. This stops the job
                        return //Control.stop_job(undefined, "User stopped Job rather than calibrating robot.")
                    }
                },
                Dexter.set_follow_me(),
                Control.loop(true,
                             function(){
                                console.log("top of record job's loop")
                                if(MiState.status == "recording_paused") {} //loop around
                                else {
                                    let rs_array = last(this.rs_history)
                                    let rs_obj = new RobotStatus({robot_status: rs_array})
                                    let angles = rs_obj.measured_angles(7)
                                    //angles.unshift("@")
                                    job_instance.orig_args.do_list.push(angles)
                                    let loc_of_new_instr = job_instance.orig_args.do_list.length - 1 //will be at least 0 due to the above push
                                    MiRecord.set_max_loc()
                                    MiRecord.set_play_loc(loc_of_new_instr) //because we want to SEE the instr just recorded, not one beyond it
                                    //out("Recording Dexter joint angles: " + angles, "#95444a", //brown,
                                    //     true)
                                    return this.robot.get_robot_status() //immediately()
                                }
                             }),
                Dexter.empty_instruction_queue(), // needed so record can get the timing
                //of the final g cmd to set inter_do_item_dur correctly.
                Dexter.get_robot_status() //get the start time of this for the end of the recording,.
            ]}).start()

    }

    static stop_record(completed_ok=true){
        MiRecord.stop_time_in_ms = Date.now()
        Job.mi_record.stop_for_reason("interrupted", "User stopped the recording.")
        setTimeout(function(){MiRecord.stop_record_aux(completed_ok)},  //give job a chance to stop properly since its still recording
                   (MiState.job_instance.inter_do_item_dur * 1000) + 300) //timeout needed for letting recordinng job to finish before calling Job.mi_record.undefine_job
    }
    //can't use 'this' because its not bound when called from the timeout above
    static stop_record_aux(completed_ok=true){
        MiState.status           = null //"recording", "playing" "reverse_playing", "stepping", "reverse_stepping"
        if(completed_ok){
            MiRecord.stick_recording_in_ui()
            MiRecord.set_max_loc() //grabs smart do_list, must be done before setting end mark or end mark will truncate to old max
            let the_do_list = MiState.get_do_list_smart() //this will always get the orig do_list length right after a record.
            MiRecord.set_end_mark_loc(the_do_list.length) //do before calling play_middle_onchange
            MiRecord.set_play_middle(true) //do before calling play_middle_onchange
            MiRecord.set_begin_mark_loc(0) //needs to be after end mark setting.
            MiRecord.play_middle_onchange() //just sets ui of highlighted segments and delete button

            MiRecord.set_play_loc(0)
        }
        MiRecord.set_record_state("enabled")
        MiRecord.set_step_reverse_state("enabled")
        MiRecord.set_reverse_state("enabled")
        MiRecord.set_pause_state("disabled")
        MiRecord.set_step_play_state("enabled")
        MiRecord.set_play_state("enabled")
        MiRecord.set_insert_recording_state("enabled")
        //Job.mi_record.undefine_job() //causes problems in sim, so just do:
        //Job.mi_record.robot.remove_from_busy_job_array(Job.mi_record)
        Dexter.remove_from_busy_job_arrays(Job.mi_record)
        Job.mi_record.remove_job_button()
        if(completed_ok){
            new Job({
                name: "mi_set_keep_position",
                robot: Job.mi_record.robot,
                do_list: [Dexter.set_keep_position()]}).start()
        }
    }

    //this fn side-effects the MI dialog items: do_list and inter_do_item_dur
    static stick_recording_in_ui(){
        let job_instance = this.job_in_mi_dialog()
        let do_list_src = "["
        let recorded_do_list = job_instance.orig_args.do_list
        for(let i = 0; i < recorded_do_list.length; i++){
           let instr_src = to_source_code({value: recorded_do_list[i]})
           let comma_or_not = ","
           let suffix = " "
           if(i == recorded_do_list.length - 1) {
                comma_or_not = " "
                suffix = "" //so final close square bracket won't be indented
           }
           let count_text = ((i == 0) ? " of " + recorded_do_list.length : "")
           do_list_src += instr_src + comma_or_not + " // " + i + count_text + "\n" + suffix
        }
        //do_list_src = replace_substrings(do_list_src, "],", "],\n")
        do_list_src += "]"
        let do_list_elt_id = MakeInstruction.arg_name_to_dom_elt_id("do_list")
        window[do_list_elt_id].value = do_list_src
        let dur_in_sec = (MiRecord.stop_time_in_ms - MiRecord.start_time_in_ms) / 1000
        let inter_do_item_dur_elt = window[MakeInstruction.arg_name_to_dom_elt_id("inter_do_item_dur")]

        //now set inter_do_item_dur in the job that represents this recording.
        let sent_inst_array = Job.mi_record.sent_instructions
        //grab start time of first non-initial "g" instruction.
        let start_time_in_ms
        for(let i = 1; //skip first g instr
            i < sent_inst_array.length;
            i++){
            let instr = sent_inst_array[i]
            if(instr[Instruction.INSTRUCTION_TYPE] == "g"){ //skip past the set mode ad loop instructions
                start_time_in_ms = instr[Instruction.START_TIME]
                break;
            }
        }
        if(!start_time_in_ms) {  out("No instructions recorded.") }
        else {
             let last_inst =  last(sent_inst_array) //should be the final "g"
             let stop_time_in_ms = last_inst[Instruction.START_TIME]
             let total_dur_in_ms = stop_time_in_ms - start_time_in_ms
             let number_of_recorded_items = recorded_do_list.length
             let inter_do_item_dur = (total_dur_in_ms / number_of_recorded_items) / 1000
             inter_do_item_dur_elt.value = inter_do_item_dur
             out("Your recording has duration: " + dur_in_sec + " seconds.")
        }
    }

    static start_reverse(step = false){
        if(!this.prepare_for_play()) {} //warning messages already printed.
        //now MiState.job_instance should be set
        else if(!MiState.job_instance.do_list || (this.get_play_loc() <= 0)) {
            warning("The play location is at 0.\nYou can't go backwards from 0.")
        }
        else {
            let [begin1, end1, begin2, end2] = this.get_play_instruction_locs()
            let real_end = ((typeof(end2) == "number") ? end2 : end1)
            if((begin1 === undefined) || (real_end == 0)) { warning("No instructions are selected to play backwards.") }
            else {
                MiState.status = (step ? "reverse_stepping" : "reverse_playing")
                let play_loc = this.get_play_loc()
                this.set_record_state("disabled")
                this.set_step_reverse_state((step ? "active" : "disabled"))
                this.set_reverse_state((step ? "disabled" : "active"))
                this.set_step_play_state("disabled")
                this.set_pause_state("enabled")
                this.set_play_state("disabled")
                this.set_insert_recording_state("disabled")
                MiState.job_instance.stop_reason = null //otherwise, if we ran to completion, do_next_item wouldn't allow instructions to be run
                MiState.job_instance.suspend("Make Instruction suspended this Job.") //If we don't have status_code = "suspended",  unsuspend will take no effect.
                //before the below, pc is on the last insr executed.
                MiState.job_instance.program_counter = play_loc //now pc is one after the first inst we want to execute.
                      //but MiState.run... will supply an inc of -1 to reduce that pc to
                      //what we want to execute first. The 1 in set_up_next_do(1) called by unsuspend is ignored
                      //by MiState.run... which always uses an inc of -1 for reverse and reverse step.
                MiState.job_instance.unsuspend()  //calls set_up_next_do(1), handles setting of disable_modify_do_list
            }
        }
    }

    static step_reverse(){
        this.start_reverse(true)
    }

    static step_play(){
        this.start_play(true)
    }

    //new semantics: sets MiState.job_instance to the job indicated in the MI dialog, and returns true,
    //else prints warnings on what to do and returns false
    static prepare_for_play(){
        if(Job.run_one && ["starting",  "running", "stopping", "suspended", "waiting"].includes(Job.run_one.status_code)){
            Job.run_one.stop_for_reason("interrupted", "Play button pressed so stop run_one job first.")
            setTimeout(function() { MiRecord.prepare_for_play()},  //MiRecord.prepare_for_play has to be wrapped in a fn because otherwise it gets called not with MiRecord as "this".
                       100)
        }
        if(!this.is_job_in_mi_dialog()) {
            warning("There is no Job in the Make Instruction dialog to play.<br/>" +
                "Pick one on the 'Replace Arg Values' menu,<br/>" +
                "or option_click on one in the editor.")
            return false
        }
        let job_name = MakeInstruction.arg_name_to_src_in_mi_dialog("name")
        if (!is_string_a_literal_string(job_name) || (job_name.length < 3)) {
            warning("The name field of the Job has invalid syntax.<br/>" +
                'It should look like <code>"my_job"</code> (including the quotes.)')
            return false
        }
        job_name = job_name.substring(1, job_name.length - 1)
        let job_instance = Job[job_name]
        if(!(job_instance instanceof Job) || !job_instance.do_list || (job_instance !== MiState.job_instance)) {
            let inst_src = MakeInstruction.dialog_to_instruction_src(true)
            if (inst_src == null) { return false } //error message has already been printed by dialog_to_instruction_src
            try { job_instance = window.eval(inst_src) }
            catch(err){ //this should rarely happen because dialog_to_instruction_src catches most bad args.
                warning("The job in the dialog is invalid with:<br/>" +
                    err.message)
                return false
            }
        }
        if(job_instance === MiState.job_instance) { }// no change so leave setting alone
        else { //got a new job.
            MiState.job_instance = job_instance
            //this.status              = null //null, "recording", "playing" "reverse_playing", "stepping", "reverse_stepping"
            this.init_with_job_in_dialog()
        }
        job_instance.modify_program_counter_increment_fn = MiState.run_next_instruction
        return true
    }

    //returns an array of start_loc and end_loc.
    //if start_loc is undefined, don't play
    static start_play_begin_end(step){
        let start_loc, end_loc
        let job_instance = this.job_in_mi_dialog()
        let [begin1, end1, begin2, end2] = this.get_play_instruction_locs()
        let play_loc = (job_instance.do_list ? this.get_play_loc() : 0 )
        if(begin1 == undefined) { //no selected play region, so leave start_loc undefined and return it
        }
        else if(this.get_play_middle()){
            if (play_loc < begin1) {
                start_loc = begin1
                end_loc = end1
            }
            else if ((play_loc >= begin1) && (play_loc <= end1)) {
                start_loc = play_loc
                end_loc = end1
            }
            else if (play_loc > end1) {
                if(step){
                    start_loc = play_loc
                    end_loc = "end"
                }
                else {
                    start_loc = begin1
                    end_loc = end1
                }
            }
            else {shouldnt("In start_play_begin_end middle") }
        }
        else { //play the ends
            if (play_loc < begin1) {
                start_loc = begin1
                end_loc = end1
            }
            else if ((play_loc >= begin1) && (play_loc <= end1)) {
                start_loc = play_loc
                end_loc = end1
            }
            else if(begin2 !== undefined) {
                if(play_loc <= begin2) {
                    start_loc = begin2
                    end_loc = end2
                }
                else if ((play_loc > begin2) && (play_loc < end2)){
                    start_loc = play_loc
                    end_loc = end2
                }
                else {  //might as well play whole end segment
                    start_loc = begin2
                    end_loc = end2
                }
             }
             else {} //don't play anything
        }
        return [start_loc, end_loc]
    }

    static start_play(step=false){
        if(!MiRecord.prepare_for_play()){ } //warnings already printed
        else { //we have a valid job in MiState.job_instance. It *might* not have a dolist
            MiState.status = (step ? "stepping" : "playing") //must be after prepare_for_play
            let job_instance = this.job_in_mi_dialog()
            //let play_loc = (job_instance.do_list ? this.get_play_loc() : 0 ) //if no do_list, we're going to start at 0
            //let [begin1, end1, begin2, end2] = this.get_play_instruction_locs()
            let  [start_loc, end_loc] = this.start_play_begin_end(step)
            if(start_loc === undefined) { warning("No instructions selected to play.") }
            else {
                if(!job_instance) { shouldnt("in MiRecord." + start_play + " with bad job_instance: " +  job_instance) }
                this.set_record_state("disabled")
                this.set_step_reverse_state("disabled")
                this.set_reverse_state("disabled")
                this.set_pause_state("enabled")
                this.set_step_play_state((step ? "active" : "disabled"))
                this.set_play_state((step ? "disabled" : "active"))
                this.set_insert_recording_state("disabled")
                if(!job_instance.do_list) { //must START the job
                    let begin1 = 0 //since no do_list, we haven't run any instructions, so only makes sense to start at the beginning, regardless of what the user has set for the begin slider. highest_completed_instruction here is none.
                    MiRecord.set_play_loc(start_loc)
                    //let end_pc = ((begin2 === undefined) ? end1 : end2) //beware, in the end2 case, there's a gap in the middle of instructions not to play
                    //end_pc += 1
                    if(end_loc == job_instance.orig_args.do_list.length) {
                        end_loc = "end" //pretty much always what you would want here. play to the end.
                                       //esp given that playing may insert instructions.
                    }
                    MiRecord.play_middle_onchange() //just sets ui of highlighted segments and delete button
                    job_instance.start({program_counter: start_loc,
                                        end_program_counter: end_loc,
                                        when_stopped: function() {MiRecord.pause("Job played to its end by Make Instruction.") }}) //can't used just this.pause_aux here because the job passes itsself as the subject when calling the when_stopped fn.
                }
                else if (start_loc == job_instance.do_list.length){
                    this.set_record_state("enabled")
                    this.set_step_reverse_state("enabled")
                    this.set_reverse_state("enabled")
                    this.set_step_play_state("enabled")
                    this.set_pause_state("enabled")
                    this.set_play_state("enabled")
                    warning("Play start location: " +  start_loc + " is already at the end of the Job's do_list.<br/>" +
                            "There are no more instructions to play.<br/>" +
                            "To play back already played instructions,<br/>" +
                            "drag the play location slider (round dot) to the left.")

                }
                else {
                   job_instance.stop_reason = null //otherwise, if we ran to completion, do_next_item wouldn't allow instructions to be run
                   job_instance.suspend("Make Instruction suspended this Job.") //If we don't have status_code = "suspended",  unsuspend will take no effect.
                   job_instance.program_counter = start_loc - 1 //-1 because unsuspend will call set_up_next_do(1), to make the first instruction run be play_loc.
                   job_instance.unsuspend()  //calls set_up_next_do(1), handles setting of disable_modify_do_list
                }
            }
        }
    }

    static pause(reason="Make Instruction suspended this Job."){
        if(MiState.status == "recording") {
            //MiRecord.stop_record()
            MiState.status = "recording_paused"
            this.set_pause_state("active")
            out("Recording paused. Click the pause button to resume recording.", "brown")
        }
        else if(MiState.status == "recording_paused") {
            //MiRecord.stop_record()
            MiState.status = "recording"
            this.set_pause_state("enabled")
            out("Recording resumed. Click the pause button to pause recording.", "brown")
        }
        else {
            MiState.status = null
            let job_instance = MiRecord.job_in_mi_dialog()
            if(!job_instance) { shouldnt("in MiRecord.pause got bad job_instance: " + job_instance) }
            job_instance.suspend(reason)
            this.pause_ui()
        }
    }

    static pause_ui(){
        this.set_record_state("enabled")
        this.set_step_reverse_state("enabled")
        this.set_reverse_state("enabled")
        this.set_step_play_state("enabled")
        this.set_pause_state("disabled")
        this.set_play_state("enabled")
        this.set_insert_recording_state("enabled")
    }

    static play_middle_onchange(){ //called when checkbox changed and by stop_record
        let begin_loc   = this.get_begin_mark_loc()
        let end_loc     = this.get_end_mark_loc()
        let the_do_list = MiState.get_do_list_smart()
        let marks_max   = (the_do_list ? the_do_list.length : 0)
        if(MiRecord.get_play_middle()){
            mi_marks_slider_id.noUiSlider.destroy() //disappears slider completely
            noUiSlider.create(mi_marks_slider_id, {
                start: [begin_loc, end_loc],
                connect: [false, true, false],
                range: {
                    'min': -0.01, //if min is not less than max, noUiSlider errors. So always make min -1, but
                              //then set_begin_mark auto-changes -1 to 0, so begin mark is never really -1
                    'max': marks_max
                }
            })
            mi_marks_slider_id.noUiSlider.on("slide", this.marks_slider_onslide)
            mi_marks_slider_id.noUiSlider.on("change", this.marks_slider_onchange) //fired at the end of a drag hande

            delete_instructions_id.innerHTML = "Delete ends"
        }
        else { //play the ends
            mi_marks_slider_id.noUiSlider.destroy() //disappears slider completely
            noUiSlider.create(mi_marks_slider_id, {
                start: [begin_loc, end_loc],
                connect: [true, false, true],
                range: {
                    'min': -0.01,
                    'max': marks_max
                }
            })
            mi_marks_slider_id.noUiSlider.on("slide", this.marks_slider_onslide)
            mi_marks_slider_id.noUiSlider.on("change", this.marks_slider_onchange)
            delete_instructions_id.innerHTML = "Delete middle"
        }
        //refresh the "suffix html" designating if there current locs are in or out.
        this.set_play_loc()
        this.set_begin_mark_loc()
        this.set_end_mark_loc()
    }


    //____________
    /* obsolete static insert_recording(){
        let result =
`\nnew Job({
        name: "mi_play_1",
        do_list: [Dexter.set_keep_position(),
                  Dexter.loop(true,
                    function(iter_index){
                        if (iter_index >= mi_recorded_angles.length){
                             return Control.break()
                        }
                        else { return Dexter.pid_move_all_joints(mi_recorded_angles[iter_index]) }
                    })
        ]})` +
        "\n\nvar mi_recorded_angles =\n" +
        this.make_big_array_string()

        Editor.insert(result)
    }
    static make_big_array_string(){
        let job_instance = this.job_in_mi_dialog()
        let the_do_list = job_instance.do_list
        let result = "[ //______joints 1 through 7______\n"
        for(let i = 0; i < the_do_list.length; i++){
            result += "["
            let arr = the_do_list[i]
            result += arr.join(", ")
            let suffix = ((i == the_do_list.length - 1) ? " " : ",")
            result += "]" + suffix + " // " + i + "\n"
        }
        result += "]\n"
        return result
    }*/

    static record_dialog_open = false
    //________buttons_________
    static on_record_twistdown(event){
        if(event.target.open){
            DocCode.open_doc(make_instruction_recording_doc_id)
            this.record_dialog_open = true //used in insert recording to see if we should really insert the two jobs of a recording
        }
        else {
            this.record_dialog_open = false
        }
    }
    static make_html(){
        let result = "<details ontoggle='MiRecord.on_record_twistdown(event)'><summary>Recording</summary>" +
                       "<div style='white-space:nowrap;'>" +
                         "<input id='mi_record_id'       style='vertical-align:25%;cursor:pointer;' type='button' value='Record'/>" +
                         "<span  id='mi_reverse_id'      style='font-size:25px;margin-left:5px;cursor:pointer;'>&#9664;</span>" +
                         "<span  id='mi_step_reverse_id' style='font-size:15px;margin-left:5px;cursor:pointer;vertical-align:20%;'>&#9664;</span>" +
                         "<b     id='mi_pause_id'        style='font-size:28px;margin-left:5px;cursor:pointer;'>&#8545</b>" +
                         "<span  id='mi_step_play_id'    style='font-size:15px;margin-left:5px;cursor:pointer;vertical-align:20%;'>&#9654;</span>" +
                         "<span  id='mi_play_id'         style='font-size:25px;margin-left:5px;cursor:pointer;'>&#9654;</span>" +

                        /* "<div style='display:inline-block;margin-left:10px;vertical-align:50%'>" +
                              "Include only:<br/>" +
                              "<input name='middle_ends' type='radio' checked id='mi_play_middle_checkbox_id' onchange='MiRecord.play_middle_onchange()' style='margin-left:0px;cursor:pointer;' " +
                                      "title='When checked, Play, and Backwards Play\nwill only run the instructions between\n(inclusive) the knobs on the double slider below.\nUnchecked plays those instructions NOT between the two knobs.'/>" +
                              "middle" +
                               "<input name='middle_ends' type='radio' onchange='MiRecord.play_middle_onchange()' style='margin-left:12px;cursor:pointer;' " +
                               "title='When checked, Play, and Backwards Play\nwill only run the instructions between\n(inclusive) the knobs on the double slider below.\nUnchecked plays those instructions NOT between the two knobs.'/>" +
                               "ends" +
                         "</div>" +
                        */
                     "</div>" +
                     "<div style='white-space:nowrap;'>highest_completed_instruction: " +
                           "<span id='mi_highest_completed_instruction_id'>None</span> " +
                           "<button title='Click to reset the current job.\nThe next time it is played, it will be:\n1. redefined from the Make Instruction dialog code\n2. started.' style='padding:1px;font-size:13px;'>Reset</button>" +
                     "</div>" +
                     "<div id='mi_record_slider_pos_id' style='white-space:nowrap;'></div>" +
                     "<div style='white-space:nowrap;'>0" +
                       "<input id='mi_record_slider_id' oninput='MiRecord.record_slider_on_input(this)' type='range' value='0' min='0' max='100' style='width:270px;cursor:pointer;'" +
                             " title='Drag the knob to set\nthe starting play location.'/>" +
                       "&nbsp;<span id='mi_record_slider_max_id'>0</span>" +
                     "</div>" +
                    "<div style='white-space:nowrap;'> 0 <div id='mi_marks_slider_id' style='display:inline-block; width:270px;height:10px;' " +
                          `title='Designates which instructions will be used\nwhen you click play, backwards play or insert.\nGoverned by the "play middle" checkbox.'></div>` +
                        "&nbsp;<span id='mi_marks_slider_max_id'>0</span> &nbsp; " +
                        "<button title='Removes the grayed-out instructions&#13;from the do_list.' id='delete_instructions_id'>Delete ends</button>" +
                    "</div>" +
                    "&nbsp;&nbsp;Include only: " +
                    "<input name='middle_ends' type='radio' checked id='mi_play_middle_checkbox_id' onchange='MiRecord.play_middle_onchange()' style='margin-left:0px;cursor:pointer;' " +
                    "title='When checked, Play, and Backwards Play\nwill only run the instructions between\n(inclusive) the knobs on the double slider below.\nUnchecked plays those instructions NOT between the two knobs.'/>" +
                    "middle" +
                    "<input name='middle_ends' type='radio' onchange='MiRecord.play_middle_onchange()' style='margin-left:12px;cursor:pointer;' " +
                    "title='When checked, Play, and Backwards Play\nwill only run the instructions between\n(inclusive) the knobs on the double slider below.\nUnchecked plays those instructions NOT between the two knobs.'/>" +
                    "ends" +
                    "<div id='mi_begin_marks_slider_pos_id' style='white-space:nowrap;'></div>" +
                    "<div id='mi_end_marks_slider_pos_id'   style='white-space:nowrap;'></div>" +
                    "</details>"

        return result
    } //&VerticalSeparator;  document.getElementById("myBtn").disabled = true;

    //returns a string, either "all", "begin", "middle" or "end"
    //static get_play_segment_selection(){
    //   return document.querySelector('input[name="mi_play_segment"]:checked').value
    //}

    //returns an array of 4 non-neg integers indicating
    // the instructions that are permitted to play.
    // data format: [begin1, end1, begin2, end2]
    // but note that all 4 may be undefined, or the last 2 undefined,
    // meaning, don't play those segments
    //begin1 >= end1 >= begin2 >= end2  except if undefines.
    //if begin1 is undefined, so is begin2.
    //if a begin is undefined, so is its corresponding end.
    //if middle is checked, the numbers are inclusive.
    //if middle is unchecked, we play the two outer "end" segments,
    // exclusive of begin1 and end2.
    static get_play_instruction_locs(){
        let begin1, end1, begin2, end2
        if(MiRecord.get_play_middle()) {
            begin1 = this.get_begin_mark_loc()
            end1   = this.get_end_mark_loc()
        }
        else {
            begin1 = 0
            end1   = this.get_begin_mark_loc() - 1
            begin2 = this.get_end_mark_loc() + 1
            end2   = MiState.get_do_list_smart().length - 1
        }
        let locs = [begin1, end1, begin2, end2]
        return locs
     }

     static play_enabled_for_loc(loc){
         let begin = this.get_begin_mark_loc()
         let end   = this.get_end_mark_loc()
         if(MiRecord.get_play_middle()) {
             return ((loc >= begin) && (loc < end))
         }
         else { //only play ends
             return ((loc < begin) || (loc >= end))
         }
     }

    //cases: parens define the 2 segments, vertical bar is MiRecord.play_loc
    //    (   )   (   ) |
    //    (   )   ( | )
    //    (   ) | (   )
    //    ( | )   (   )
    // |  (   )   (   )
    // play_loc reduces the locs to play unless its <= begin1
    /* No longer needed
      static modify_play_instruction_locs_playing_forward(play_loc, locs){
         let [begin1, end1, begin2, end2] = locs
         if(begin1 === undefined) { return locs } //0 segments, nothing to play
         //else if(end2) { //we have 2 segments         (  )    (  )
         else if(end2 && (play_loc > end2)) {      //   (   )   (   ) |
             return [undefined, undefined, undefined, undefined]
         }
         else if(end2 && (play_loc <= end2) &&
                         (play_loc > begin2)){     //   (   )   ( | )
             return [play_loc, end2, undefined, undefined]
         }
         else if(play_loc > end1){                 //    (   ) | (   )
             return [begin2, end2, undefined, undefined]
         }
         // has seg 1, and maybe seg2 below here, leave seg2 alone
         else if((play_loc < end1) &&
                 (play_loc >= begin1)){            //    ( | )   (   )
             return [play_loc, end1, begin2, end2]
         }
         else  { return locs }                     // |  (   )   (   )
    }

    static modify_play_instruction_locs_playing_reverse(play_loc, locs){
        let [begin1, end1, begin2, end2] = locs
        if(begin1 === undefined) { return locs } //0 segments, nothing to play
        //else if(end2) { //we have 2 segments         (  )  (  )
        else if(end2 && (play_loc > end2)) {      //   (   )   (   ) |
            return locs
        }
        else if(end2 && (play_loc <= end2) &&
            (play_loc > begin2)){                 //   (   )   ( | )
            return [begin1, end1, begin2, play_loc]
        }
        else if(play_loc >= end1){                 //    (   ) | (   )
            return [begin1, end1, undefined, undefined]
        }
        // has seg 1, and maybe seg2 below here, leave seg2 alone
        else if((play_loc < end1) &&
            (play_loc >= begin1)){                //    ( | )   (   )
            return [begin1, play_loc, undefined, undefined]
        }
        else  {                                   // |  (   )   (   )
            return [undefined, undefined, undefined, undefined]
        }
    }*/

    //https://refreshless.com/nouislider/events-callbacks/
    static marks_slider_onslide(values_array, handle_number, unencoded, tap, positions){
         let new_val = values_array[handle_number]
         if(handle_number == 0)       { MiRecord.set_begin_mark_loc(new_val) } //can't use "this" here, must be MiRecord
         else if (handle_number == 1) { MiRecord.set_end_mark_loc(new_val) }
         else { shouldnt("in marks_slider_onupdate with handle_number: " + handle_number) }
    }

    static marks_slider_onchange(values_array, handle_number, unencoded, tap, positions){
        if(handle_number == 1) {
            if(MiState.job_instance &&
                (handle_number == 1) &&
                (values_array[1] == MiState.get_do_list_smart().length)){
                MiState.set_end_mark_to_do_list_length_maybe()
            }
        }
    }

     //ultimately called by show when there's a job in the dialog
    static init(){
       MiState.init(MiState.job_instance) //so that we don't set MiState.job_instance to null IFF MiState.job_instance is not null
       let max_loc = 0 //also used for end_loc
       //try to get a non-zero max_loc. This shows the user the do_list length
       //and, if we attempt to insert without playing, gives us a real do_list
       if(MiState.job_instance) {
           let do_list = MiState.get_do_list_smart()
           max_loc = do_list.length
       }
       else if(this.is_job_in_mi_dialog()){  //similar to MiRecord.prepare_for_play, but gets us a non-zero max_loc quicker
           let job_name = MakeInstruction.arg_name_to_src_in_mi_dialog("name")
           if (!is_string_a_literal_string(job_name) || (job_name.length < 3)) {
               warning("The name field of the Job has invalid syntax.<br/>" +
                   'It should look like <code>"my_job"</code> (including the quotes.)')
               return false
           }
           job_name = job_name.substring(1, job_name.length - 1)
           let job_instance = Job[job_name]
           if(!(job_instance instanceof Job) || !job_instance.do_list || (job_instance !== MiState.job_instance)) {
               let do_list_src = MakeInstruction.arg_name_to_src_in_mi_dialog("do_list")
               try {
                    let do_list = window.eval(do_list_src)
                    max_loc = do_list.length
               }
               catch(err){ //this should rarely happen because dialog_to_instruction_src catches most bad args.
                   warning("The job in the dialog has an invalid do_list<br/>" + err.message)
                   MakeInstruction.set_border_color_of_arg("do_list", "red")
               }
           }
           else {
               let do_list = get_do_list_smart()
               max_loc = do_list.length
           }
       }
       if(mi_marks_slider_id && mi_marks_slider_id.noUiSlider) { mi_marks_slider_id.noUiSlider.destroy() }
       noUiSlider.create(mi_marks_slider_id, {
            start: [0, 0],
            connect: [false, true, false],
            range: {
                'min': -0.01,
                'max': max_loc
            }
        })
        this.set_max_loc()
        this.set_end_mark_loc(max_loc)
        this.set_begin_mark_loc(0)
        this.set_play_loc(0)
        mi_marks_slider_max_id.innerHTML = max_loc
        mi_marks_slider_id.noUiSlider.on("slide", this.marks_slider_onslide)
        mi_marks_slider_id.noUiSlider.on("change", this.marks_slider_onchange)

        MiRecord.set_play_middle(true) //makes sense with no do_list. do before calling play_middle_onchange
        //MiRecord.play_middle_onchange() //don't do as screws up if no job_instance or do_list
        delete_instructions_id.innerHTML = "Delete ends"
        delete_instructions_id.onclick = MiRecord.delete_instructions
        mi_highest_completed_instruction_id.onclick = function(){ MiRecord.reset_job() }
       // MiState.set_end_mark_to_do_list_length_maybe() //no, we already take care of this above.
        this.set_record_state("enabled")
        this.set_reverse_state("disabled")
        this.set_step_reverse_state("disabled")
        this.set_pause_state("disabled")
        this.set_step_play_state("disabled")
        this.set_play_state("disabled")
        this.set_insert_recording_state("enabled")
        this.set_highest_completed_instruction_ui()
    }

    static init_with_job_in_dialog(){
        this.init()
        this.set_step_play_state("enabled")
        this.set_play_state("enabled")
    }

    static set_record_state(state) {
        if(state == "disabled") {
            mi_record_id.disabled = true
            mi_record_id.value    = "Record"
            mi_record_id.onclick  = function(){MiRecord.start_record()}
            mi_record_id.title    = "Record disabled while playing."
            mi_record_id.style["background-color"] = "#d8dadf" //"#ffd5e2"
        }
        else if(state == "enabled") {
            mi_record_id.disabled = false
            mi_record_id.value    = "Record"
            mi_record_id.onclick  = function(){MiRecord.start_record()}
            mi_record_id.title    = "Click to record Dexter's motions\nas you manually move it.\nRecordings are stored in Jobs."
            mi_record_id.style["background-color"] = "#ff8899" //"#ff6981"
        }
        else if(state == "active") {
            mi_record_id.disabled = false
            mi_record_id.value    = "recording"
            mi_record_id.onclick  = function(){MiRecord.stop_record()}
            mi_record_id.title    = "Click to stop recording."
            mi_record_id.style["background-color"] = "rgb(136, 255, 136)" //green,   "#ff2839" bright red
        }
        else {shouldnt("MiRecord.set_record_state passed invalid state: " + state) }
    }
    static set_reverse_state(state) {
        if(state == "disabled") {
            mi_reverse_id.disabled = true
            mi_reverse_id.onclick  = function(){MiRecord.start_reverse()}
            mi_reverse_id.title    = "Reverse is disabled when no recording and\nduring recording & playing."
            mi_reverse_id.style["color"] = "#bebcc0"
        }
        else if(state == "enabled") {
            mi_reverse_id.disabled = false
            mi_reverse_id.onclick  = function(){MiRecord.start_reverse()}
            mi_reverse_id.title    = "Play the current job backwards.\nPlay only those instructions indicated\nin dark green on the double slider below."
            mi_reverse_id.style["color"] = "#000000"
        }
        else if(state == "active") {
            mi_reverse_id.disabled = false
            mi_reverse_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_reverse_id.title    = "Click to stop playing."
            mi_reverse_id.style["color"] = "#00f036"  //green
        }
        else {shouldnt("MiRecord.set_reverse_state passed invalid state: " + state) }
    }

    static set_step_reverse_state(state) {
        if(state == "disabled") {
            mi_step_reverse_id.disabled = true
            mi_step_reverse_id.onclick     = function(){MiRecord.step_reverse()}
            mi_step_reverse_id.title       = "Play is disabled when there is no recording and\nduring recording."
            mi_step_reverse_id.style["color"] = "#bebcc0"
        }
        else if(state == "enabled") {
            mi_step_reverse_id.disabled = false
            mi_step_reverse_id.onclick     = function(){MiRecord.step_reverse()}
            mi_step_reverse_id.title       = "Run the current instruction and step back one instruction.\nIgnores the double slider below."
            mi_step_reverse_id.style["color"] = "#000000"
        }
        else if(state == "active") {
            mi_step_reverse_id.disabled = false
            mi_step_reverse_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_step_reverse_id.title    = "Click to stop playing."
            mi_step_reverse_id.style["color"] = "#00f036" //green
        }
        else {shouldnt("MiRecord.set_reverse_state passed invalid state: " + state) }
    }
    static set_pause_state(state) {
        if(state == "disabled") {
            mi_pause_id.disabled = true
            mi_pause_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_pause_id.title    = "Pause is disabled when not playing."
            mi_pause_id.style["color"] = "#bebcc0"
            mi_pause_id.style["background-color"] = "#EEEEEE"
        }
        else if(state == "enabled") {
            mi_pause_id.disabled = false
            mi_pause_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_pause_id.title    = "Stop playing."
            mi_pause_id.style["color"] = "#000000"
            mi_pause_id.style["background-color"] = "#EEEEEE"
        }
        else if(state == "active") { //only active when we are recording and paused during the recording
            mi_pause_id.disabled = false
            mi_pause_id.onclick  = function(){MiRecord.pause("Recording paused by Make Instruction.")}
            mi_pause_id.title    = "Resume recording."
            mi_pause_id.style["color"] = "#000000"
            mi_pause_id.style["background-color"] = "#FFF019" //"#FFD711" //"#FFF019" //rgb(255, 255, 50)" //102"#FFEE00" //yellow
        }
        else {shouldnt("MiRecord.set_reverse_state passed invalid state: " + state) }
    }
    static set_step_play_state(state) {
        if(state == "disabled") {
            mi_step_play_id.disabled = true
            mi_step_play_id.onclick     = function(){MiRecord.step_play()}
            mi_step_play_id.title       = "Play is disabled when there is no recording and\nduring recording."
            mi_step_play_id.style["color"] = "#bebcc0"
        }
        else if(state == "enabled") {
            mi_step_play_id.disabled = false
            mi_step_play_id.onclick     = function(){MiRecord.step_play()}
            mi_step_play_id.title       = "Run the current instruction and step forward one instruction.\nIgnores the double slider below."
            mi_step_play_id.style["color"] = "#000000"
        }
        else if(state == "active") {
            mi_step_play_id.disabled = false
            mi_step_play_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_step_play_id.title    = "Click to stop playing."
            mi_step_play_id.style["color"] = "#00f036" //green
        }
        else {shouldnt("MiRecord.set_reverse_state passed invalid state: " + state) }
    }

    static set_play_state(state) {
        if(state == "disabled") {
            mi_play_id.disabled = true
            mi_play_id.onclick     = function(){MiRecord.start_play()}
            mi_play_id.title       = "Play is disabled when there is no recording and\nduring recording."
            mi_play_id.style["color"] = "#bebcc0"
        }
        else if(state == "enabled") {
            mi_play_id.disabled = false
            mi_play_id.onclick     = function(){MiRecord.start_play()}
            mi_play_id.title       = "Play the current job forwards.\nPlay only those instructions indicated\nin dark green on the double slider below."
            mi_play_id.style["color"] = "#000000"
        }
        else if(state == "active") {
            mi_play_id.disabled = false
            mi_play_id.onclick  = function(){MiRecord.pause("Job paused by Make Instruction.")}
            mi_play_id.title    = "Click to stop playing."
            mi_play_id.style["color"] = "#00f036" //green
        }
        else {shouldnt("MiRecord.set_reverse_state passed invalid state: " + state) }
    }


    static set_insert_recording_state(state) { }
       /* if(state == "disabled") {
            mi_insert_recording_id.disabled = true
            mi_insert_recording_id.value    = "Insert Recording"
            mi_insert_recording_id.onclick  = function(){MiRecord.insert_recording()}
            mi_insert_recording_id.title    = "Disabled when no recording and\nduring recording & playing."
            mi_insert_recording_id.style["background-color"] = "#d8dadf" //"#e0d9ff"
        }
        else if(state == "enabled") {
            mi_insert_recording_id.disabled = false
            mi_insert_recording_id.value    = "Insert Recording"
            mi_insert_recording_id.onclick  = function(){MiRecord.insert_recording()}
            mi_insert_recording_id.title    = "Insert a job that will\nplay the latest recording\ninto the editor."
            mi_insert_recording_id.style["background-color"] = "#bca6fd"
        }
        else if(state == "active") {
            mi_insert_recording_id.disabled = true
            mi_insert_recording_id.value    = "Insert Recording"
            mi_insert_recording_id.onclick  = function(){MiRecord.insert_recording()}
            mi_insert_recording_id.title    = "Now inserting the recording."
            mi_insert_recording_id.style["background-color"] = "#9447ff"
        }
        else {shouldnt("MiRecord.set_insert_recording_state passed invalid state: " + state) }
    }*/

    //also called from make_instruction.js
    static set_prepare_for_play_ui(){
        MiRecord.set_record_state("enabled")
        MiRecord.set_reverse_state("disabled")
        MiRecord.set_step_reverse_state("disabled")
        MiRecord.set_pause_state("disabled")
        MiRecord.set_step_play_state("enabled")
        MiRecord.set_play_state("enabled")
        MiRecord.set_insert_recording_state("disabled")
        MiRecord.set_highest_completed_instruction_ui()
    }

    static delete_instructions(){
        if(!MiState.job_instance) {
            warning("No job defined to delete instructions from.")
            return
        }
        if(["starting", "running", "stopping", "suspended", "waiting"].includes(MiState.job_instance.status_code)){
            MiState.job_instance.stop_for_reason("interrupted", "Delete button pressed to change do_list.")
            MiState.job_instance.do_list = undefined
            setTimeout(function() {MiRecord.delete_instructions()} //must wrap MiRecord.delete_instructions in a fn to have "this" be correct when its called.
                      , 200)
        }
        let do_list = MiState.job_instance.orig_args.do_list //get_do_list_smart()
        if(!do_list || (do_list.length == 0)) {
            let do_list_elt_id = MakeInstruction.arg_name_to_dom_elt_id("do_list")
            if(!do_list_elt_id) {
                warning("There are no instructions in the do_list to delete.")
                return
            }
            let do_list_src = window[do_list_elt_id].value.trim()
            if(do_list_src == "") {
                warning("There are no instructions in the do_list to delete.")
                return
            }
            try {
                do_list = eval(do_list_src)
                if(Array.isArray(do_list)){
                }
                else {
                    MakeInstruction.set_border_color_of_arg("do_list", "red")
                    dde_error("The do_list in the Make Instruction dialog is not an array: " + err.message)
                }
            }
            catch(err) {
                MakeInstruction.set_border_color_of_arg("do_list", "red")
                dde_error("The do_list in the Make Instruction dialog is invalid: " + err.message)
            }
            if(do_list.length == 0) {
                warning("There are no instructions in the do_list to delete.")
                return
            }
        }
        MakeInstruction.set_border_color_of_arg("do_list") //eval is ok
        let begin   = MiRecord.get_begin_mark_loc()
        let end     = MiRecord.get_end_mark_loc()
        if(MiRecord.get_play_middle()) { //delete the ends
            out("delete the ends")
            do_list = do_list.slice(begin, end) //get rid of the ends
        }
        else { //delete the middle
            out("delete the middle")
            do_list.splice(begin, end - begin) //splice modifies the array
        }
        if(!MiState.job_instance){
            let ji = MiRecord.job_in_mi_dialog()
            if(!(ji instanceof Job)) {
                warning("No job to delete do_list items of.")
                return
            }
            else {
                MiState.job_instance = ji
            }
        }
        MiState.job_instance.do_list = undefined //since we've never played this particular do_list before, we effectively have a new job
        MiState.job_instance.orig_args.do_list = do_list
        MiRecord.stick_recording_in_ui() //uses orig_args.do_list, also adjusts inter_do_item_dur
        MiRecord.set_play_loc(0)
        MiRecord.set_begin_mark_loc(0)
        MiRecord.set_end_mark_loc(do_list.length)
        MiRecord.set_max_loc()
    }

    static reset_job(){
        if(MiState.job_instance) {
           if(MiState.job_instance.is_active()){
               MiState.job_instance.stop_for_reason("interrupted", "Make Instance restarting job.")
           }
           delete MiState.job_instance.do_list //now prepare_for_play will recreate
                                               //job from its source in the dialog box.
        }
        if(MiRecord.prepare_for_play()){ //if no job in the MI dialog, his will print out warning and return false
            MiState.job_instance.highest_completed_instruction_id = -1
            MiRecord.set_prepare_for_play_ui()
            MiRecord.set_play_loc(0)
        }
        //don't do this. prepare_for_play prints a more accuurate message. else { warning("There's no job_instance that Make Instruction is now managing.") }
    }

    static insert_recording(){
        let full_src = Editor.get_javascript()
        let full_src_trimmed = full_src.trim()
        let new_high_level_job_name = MakeInstruction.arg_name_to_src_in_mi_dialog("name")
        new_high_level_job_name = new_high_level_job_name.substring(1, new_high_level_job_name.length -1) //cut off surrounding double quotes
        let jobs_db = Editor.find_job_defs()
        let new_low_level_job_name = this.compute_low_level_job_name(new_high_level_job_name, jobs_db)
        if(jobs_db.length === 0){ //editor has no jobs in it.
                  // insert full high and low level jobs at end of buffer.
            Editor.insert(this.make_high_level_job(new_high_level_job_name, new_low_level_job_name), "end")
            //Editor.insert(this.make_low_level_job(new_low_level_job_name), "end")
            full_src = Editor.get_javascript()
            jobs_db = Editor.find_job_defs() //capture the newly inserted high level job
        }
        //we've got at least one job in the editor so add
               //a Control.start_job as its new last do_list item,
               //and insert the new low_level job at the end of the editor
        let ref = this.ref_to_low_level_job(new_low_level_job_name)
        this.insert_low_level_job_ref(ref, full_src, jobs_db)
        Editor.insert("\n", "end")
        Editor.insert(this.make_low_level_job(new_low_level_job_name), "end")
    }

    static compute_low_level_job_name(new_high_level_job_name, jobs_db){
        if(jobs_db.length < 2) { //if the jobs_db has 1 job in it, that becomes the high level
                                 //job, regardless of its name.
                                 //but we use as the base of the new (first) low level job
                                 //of the job name from the Make-insruction dialog jpb's name.
            return new_high_level_job_name + "_0"
        }
        else { //we have at least 2 jobs in the jobs_db
            let max_existing_low_level_job_number = -1
            for(let job_array of jobs_db){
                let existing_job_name = job_array[0]
                if(existing_job_name.startsWith(new_high_level_job_name + "_")){
                    let length_of_prefix = new_high_level_job_name.length + 1 //+1 for the underscore
                    let existing_job_name_suffix = existing_job_name.substring(length_of_prefix)
                    if((existing_job_name_suffix.length > 0) &&
                       is_string_a_integer(existing_job_name_suffix) &&
                        (existing_job_name_suffix[0] !== "-")){
                     let the_int = parseInt(existing_job_name_suffix)
                     max_existing_low_level_job_number = Math.max(the_int, max_existing_low_level_job_number)
                    }
                }
            }
            let int_of_new_low_level_job = max_existing_low_level_job_number + 1
            let new_low_level_job_name = new_high_level_job_name + "_" + int_of_new_low_level_job
            return new_low_level_job_name
        }
    }

    static ref_to_low_level_job(new_low_level_job_name){
        let options = '{start_if_robot_busy: true}'
        let ref = '        Control.start_job("' + new_low_level_job_name + '", ' + options + ', "error", true),\n'
        return ref
    }

    //really this is insert_instruction_src_at_end_of_do_list
    static insert_low_level_job_ref(low_level_job_ref, full_src, jobs_db){
        let [high_level_job_name, start_pos, end_pos] = jobs_db[0]
        let do_list_start = full_src.indexOf("do_list:", start_pos)
        do_list_start     = full_src.indexOf("[", do_list_start) //now do_list_start points at opening [ of do_list
        let do_list_end   = Editor.find_matching_close(full_src, do_list_start)
        Editor.insert(low_level_job_ref, do_list_end)
    }

    static make_high_level_job(high_level_job_name, new_low_level_job_name){
        let options = '{start_if_robot_busy: true}'
        //let ref = this.ref_to_low_level_job(new_low_level_job_name)
        return '\n//A high-level Job that includes other jobs.\n' +
                'new Job({\n' +
                '    name: "' + high_level_job_name + '",\n' +
                '    robot: new Brain({name: "' + high_level_job_name + '_brain"}),\n' +
                '    do_list: [\n' +
                //'        ' + ref +
                ']})\n'
    }
    static make_low_level_job(new_low_level_job_name){
        let src = MakeInstruction.dialog_to_instruction_src()
        let name_pos = src.indexOf("name:")
        let name_poses = Editor.find_literal_string(src, name_pos + 5)
        src = src.substring(0, name_poses[0]) +
              '"' + new_low_level_job_name + '"' +
              src.substring(name_poses[1])
        return '\n' + src
    }
    static start_time_in_ms = null
}

globalThis.MiRocord = MiRecord

