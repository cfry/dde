import net$1 from 'net';
import url from 'url';
import util$2 from 'util';
import Punycode from 'punycode';
import crypto$1 from 'crypto';
import buffer from 'buffer';
import http from 'http';
import https from 'https';
import stream from 'stream';
import zlib from 'zlib';
import querystring from 'querystring';
import assert from 'assert';
import path from 'path';
import tls from 'tls';
import fs from 'fs';
import events from 'events';
import child_process from 'child_process';
import readline from 'readline';

/*
jQWidgets v12.1.2 (2021-July)
Copyright (c) 2011-2021 jQWidgets.
License: https://jqwidgets.com/license/
*/
/* eslint-disable */

var oldBrowser=document.all&&!document.addEventListener;if(!oldBrowser){(function(bd,G){var q,an,ak=bd.document;bd.location;var bt=bd.navigator,ax=bd.JQXLite,X=bd.$,aR=Array.prototype.push,aD=Array.prototype.slice,aA=Array.prototype.indexOf,y=Object.prototype.toString,b=Object.prototype.hasOwnProperty,aw=String.prototype.trim,C=function(bu,bv){return new C.fn.init(bu,bv,q)},aE=/[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source,at=/\S/,a8=/\s+/,S=/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,aF=/^(?:[^#<]*(<[\w\W]+>)[^>]*$|#([\w\-]*)$)/,e=/^<(\w+)\s*\/?>(?:<\/\1>|)$/,j=/^[\],:{}\s]*$/,t=/(?:^|:|,)(?:\s*\[)+/g,a5=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,K=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g,au=/^-ms-/,aS=/-([\da-z])/gi,m=function(bu,bv){return (bv+"").toUpperCase()},a4=function(){if(ak.addEventListener){ak.removeEventListener("DOMContentLoaded",a4,false);C.ready();}else {if(ak.readyState==="complete"){ak.detachEvent("onreadystatechange",a4);C.ready();}}},a0={};C.fn=C.prototype={constructor:C,init:function(bu,bx,by){var bw,bz,bA;if(!bu){return this}if(bu.nodeType){this.context=this[0]=bu;this.length=1;return this}if(typeof bu==="string"){if(bu.charAt(0)==="<"&&bu.charAt(bu.length-1)===">"&&bu.length>=3){bw=[null,bu,null];}else {bw=aF.exec(bu);}if(bw&&(bw[1]||!bx)){if(bw[1]){bx=bx instanceof C?bx[0]:bx;bA=(bx&&bx.nodeType?bx.ownerDocument||bx:ak);bu=C.parseHTML(bw[1],bA,true);if(e.test(bw[1])&&C.isPlainObject(bx)){this.attr.call(bu,bx,true);}return C.merge(this,bu)}else {bz=ak.getElementById(bw[2]);if(bz&&bz.parentNode){if(bz.id!==bw[2]){return by.find(bu)}this.length=1;this[0]=bz;}this.context=ak;this.selector=bu;return this}}else {if(!bx||bx.jqx){return (bx||by).find(bu)}else {return this.constructor(bx).find(bu)}}}else {if(C.isFunction(bu)){return by.ready(bu)}}if(bu.selector!==G){this.selector=bu.selector;this.context=bu.context;}return C.makeArray(bu,this)},selector:"",jqx:"4.5.0",length:0,size:function(){return this.length},toArray:function(){return aD.call(this)},get:function(bu){return bu==null?this.toArray():(bu<0?this[this.length+bu]:this[bu])},pushStack:function(bv,bx,bu){var bw=C.merge(this.constructor(),bv);bw.prevObject=this;bw.context=this.context;if(bx==="find"){bw.selector=this.selector+(this.selector?" ":"")+bu;}else {if(bx){bw.selector=this.selector+"."+bx+"("+bu+")";}}return bw},each:function(bv,bu){return C.each(this,bv,bu)},ready:function(bu){C.ready.promise().done(bu);return this},eq:function(bu){bu=+bu;return bu===-1?this.slice(bu):this.slice(bu,bu+1)},first:function(){return this.eq(0)},last:function(){return this.eq(-1)},slice:function(){return this.pushStack(aD.apply(this,arguments),"slice",aD.call(arguments).join(","))},map:function(bu){return this.pushStack(C.map(this,function(bw,bv){return bu.call(bw,bv,bw)}))},end:function(){return this.prevObject||this.constructor(null)},push:aR,sort:[].sort,splice:[].splice};C.fn.init.prototype=C.fn;C.extend=C.fn.extend=function(){var bD,bw,bu,bv,bA,bB,bz=arguments[0]||{},by=1,bx=arguments.length,bC=false;if(typeof bz==="boolean"){bC=bz;bz=arguments[1]||{};by=2;}if(typeof bz!=="object"&&!C.isFunction(bz)){bz={};}if(bx===by){bz=this;--by;}for(;by<bx;by++){if((bD=arguments[by])!=null){for(bw in bD){bu=bz[bw];bv=bD[bw];if(bz===bv){continue}if(bC&&bv&&(C.isPlainObject(bv)||(bA=C.isArray(bv)))){if(bA){bA=false;bB=bu&&C.isArray(bu)?bu:[];}else {bB=bu&&C.isPlainObject(bu)?bu:{};}bz[bw]=C.extend(bC,bB,bv);}else {if(bv!==G){bz[bw]=bv;}}}}}return bz};C.extend({noConflict:function(bu){if(bd.$===C){bd.$=X;}if(bu&&bd.JQXLite===C){bd.JQXLite=ax;}return C},isReady:false,readyWait:1,holdReady:function(bu){if(bu){C.readyWait++;}else {C.ready(true);}},ready:function(bu){if(bu===true?--C.readyWait:C.isReady){return}if(!ak.body){return setTimeout(C.ready,1)}C.isReady=true;if(bu!==true&&--C.readyWait>0){return}an.resolveWith(ak,[C]);if(C.fn.trigger){C(ak).trigger("ready").off("ready");}},isFunction:function(bu){return C.type(bu)==="function"},isArray:Array.isArray||function(bu){return C.type(bu)==="array"},isWindow:function(bu){return bu!=null&&bu==bu.window},isNumeric:function(bu){return !isNaN(parseFloat(bu))&&isFinite(bu)},type:function(bu){return bu==null?String(bu):a0[y.call(bu)]||"object"},isPlainObject:function(bw){if(!bw||C.type(bw)!=="object"||bw.nodeType||C.isWindow(bw)){return false}try{if(bw.constructor&&!b.call(bw,"constructor")&&!b.call(bw.constructor.prototype,"isPrototypeOf")){return false}}catch(bv){return false}var bu;for(bu in bw){}return bu===G||b.call(bw,bu)},isEmptyObject:function(bv){var bu;for(bu in bv){return false}return true},error:function(bu){throw new Error(bu)},parseHTML:function(bx,bw,bu){var bv;if(!bx||typeof bx!=="string"){return null}if(typeof bw==="boolean"){bu=bw;bw=0;}bw=bw||ak;if((bv=e.exec(bx))){return [bw.createElement(bv[1])]}bv=C.buildFragment([bx],bw,bu?null:[]);return C.merge([],(bv.cacheable?C.clone(bv.fragment):bv.fragment).childNodes)},parseJSON:function(bu){if(!bu||typeof bu!=="string"){return null}bu=C.trim(bu);if(bd.JSON&&bd.JSON.parse){return bd.JSON.parse(bu)}if(j.test(bu.replace(a5,"@").replace(K,"]").replace(t,""))){return (new Function("return "+bu))()}C.error("Invalid JSON: "+bu);},parseXML:function(bw){var bu,bv;if(!bw||typeof bw!=="string"){return null}try{if(bd.DOMParser){bv=new DOMParser();bu=bv.parseFromString(bw,"text/xml");}else {bu=new ActiveXObject("Microsoft.XMLDOM");bu.async="false";bu.loadXML(bw);}}catch(bx){bu=G;}if(!bu||!bu.documentElement||bu.getElementsByTagName("parsererror").length){C.error("Invalid XML: "+bw);}return bu},noop:function(){},globalEval:function(bu){if(bu&&at.test(bu)){(bd.execScript||function(bv){bd["eval"].call(bd,bv);})(bu);}},camelCase:function(bu){return bu.replace(au,"ms-").replace(aS,m)},nodeName:function(bv,bu){return bv.nodeName&&bv.nodeName.toLowerCase()===bu.toLowerCase()},each:function(bz,bA,bw){var bv,bx=0,by=bz.length,bu=by===G||C.isFunction(bz);if(bw){if(bu){for(bv in bz){if(bA.apply(bz[bv],bw)===false){break}}}else {for(;bx<by;){if(bA.apply(bz[bx++],bw)===false){break}}}}else {if(bu){for(bv in bz){if(bA.call(bz[bv],bv,bz[bv])===false){break}}}else {for(;bx<by;){if(bA.call(bz[bx],bx,bz[bx++])===false){break}}}}return bz},trim:aw&&!aw.call("\uFEFF\xA0")?function(bu){return bu==null?"":aw.call(bu)}:function(bu){return bu==null?"":(bu+"").replace(S,"")},makeArray:function(bu,bw){var bx,bv=bw||[];if(bu!=null){bx=C.type(bu);if(bu.length==null||bx==="string"||bx==="function"||bx==="regexp"||C.isWindow(bu)){aR.call(bv,bu);}else {C.merge(bv,bu);}}return bv},inArray:function(bx,bv,bw){var bu;if(bv){if(aA){return aA.call(bv,bx,bw)}bu=bv.length;bw=bw?bw<0?Math.max(0,bu+bw):bw:0;for(;bw<bu;bw++){if(bw in bv&&bv[bw]===bx){return bw}}}return -1},merge:function(by,bw){var bu=bw.length,bx=by.length,bv=0;if(typeof bu==="number"){for(;bv<bu;bv++){by[bx++]=bw[bv];}}else {while(bw[bv]!==G){by[bx++]=bw[bv++];}}by.length=bx;return by},grep:function(bv,bA,bu){var bz,bw=[],bx=0,by=bv.length;bu=!!bu;for(;bx<by;bx++){bz=!!bA(bv[bx],bx);if(bu!==bz){bw.push(bv[bx]);}}return bw},map:function(bu,bB,bC){var bz,bA,by=[],bw=0,bv=bu.length,bx=bu instanceof C||bv!==G&&typeof bv==="number"&&((bv>0&&bu[0]&&bu[bv-1])||bv===0||C.isArray(bu));if(bx){for(;bw<bv;bw++){bz=bB(bu[bw],bw,bC);if(bz!=null){by[by.length]=bz;}}}else {for(bA in bu){bz=bB(bu[bA],bA,bC);if(bz!=null){by[by.length]=bz;}}}return by.concat.apply([],by)},guid:1,proxy:function(by,bx){var bw,bu,bv;if(typeof bx==="string"){bw=by[bx];bx=by;by=bw;}if(!C.isFunction(by)){return G}bu=aD.call(arguments,2);bv=function(){return by.apply(bx,bu.concat(aD.call(arguments)))};bv.guid=by.guid=by.guid||C.guid++;return bv},access:function(bu,bA,bD,bB,by,bE,bC){var bw,bz=bD==null,bx=0,bv=bu.length;if(bD&&typeof bD==="object"){for(bx in bD){C.access(bu,bA,bx,bD[bx],1,bE,bB);}by=1;}else {if(bB!==G){bw=bC===G&&C.isFunction(bB);if(bz){if(bw){bw=bA;bA=function(bG,bF,bH){return bw.call(C(bG),bH)};}else {bA.call(bu,bB);bA=null;}}if(bA){for(;bx<bv;bx++){bA(bu[bx],bD,bw?bB.call(bu[bx],bx,bA(bu[bx],bD)):bB,bC);}}by=1;}}return by?bu:bz?bA.call(bu):bv?bA(bu[0],bD):bE},now:function(){return (new Date()).getTime()}});C.ready.promise=function(bx){if(!an){an=C.Deferred();if(ak.readyState==="complete"){setTimeout(C.ready,1);}else {if(ak.addEventListener){ak.addEventListener("DOMContentLoaded",a4,false);bd.addEventListener("load",C.ready,false);}else {ak.attachEvent("onreadystatechange",a4);bd.attachEvent("onload",C.ready);var bw=false;try{bw=bd.frameElement==null&&ak.documentElement;}catch(bv){}if(bw&&bw.doScroll){(function bu(){if(!C.isReady){try{bw.doScroll("left");}catch(by){return setTimeout(bu,50)}C.ready();}})();}}}}return an.promise(bx)};C.each("Boolean Number String Function Array Date RegExp Object".split(" "),function(bv,bu){a0["[object "+bu+"]"]=bu.toLowerCase();});q=C(ak);var aX={};function B(bv){var bu=aX[bv]={};C.each(bv.split(a8),function(bx,bw){bu[bw]=true;});return bu}C.Callbacks=function(bE){bE=typeof bE==="string"?(aX[bE]||B(bE)):C.extend({},bE);var bx,bu,by,bw,bz,bA,bB=[],bC=!bE.once&&[],bv=function(bF){bx=bE.memory&&bF;bu=true;bA=bw||0;bw=0;bz=bB.length;by=true;for(;bB&&bA<bz;bA++){if(bB[bA].apply(bF[0],bF[1])===false&&bE.stopOnFalse){bx=false;break}}by=false;if(bB){if(bC){if(bC.length){bv(bC.shift());}}else {if(bx){bB=[];}else {bD.disable();}}}},bD={add:function(){if(bB){var bG=bB.length;(function bF(bH){C.each(bH,function(bJ,bI){var bK=C.type(bI);if(bK==="function"){if(!bE.unique||!bD.has(bI)){bB.push(bI);}}else {if(bI&&bI.length&&bK!=="string"){bF(bI);}}});})(arguments);if(by){bz=bB.length;}else {if(bx){bw=bG;bv(bx);}}}return this},remove:function(){if(bB){C.each(arguments,function(bH,bF){var bG;while((bG=C.inArray(bF,bB,bG))>-1){bB.splice(bG,1);if(by){if(bG<=bz){bz--;}if(bG<=bA){bA--;}}}});}return this},has:function(bF){return C.inArray(bF,bB)>-1},empty:function(){bB=[];return this},disable:function(){bB=bC=bx=G;return this},disabled:function(){return !bB},lock:function(){bC=G;if(!bx){bD.disable();}return this},locked:function(){return !bC},fireWith:function(bG,bF){bF=bF||[];bF=[bG,bF.slice?bF.slice():bF];if(bB&&(!bu||bC)){if(by){bC.push(bF);}else {bv(bF);}}return this},fire:function(){bD.fireWith(this,arguments);return this},fired:function(){return !!bu}};return bD};C.extend({Deferred:function(bw){var bv=[["resolve","done",C.Callbacks("once memory"),"resolved"],["reject","fail",C.Callbacks("once memory"),"rejected"],["notify","progress",C.Callbacks("memory")]],bx="pending",by={state:function(){return bx},always:function(){bu.done(arguments).fail(arguments);return this},then:function(){var bz=arguments;return C.Deferred(function(bA){C.each(bv,function(bC,bB){var bE=bB[0],bD=bz[bC];bu[bB[1]](C.isFunction(bD)?function(){var bF=bD.apply(this,arguments);if(bF&&C.isFunction(bF.promise)){bF.promise().done(bA.resolve).fail(bA.reject).progress(bA.notify);}else {bA[bE+"With"](this===bu?bA:this,[bF]);}}:bA[bE]);});bz=null;}).promise()},promise:function(bz){return bz!=null?C.extend(bz,by):by}},bu={};by.pipe=by.then;C.each(bv,function(bA,bz){var bC=bz[2],bB=bz[3];by[bz[1]]=bC.add;if(bB){bC.add(function(){bx=bB;},bv[bA^1][2].disable,bv[2][2].lock);}bu[bz[0]]=bC.fire;bu[bz[0]+"With"]=bC.fireWith;});by.promise(bu);if(bw){bw.call(bu,bu);}return bu},when:function(by){var bw=0,bA=aD.call(arguments),bu=bA.length,bv=bu!==1||(by&&C.isFunction(by.promise))?bu:0,bD=bv===1?by:C.Deferred(),bx=function(bF,bG,bE){return function(bH){bG[bF]=this;bE[bF]=arguments.length>1?aD.call(arguments):bH;if(bE===bC){bD.notifyWith(bG,bE);}else {if(!(--bv)){bD.resolveWith(bG,bE);}}}},bC,bz,bB;if(bu>1){bC=new Array(bu);bz=new Array(bu);bB=new Array(bu);for(;bw<bu;bw++){if(bA[bw]&&C.isFunction(bA[bw].promise)){bA[bw].promise().done(bx(bw,bB,bA)).fail(bD.reject).progress(bx(bw,bz,bC));}else {--bv;}}}if(!bv){bD.resolveWith(bB,bA);}return bD.promise()}});C.support=(function(){var bG,bF,bD,bE,bx,bC,bB,bz,by,bw,bu,bv=ak.createElement("div");bv.setAttribute("className","t");bv.innerHTML="  <link/><table></table><a href='/a'>a</a><input type='checkbox'/>";bF=bv.getElementsByTagName("*");bD=bv.getElementsByTagName("a")[0];if(!bF||!bD||!bF.length){return {}}bE=ak.createElement("select");bx=bE.appendChild(ak.createElement("option"));bC=bv.getElementsByTagName("input")[0];bD.style.cssText="top:1px;float:left;opacity:.5";bG={leadingWhitespace:(bv.firstChild.nodeType===3),tbody:!bv.getElementsByTagName("tbody").length,htmlSerialize:!!bv.getElementsByTagName("link").length,style:/top/.test(bD.getAttribute("style")),hrefNormalized:(bD.getAttribute("href")==="/a"),opacity:/^0.5/.test(bD.style.opacity),cssFloat:!!bD.style.cssFloat,checkOn:(bC.value==="on"),optSelected:bx.selected,getSetAttribute:bv.className!=="t",enctype:!!ak.createElement("form").enctype,html5Clone:ak.createElement("nav").cloneNode(true).outerHTML!=="<:nav></:nav>",boxModel:(ak.compatMode==="CSS1Compat"),submitBubbles:true,changeBubbles:true,focusinBubbles:false,deleteExpando:true,noCloneEvent:true,inlineBlockNeedsLayout:false,shrinkWrapBlocks:false,reliableMarginRight:true,boxSizingReliable:true,pixelPosition:false};bC.checked=true;bG.noCloneChecked=bC.cloneNode(true).checked;bE.disabled=true;bG.optDisabled=!bx.disabled;try{delete bv.test;}catch(bA){bG.deleteExpando=false;}if(!bv.addEventListener&&bv.attachEvent&&bv.fireEvent){bv.attachEvent("onclick",bu=function(){bG.noCloneEvent=false;});bv.cloneNode(true).fireEvent("onclick");bv.detachEvent("onclick",bu);}bC=ak.createElement("input");bC.value="t";bC.setAttribute("type","radio");bG.radioValue=bC.value==="t";bC.setAttribute("checked","checked");bC.setAttribute("name","t");bv.appendChild(bC);bB=ak.createDocumentFragment();bB.appendChild(bv.lastChild);bG.checkClone=bB.cloneNode(true).cloneNode(true).lastChild.checked;bG.appendChecked=bC.checked;bB.removeChild(bC);bB.appendChild(bv);if(bv.attachEvent){for(by in {submit:true,change:true,focusin:true}){bz="on"+by;bw=(bz in bv);if(!bw){bv.setAttribute(bz,"return;");bw=(typeof bv[bz]==="function");}bG[by+"Bubbles"]=bw;}}C(function(){var bI,bM,bK,bL,bJ="padding:0;margin:0;border:0;display:block;overflow:hidden;",bH=ak.getElementsByTagName("body")[0];if(!bH){return}bI=ak.createElement("div");bI.style.cssText="visibility:hidden;border:0;width:0;height:0;position:static;top:0;margin-top:1px";bH.insertBefore(bI,bH.firstChild);bM=ak.createElement("div");bI.appendChild(bM);bM.innerHTML="<table><tr><td></td><td>t</td></tr></table>";bK=bM.getElementsByTagName("td");bK[0].style.cssText="padding:0;margin:0;border:0;display:none";bw=(bK[0].offsetHeight===0);bK[0].style.display="";bK[1].style.display="none";bG.reliableHiddenOffsets=bw&&(bK[0].offsetHeight===0);bM.innerHTML="";bM.style.cssText="box-sizing:border-box;-moz-box-sizing:border-box;-webkit-box-sizing:border-box;padding:1px;border:1px;display:block;width:4px;margin-top:1%;position:absolute;top:1%;";bG.boxSizing=(bM.offsetWidth===4);bG.doesNotIncludeMarginInBodyOffset=(bH.offsetTop!==1);if(bd.getComputedStyle){bG.pixelPosition=(bd.getComputedStyle(bM,null)||{}).top!=="1%";bG.boxSizingReliable=(bd.getComputedStyle(bM,null)||{width:"4px"}).width==="4px";bL=ak.createElement("div");bL.style.cssText=bM.style.cssText=bJ;bL.style.marginRight=bL.style.width="0";bM.style.width="1px";bM.appendChild(bL);bG.reliableMarginRight=!parseFloat((bd.getComputedStyle(bL,null)||{}).marginRight);}if(typeof bM.style.zoom!=="undefined"){bM.innerHTML="";bM.style.cssText=bJ+"width:1px;padding:1px;display:inline;zoom:1";bG.inlineBlockNeedsLayout=(bM.offsetWidth===3);bM.style.display="block";bM.style.overflow="visible";bM.innerHTML="<div></div>";bM.firstChild.style.width="5px";bG.shrinkWrapBlocks=(bM.offsetWidth!==3);bI.style.zoom=1;}bH.removeChild(bI);bI=bM=bK=bL=null;});bB.removeChild(bv);bF=bD=bE=bx=bC=bB=bv=null;return bG})();var aK=/(?:\{[\s\S]*\}|\[[\s\S]*\])$/,aq=/([A-Z])/g;C.extend({cache:{},deletedIds:[],uuid:0,expando:"JQXLite"+(C.fn.jqx+Math.random()).replace(/\D/g,""),noData:{embed:true,object:"clsid:D27CDB6E-AE6D-11cf-96B8-444553540000",applet:true},hasData:function(bu){bu=bu.nodeType?C.cache[bu[C.expando]]:bu[C.expando];return !!bu&&!M(bu)},data:function(bx,bv,bz,by){if(!C.acceptData(bx)){return}var bA,bC,bD=C.expando,bB=typeof bv==="string",bE=bx.nodeType,bu=bE?C.cache:bx,bw=bE?bx[bD]:bx[bD]&&bD;if((!bw||!bu[bw]||(!by&&!bu[bw].data))&&bB&&bz===G){return}if(!bw){if(bE){bx[bD]=bw=C.deletedIds.pop()||C.guid++;}else {bw=bD;}}if(!bu[bw]){bu[bw]={};if(!bE){bu[bw].toJSON=C.noop;}}if(typeof bv==="object"||typeof bv==="function"){if(by){bu[bw]=C.extend(bu[bw],bv);}else {bu[bw].data=C.extend(bu[bw].data,bv);}}bA=bu[bw];if(!by){if(!bA.data){bA.data={};}bA=bA.data;}if(bz!==G){bA[C.camelCase(bv)]=bz;}if(bB){bC=bA[bv];if(bC==null){bC=bA[C.camelCase(bv)];}}else {bC=bA;}return bC},removeData:function(bx,bv,by){if(!C.acceptData(bx)){return}var bB,bA,bz,bC=bx.nodeType,bu=bC?C.cache:bx,bw=bC?bx[C.expando]:C.expando;if(!bu[bw]){return}if(bv){bB=by?bu[bw]:bu[bw].data;if(bB){if(!C.isArray(bv)){if(bv in bB){bv=[bv];}else {bv=C.camelCase(bv);if(bv in bB){bv=[bv];}else {bv=bv.split(" ");}}}for(bA=0,bz=bv.length;bA<bz;bA++){delete bB[bv[bA]];}if(!(by?M:C.isEmptyObject)(bB)){return}}}if(!by){delete bu[bw].data;if(!M(bu[bw])){return}}if(bC){C.cleanData([bx],true);}else {if(C.support.deleteExpando||bu!=bu.window){delete bu[bw];}else {bu[bw]=null;}}},_data:function(bv,bu,bw){return C.data(bv,bu,bw,true)},acceptData:function(bv){var bu=bv.nodeName&&C.noData[bv.nodeName.toLowerCase()];return !bu||bu!==true&&bv.getAttribute("classid")===bu}});C.fn.extend({data:function(bD,bC){var by,bv,bB,bu,bx,bw=this[0],bA=0,bz=null;if(bD===G){if(this.length){bz=C.data(bw);if(bw.nodeType===1&&!C._data(bw,"parsedAttrs")){bB=bw.attributes;for(bx=bB.length;bA<bx;bA++){bu=bB[bA].name;if(!bu.indexOf("data-")){bu=C.camelCase(bu.substring(5));a9(bw,bu,bz[bu]);}}C._data(bw,"parsedAttrs",true);}}return bz}if(typeof bD==="object"){return this.each(function(){C.data(this,bD);})}by=bD.split(".",2);by[1]=by[1]?"."+by[1]:"";bv=by[1]+"!";return C.access(this,function(bE){if(bE===G){bz=this.triggerHandler("getData"+bv,[by[0]]);if(bz===G&&bw){bz=C.data(bw,bD);bz=a9(bw,bD,bz);}return bz===G&&by[1]?this.data(by[0]):bz}by[1]=bE;this.each(function(){var bF=C(this);bF.triggerHandler("setData"+bv,by);C.data(this,bD,bE);bF.triggerHandler("changeData"+bv,by);});},null,bC,arguments.length>1,null,false)},removeData:function(bu){return this.each(function(){C.removeData(this,bu);})}});function a9(bw,bv,bx){if(bx===G&&bw.nodeType===1){var bu="data-"+bv.replace(aq,"-$1").toLowerCase();bx=bw.getAttribute(bu);if(typeof bx==="string"){try{bx=bx==="true"?true:bx==="false"?false:bx==="null"?null:+bx+""===bx?+bx:aK.test(bx)?C.parseJSON(bx):bx;}catch(by){}C.data(bw,bv,bx);}else {bx=G;}}return bx}function M(bv){var bu;for(bu in bv){if(bu==="data"&&C.isEmptyObject(bv[bu])){continue}if(bu!=="toJSON"){return false}}return true}C.extend({queue:function(bw,bv,bx){var bu;if(bw){bv=(bv||"fx")+"queue";bu=C._data(bw,bv);if(bx){if(!bu||C.isArray(bx)){bu=C._data(bw,bv,C.makeArray(bx));}else {bu.push(bx);}}return bu||[]}},dequeue:function(bz,by){by=by||"fx";var bv=C.queue(bz,by),bA=bv.length,bx=bv.shift(),bu=C._queueHooks(bz,by),bw=function(){C.dequeue(bz,by);};if(bx==="inprogress"){bx=bv.shift();bA--;}if(bx){if(by==="fx"){bv.unshift("inprogress");}delete bu.stop;bx.call(bz,bw,bu);}if(!bA&&bu){bu.empty.fire();}},_queueHooks:function(bw,bv){var bu=bv+"queueHooks";return C._data(bw,bu)||C._data(bw,bu,{empty:C.Callbacks("once memory").add(function(){C.removeData(bw,bv+"queue",true);C.removeData(bw,bu,true);})})}});C.fn.extend({queue:function(bu,bv){var bw=2;if(typeof bu!=="string"){bv=bu;bu="fx";bw--;}if(arguments.length<bw){return C.queue(this[0],bu)}return bv===G?this:this.each(function(){var bx=C.queue(this,bu,bv);C._queueHooks(this,bu);if(bu==="fx"&&bx[0]!=="inprogress"){C.dequeue(this,bu);}})},dequeue:function(bu){return this.each(function(){C.dequeue(this,bu);})},delay:function(bv,bu){bv=C.fx?C.fx.speeds[bv]||bv:bv;bu=bu||"fx";return this.queue(bu,function(bx,bw){var by=setTimeout(bx,bv);bw.stop=function(){clearTimeout(by);};})},clearQueue:function(bu){return this.queue(bu||"fx",[])},promise:function(bw,bA){var bv,bx=1,bB=C.Deferred(),bz=this,bu=this.length,by=function(){if(!(--bx)){bB.resolveWith(bz,[bz]);}};if(typeof bw!=="string"){bA=bw;bw=G;}bw=bw||"fx";while(bu--){bv=C._data(bz[bu],bw+"queueHooks");if(bv&&bv.empty){bx++;bv.empty.add(by);}}by();return bB.promise(bA)}});var bh,aT,aI=/[\t\r\n]/g,aP=/\r/g,d=/^(?:button|input)$/i,z=/^(?:button|input|object|select|textarea)$/i,h=/^a(?:rea|)$/i,ae=/^(?:autofocus|autoplay|async|checked|controls|defer|disabled|hidden|loop|multiple|open|readonly|required|scoped|selected)$/i,A=C.support.getSetAttribute;C.fn.extend({attr:function(bu,bv){return C.access(this,C.attr,bu,bv,arguments.length>1)},removeAttr:function(bu){return this.each(function(){C.removeAttr(this,bu);})},prop:function(bu,bv){return C.access(this,C.prop,bu,bv,arguments.length>1)},removeProp:function(bu){bu=C.propFix[bu]||bu;return this.each(function(){try{this[bu]=G;delete this[bu];}catch(bv){}})},addClass:function(by){var bA,bw,bv,bx,bz,bB,bu;if(C.isFunction(by)){return this.each(function(bC){C(this).addClass(by.call(this,bC,this.className));})}if(by&&typeof by==="string"){bA=by.split(a8);for(bw=0,bv=this.length;bw<bv;bw++){bx=this[bw];if(bx.nodeType===1){if(!bx.className&&bA.length===1){bx.className=by;}else {bz=" "+bx.className+" ";for(bB=0,bu=bA.length;bB<bu;bB++){if(bz.indexOf(" "+bA[bB]+" ")<0){bz+=bA[bB]+" ";}}bx.className=C.trim(bz);}}}}return this},removeClass:function(bA){var bx,by,bz,bB,bv,bw,bu;if(C.isFunction(bA)){return this.each(function(bC){C(this).removeClass(bA.call(this,bC,this.className));})}if((bA&&typeof bA==="string")||bA===G){bx=(bA||"").split(a8);for(bw=0,bu=this.length;bw<bu;bw++){bz=this[bw];if(bz.nodeType===1&&bz.className){by=(" "+bz.className+" ").replace(aI," ");for(bB=0,bv=bx.length;bB<bv;bB++){while(by.indexOf(" "+bx[bB]+" ")>=0){by=by.replace(" "+bx[bB]+" "," ");}}bz.className=bA?C.trim(by):"";}}}return this},toggleClass:function(bx,bv){var bw=typeof bx,bu=typeof bv==="boolean";if(C.isFunction(bx)){return this.each(function(by){C(this).toggleClass(bx.call(this,by,this.className,bv),bv);})}return this.each(function(){if(bw==="string"){var bA,bz=0,by=C(this),bB=bv,bC=bx.split(a8);while((bA=bC[bz++])){bB=bu?bB:!by.hasClass(bA);by[bB?"addClass":"removeClass"](bA);}}else {if(bw==="undefined"||bw==="boolean"){if(this.className){C._data(this,"__className__",this.className);}this.className=this.className||bx===false?"":C._data(this,"__className__")||"";}}})},hasClass:function(bu){var bx=" "+bu+" ",bw=0,bv=this.length;for(;bw<bv;bw++){if(this[bw].nodeType===1&&(" "+this[bw].className+" ").replace(aI," ").indexOf(bx)>=0){return true}}return false},val:function(bx){var bu,bv,by,bw=this[0];if(!arguments.length){if(bw){bu=C.valHooks[bw.type]||C.valHooks[bw.nodeName.toLowerCase()];if(bu&&"get" in bu&&(bv=bu.get(bw,"value"))!==G){return bv}bv=bw.value;return typeof bv==="string"?bv.replace(aP,""):bv==null?"":bv}return}by=C.isFunction(bx);return this.each(function(bA){var bB,bz=C(this);if(this.nodeType!==1){return}if(by){bB=bx.call(this,bA,bz.val());}else {bB=bx;}if(bB==null){bB="";}else {if(typeof bB==="number"){bB+="";}else {if(C.isArray(bB)){bB=C.map(bB,function(bC){return bC==null?"":bC+""});}}}bu=C.valHooks[this.type]||C.valHooks[this.nodeName.toLowerCase()];if(!bu||!("set" in bu)||bu.set(this,bB,"value")===G){this.value=bB;}})}});C.extend({valHooks:{option:{get:function(bu){var bv=bu.attributes.value;return !bv||bv.specified?bu.value:bu.text}},select:{get:function(bu){var bA,bw,bC=bu.options,by=bu.selectedIndex,bx=bu.type==="select-one"||by<0,bB=bx?null:[],bz=bx?by+1:bC.length,bv=by<0?bz:bx?by:0;for(;bv<bz;bv++){bw=bC[bv];if((bw.selected||bv===by)&&(C.support.optDisabled?!bw.disabled:bw.getAttribute("disabled")===null)&&(!bw.parentNode.disabled||!C.nodeName(bw.parentNode,"optgroup"))){bA=C(bw).val();if(bx){return bA}bB.push(bA);}}return bB},set:function(bv,bw){var bu=C.makeArray(bw);C(bv).find("option").each(function(){this.selected=C.inArray(C(this).val(),bu)>=0;});if(!bu.length){bv.selectedIndex=-1;}return bu}}},attrFn:{},attr:function(bA,bx,bB,bz){var bw,bu,by,bv=bA.nodeType;if(!bA||bv===3||bv===8||bv===2){return}if(bz&&C.isFunction(C.fn[bx])){return C(bA)[bx](bB)}if(typeof bA.getAttribute==="undefined"){return C.prop(bA,bx,bB)}by=bv!==1||!C.isXMLDoc(bA);if(by){bx=bx.toLowerCase();bu=C.attrHooks[bx]||(ae.test(bx)?aT:bh);}if(bB!==G){if(bB===null){C.removeAttr(bA,bx);return}else {if(bu&&"set" in bu&&by&&(bw=bu.set(bA,bB,bx))!==G){return bw}else {bA.setAttribute(bx,bB+"");return bB}}}else {if(bu&&"get" in bu&&by&&(bw=bu.get(bA,bx))!==null){return bw}else {bw=bA.getAttribute(bx);return bw===null?G:bw}}},removeAttr:function(bx,bz){var by,bA,bv,bu,bw=0;if(bz&&bx.nodeType===1){bA=bz.split(a8);for(;bw<bA.length;bw++){bv=bA[bw];if(bv){by=C.propFix[bv]||bv;bu=ae.test(bv);if(!bu){C.attr(bx,bv,"");}bx.removeAttribute(A?bv:by);if(bu&&by in bx){bx[by]=false;}}}}},attrHooks:{type:{set:function(bu,bv){if(d.test(bu.nodeName)&&bu.parentNode){C.error("type property can't be changed");}else {if(!C.support.radioValue&&bv==="radio"&&C.nodeName(bu,"input")){var bw=bu.value;bu.setAttribute("type",bv);if(bw){bu.value=bw;}return bv}}}},value:{get:function(bv,bu){return bu in bv?bv.value:null},set:function(bv,bw,bu){bv.value=bw;}}},propFix:{tabindex:"tabIndex",readonly:"readOnly","for":"htmlFor","class":"className",maxlength:"maxLength",cellspacing:"cellSpacing",cellpadding:"cellPadding",rowspan:"rowSpan",colspan:"colSpan",usemap:"useMap",frameborder:"frameBorder",contenteditable:"contentEditable"},prop:function(bz,bx,bA){var bw,bu,by,bv=bz.nodeType;if(!bz||bv===3||bv===8||bv===2){return}by=bv!==1||!C.isXMLDoc(bz);if(by){bx=C.propFix[bx]||bx;bu=C.propHooks[bx];}if(bA!==G){if(bu&&"set" in bu&&(bw=bu.set(bz,bA,bx))!==G){return bw}else {return(bz[bx]=bA)}}else {if(bu&&"get" in bu&&(bw=bu.get(bz,bx))!==null){return bw}else {return bz[bx]}}},propHooks:{tabIndex:{get:function(bv){var bu=bv.getAttributeNode("tabindex");return bu&&bu.specified?parseInt(bu.value,10):z.test(bv.nodeName)||h.test(bv.nodeName)&&bv.href?0:G}}}});aT={get:function(bv,bu){var bx,bw=C.prop(bv,bu);return bw===true||typeof bw!=="boolean"&&(bx=bv.getAttributeNode(bu))&&bx.nodeValue!==false?bu.toLowerCase():G},set:function(bv,bx,bu){var bw;if(bx===false){C.removeAttr(bv,bu);}else {bw=C.propFix[bu]||bu;if(bw in bv){bv[bw]=true;}bv.setAttribute(bu,bu.toLowerCase());}return bu}};if(!C.support.enctype){C.propFix.enctype="encoding";}var n=/^([^\.]*|)(?:\.(.+)|)$/,F=/(?:^|\s)hover(\.\S+|)\b/,aH=/^key/,bi=/^(?:mouse|contextmenu)|click/,N=/^(?:focusinfocus|focusoutblur)$/,bs=function(bu){return C.event.special.hover?bu:bu.replace(F,"mouseenter$1 mouseleave$1")};C.event={add:function(bx,bB,bI,bz,by){var bC,bA,bJ,bH,bG,bE,bu,bF,bv,bw,bD;if(bx.nodeType===3||bx.nodeType===8||!bB||!bI||!(bC=C._data(bx))){return}if(bI.handler){bv=bI;bI=bv.handler;by=bv.selector;}if(!bI.guid){bI.guid=C.guid++;}bJ=bC.events;if(!bJ){bC.events=bJ={};}bA=bC.handle;if(!bA){bC.handle=bA=function(bK){return typeof C!=="undefined"&&(!bK||C.event.triggered!==bK.type)?C.event.dispatch.apply(bA.elem,arguments):G};bA.elem=bx;}bB=C.trim(bs(bB)).split(" ");for(bH=0;bH<bB.length;bH++){bG=n.exec(bB[bH])||[];bE=bG[1];bu=(bG[2]||"").split(".").sort();bD=C.event.special[bE]||{};bE=(by?bD.delegateType:bD.bindType)||bE;bD=C.event.special[bE]||{};bF=C.extend({type:bE,origType:bG[1],data:bz,handler:bI,guid:bI.guid,selector:by,needsContext:by&&C.expr.match.needsContext.test(by),namespace:bu.join(".")},bv);bw=bJ[bE];if(!bw){bw=bJ[bE]=[];bw.delegateCount=0;if(!bD.setup||bD.setup.call(bx,bz,bu,bA)===false){if(bx.addEventListener){if(bz&&bz.passive!==G){bx.addEventListener(bE,bA,bz);}else {bx.addEventListener(bE,bA,false);}}else {if(bx.attachEvent){bx.attachEvent("on"+bE,bA);}}}}if(bD.add){bD.add.call(bx,bF);if(!bF.handler.guid){bF.handler.guid=bI.guid;}}if(by){bw.splice(bw.delegateCount++,0,bF);}else {bw.push(bF);}C.event.global[bE]=true;}bx=null;},global:{},remove:function(bx,bC,bI,by,bB){var bJ,bK,bF,bw,bv,bz,bA,bH,bE,bu,bG,bD=C.hasData(bx)&&C._data(bx);if(!bD||!(bH=bD.events)){return}bC=C.trim(bs(bC||"")).split(" ");for(bJ=0;bJ<bC.length;bJ++){bK=n.exec(bC[bJ])||[];bF=bw=bK[1];bv=bK[2];if(!bF){for(bF in bH){C.event.remove(bx,bF+bC[bJ],bI,by,true);}continue}bE=C.event.special[bF]||{};bF=(by?bE.delegateType:bE.bindType)||bF;bu=bH[bF]||[];bz=bu.length;bv=bv?new RegExp("(^|\\.)"+bv.split(".").sort().join("\\.(?:.*\\.|)")+"(\\.|$)"):null;for(bA=0;bA<bu.length;bA++){bG=bu[bA];if((bB||bw===bG.origType)&&(!bI||bI.guid===bG.guid)&&(!bv||bv.test(bG.namespace))&&(!by||by===bG.selector||by==="**"&&bG.selector)){bu.splice(bA--,1);if(bG.selector){bu.delegateCount--;}if(bE.remove){bE.remove.call(bx,bG);}}}if(bu.length===0&&bz!==bu.length){if(!bE.teardown||bE.teardown.call(bx,bv,bD.handle)===false){C.removeEvent(bx,bF,bD.handle);}delete bH[bF];}}if(C.isEmptyObject(bH)){delete bD.handle;C.removeData(bx,"events",true);}},customEvent:{getData:true,setData:true,changeData:true},trigger:function(bv,bC,bA,bJ){if(bA&&(bA.nodeType===3||bA.nodeType===8)){return}var bu,bx,bD,bH,bz,by,bF,bE,bB,bI,bG=bv.type||bv,bw=[];if(N.test(bG+C.event.triggered)){return}if(bG.indexOf("!")>=0){bG=bG.slice(0,-1);bx=true;}if(bG.indexOf(".")>=0){bw=bG.split(".");bG=bw.shift();bw.sort();}if((!bA||C.event.customEvent[bG])&&!C.event.global[bG]){return}bv=typeof bv==="object"?bv[C.expando]?bv:new C.Event(bG,bv):new C.Event(bG);bv.type=bG;bv.isTrigger=true;bv.exclusive=bx;bv.namespace=bw.join(".");bv.namespace_re=bv.namespace?new RegExp("(^|\\.)"+bw.join("\\.(?:.*\\.|)")+"(\\.|$)"):null;by=bG.indexOf(":")<0?"on"+bG:"";if(!bA){bu=C.cache;for(bD in bu){if(bu[bD].events&&bu[bD].events[bG]){C.event.trigger(bv,bC,bu[bD].handle.elem,true);}}return}bv.result=G;if(!bv.target){bv.target=bA;}bC=bC!=null?C.makeArray(bC):[];bC.unshift(bv);bF=C.event.special[bG]||{};if(bF.trigger&&bF.trigger.apply(bA,bC)===false){return}bB=[[bA,bF.bindType||bG]];if(!bJ&&!bF.noBubble&&!C.isWindow(bA)){bI=bF.delegateType||bG;bH=N.test(bI+bG)?bA:bA.parentNode;for(bz=bA;bH;bH=bH.parentNode){bB.push([bH,bI]);bz=bH;}if(bz===(bA.ownerDocument||ak)){bB.push([bz.defaultView||bz.parentWindow||bd,bI]);}}for(bD=0;bD<bB.length&&!bv.isPropagationStopped();bD++){bH=bB[bD][0];bv.type=bB[bD][1];bE=(C._data(bH,"events")||{})[bv.type]&&C._data(bH,"handle");if(bE){bE.apply(bH,bC);}bE=by&&bH[by];if(bE&&C.acceptData(bH)&&bE.apply&&bE.apply(bH,bC)===false){bv.preventDefault();}}bv.type=bG;if(!bJ&&!bv.isDefaultPrevented()){if((!bF._default||bF._default.apply(bA.ownerDocument,bC)===false)&&!(bG==="click"&&C.nodeName(bA,"a"))&&C.acceptData(bA)){if(by&&bA[bG]&&((bG!=="focus"&&bG!=="blur")||bv.target.offsetWidth!==0)&&!C.isWindow(bA)){bz=bA[by];if(bz){bA[by]=null;}C.event.triggered=bG;bA[bG]();C.event.triggered=G;if(bz){bA[by]=bz;}}}}return bv.result},dispatch:function(bu){bu=C.event.fix(bu||bd.event);var bB,bA,bK,bE,bD,bv,bC,bI,bx,by=((C._data(this,"events")||{})[bu.type]||[]),bz=by.delegateCount,bG=aD.call(arguments),bw=!bu.exclusive&&!bu.namespace,bF=C.event.special[bu.type]||{},bH=[];bG[0]=bu;bu.delegateTarget=this;if(bF.preDispatch&&bF.preDispatch.call(this,bu)===false){return}if(bz&&!(bu.button&&bu.type==="click")){for(bK=bu.target;bK!=this;bK=bK.parentNode||this){if(bK.disabled!==true||bu.type!=="click"){bD={};bC=[];for(bB=0;bB<bz;bB++){bI=by[bB];bx=bI.selector;if(bD[bx]===G){bD[bx]=bI.needsContext?C(bx,this).index(bK)>=0:C.find(bx,this,null,[bK]).length;}if(bD[bx]){bC.push(bI);}}if(bC.length){bH.push({elem:bK,matches:bC});}}}}if(by.length>bz){bH.push({elem:this,matches:by.slice(bz)});}for(bB=0;bB<bH.length&&!bu.isPropagationStopped();bB++){bv=bH[bB];bu.currentTarget=bv.elem;for(bA=0;bA<bv.matches.length&&!bu.isImmediatePropagationStopped();bA++){bI=bv.matches[bA];if(bw||(!bu.namespace&&!bI.namespace)||bu.namespace_re&&bu.namespace_re.test(bI.namespace)){bu.data=bI.data;bu.handleObj=bI;bE=((C.event.special[bI.origType]||{}).handle||bI.handler).apply(bv.elem,bG);if(bE!==G){bu.result=bE;if(bE===false){bu.preventDefault();bu.stopPropagation();}}}}}if(bF.postDispatch){bF.postDispatch.call(this,bu);}return bu.result},props:"attrChange attrName relatedNode srcElement altKey bubbles cancelable ctrlKey currentTarget eventPhase metaKey relatedTarget shiftKey target timeStamp view which".split(" "),fixHooks:{},keyHooks:{props:"char charCode key keyCode".split(" "),filter:function(bv,bu){if(bv.which==null){bv.which=bu.charCode!=null?bu.charCode:bu.keyCode;}return bv}},mouseHooks:{props:"button buttons clientX clientY fromElement offsetX offsetY pageX pageY screenX screenY toElement".split(" "),filter:function(bx,bw){var by,bz,bu,bv=bw.button,bA=bw.fromElement;if(bx.pageX==null&&bw.clientX!=null){by=bx.target.ownerDocument||ak;bz=by.documentElement;bu=by.body;bx.pageX=bw.clientX+(bz&&bz.scrollLeft||bu&&bu.scrollLeft||0)-(bz&&bz.clientLeft||bu&&bu.clientLeft||0);bx.pageY=bw.clientY+(bz&&bz.scrollTop||bu&&bu.scrollTop||0)-(bz&&bz.clientTop||bu&&bu.clientTop||0);}if(!bx.relatedTarget&&bA){bx.relatedTarget=bA===bx.target?bw.toElement:bA;}if(!bx.which&&bv!==G){bx.which=(bv&1?1:(bv&2?3:(bv&4?2:0)));}return bx}},fix:function(bw){if(bw[C.expando]){return bw}var bv,bz,bu=bw,bx=C.event.fixHooks[bw.type]||{},by=bx.props?this.props.concat(bx.props):this.props;bw=C.Event(bu);for(bv=by.length;bv;){bz=by[--bv];bw[bz]=bu[bz];}if(!bw.target){bw.target=bu.srcElement||ak;}if(bw.target.nodeType===3){bw.target=bw.target.parentNode;}bw.metaKey=!!bw.metaKey;return bx.filter?bx.filter(bw,bu):bw},special:{load:{noBubble:true},focus:{delegateType:"focusin"},blur:{delegateType:"focusout"},beforeunload:{setup:function(bw,bv,bu){if(C.isWindow(this)){this.onbeforeunload=bu;}},teardown:function(bv,bu){if(this.onbeforeunload===bu){this.onbeforeunload=null;}}}},simulate:function(bv,bx,bw,bu){var by=C.extend(new C.Event(),bw,{type:bv,isSimulated:true,originalEvent:{}});if(bu){C.event.trigger(by,null,bx);}else {C.event.dispatch.call(bx,by);}if(by.isDefaultPrevented()){bw.preventDefault();}}};C.event.handle=C.event.dispatch;C.removeEvent=ak.removeEventListener?function(bv,bu,bw){if(bv.removeEventListener){bv.removeEventListener(bu,bw,false);}}:function(bw,bv,bx){var bu="on"+bv;if(bw.detachEvent){if(typeof bw[bu]==="undefined"){bw[bu]=null;}bw.detachEvent(bu,bx);}};C.Event=function(bv,bu){if(!(this instanceof C.Event)){return new C.Event(bv,bu)}if(bv&&bv.type){this.originalEvent=bv;this.type=bv.type;this.isDefaultPrevented=(bv.defaultPrevented||bv.returnValue===false||bv.getPreventDefault&&bv.getPreventDefault())?f:bn;}else {this.type=bv;}if(bu){C.extend(this,bu);}this.timeStamp=bv&&bv.timeStamp||C.now();this[C.expando]=true;};function bn(){return false}function f(){return true}C.Event.prototype={preventDefault:function(){this.isDefaultPrevented=f;var bu=this.originalEvent;if(!bu){return}if(bu.preventDefault){bu.preventDefault();}else {bu.returnValue=false;}},stopPropagation:function(){this.isPropagationStopped=f;var bu=this.originalEvent;if(!bu){return}if(bu.stopPropagation){bu.stopPropagation();}bu.cancelBubble=true;},stopImmediatePropagation:function(){this.isImmediatePropagationStopped=f;this.stopPropagation();},isDefaultPrevented:bn,isPropagationStopped:bn,isImmediatePropagationStopped:bn};C.each({mouseenter:"mouseover",mouseleave:"mouseout"},function(bv,bu){C.event.special[bv]={delegateType:bu,bindType:bu,handle:function(bz){var bx,bB=this,bA=bz.relatedTarget,by=bz.handleObj;by.selector;if(!bA||(bA!==bB&&!C.contains(bB,bA))){bz.type=by.origType;bx=by.handler.apply(this,arguments);bz.type=bu;}return bx}};});C.fn.extend({on:function(bw,bu,bz,by,bv){var bA,bx;if(typeof bw==="object"){if(typeof bu!=="string"){bz=bz||bu;bu=G;}for(bx in bw){this.on(bx,bu,bz,bw[bx],bv);}return this}if(bz==null&&by==null){by=bu;bz=bu=G;}else {if(by==null){if(typeof bu==="string"){by=bz;bz=G;}else {by=bz;bz=bu;bu=G;}}}if(by===false){by=bn;}else {if(!by){return this}}if(bv===1){bA=by;by=function(bB){C().off(bB);return bA.apply(this,arguments)};by.guid=bA.guid||(bA.guid=C.guid++);}return this.each(function(){C.event.add(this,bw,by,bz,bu);})},off:function(bw,bu,by){var bv,bx;if(bw&&bw.preventDefault&&bw.handleObj){bv=bw.handleObj;C(bw.delegateTarget).off(bv.namespace?bv.origType+"."+bv.namespace:bv.origType,bv.selector,bv.handler);return this}if(typeof bw==="object"){for(bx in bw){this.off(bx,bu,bw[bx]);}return this}if(bu===false||typeof bu==="function"){by=bu;bu=G;}if(by===false){by=bn;}return this.each(function(){C.event.remove(this,bw,by,bu);})},delegate:function(bu,bv,bx,bw){return this.on(bv,bu,bx,bw)},undelegate:function(bu,bv,bw){return arguments.length===1?this.off(bu,"**"):this.off(bv,bu||"**",bw)},trigger:function(bu,bv){return this.each(function(){C.event.trigger(bu,bv,this);})},triggerHandler:function(bu,bv){if(this[0]){return C.event.trigger(bu,bv,this[0],true)}},toggle:function(bx){var bv=arguments,bu=bx.guid||C.guid++,bw=0,by=function(bz){var bA=(C._data(this,"lastToggle"+bx.guid)||0)%bw;C._data(this,"lastToggle"+bx.guid,bA+1);bz.preventDefault();return bv[bA].apply(this,arguments)||false};by.guid=bu;while(bw<bv.length){bv[bw++].guid=bu;}return this.click(by)},hover:function(bu,bv){return this.mouseenter(bu).mouseleave(bv||bu)}});C.each(("blur focus focusin focusout load resize scroll unload click dblclick mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave change select submit keydown keypress keyup error contextmenu").split(" "),function(bv,bu){C.fn[bu]=function(bx,bw){if(bw==null){bw=bx;bx=null;}return arguments.length>0?this.on(bu,null,bx,bw):this.trigger(bu)};if(aH.test(bu)){C.event.fixHooks[bu]=C.event.keyHooks;}if(bi.test(bu)){C.event.fixHooks[bu]=C.event.mouseHooks;}});
/*!
         * Sizzle CSS Selector Engine
         * Copyright 2012 JQXLite Foundation and other contributors
         * Released under the MIT license
         * http://sizzlejs.com/
         */
(function(cn,bM){var cs,bF,cg,bv,bR,b5,bI,bL,bH,ce,bE=true,bZ="undefined",cu=("sizcache"+Math.random()).replace(".",""),bz=String,bD=cn.document,bG=bD.documentElement,bW=0,bK=0,b9=[].pop,cr=[].push,bQ=[].slice,bT=[].indexOf||function(cE){var cD=0,cC=this.length;for(;cD<cC;cD++){if(this[cD]===cE){return cD}}return -1},cw=function(cC,cD){cC[cu]=cD==null||cD;return cC},cA=function(){var cC={},cD=[];return cw(function(cE,cF){if(cD.push(cE)>cg.cacheLength){delete cC[cD.shift()];}return(cC[cE+" "]=cF)},cC)},cp=cA(),cq=cA(),bS=cA(),b3="[\\x20\\t\\r\\n\\f]",bP="(?:\\\\.|[-\\w]|[^\\x00-\\xa0])+",bN=bP.replace("w","w#"),cz="([*^$|!~]?=)",ck="\\["+b3+"*("+bP+")"+b3+"*(?:"+cz+b3+"*(?:(['\"])((?:\\\\.|[^\\\\])*?)\\3|("+bN+")|)|)"+b3+"*\\]",cB=":("+bP+")(?:\\((?:(['\"])((?:\\\\.|[^\\\\])*?)\\2|([^()[\\]]*|(?:(?:"+ck+")|[^:]|\\\\.)*|.*))\\)|)",b4=":(even|odd|eq|gt|lt|nth|first|last)(?:\\("+b3+"*((?:-\\d)?\\d*)"+b3+"*\\)|)(?=[^-]|$)",co=new RegExp("^"+b3+"+|((?:^|[^\\\\])(?:\\\\.)*)"+b3+"+$","g"),bA=new RegExp("^"+b3+"*,"+b3+"*"),cc=new RegExp("^"+b3+"*([\\x20\\t\\r\\n\\f>+~])"+b3+"*"),ch=new RegExp(cB),cj=/^(?:#([\w\-]+)|(\w+)|\.([\w\-]+))$/,cm=/[\x20\t\r\n\f]*[+~]/,bX=/h\d/i,ci=/input|select|textarea|button/i,bY=/\\(?!\\)/g,cb={ID:new RegExp("^#("+bP+")"),CLASS:new RegExp("^\\.("+bP+")"),NAME:new RegExp("^\\[name=['\"]?("+bP+")['\"]?\\]"),TAG:new RegExp("^("+bP.replace("w","w*")+")"),ATTR:new RegExp("^"+ck),PSEUDO:new RegExp("^"+cB),POS:new RegExp(b4,"i"),CHILD:new RegExp("^:(only|nth|first|last)-child(?:\\("+b3+"*(even|odd|(([+-]|)(\\d*)n|)"+b3+"*(?:([+-]|)"+b3+"*(\\d+)|))"+b3+"*\\)|)","i"),needsContext:new RegExp("^"+b3+"*[>+~]|"+b4,"i")},cf=function(cC){var cE=bD.createElement("div");try{return cC(cE)}catch(cD){return false}finally{cE=null;}},bC=cf(function(cC){cC.appendChild(bD.createComment(""));return !cC.getElementsByTagName("*").length}),b7=cf(function(cC){cC.innerHTML="<a href='#'></a>";return cC.firstChild&&typeof cC.firstChild.getAttribute!==bZ&&cC.firstChild.getAttribute("href")==="#"}),bV=cf(function(cD){cD.innerHTML="<select></select>";var cC=typeof cD.lastChild.getAttribute("multiple");return cC!=="boolean"&&cC!=="string"}),b6=cf(function(cC){cC.innerHTML="<div class='hidden e'></div><div class='hidden'></div>";if(!cC.getElementsByClassName||!cC.getElementsByClassName("e").length){return false}cC.lastChild.className="e";return cC.getElementsByClassName("e").length===2}),bu=cf(function(cD){cD.id=cu+0;cD.innerHTML="<a name='"+cu+"'></a><div name='"+cu+"'></div>";bG.insertBefore(cD,bG.firstChild);var cC=bD.getElementsByName&&bD.getElementsByName(cu).length===2+bD.getElementsByName(cu+0).length;bF=!bD.getElementById(cu);bG.removeChild(cD);return cC});try{bQ.call(bG.childNodes,0)[0].nodeType;}catch(cy){bQ=function(cD){var cE,cC=[];for(;(cE=this[cD]);cD++){cC.push(cE);}return cC};}function cl(cF,cC,cH,cK){cH=cH||[];cC=cC||bD;var cI,cD,cJ,cE,cG=cC.nodeType;if(!cF||typeof cF!=="string"){return cH}if(cG!==1&&cG!==9){return []}cJ=bR(cC);if(!cJ&&!cK){if((cI=cj.exec(cF))){if((cE=cI[1])){if(cG===9){cD=cC.getElementById(cE);if(cD&&cD.parentNode){if(cD.id===cE){cH.push(cD);return cH}}else {return cH}}else {if(cC.ownerDocument&&(cD=cC.ownerDocument.getElementById(cE))&&b5(cC,cD)&&cD.id===cE){cH.push(cD);return cH}}}else {if(cI[2]){cr.apply(cH,bQ.call(cC.getElementsByTagName(cF),0));return cH}else {if((cE=cI[3])&&b6&&cC.getElementsByClassName){cr.apply(cH,bQ.call(cC.getElementsByClassName(cE),0));return cH}}}}}return ct(cF.replace(co,"$1"),cC,cH,cK,cJ)}cl.matches=function(cD,cC){return cl(cD,null,null,cC)};cl.matchesSelector=function(cC,cD){return cl(cD,null,null,[cC]).length>0};function cd(cC){return function(cE){var cD=cE.nodeName.toLowerCase();return cD==="input"&&cE.type===cC}}function by(cC){return function(cE){var cD=cE.nodeName.toLowerCase();return (cD==="input"||cD==="button")&&cE.type===cC}}function ca(cC){return cw(function(cD){cD=+cD;return cw(function(cE,cI){var cG,cF=cC([],cE.length,cD),cH=cF.length;while(cH--){if(cE[(cG=cF[cH])]){cE[cG]=!(cI[cG]=cE[cG]);}}})})}bv=cl.getText=function(cG){var cF,cD="",cE=0,cC=cG.nodeType;if(cC){if(cC===1||cC===9||cC===11){if(typeof cG.textContent==="string"){return cG.textContent}else {for(cG=cG.firstChild;cG;cG=cG.nextSibling){cD+=bv(cG);}}}else {if(cC===3||cC===4){return cG.nodeValue}}}else {for(;(cF=cG[cE]);cE++){cD+=bv(cF);}}return cD};bR=cl.isXML=function(cC){var cD=cC&&(cC.ownerDocument||cC).documentElement;return cD?cD.nodeName!=="HTML":false};b5=cl.contains=bG.contains?function(cD,cC){var cF=cD.nodeType===9?cD.documentElement:cD,cE=cC&&cC.parentNode;return cD===cE||!!(cE&&cE.nodeType===1&&cF.contains&&cF.contains(cE))}:bG.compareDocumentPosition?function(cD,cC){return cC&&!!(cD.compareDocumentPosition(cC)&16)}:function(cD,cC){while((cC=cC.parentNode)){if(cC===cD){return true}}return false};cl.attr=function(cE,cD){var cF,cC=bR(cE);if(!cC){cD=cD.toLowerCase();}if((cF=cg.attrHandle[cD])){return cF(cE)}if(cC||bV){return cE.getAttribute(cD)}cF=cE.getAttributeNode(cD);return cF?typeof cE[cD]==="boolean"?cE[cD]?cD:null:cF.specified?cF.value:null:null};cg=cl.selectors={cacheLength:50,createPseudo:cw,match:cb,attrHandle:b7?{}:{href:function(cC){return cC.getAttribute("href",2)},type:function(cC){return cC.getAttribute("type")}},find:{ID:bF?function(cF,cE,cD){if(typeof cE.getElementById!==bZ&&!cD){var cC=cE.getElementById(cF);return cC&&cC.parentNode?[cC]:[]}}:function(cF,cE,cD){if(typeof cE.getElementById!==bZ&&!cD){var cC=cE.getElementById(cF);return cC?cC.id===cF||typeof cC.getAttributeNode!==bZ&&cC.getAttributeNode("id").value===cF?[cC]:bM:[]}},TAG:bC?function(cC,cD){if(typeof cD.getElementsByTagName!==bZ){return cD.getElementsByTagName(cC)}}:function(cC,cG){var cF=cG.getElementsByTagName(cC);if(cC==="*"){var cH,cE=[],cD=0;for(;(cH=cF[cD]);cD++){if(cH.nodeType===1){cE.push(cH);}}return cE}return cF},NAME:bu&&function(cC,cD){if(typeof cD.getElementsByName!==bZ){return cD.getElementsByName(name)}},CLASS:b6&&function(cE,cD,cC){if(typeof cD.getElementsByClassName!==bZ&&!cC){return cD.getElementsByClassName(cE)}}},relative:{">":{dir:"parentNode",first:true}," ":{dir:"parentNode"},"+":{dir:"previousSibling",first:true},"~":{dir:"previousSibling"}},preFilter:{ATTR:function(cC){cC[1]=cC[1].replace(bY,"");cC[3]=(cC[4]||cC[5]||"").replace(bY,"");if(cC[2]==="~="){cC[3]=" "+cC[3]+" ";}return cC.slice(0,4)},CHILD:function(cC){cC[1]=cC[1].toLowerCase();if(cC[1]==="nth"){if(!cC[2]){cl.error(cC[0]);}cC[3]=+(cC[3]?cC[4]+(cC[5]||1):2*(cC[2]==="even"||cC[2]==="odd"));cC[4]=+((cC[6]+cC[7])||cC[2]==="odd");}else {if(cC[2]){cl.error(cC[0]);}}return cC},PSEUDO:function(cD){var cE,cC;if(cb.CHILD.test(cD[0])){return null}if(cD[3]){cD[2]=cD[3];}else {if((cE=cD[4])){if(ch.test(cE)&&(cC=bw(cE,true))&&(cC=cE.indexOf(")",cE.length-cC)-cE.length)){cE=cE.slice(0,cC);cD[0]=cD[0].slice(0,cC);}cD[2]=cE;}}return cD.slice(0,3)}},filter:{ID:bF?function(cC){cC=cC.replace(bY,"");return function(cD){return cD.getAttribute("id")===cC}}:function(cC){cC=cC.replace(bY,"");return function(cE){var cD=typeof cE.getAttributeNode!==bZ&&cE.getAttributeNode("id");return cD&&cD.value===cC}},TAG:function(cC){if(cC==="*"){return function(){return true}}cC=cC.replace(bY,"").toLowerCase();return function(cD){return cD.nodeName&&cD.nodeName.toLowerCase()===cC}},CLASS:function(cC){var cD=cp[cu][cC+" "];return cD||(cD=new RegExp("(^|"+b3+")"+cC+"("+b3+"|$)"))&&cp(cC,function(cE){return cD.test(cE.className||(typeof cE.getAttribute!==bZ&&cE.getAttribute("class"))||"")})},ATTR:function(cE,cD,cC){return function(cH,cG){var cF=cl.attr(cH,cE);if(cF==null){return cD==="!="}if(!cD){return true}cF+="";return cD==="="?cF===cC:cD==="!="?cF!==cC:cD==="^="?cC&&cF.indexOf(cC)===0:cD==="*="?cC&&cF.indexOf(cC)>-1:cD==="$="?cC&&cF.substr(cF.length-cC.length)===cC:cD==="~="?(" "+cF+" ").indexOf(cC)>-1:cD==="|="?cF===cC||cF.substr(0,cC.length+1)===cC+"-":false}},CHILD:function(cC,cE,cF,cD){if(cC==="nth"){return function(cI){var cH,cJ,cG=cI.parentNode;if(cF===1&&cD===0){return true}if(cG){cJ=0;for(cH=cG.firstChild;cH;cH=cH.nextSibling){if(cH.nodeType===1){cJ++;if(cI===cH){break}}}}cJ-=cD;return cJ===cF||(cJ%cF===0&&cJ/cF>=0)}}return function(cH){var cG=cH;switch(cC){case"only":case"first":while((cG=cG.previousSibling)){if(cG.nodeType===1){return false}}if(cC==="first"){return true}cG=cH;case"last":while((cG=cG.nextSibling)){if(cG.nodeType===1){return false}}return true}}},PSEUDO:function(cF,cE){var cC,cD=cg.pseudos[cF]||cg.setFilters[cF.toLowerCase()]||cl.error("unsupported pseudo: "+cF);if(cD[cu]){return cD(cE)}if(cD.length>1){cC=[cF,cF,"",cE];return cg.setFilters.hasOwnProperty(cF.toLowerCase())?cw(function(cI,cK){var cH,cG=cD(cI,cE),cJ=cG.length;while(cJ--){cH=bT.call(cI,cG[cJ]);cI[cH]=!(cK[cH]=cG[cJ]);}}):function(cG){return cD(cG,0,cC)}}return cD}},pseudos:{not:cw(function(cC){var cD=[],cE=[],cF=bI(cC.replace(co,"$1"));return cF[cu]?cw(function(cH,cM,cK,cI){var cL,cG=cF(cH,null,cI,[]),cJ=cH.length;while(cJ--){if((cL=cG[cJ])){cH[cJ]=!(cM[cJ]=cL);}}}):function(cI,cH,cG){cD[0]=cI;cF(cD,null,cG,cE);return !cE.pop()}}),has:cw(function(cC){return function(cD){return cl(cC,cD).length>0}}),contains:cw(function(cC){return function(cD){return (cD.textContent||cD.innerText||bv(cD)).indexOf(cC)>-1}}),enabled:function(cC){return cC.disabled===false},disabled:function(cC){return cC.disabled===true},checked:function(cC){var cD=cC.nodeName.toLowerCase();return (cD==="input"&&!!cC.checked)||(cD==="option"&&!!cC.selected)},selected:function(cC){if(cC.parentNode){cC.parentNode.selectedIndex;}return cC.selected===true},parent:function(cC){return !cg.pseudos.empty(cC)},empty:function(cD){var cC;cD=cD.firstChild;while(cD){if(cD.nodeName>"@"||(cC=cD.nodeType)===3||cC===4){return false}cD=cD.nextSibling;}return true},header:function(cC){return bX.test(cC.nodeName)},text:function(cE){var cD,cC;return cE.nodeName.toLowerCase()==="input"&&(cD=cE.type)==="text"&&((cC=cE.getAttribute("type"))==null||cC.toLowerCase()===cD)},radio:cd("radio"),checkbox:cd("checkbox"),file:cd("file"),password:cd("password"),image:cd("image"),submit:by("submit"),reset:by("reset"),button:function(cD){var cC=cD.nodeName.toLowerCase();return cC==="input"&&cD.type==="button"||cC==="button"},input:function(cC){return ci.test(cC.nodeName)},focus:function(cC){var cD=cC.ownerDocument;return cC===cD.activeElement&&(!cD.hasFocus||cD.hasFocus())&&!!(cC.type||cC.href||~cC.tabIndex)},active:function(cC){return cC===cC.ownerDocument.activeElement},first:ca(function(){return [0]}),last:ca(function(cC,cD){return [cD-1]}),eq:ca(function(cC,cE,cD){return [cD<0?cD+cE:cD]}),even:ca(function(cC,cE){for(var cD=0;cD<cE;cD+=2){cC.push(cD);}return cC}),odd:ca(function(cC,cE){for(var cD=1;cD<cE;cD+=2){cC.push(cD);}return cC}),lt:ca(function(cC,cF,cE){for(var cD=cE<0?cE+cF:cE;--cD>=0;){cC.push(cD);}return cC}),gt:ca(function(cC,cF,cE){for(var cD=cE<0?cE+cF:cE;++cD<cF;){cC.push(cD);}return cC})}};function bx(cD,cC,cE){if(cD===cC){return cE}var cF=cD.nextSibling;while(cF){if(cF===cC){return -1}cF=cF.nextSibling;}return 1}bL=bG.compareDocumentPosition?function(cD,cC){if(cD===cC){bH=true;return 0}return (!cD.compareDocumentPosition||!cC.compareDocumentPosition?cD.compareDocumentPosition:cD.compareDocumentPosition(cC)&4)?-1:1}:function(cK,cJ){if(cK===cJ){bH=true;return 0}else {if(cK.sourceIndex&&cJ.sourceIndex){return cK.sourceIndex-cJ.sourceIndex}}var cH,cD,cE=[],cC=[],cG=cK.parentNode,cI=cJ.parentNode,cL=cG;if(cG===cI){return bx(cK,cJ)}else {if(!cG){return -1}else {if(!cI){return 1}}}while(cL){cE.unshift(cL);cL=cL.parentNode;}cL=cI;while(cL){cC.unshift(cL);cL=cL.parentNode;}cH=cE.length;cD=cC.length;for(var cF=0;cF<cH&&cF<cD;cF++){if(cE[cF]!==cC[cF]){return bx(cE[cF],cC[cF])}}return cF===cH?bx(cK,cC[cF],-1):bx(cE[cF],cJ,1)};[0,0].sort(bL);bE=!bH;cl.uniqueSort=function(cE){var cF,cG=[],cD=1,cC=0;bH=bE;cE.sort(bL);if(bH){for(;(cF=cE[cD]);cD++){if(cF===cE[cD-1]){cC=cG.push(cD);}}while(cC--){cE.splice(cG[cC],1);}}return cE};cl.error=function(cC){throw new Error("Syntax error, unrecognized expression: "+cC)};function bw(cG,cL){var cD,cH,cJ,cK,cI,cE,cC,cF=cq[cu][cG+" "];if(cF){return cL?0:cF.slice(0)}cI=cG;cE=[];cC=cg.preFilter;while(cI){if(!cD||(cH=bA.exec(cI))){if(cH){cI=cI.slice(cH[0].length)||cI;}cE.push(cJ=[]);}cD=false;if((cH=cc.exec(cI))){cJ.push(cD=new bz(cH.shift()));cI=cI.slice(cD.length);cD.type=cH[0].replace(co," ");}for(cK in cg.filter){if((cH=cb[cK].exec(cI))&&(!cC[cK]||(cH=cC[cK](cH)))){cJ.push(cD=new bz(cH.shift()));cI=cI.slice(cD.length);cD.type=cK;cD.matches=cH;}}if(!cD){break}}return cL?cI.length:cI?cl.error(cG):cq(cG,cE).slice(0)}function b1(cG,cE,cF){var cC=cE.dir,cH=cF&&cE.dir==="parentNode",cD=bK++;return cE.first?function(cK,cJ,cI){while((cK=cK[cC])){if(cH||cK.nodeType===1){return cG(cK,cJ,cI)}}}:function(cL,cK,cJ){if(!cJ){var cI,cM=bW+" "+cD+" ",cN=cM+cs;while((cL=cL[cC])){if(cH||cL.nodeType===1){if((cI=cL[cu])===cN){return cL.sizset}else {if(typeof cI==="string"&&cI.indexOf(cM)===0){if(cL.sizset){return cL}}else {cL[cu]=cN;if(cG(cL,cK,cJ)){cL.sizset=true;return cL}cL.sizset=false;}}}}}else {while((cL=cL[cC])){if(cH||cL.nodeType===1){if(cG(cL,cK,cJ)){return cL}}}}}}function bJ(cC){return cC.length>1?function(cG,cF,cD){var cE=cC.length;while(cE--){if(!cC[cE](cG,cF,cD)){return false}}return true}:cC[0]}function b0(cC,cD,cE,cF,cI){var cG,cL=[],cH=0,cJ=cC.length,cK=cD!=null;for(;cH<cJ;cH++){if((cG=cC[cH])){if(!cE||cE(cG,cF,cI)){cL.push(cG);if(cK){cD.push(cH);}}}}return cL}function cx(cE,cD,cG,cF,cH,cC){if(cF&&!cF[cu]){cF=cx(cF);}if(cH&&!cH[cu]){cH=cx(cH,cC);}return cw(function(cS,cP,cK,cR){var cU,cQ,cM,cL=[],cT=[],cJ=cP.length,cI=cS||bU(cD||"*",cK.nodeType?[cK]:cK,[]),cN=cE&&(cS||!cD)?b0(cI,cL,cE,cK,cR):cI,cO=cG?cH||(cS?cE:cJ||cF)?[]:cP:cN;if(cG){cG(cN,cO,cK,cR);}if(cF){cU=b0(cO,cT);cF(cU,[],cK,cR);cQ=cU.length;while(cQ--){if((cM=cU[cQ])){cO[cT[cQ]]=!(cN[cT[cQ]]=cM);}}}if(cS){if(cH||cE){if(cH){cU=[];cQ=cO.length;while(cQ--){if((cM=cO[cQ])){cU.push((cN[cQ]=cM));}}cH(null,(cO=[]),cU,cR);}cQ=cO.length;while(cQ--){if((cM=cO[cQ])&&(cU=cH?bT.call(cS,cM):cL[cQ])>-1){cS[cU]=!(cP[cU]=cM);}}}}else {cO=b0(cO===cP?cO.splice(cJ,cO.length):cO);if(cH){cH(null,cP,cO,cR);}else {cr.apply(cP,cO);}}})}function b2(cI){var cD,cG,cE,cH=cI.length,cL=cg.relative[cI[0].type],cM=cL||cg.relative[" "],cF=cL?1:0,cJ=b1(function(cN){return cN===cD},cM,true),cK=b1(function(cN){return bT.call(cD,cN)>-1},cM,true),cC=[function(cP,cO,cN){return (!cL&&(cN||cO!==ce))||((cD=cO).nodeType?cJ(cP,cO,cN):cK(cP,cO,cN))}];for(;cF<cH;cF++){if((cG=cg.relative[cI[cF].type])){cC=[b1(bJ(cC),cG)];}else {cG=cg.filter[cI[cF].type].apply(null,cI[cF].matches);if(cG[cu]){cE=++cF;for(;cE<cH;cE++){if(cg.relative[cI[cE].type]){break}}return cx(cF>1&&bJ(cC),cF>1&&cI.slice(0,cF-1).join("").replace(co,"$1"),cG,cF<cE&&b2(cI.slice(cF,cE)),cE<cH&&b2((cI=cI.slice(cE))),cE<cH&&cI.join(""))}cC.push(cG);}}return bJ(cC)}function bB(cF,cE){var cC=cE.length>0,cG=cF.length>0,cD=function(cQ,cK,cP,cO,cW){var cL,cM,cR,cV=[],cU=0,cN="0",cH=cQ&&[],cS=cW!=null,cT=ce,cJ=cQ||cG&&cg.find.TAG("*",cW&&cK.parentNode||cK),cI=(bW+=cT==null?1:Math.E);if(cS){ce=cK!==bD&&cK;cs=cD.el;}for(;(cL=cJ[cN])!=null;cN++){if(cG&&cL){for(cM=0;(cR=cF[cM]);cM++){if(cR(cL,cK,cP)){cO.push(cL);break}}if(cS){bW=cI;cs=++cD.el;}}if(cC){if((cL=!cR&&cL)){cU--;}if(cQ){cH.push(cL);}}}cU+=cN;if(cC&&cN!==cU){for(cM=0;(cR=cE[cM]);cM++){cR(cH,cV,cK,cP);}if(cQ){if(cU>0){while(cN--){if(!(cH[cN]||cV[cN])){cV[cN]=b9.call(cO);}}}cV=b0(cV);}cr.apply(cO,cV);if(cS&&!cQ&&cV.length>0&&(cU+cE.length)>1){cl.uniqueSort(cO);}}if(cS){bW=cI;ce=cT;}return cH};cD.el=0;return cC?cw(cD):cD}bI=cl.compile=function(cC,cH){var cE,cD=[],cG=[],cF=bS[cu][cC+" "];if(!cF){if(!cH){cH=bw(cC);}cE=cH.length;while(cE--){cF=b2(cH[cE]);if(cF[cu]){cD.push(cF);}else {cG.push(cF);}}cF=bS(cC,bB(cG,cD));}return cF};function bU(cD,cG,cF){var cE=0,cC=cG.length;for(;cE<cC;cE++){cl(cD,cG[cE],cF);}return cF}function ct(cE,cC,cG,cK,cJ){var cH,cN,cD,cM,cL,cI=bw(cE);cI.length;if(!cK){if(cI.length===1){cN=cI[0]=cI[0].slice(0);if(cN.length>2&&(cD=cN[0]).type==="ID"&&cC.nodeType===9&&!cJ&&cg.relative[cN[1].type]){cC=cg.find.ID(cD.matches[0].replace(bY,""),cC,cJ)[0];if(!cC){return cG}cE=cE.slice(cN.shift().length);}for(cH=cb.POS.test(cE)?-1:cN.length-1;cH>=0;cH--){cD=cN[cH];if(cg.relative[(cM=cD.type)]){break}if((cL=cg.find[cM])){if((cK=cL(cD.matches[0].replace(bY,""),cm.test(cN[0].type)&&cC.parentNode||cC,cJ))){cN.splice(cH,1);cE=cK.length&&cN.join("");if(!cE){cr.apply(cG,bQ.call(cK,0));return cG}break}}}}}bI(cE,cI)(cK,cC,cJ,cG,cm.test(cE));return cG}if(bD.querySelectorAll){(function(){var cH,cI=ct,cG=/'|\\/g,cE=/\=[\x20\t\r\n\f]*([^'"\]]*)[\x20\t\r\n\f]*\]/g,cD=[":focus"],cC=[":active"],cF=bG.matchesSelector||bG.mozMatchesSelector||bG.webkitMatchesSelector||bG.oMatchesSelector||bG.msMatchesSelector;cf(function(cJ){cJ.innerHTML="<select><option selected=''></option></select>";if(!cJ.querySelectorAll("[selected]").length){cD.push("\\["+b3+"*(?:checked|disabled|ismap|multiple|readonly|selected|value)");}if(!cJ.querySelectorAll(":checked").length){cD.push(":checked");}});cf(function(cJ){cJ.innerHTML="<p test=''></p>";if(cJ.querySelectorAll("[test^='']").length){cD.push("[*^$]="+b3+"*(?:\"\"|'')");}cJ.innerHTML="<input type='hidden'/>";if(!cJ.querySelectorAll(":enabled").length){cD.push(":enabled",":disabled");}});cD=new RegExp(cD.join("|"));ct=function(cP,cK,cR,cU,cT){if(!cU&&!cT&&!cD.test(cP)){var cN,cS,cM=true,cJ=cu,cL=cK,cQ=cK.nodeType===9&&cP;if(cK.nodeType===1&&cK.nodeName.toLowerCase()!=="object"){cN=bw(cP);if((cM=cK.getAttribute("id"))){cJ=cM.replace(cG,"\\$&");}else {cK.setAttribute("id",cJ);}cJ="[id='"+cJ+"'] ";cS=cN.length;while(cS--){cN[cS]=cJ+cN[cS].join("");}cL=cm.test(cP)&&cK.parentNode||cK;cQ=cN.join(",");}if(cQ){try{cr.apply(cR,bQ.call(cL.querySelectorAll(cQ),0));return cR}catch(cO){}finally{if(!cM){cK.removeAttribute("id");}}}}return cI(cP,cK,cR,cU,cT)};if(cF){cf(function(cK){cH=cF.call(cK,"div");try{cF.call(cK,"[test!='']:sizzle");cC.push("!=",cB);}catch(cJ){}});cC=new RegExp(cC.join("|"));cl.matchesSelector=function(cK,cM){cM=cM.replace(cE,"='$1']");if(!bR(cK)&&!cC.test(cM)&&!cD.test(cM)){try{var cJ=cF.call(cK,cM);if(cJ||cH||cK.document&&cK.document.nodeType!==11){return cJ}}catch(cL){}}return cl(cM,null,null,[cK]).length>0};}})();}cg.pseudos.nth=cg.pseudos.eq;function bO(){}cg.filters=bO.prototype=cg.pseudos;cg.setFilters=new bO();cl.attr=C.attr;C.find=cl;C.expr=cl.selectors;C.expr[":"]=C.expr.pseudos;C.unique=cl.uniqueSort;C.text=cl.getText;C.isXMLDoc=cl.isXML;C.contains=cl.contains;})(bd);var U=/Until$/,ag=/^(?:parents|prev(?:Until|All))/,bq=/^.[^:#\[\.,]*$/,aQ=C.expr.match.needsContext,ao={children:true,contents:true,next:true,prev:true};C.fn.extend({find:function(bu){var by,bv,bA,bB,bz,bx,bw=this;if(typeof bu!=="string"){return C(bu).filter(function(){for(by=0,bv=bw.length;by<bv;by++){if(C.contains(bw[by],this)){return true}}})}bx=this.pushStack("","find",bu);for(by=0,bv=this.length;by<bv;by++){bA=bx.length;C.find(bu,this[by],bx);if(by>0){for(bB=bA;bB<bx.length;bB++){for(bz=0;bz<bA;bz++){if(bx[bz]===bx[bB]){bx.splice(bB--,1);break}}}}}return bx},has:function(bx){var bw,bv=C(bx,this),bu=bv.length;return this.filter(function(){for(bw=0;bw<bu;bw++){if(C.contains(this,bv[bw])){return true}}})},not:function(bu){return this.pushStack(az(this,bu,false),"not",bu)},filter:function(bu){return this.pushStack(az(this,bu,true),"filter",bu)},is:function(bu){return !!bu&&(typeof bu==="string"?aQ.test(bu)?C(bu,this.context).index(this[0])>=0:C.filter(bu,this).length>0:this.filter(bu).length>0)},closest:function(by,bx){var bz,bw=0,bu=this.length,bv=[],bA=aQ.test(by)||typeof by!=="string"?C(by,bx||this.context):0;for(;bw<bu;bw++){bz=this[bw];while(bz&&bz.ownerDocument&&bz!==bx&&bz.nodeType!==11){if(bA?bA.index(bz)>-1:C.find.matchesSelector(bz,by)){bv.push(bz);break}bz=bz.parentNode;}}bv=bv.length>1?C.unique(bv):bv;return this.pushStack(bv,"closest",by)},index:function(bu){if(!bu){return (this[0]&&this[0].parentNode)?this.prevAll().length:-1}if(typeof bu==="string"){return C.inArray(this[0],C(bu))}return C.inArray(bu.jqx?bu[0]:bu,this)},add:function(bu,bv){var bx=typeof bu==="string"?C(bu,bv):C.makeArray(bu&&bu.nodeType?[bu]:bu),bw=C.merge(this.get(),bx);return this.pushStack(x(bx[0])||x(bw[0])?bw:C.unique(bw))},addBack:function(bu){return this.add(bu==null?this.prevObject:this.prevObject.filter(bu))}});C.fn.andSelf=C.fn.addBack;function x(bu){return !bu||!bu.parentNode||bu.parentNode.nodeType===11}function aB(bv,bu){do{bv=bv[bu];}while(bv&&bv.nodeType!==1);return bv}C.each({parent:function(bv){var bu=bv.parentNode;return bu&&bu.nodeType!==11?bu:null},parents:function(bu){return C.dir(bu,"parentNode")},parentsUntil:function(bv,bu,bw){return C.dir(bv,"parentNode",bw)},next:function(bu){return aB(bu,"nextSibling")},prev:function(bu){return aB(bu,"previousSibling")},nextAll:function(bu){return C.dir(bu,"nextSibling")},prevAll:function(bu){return C.dir(bu,"previousSibling")},nextUntil:function(bv,bu,bw){return C.dir(bv,"nextSibling",bw)},prevUntil:function(bv,bu,bw){return C.dir(bv,"previousSibling",bw)},siblings:function(bu){return C.sibling((bu.parentNode||{}).firstChild,bu)},children:function(bu){return C.sibling(bu.firstChild)},contents:function(bu){return C.nodeName(bu,"iframe")?bu.contentDocument||bu.contentWindow.document:C.merge([],bu.childNodes)}},function(bu,bv){C.fn[bu]=function(by,bw){var bx=C.map(this,bv,by);if(!U.test(bu)){bw=by;}if(bw&&typeof bw==="string"){bx=C.filter(bw,bx);}bx=this.length>1&&!ao[bu]?C.unique(bx):bx;if(this.length>1&&ag.test(bu)){bx=bx.reverse();}return this.pushStack(bx,bu,aD.call(arguments).join(","))};});C.extend({filter:function(bw,bu,bv){if(bv){bw=":not("+bw+")";}return bu.length===1?C.find.matchesSelector(bu[0],bw)?[bu[0]]:[]:C.find.matches(bw,bu)},dir:function(bw,bv,by){var bu=[],bx=bw[bv];while(bx&&bx.nodeType!==9&&(by===G||bx.nodeType!==1||!C(bx).is(by))){if(bx.nodeType===1){bu.push(bx);}bx=bx[bv];}return bu},sibling:function(bw,bv){var bu=[];for(;bw;bw=bw.nextSibling){if(bw.nodeType===1&&bw!==bv){bu.push(bw);}}return bu}});function az(bx,bw,bu){bw=bw||0;if(C.isFunction(bw)){return C.grep(bx,function(bz,by){var bA=!!bw.call(bz,by,bz);return bA===bu})}else {if(bw.nodeType){return C.grep(bx,function(bz,by){return (bz===bw)===bu})}else {if(typeof bw==="string"){var bv=C.grep(bx,function(by){return by.nodeType===1});if(bq.test(bw)){return C.filter(bw,bv,!bu)}else {bw=C.filter(bw,bv);}}}}return C.grep(bx,function(bz,by){return (C.inArray(bz,bw)>=0)===bu})}function a(bu){var bw=aJ.split("|"),bv=bu.createDocumentFragment();if(bv.createElement){while(bw.length){bv.createElement(bw.pop());}}return bv}var aJ="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",aa=/ JQXLite\d+="(?:null|\d+)"/g,ah=/^\s+/,L=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,c=/<([\w:]+)/,v=/<tbody/i,P=/<|&#?\w+;/,W=/<(?:script|style|link)/i,I=/<(?:script|object|embed|option|style)/i,ac=new RegExp("<(?:"+aJ+")[\\s/>]","i"),R=/^(?:checkbox|radio)$/,o=/checked\s*(?:[^=]|=\s*.checked.)/i,bp=/\/(java|ecma)script/i,aG=/^\s*<!(?:\[CDATA\[|\-\-)|[\]\-]{2}>\s*$/g,am={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]},T=a(ak),bg=T.appendChild(ak.createElement("div"));am.optgroup=am.option;am.tbody=am.tfoot=am.colgroup=am.caption=am.thead;am.th=am.td;if(!C.support.htmlSerialize){am._default=[1,"X<div>","</div>"];}C.fn.extend({text:function(bu){return C.access(this,function(bv){return bv===G?C.text(this):this.empty().append((this[0]&&this[0].ownerDocument||ak).createTextNode(bv))},null,bu,arguments.length)},wrapAll:function(bu){if(C.isFunction(bu)){return this.each(function(bw){C(this).wrapAll(bu.call(this,bw));})}if(this[0]){var bv=C(bu,this[0].ownerDocument).eq(0).clone(true);if(this[0].parentNode){bv.insertBefore(this[0]);}bv.map(function(){var bw=this;while(bw.firstChild&&bw.firstChild.nodeType===1){bw=bw.firstChild;}return bw}).append(this);}return this},wrapInner:function(bu){if(C.isFunction(bu)){return this.each(function(bv){C(this).wrapInner(bu.call(this,bv));})}return this.each(function(){var bv=C(this),bw=bv.contents();if(bw.length){bw.wrapAll(bu);}else {bv.append(bu);}})},wrap:function(bu){var bv=C.isFunction(bu);return this.each(function(bw){C(this).wrapAll(bv?bu.call(this,bw):bu);})},unwrap:function(){return this.parent().each(function(){if(!C.nodeName(this,"body")){C(this).replaceWith(this.childNodes);}}).end()},append:function(){return this.domManip(arguments,true,function(bu){if(this.nodeType===1||this.nodeType===11){this.appendChild(bu);}})},prepend:function(){return this.domManip(arguments,true,function(bu){if(this.nodeType===1||this.nodeType===11){this.insertBefore(bu,this.firstChild);}})},before:function(){if(!x(this[0])){return this.domManip(arguments,false,function(bv){this.parentNode.insertBefore(bv,this);})}if(arguments.length){var bu=C.clean(arguments);return this.pushStack(C.merge(bu,this),"before",this.selector)}},after:function(){if(!x(this[0])){return this.domManip(arguments,false,function(bv){this.parentNode.insertBefore(bv,this.nextSibling);})}if(arguments.length){var bu=C.clean(arguments);return this.pushStack(C.merge(this,bu),"after",this.selector)}},remove:function(bu,bx){var bw,bv=0;for(;(bw=this[bv])!=null;bv++){if(!bu||C.filter(bu,[bw]).length){if(!bx&&bw.nodeType===1){C.cleanData(bw.getElementsByTagName("*"));C.cleanData([bw]);}if(bw.parentNode){bw.parentNode.removeChild(bw);}}}return this},empty:function(){var bv,bu=0;for(;(bv=this[bu])!=null;bu++){if(bv.nodeType===1){C.cleanData(bv.getElementsByTagName("*"));}while(bv.firstChild){bv.removeChild(bv.firstChild);}}return this},clone:function(bv,bu){bv=bv==null?false:bv;bu=bu==null?bv:bu;return this.map(function(){return C.clone(this,bv,bu)})},html:function(bu){return C.access(this,function(by){var bx=this[0]||{},bw=0,bv=this.length;if(by===G){return bx.nodeType===1?bx.innerHTML.replace(aa,""):G}if(typeof by==="string"&&!W.test(by)&&(C.support.htmlSerialize||!ac.test(by))&&(C.support.leadingWhitespace||!ah.test(by))&&!am[(c.exec(by)||["",""])[1].toLowerCase()]){by=by.replace(L,"<$1></$2>");try{for(;bw<bv;bw++){bx=this[bw]||{};if(bx.nodeType===1){C.cleanData(bx.getElementsByTagName("*"));bx.innerHTML=by;}}bx=0;}catch(bz){}}if(bx){this.empty().append(by);}},null,bu,arguments.length)},replaceWith:function(bu){if(!x(this[0])){if(C.isFunction(bu)){return this.each(function(bx){var bw=C(this),bv=bw.html();bw.replaceWith(bu.call(this,bx,bv));})}if(typeof bu!=="string"){bu=C(bu).detach();}return this.each(function(){var bw=this.nextSibling,bv=this.parentNode;C(this).remove();if(bw){C(bw).before(bu);}else {C(bv).append(bu);}})}return this.length?this.pushStack(C(C.isFunction(bu)?bu():bu),"replaceWith",bu):this},detach:function(bu){return this.remove(bu,true)},domManip:function(bA,bE,bD){bA=[].concat.apply([],bA);var bw,by,bz,bC,bx=0,bB=bA[0],bv=[],bu=this.length;if(!C.support.checkClone&&bu>1&&typeof bB==="string"&&o.test(bB)){return this.each(function(){C(this).domManip(bA,bE,bD);})}if(C.isFunction(bB)){return this.each(function(bG){var bF=C(this);bA[0]=bB.call(this,bG,bE?bF.html():G);bF.domManip(bA,bE,bD);})}if(this[0]){bw=C.buildFragment(bA,this,bv);bz=bw.fragment;by=bz.firstChild;if(bz.childNodes.length===1){bz=by;}if(by){bE=bE&&C.nodeName(by,"tr");for(bC=bw.cacheable||bu-1;bx<bu;bx++){bD.call(bE&&C.nodeName(this[bx],"table")?a3(this[bx],"tbody"):this[bx],bx===bC?bz:C.clone(bz,true,true));}}bz=by=null;if(bv.length){C.each(bv,function(bF,bG){if(bG.src){if(C.ajax){C.ajax({url:bG.src,type:"GET",dataType:"script",async:false,global:false,"throws":true});}else {C.error("no ajax");}}else {C.globalEval((bG.text||bG.textContent||bG.innerHTML||"").replace(aG,""));}if(bG.parentNode){bG.parentNode.removeChild(bG);}});}}return this}});function a3(bv,bu){return bv.getElementsByTagName(bu)[0]||bv.appendChild(bv.ownerDocument.createElement(bu))}function r(bB,bv){if(bv.nodeType!==1||!C.hasData(bB)){return}var by,bx,bu,bA=C._data(bB),bz=C._data(bv,bA),bw=bA.events;if(bw){delete bz.handle;bz.events={};for(by in bw){for(bx=0,bu=bw[by].length;bx<bu;bx++){C.event.add(bv,by,bw[by][bx]);}}}if(bz.data){bz.data=C.extend({},bz.data);}}function ab(bv,bu){var bw;if(bu.nodeType!==1){return}if(bu.clearAttributes){bu.clearAttributes();}if(bu.mergeAttributes){bu.mergeAttributes(bv);}bw=bu.nodeName.toLowerCase();if(bw==="object"){if(bu.parentNode){bu.outerHTML=bv.outerHTML;}if(C.support.html5Clone&&(bv.innerHTML&&!C.trim(bu.innerHTML))){bu.innerHTML=bv.innerHTML;}}else {if(bw==="input"&&R.test(bv.type)){bu.defaultChecked=bu.checked=bv.checked;if(bu.value!==bv.value){bu.value=bv.value;}}else {if(bw==="option"){bu.selected=bv.defaultSelected;}else {if(bw==="input"||bw==="textarea"){bu.defaultValue=bv.defaultValue;}else {if(bw==="script"&&bu.text!==bv.text){bu.text=bv.text;}}}}}bu.removeAttribute(C.expando);}C.buildFragment=function(bx,by,bv){var bw,bu,bz,bA=bx[0];by=by||ak;by=!by.nodeType&&by[0]||by;by=by.ownerDocument||by;if(bx.length===1&&typeof bA==="string"&&bA.length<512&&by===ak&&bA.charAt(0)==="<"&&!I.test(bA)&&(C.support.checkClone||!o.test(bA))&&(C.support.html5Clone||!ac.test(bA))){bu=true;bw=C.fragments[bA];bz=bw!==G;}if(!bw){bw=by.createDocumentFragment();C.clean(bx,by,bw,bv);if(bu){C.fragments[bA]=bz&&bw;}}return {fragment:bw,cacheable:bu}};C.fragments={};C.each({appendTo:"append",prependTo:"prepend",insertBefore:"before",insertAfter:"after",replaceAll:"replaceWith"},function(bu,bv){C.fn[bu]=function(bw){var by,bA=0,bz=[],bC=C(bw),bx=bC.length,bB=this.length===1&&this[0].parentNode;if((bB==null||bB&&bB.nodeType===11&&bB.childNodes.length===1)&&bx===1){bC[bv](this[0]);return this}else {for(;bA<bx;bA++){by=(bA>0?this.clone(true):this).get();C(bC[bA])[bv](by);bz=bz.concat(by);}return this.pushStack(bz,bu,bC.selector)}};});function bk(bu){if(typeof bu.getElementsByTagName!=="undefined"){return bu.getElementsByTagName("*")}else {if(typeof bu.querySelectorAll!=="undefined"){return bu.querySelectorAll("*")}else {return []}}}function al(bu){if(R.test(bu.type)){bu.defaultChecked=bu.checked;}}C.extend({clone:function(by,bA,bw){var bu,bv,bx,bz;if(C.support.html5Clone||C.isXMLDoc(by)||!ac.test("<"+by.nodeName+">")){bz=by.cloneNode(true);}else {bg.innerHTML=by.outerHTML;bg.removeChild(bz=bg.firstChild);}if((!C.support.noCloneEvent||!C.support.noCloneChecked)&&(by.nodeType===1||by.nodeType===11)&&!C.isXMLDoc(by)){ab(by,bz);bu=bk(by);bv=bk(bz);for(bx=0;bu[bx];++bx){if(bv[bx]){ab(bu[bx],bv[bx]);}}}if(bA){r(by,bz);if(bw){bu=bk(by);bv=bk(bz);for(bx=0;bu[bx];++bx){r(bu[bx],bv[bx]);}}}bu=bv=null;return bz},clean:function(bH,bw,bu,bx){var bE,bD,bG,bL,bA,bK,bB,by,bv,bJ,bC,bz=bw===ak&&T,bI=[];if(!bw||typeof bw.createDocumentFragment==="undefined"){bw=ak;}for(bE=0;(bG=bH[bE])!=null;bE++){if(typeof bG==="number"){bG+="";}if(!bG){continue}if(typeof bG==="string"){if(!P.test(bG)){bG=bw.createTextNode(bG);}else {bz=bz||a(bw);bB=bw.createElement("div");bz.appendChild(bB);bG=bG.replace(L,"<$1></$2>");bL=(c.exec(bG)||["",""])[1].toLowerCase();bA=am[bL]||am._default;bK=bA[0];bB.innerHTML=bA[1]+bG+bA[2];while(bK--){bB=bB.lastChild;}if(!C.support.tbody){by=v.test(bG);bv=bL==="table"&&!by?bB.firstChild&&bB.firstChild.childNodes:bA[1]==="<table>"&&!by?bB.childNodes:[];for(bD=bv.length-1;bD>=0;--bD){if(C.nodeName(bv[bD],"tbody")&&!bv[bD].childNodes.length){bv[bD].parentNode.removeChild(bv[bD]);}}}if(!C.support.leadingWhitespace&&ah.test(bG)){bB.insertBefore(bw.createTextNode(ah.exec(bG)[0]),bB.firstChild);}bG=bB.childNodes;bB.parentNode.removeChild(bB);}}if(bG.nodeType){bI.push(bG);}else {C.merge(bI,bG);}}if(bB){bG=bB=bz=null;}if(!C.support.appendChecked){for(bE=0;(bG=bI[bE])!=null;bE++){if(C.nodeName(bG,"input")){al(bG);}else {if(typeof bG.getElementsByTagName!=="undefined"){C.grep(bG.getElementsByTagName("input"),al);}}}}if(bu){bJ=function(bM){if(!bM.type||bp.test(bM.type)){return bx?bx.push(bM.parentNode?bM.parentNode.removeChild(bM):bM):bu.appendChild(bM)}};for(bE=0;(bG=bI[bE])!=null;bE++){if(!(C.nodeName(bG,"script")&&bJ(bG))){bu.appendChild(bG);if(typeof bG.getElementsByTagName!=="undefined"){bC=C.grep(C.merge([],bG.getElementsByTagName("script")),bJ);bI.splice.apply(bI,[bE+1,0].concat(bC));bE+=bC.length;}}}}return bI},cleanData:function(bv,bD){var by,bw,bx,bC,bz=0,bE=C.expando,bu=C.cache,bA=C.support.deleteExpando,bB=C.event.special;for(;(bx=bv[bz])!=null;bz++){if(bD||C.acceptData(bx)){bw=bx[bE];by=bw&&bu[bw];if(by){if(by.events){for(bC in by.events){if(bB[bC]){C.event.remove(bx,bC);}else {C.removeEvent(bx,bC,by.handle);}}}if(bu[bw]){delete bu[bw];if(bA){delete bx[bE];}else {if(bx.removeAttribute){bx.removeAttribute(bE);}else {bx[bE]=null;}}C.deletedIds.push(bw);}}}}}});(function(){var bu,bv;C.uaMatch=function(bx){bx=bx.toLowerCase();var bw=/(chrome)[ \/]([\w.]+)/.exec(bx)||/(webkit)[ \/]([\w.]+)/.exec(bx)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(bx)||/(msie) ([\w.]+)/.exec(bx)||bx.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(bx)||[];return {browser:bw[1]||"",version:bw[2]||"0"}};bu=C.uaMatch(bt.userAgent);bv={};if(bu.browser){bv[bu.browser]=true;bv.version=bu.version;}if(bv.chrome){bv.webkit=true;}else {if(bv.webkit){bv.safari=true;}}C.browser=bv;C.sub=function(){function bx(bz,bA){return new bx.fn.init(bz,bA)}C.extend(true,bx,this);bx.superclass=this;bx.fn=bx.prototype=this();bx.fn.constructor=bx;bx.sub=this.sub;bx.fn.init=function by(bz,bA){if(bA&&bA instanceof C&&!(bA instanceof bx)){bA=bx(bA);}return C.fn.init.call(this,bz,bA,bw)};bx.fn.init.prototype=bx.fn;var bw=bx(ak);return bx};})();var Q,bc,l,ad=/alpha\([^)]*\)/i,aj=/opacity=([^)]*)/,w=/^(top|right|bottom|left)$/,ai=/^(none|table(?!-c[ea]).+)/,av=/^margin/,i=new RegExp("^("+aE+")(.*)$","i"),aV=new RegExp("^("+aE+")(?!px)[a-z%]+$","i"),E=new RegExp("^([-+])=("+aE+")","i"),J={BODY:"block"},ba={position:"absolute",visibility:"hidden",display:"block"},aL={letterSpacing:0,fontWeight:400},D=["Top","Right","Bottom","Left"],O=["Webkit","O","Moz","ms"],be=C.fn.toggle;function a2(bx,bv){if(bv in bx){return bv}var by=bv.charAt(0).toUpperCase()+bv.slice(1),bu=bv,bw=O.length;while(bw--){bv=O[bw]+by;if(bv in bx){return bv}}return bu}function ap(bv,bu){bv=bu||bv;return C.css(bv,"display")==="none"||!C.contains(bv.ownerDocument,bv)}function bb(bz,bu){var by,bA,bv=[],bw=0,bx=bz.length;for(;bw<bx;bw++){by=bz[bw];if(!by.style){continue}bv[bw]=C._data(by,"olddisplay");if(bu){if(!bv[bw]&&by.style.display==="none"){by.style.display="";}if(by.style.display===""&&ap(by)){bv[bw]=C._data(by,"olddisplay",aN(by.nodeName));}}else {bA=Q(by,"display");if(!bv[bw]&&bA!=="none"){C._data(by,"olddisplay",bA);}}}for(bw=0;bw<bx;bw++){by=bz[bw];if(!by.style){continue}if(!bu||by.style.display==="none"||by.style.display===""){by.style.display=bu?bv[bw]||"":"none";}}return bz}C.fn.extend({css:function(bu,bv){return C.access(this,function(bx,bw,by){return by!==G?C.style(bx,bw,by):C.css(bx,bw)},bu,bv,arguments.length>1)},show:function(){return bb(this,true)},hide:function(){return bb(this)},toggle:function(bw,bv){var bu=typeof bw==="boolean";if(C.isFunction(bw)&&C.isFunction(bv)){return be.apply(this,arguments)}return this.each(function(){if(bu?bw:ap(this)){C(this).show();}else {C(this).hide();}})}});C.extend({cssHooks:{opacity:{get:function(bw,bv){if(bv){var bu=Q(bw,"opacity");return bu===""?"1":bu}}}},cssNumber:{fillOpacity:true,fontWeight:true,lineHeight:true,opacity:true,orphans:true,widows:true,zIndex:true,zoom:true},cssProps:{"float":C.support.cssFloat?"cssFloat":"styleFloat"},style:function(bw,bv,bC,bx){if(!bw||bw.nodeType===3||bw.nodeType===8||!bw.style){return}var bA,bB,bD,by=C.camelCase(bv),bu=bw.style;bv=C.cssProps[by]||(C.cssProps[by]=a2(bu,by));bD=C.cssHooks[bv]||C.cssHooks[by];if(bC!==G){bB=typeof bC;if(bB==="string"&&(bA=E.exec(bC))){bC=(bA[1]+1)*bA[2]+parseFloat(C.css(bw,bv));bB="number";}if(bC==null||bB==="number"&&isNaN(bC)){return}if(bB==="number"&&!C.cssNumber[by]){bC+="px";}if(!bD||!("set" in bD)||(bC=bD.set(bw,bC,bx))!==G){try{bu[bv]=bC;}catch(bz){}}}else {if(bD&&"get" in bD&&(bA=bD.get(bw,false,bx))!==G){return bA}return bu[bv]}},css:function(bA,by,bz,bv){var bB,bx,bu,bw=C.camelCase(by);by=C.cssProps[bw]||(C.cssProps[bw]=a2(bA.style,bw));bu=C.cssHooks[by]||C.cssHooks[bw];if(bu&&"get" in bu){bB=bu.get(bA,true,bv);}if(bB===G){bB=Q(bA,by);}if(bB==="normal"&&by in aL){bB=aL[by];}if(bz||bv!==G){bx=parseFloat(bB);return bz||C.isNumeric(bx)?bx||0:bB}return bB},swap:function(by,bx,bz){var bw,bv,bu={};for(bv in bx){bu[bv]=by.style[bv];by.style[bv]=bx[bv];}bw=bz.call(by);for(bv in bx){by.style[bv]=bu[bv];}return bw}});if(bd.getComputedStyle){Q=function(bB,bv){var bu,by,bx,bA,bz=bd.getComputedStyle(bB,null),bw=bB.style;if(bz){bu=bz.getPropertyValue(bv)||bz[bv];if(bu===""&&!C.contains(bB.ownerDocument,bB)){bu=C.style(bB,bv);}if(aV.test(bu)&&av.test(bv)){by=bw.width;bx=bw.minWidth;bA=bw.maxWidth;bw.minWidth=bw.maxWidth=bw.width=bu;bu=bz.width;bw.width=by;bw.minWidth=bx;bw.maxWidth=bA;}}return bu};}else {if(ak.documentElement.currentStyle){Q=function(by,bw){var bz,bu,bv=by.currentStyle&&by.currentStyle[bw],bx=by.style;if(bv==null&&bx&&bx[bw]){bv=bx[bw];}if(aV.test(bv)&&!w.test(bw)){bz=bx.left;bu=by.runtimeStyle&&by.runtimeStyle.left;if(bu){by.runtimeStyle.left=by.currentStyle.left;}bx.left=bw==="fontSize"?"1em":bv;bv=bx.pixelLeft+"px";bx.left=bz;if(bu){by.runtimeStyle.left=bu;}}return bv===""?"auto":bv};}}function aO(bu,bw,bx){var bv=i.exec(bw);return bv?Math.max(0,bv[1]-(bx||0))+(bv[2]||"px"):bw}function aZ(bx,bv,bu,bz){var bw=bu===(bz?"border":"content")?4:bv==="width"?1:0,by=0;for(;bw<4;bw+=2){if(bu==="margin"){by+=C.css(bx,bu+D[bw],true);}if(bz){if(bu==="content"){by-=parseFloat(Q(bx,"padding"+D[bw]))||0;}if(bu!=="margin"){by-=parseFloat(Q(bx,"border"+D[bw]+"Width"))||0;}}else {by+=parseFloat(Q(bx,"padding"+D[bw]))||0;if(bu!=="padding"){by+=parseFloat(Q(bx,"border"+D[bw]+"Width"))||0;}}}return by}function Y(bx,bv,bu){var by=bv==="width"?bx.offsetWidth:bx.offsetHeight,bw=true,bz=C.support.boxSizing&&C.css(bx,"boxSizing")==="border-box";if(by<=0||by==null){by=Q(bx,bv);if(by<0||by==null){by=bx.style[bv];}if(aV.test(by)){return by}bw=bz&&(C.support.boxSizingReliable||by===bx.style[bv]);by=parseFloat(by)||0;}return (by+aZ(bx,bv,bu||(bz?"border":"content"),bw))+"px"}function aN(bw){if(J[bw]){return J[bw]}var bu=C("<"+bw+">").appendTo(ak.body),bv=bu.css("display");bu.remove();if(bv==="none"||bv===""){bc=ak.body.appendChild(bc||C.extend(ak.createElement("iframe"),{frameBorder:0,width:0,height:0}));if(!l||!bc.createElement){l=(bc.contentWindow||bc.contentDocument).document;l.write("<!doctype html><html><body>");l.close();}bu=l.body.appendChild(l.createElement(bw));bv=Q(bu,"display");ak.body.removeChild(bc);}J[bw]=bv;return bv}C.each(["height","width"],function(bv,bu){C.cssHooks[bu]={get:function(by,bx,bw){if(bx){if(by.offsetWidth===0&&ai.test(Q(by,"display"))){return C.swap(by,ba,function(){return Y(by,bu,bw)})}else {return Y(by,bu,bw)}}},set:function(bx,by,bw){return aO(bx,by,bw?aZ(bx,bu,bw,C.support.boxSizing&&C.css(bx,"boxSizing")==="border-box"):0)}};});if(!C.support.opacity){C.cssHooks.opacity={get:function(bv,bu){return aj.test((bu&&bv.currentStyle?bv.currentStyle.filter:bv.style.filter)||"")?(0.01*parseFloat(RegExp.$1))+"":bu?"1":""},set:function(by,bz){var bx=by.style,bv=by.currentStyle,bu=C.isNumeric(bz)?"alpha(opacity="+bz*100+")":"",bw=bv&&bv.filter||bx.filter||"";bx.zoom=1;if(bz>=1&&C.trim(bw.replace(ad,""))===""&&bx.removeAttribute){bx.removeAttribute("filter");if(bv&&!bv.filter){return}}bx.filter=ad.test(bw)?bw.replace(ad,bu):bw+" "+bu;}};}C(function(){if(!C.support.reliableMarginRight){C.cssHooks.marginRight={get:function(bv,bu){return C.swap(bv,{display:"inline-block"},function(){if(bu){return Q(bv,"marginRight")}})}};}if(!C.support.pixelPosition&&C.fn.position){C.each(["top","left"],function(bu,bv){C.cssHooks[bv]={get:function(by,bx){if(bx){var bw=Q(by,bv);return aV.test(bw)?C(by).position()[bv]+"px":bw}}};});}});if(C.expr&&C.expr.filters){C.expr.filters.hidden=function(bu){return (bu.offsetWidth===0&&bu.offsetHeight===0)||(!C.support.reliableHiddenOffsets&&((bu.style&&bu.style.display)||Q(bu,"display"))==="none")};C.expr.filters.visible=function(bu){return !C.expr.filters.hidden(bu)};}C.each({margin:"",padding:"",border:"Width"},function(bu,bv){C.cssHooks[bu+bv]={expand:function(by){var bx,bz=typeof by==="string"?by.split(" "):[by],bw={};for(bx=0;bx<4;bx++){bw[bu+D[bx]+bv]=bz[bx]||bz[bx-2]||bz[0];}return bw}};if(!av.test(bu)){C.cssHooks[bu+bv].set=aO;}});var g=/%20/g,af=/\[\]$/,br=/\r?\n/g,aU=/^(?:color|date|datetime|datetime-local|email|hidden|month|number|password|range|search|tel|text|time|url|week)$/i,p=/^(?:select|textarea)/i;C.fn.extend({serialize:function(){return C.param(this.serializeArray())},serializeArray:function(){return this.map(function(){return this.elements?C.makeArray(this.elements):this}).filter(function(){return this.name&&!this.disabled&&(this.checked||p.test(this.nodeName)||aU.test(this.type))}).map(function(bu,bv){var bw=C(this).val();return bw==null?null:C.isArray(bw)?C.map(bw,function(by,bx){return {name:bv.name,value:by.replace(br,"\r\n")}}):{name:bv.name,value:bw.replace(br,"\r\n")}}).get()}});C.param=function(bu,bw){var bx,bv=[],by=function(bz,bA){bA=C.isFunction(bA)?bA():(bA==null?"":bA);bv[bv.length]=encodeURIComponent(bz)+"="+encodeURIComponent(bA);};if(bw===G){bw=C.ajaxSettings&&C.ajaxSettings.traditional;}if(C.isArray(bu)||(bu.jqx&&!C.isPlainObject(bu))){C.each(bu,function(){by(this.name,this.value);});}else {for(bx in bu){s(bx,bu[bx],bw,by);}}return bv.join("&").replace(g,"+")};function s(bw,by,bv,bx){var bu;if(C.isArray(by)){C.each(by,function(bA,bz){if(bv||af.test(bw)){bx(bw,bz);}else {s(bw+"["+(typeof bz==="object"?bA:"")+"]",bz,bv,bx);}});}else {if(!bv&&C.type(by)==="object"){for(bu in by){s(bw+"["+bu+"]",by[bu],bv,bx);}}else {bx(bw,by);}}}if(C.support.ajax){C.ajaxTransport(function(bu){if(!bu.crossDomain||C.support.cors){var bv;return {send:function(bB,bw){var bz,by,bA=bu.xhr();if(bu.username){bA.open(bu.type,bu.url,bu.async,bu.username,bu.password);}else {bA.open(bu.type,bu.url,bu.async);}if(bu.xhrFields){for(by in bu.xhrFields){bA[by]=bu.xhrFields[by];}}if(bu.mimeType&&bA.overrideMimeType){bA.overrideMimeType(bu.mimeType);}if(!bu.crossDomain&&!bB["X-Requested-With"]){bB["X-Requested-With"]="XMLHttpRequest";}try{for(by in bB){bA.setRequestHeader(by,bB[by]);}}catch(bx){}bA.send((bu.hasContent&&bu.data)||null);bv=function(bK,bE){var bF,bD,bC,bI,bH;try{if(bv&&(bE||bA.readyState===4)){bv=G;if(bz){bA.onreadystatechange=C.noop;if(xhrOnUnloadAbort){delete xhrCallbacks[bz];}}if(bE){if(bA.readyState!==4){bA.abort();}}else {bF=bA.status;bC=bA.getAllResponseHeaders();bI={};bH=bA.responseXML;if(bH&&bH.documentElement){bI.xml=bH;}try{bI.text=bA.responseText;}catch(bJ){}try{bD=bA.statusText;}catch(bJ){bD="";}if(!bF&&bu.isLocal&&!bu.crossDomain){bF=bI.text?200:404;}else {if(bF===1223){bF=204;}}}}}catch(bG){if(!bE){bw(-1,bG);}}if(bI){bw(bF,bD,bI,bC);}};if(!bu.async){bv();}else {if(bA.readyState===4){setTimeout(bv,0);}else {bz=++xhrId;if(xhrOnUnloadAbort){if(!xhrCallbacks){xhrCallbacks={};C(bd).unload(xhrOnUnloadAbort);}xhrCallbacks[bz]=bv;}bA.onreadystatechange=bv;}}},abort:function(){if(bv){bv(0,1);}}}}});}var a6,a1,ar=/^(?:toggle|show|hide)$/,aM=new RegExp("^(?:([-+])=|)("+aE+")([a-z%]*)$","i"),a7=/queueHooks$/,k=[bm],H={"*":[function(bu,bB){var bx,bC,bD=this.createTween(bu,bB),by=aM.exec(bB),bz=bD.cur(),bv=+bz||0,bw=1,bA=20;if(by){bx=+by[2];bC=by[3]||(C.cssNumber[bu]?"":"px");if(bC!=="px"&&bv){bv=C.css(bD.elem,bu,true)||bx||1;do{bw=bw||".5";bv=bv/bw;C.style(bD.elem,bu,bv+bC);}while(bw!==(bw=bD.cur()/bz)&&bw!==1&&--bA)}bD.unit=bC;bD.start=bv;bD.end=by[1]?bv+(by[1]+1)*bx:bx;}return bD}]};function bl(){setTimeout(function(){a6=G;},0);return(a6=C.now())}function Z(bv,bu){C.each(bu,function(bA,by){var bz=(H[bA]||[]).concat(H["*"]),bw=0,bx=bz.length;for(;bw<bx;bw++){if(bz[bw].call(bv,bA,by)){return}}});}function bj(bw,bA,bD){var bE,bz=0,bv=k.length,bC=C.Deferred().always(function(){delete by.elem;}),by=function(){var bK=a6||bl(),bH=Math.max(0,bx.startTime+bx.duration-bK),bF=bH/bx.duration||0,bJ=1-bF,bG=0,bI=bx.tweens.length;for(;bG<bI;bG++){bx.tweens[bG].run(bJ);}bC.notifyWith(bw,[bx,bJ,bH]);if(bJ<1&&bI){return bH}else {bC.resolveWith(bw,[bx]);return false}},bx=bC.promise({elem:bw,props:C.extend({},bA),opts:C.extend(true,{specialEasing:{}},bD),originalProperties:bA,originalOptions:bD,startTime:a6||bl(),duration:bD.duration,tweens:[],createTween:function(bI,bF,bH){var bG=C.Tween(bw,bx.opts,bI,bF,bx.opts.specialEasing[bI]||bx.opts.easing);bx.tweens.push(bG);return bG},stop:function(bG){var bF=0,bH=bG?bx.tweens.length:0;for(;bF<bH;bF++){bx.tweens[bF].run(1);}if(bG){bC.resolveWith(bw,[bx,bG]);}else {bC.rejectWith(bw,[bx,bG]);}return this}}),bB=bx.props;aW(bB,bx.opts.specialEasing);for(;bz<bv;bz++){bE=k[bz].call(bx,bw,bB,bx.opts);if(bE){return bE}}Z(bx,bB);if(C.isFunction(bx.opts.start)){bx.opts.start.call(bw,bx);}C.fx.timer(C.extend(by,{anim:bx,queue:bx.opts.queue,elem:bw}));return bx.progress(bx.opts.progress).done(bx.opts.done,bx.opts.complete).fail(bx.opts.fail).always(bx.opts.always)}function aW(bx,bz){var bw,bv,bA,by,bu;for(bw in bx){bv=C.camelCase(bw);bA=bz[bv];by=bx[bw];if(C.isArray(by)){bA=by[1];by=bx[bw]=by[0];}if(bw!==bv){bx[bv]=by;delete bx[bw];}bu=C.cssHooks[bv];if(bu&&"expand" in bu){by=bu.expand(by);delete bx[bv];for(bw in by){if(!(bw in bx)){bx[bw]=by[bw];bz[bw]=bA;}}}else {bz[bv]=bA;}}}C.Animation=C.extend(bj,{tweener:function(bv,by){if(C.isFunction(bv)){by=bv;bv=["*"];}else {bv=bv.split(" ");}var bx,bu=0,bw=bv.length;for(;bu<bw;bu++){bx=bv[bu];H[bx]=H[bx]||[];H[bx].unshift(by);}},prefilter:function(bv,bu){if(bu){k.unshift(bv);}else {k.push(bv);}}});function bm(by,bE,bu){var bD,bw,bG,bx,bK,bA,bJ,bI,bH,bz=this,bv=by.style,bF={},bC=[],bB=by.nodeType&&ap(by);if(!bu.queue){bI=C._queueHooks(by,"fx");if(bI.unqueued==null){bI.unqueued=0;bH=bI.empty.fire;bI.empty.fire=function(){if(!bI.unqueued){bH();}};}bI.unqueued++;bz.always(function(){bz.always(function(){bI.unqueued--;if(!C.queue(by,"fx").length){bI.empty.fire();}});});}if(by.nodeType===1&&("height" in bE||"width" in bE)){bu.overflow=[bv.overflow,bv.overflowX,bv.overflowY];if(C.css(by,"display")==="inline"&&C.css(by,"float")==="none"){if(!C.support.inlineBlockNeedsLayout||aN(by.nodeName)==="inline"){bv.display="inline-block";}else {bv.zoom=1;}}}if(bu.overflow){bv.overflow="hidden";if(!C.support.shrinkWrapBlocks){bz.done(function(){bv.overflow=bu.overflow[0];bv.overflowX=bu.overflow[1];bv.overflowY=bu.overflow[2];});}}for(bD in bE){bG=bE[bD];if(ar.exec(bG)){delete bE[bD];bA=bA||bG==="toggle";if(bG===(bB?"hide":"show")){continue}bC.push(bD);}}bx=bC.length;if(bx){bK=C._data(by,"fxshow")||C._data(by,"fxshow",{});if("hidden" in bK){bB=bK.hidden;}if(bA){bK.hidden=!bB;}if(bB){C(by).show();}else {bz.done(function(){C(by).hide();});}bz.done(function(){var bL;C.removeData(by,"fxshow",true);for(bL in bF){C.style(by,bL,bF[bL]);}});for(bD=0;bD<bx;bD++){bw=bC[bD];bJ=bz.createTween(bw,bB?bK[bw]:0);bF[bw]=bK[bw]||C.style(by,bw);if(!(bw in bK)){bK[bw]=bJ.start;if(bB){bJ.end=bJ.start;bJ.start=bw==="width"||bw==="height"?1:0;}}}}}function u(bw,bv,by,bu,bx){return new u.prototype.init(bw,bv,by,bu,bx)}C.Tween=u;u.prototype={constructor:u,init:function(bx,bv,bz,bu,by,bw){this.elem=bx;this.prop=bz;this.easing=by||"swing";this.options=bv;this.start=this.now=this.cur();this.end=bu;this.unit=bw||(C.cssNumber[bz]?"":"px");},cur:function(){var bu=u.propHooks[this.prop];return bu&&bu.get?bu.get(this):u.propHooks._default.get(this)},run:function(bw){var bv,bu=u.propHooks[this.prop];if(this.options.duration){this.pos=bv=C.easing[this.easing](bw,this.options.duration*bw,0,1,this.options.duration);}else {this.pos=bv=bw;}this.now=(this.end-this.start)*bv+this.start;if(this.options.step){this.options.step.call(this.elem,this.now,this);}if(bu&&bu.set){bu.set(this);}else {u.propHooks._default.set(this);}return this}};u.prototype.init.prototype=u.prototype;u.propHooks={_default:{get:function(bv){var bu;if(bv.elem[bv.prop]!=null&&(!bv.elem.style||bv.elem.style[bv.prop]==null)){return bv.elem[bv.prop]}bu=C.css(bv.elem,bv.prop,false,"");return !bu||bu==="auto"?0:bu},set:function(bu){if(C.fx.step[bu.prop]){C.fx.step[bu.prop](bu);}else {if(bu.elem.style&&(bu.elem.style[C.cssProps[bu.prop]]!=null||C.cssHooks[bu.prop])){C.style(bu.elem,bu.prop,bu.now+bu.unit);}else {bu.elem[bu.prop]=bu.now;}}}}};u.propHooks.scrollTop=u.propHooks.scrollLeft={set:function(bu){if(bu.elem.nodeType&&bu.elem.parentNode){bu.elem[bu.prop]=bu.now;}}};C.each(["toggle","show","hide"],function(bv,bu){var bw=C.fn[bu];C.fn[bu]=function(bx,bz,by){return bx==null||typeof bx==="boolean"||(!bv&&C.isFunction(bx)&&C.isFunction(bz))?bw.apply(this,arguments):this.animate(aY(bu,true),bx,bz,by)};});C.fn.extend({fadeTo:function(bu,bx,bw,bv){return this.filter(ap).css("opacity",0).show().end().animate({opacity:bx},bu,bw,bv)},animate:function(bA,bx,bz,by){var bw=C.isEmptyObject(bA),bu=C.speed(bx,bz,by),bv=function(){var bB=bj(this,C.extend({},bA),bu);if(bw){bB.stop(true);}};return bw||bu.queue===false?this.each(bv):this.queue(bu.queue,bv)},stop:function(bw,bv,bu){var bx=function(by){var bz=by.stop;delete by.stop;bz(bu);};if(typeof bw!=="string"){bu=bv;bv=bw;bw=G;}if(bv&&bw!==false){this.queue(bw||"fx",[]);}return this.each(function(){var bB=true,by=bw!=null&&bw+"queueHooks",bA=C.timers,bz=C._data(this);if(by){if(bz[by]&&bz[by].stop){bx(bz[by]);}}else {for(by in bz){if(bz[by]&&bz[by].stop&&a7.test(by)){bx(bz[by]);}}}for(by=bA.length;by--;){if(bA[by].elem===this&&(bw==null||bA[by].queue===bw)){bA[by].anim.stop(bu);bB=false;bA.splice(by,1);}}if(bB||!bu){C.dequeue(this,bw);}})}});function aY(bw,by){var bx,bu={height:bw},bv=0;by=by?1:0;for(;bv<4;bv+=2-by){bx=D[bv];bu["margin"+bx]=bu["padding"+bx]=bw;}if(by){bu.opacity=bu.width=bw;}return bu}C.each({slideDown:aY("show"),slideUp:aY("hide"),slideToggle:aY("toggle"),fadeIn:{opacity:"show"},fadeOut:{opacity:"hide"},fadeToggle:{opacity:"toggle"}},function(bu,bv){C.fn[bu]=function(bw,by,bx){return this.animate(bv,bw,by,bx)};});C.speed=function(bw,bx,bv){var bu=bw&&typeof bw==="object"?C.extend({},bw):{complete:bv||!bv&&bx||C.isFunction(bw)&&bw,duration:bw,easing:bv&&bx||bx&&!C.isFunction(bx)&&bx};bu.duration=C.fx.off?0:typeof bu.duration==="number"?bu.duration:bu.duration in C.fx.speeds?C.fx.speeds[bu.duration]:C.fx.speeds._default;if(bu.queue==null||bu.queue===true){bu.queue="fx";}bu.old=bu.complete;bu.complete=function(){if(C.isFunction(bu.old)){bu.old.call(this);}if(bu.queue){C.dequeue(this,bu.queue);}};return bu};C.easing={linear:function(bu){return bu},swing:function(bu){return 0.5-Math.cos(bu*Math.PI)/2}};C.timers=[];C.fx=u.prototype.init;C.fx.tick=function(){var bw,bv=C.timers,bu=0;a6=C.now();for(;bu<bv.length;bu++){bw=bv[bu];if(!bw()&&bv[bu]===bw){bv.splice(bu--,1);}}if(!bv.length){C.fx.stop();}a6=G;};C.fx.timer=function(bu){if(bu()&&C.timers.push(bu)&&!a1){a1=setInterval(C.fx.tick,C.fx.interval);}};C.fx.interval=13;C.fx.stop=function(){clearInterval(a1);a1=null;};C.fx.speeds={slow:600,fast:200,_default:400};C.fx.step={};if(C.expr&&C.expr.filters){C.expr.filters.animated=function(bu){return C.grep(C.timers,function(bv){return bu===bv.elem}).length};}var V=/^(?:body|html)$/i;C.fn.offset=function(bE){if(arguments.length){return bE===G?this:this.each(function(bF){C.offset.setOffset(this,bE,bF);})}var bv,bA,bB,by,bC,bu,bx,bz={top:0,left:0},bw=this[0],bD=bw&&bw.ownerDocument;if(!bD){return}if((bA=bD.body)===bw){return C.offset.bodyOffset(bw)}bv=bD.documentElement;if(!C.contains(bv,bw)){return bz}if(typeof bw.getBoundingClientRect!=="undefined"){bz=bw.getBoundingClientRect();}bB=aC(bD);by=bv.clientTop||bA.clientTop||0;bC=bv.clientLeft||bA.clientLeft||0;bu=bB.pageYOffset||bv.scrollTop;bx=bB.pageXOffset||bv.scrollLeft;return {top:bz.top+bu-by,left:bz.left+bx-bC}};C.offset={bodyOffset:function(bu){var bw=bu.offsetTop,bv=bu.offsetLeft;if(C.support.doesNotIncludeMarginInBodyOffset){bw+=parseFloat(C.css(bu,"marginTop"))||0;bv+=parseFloat(C.css(bu,"marginLeft"))||0;}return {top:bw,left:bv}},setOffset:function(bx,bG,bA){var bB=C.css(bx,"position");if(bB==="static"){bx.style.position="relative";}var bz=C(bx),bv=bz.offset(),bu=C.css(bx,"top"),bE=C.css(bx,"left"),bF=(bB==="absolute"||bB==="fixed")&&C.inArray("auto",[bu,bE])>-1,bD={},bC={},bw,by;if(bF){bC=bz.position();bw=bC.top;by=bC.left;}else {bw=parseFloat(bu)||0;by=parseFloat(bE)||0;}if(C.isFunction(bG)){bG=bG.call(bx,bA,bv);}if(bG.top!=null){bD.top=(bG.top-bv.top)+bw;}if(bG.left!=null){bD.left=(bG.left-bv.left)+by;}if("using" in bG){bG.using.call(bx,bD);}else {bz.css(bD);}}};C.fn.extend({isRendered:function(){var bu=this[0];if(bu.parentNode==null||(bu.offsetWidth===0||bu.offsetHeight===0)){return false}return true},getSizeFromStyle:function(){var bx=null;var bu=null;var bw=this[0];var bv;if(bw.style.width){bx=bw.style.width;}if(bw.style.height){bu=bw.style.height;}if(bd.getComputedStyle){bv=getComputedStyle(bw,null);}else {bv=bw.currentStyle;}if(bv){if(bv.width){bx=bv.width;}if(bv.height){bu=bv.height;}}if(bx==="0px"){bx=0;}if(bu==="0px"){bu=0;}if(bx===null){bx=0;}if(bu===null){bu=0;}return {width:bx,height:bu}},initAnimate:function(){},sizeStyleChanged:function(bx){var bw=this;var by;var bu=function(bz){var bA=by;if(bz&&bz[0]&&bz[0].attributeName==="style"&&bz[0].type==="attributes"){if(bA.element.offsetWidth!==bA.offsetWidth||bA.element.offsetHeight!==bA.offsetHeight){bA.offsetWidth=bA.element.offsetWidth;bA.offsetHeight=bA.element.offsetHeight;if(bw.isRendered()){bA.callback();}}}};by={element:bw[0],offsetWidth:bw[0].offsetWidth,offsetHeight:bw[0].offsetHeight,callback:bx};try{if(!bw.elementStyleObserver){bw.elementStyleObserver=new MutationObserver(bu);bw.elementStyleObserver.observe(bw[0],{attributes:true,childList:false,characterData:false});}}catch(bv){}},position:function(){if(!this[0]){return}var bw=this[0],bv=this.offsetParent(),bx=this.offset(),bu=V.test(bv[0].nodeName)?{top:0,left:0}:bv.offset();bx.top-=parseFloat(C.css(bw,"marginTop"))||0;bx.left-=parseFloat(C.css(bw,"marginLeft"))||0;bu.top+=parseFloat(C.css(bv[0],"borderTopWidth"))||0;bu.left+=parseFloat(C.css(bv[0],"borderLeftWidth"))||0;return {top:bx.top-bu.top,left:bx.left-bu.left}},offsetParent:function(){return this.map(function(){var bu=this.offsetParent||ak.body;while(bu&&(!V.test(bu.nodeName)&&C.css(bu,"position")==="static")){bu=bu.offsetParent;}return bu||ak.body})}});C.each({scrollLeft:"pageXOffset",scrollTop:"pageYOffset"},function(bw,bv){var bu=/Y/.test(bv);C.fn[bw]=function(bx){return C.access(this,function(by,bB,bA){var bz=aC(by);if(bA===G){return bz?(bv in bz)?bz[bv]:bz.document.documentElement[bB]:by[bB]}if(bz){bz.scrollTo(!bu?bA:C(bz).scrollLeft(),bu?bA:C(bz).scrollTop());}else {by[bB]=bA;}},bw,bx,arguments.length,null)};});function aC(bu){return C.isWindow(bu)?bu:bu.nodeType===9?bu.defaultView||bu.parentWindow:false}C.each({Height:"height",Width:"width"},function(bu,bv){C.each({padding:"inner"+bu,content:bv,"":"outer"+bu},function(bw,bx){C.fn[bx]=function(bB,bA){var bz=arguments.length&&(bw||typeof bB!=="boolean"),by=bw||(bB===true||bA===true?"margin":"border");return C.access(this,function(bD,bC,bE){var bF;if(C.isWindow(bD)){return bD.document.documentElement["client"+bu]}if(bD.nodeType===9){bF=bD.documentElement;return Math.max(bD.body["scroll"+bu],bF["scroll"+bu],bD.body["offset"+bu],bF["offset"+bu],bF["client"+bu])}return bE===G?C.css(bD,bC,bE,by):C.style(bD,bC,bE,by)},bv,bz?bB:G,bz,null)};});});bd.JQXLite=bd.jqxHelper=C;if(typeof define==="function"&&define.amd&&define.amd.JQXLite){define("jqx",[],function(){return C});}})(window);}(function(a){if(a.jqxCore){a.$$=a.minQuery=a.JQXLite;if(!a.$){a.$=a.minQuery;}return}if(a.jQuery){a.minQuery=a.JQXLite=a.jQuery;return}if(!a.$){a.$=a.minQuery=a.JQXLite;}else {a.minQuery=a.JQXLite=a.$;}})(window);JQXLite.generateID=function(){var a=function(){return (((1+Math.random())*65536)|0).toString(16).substring(1)};var b="";do{b="jqx"+a()+a()+a();}while($("#"+b).length>0);return b};var jqxBaseFramework$1=window.jqxBaseFramework=window.minQuery||window.jQuery;(function(b){b.jqx=b.jqx||{};window.jqx=b.jqx;var a={createInstance:function(c,e,g){if(e=="jqxDataAdapter"){var f=g[0];var d=g[1]||{};return new b.jqx.dataAdapter(f,d)}b(c)[e](g||{});return b(c)[e]("getInstance")}};window.jqwidgets=a;b.jqx.define=function(c,d,e){c[d]=function(){if(this.baseType){this.base=new c[this.baseType]();this.base.defineInstance();}this.defineInstance();this.metaInfo();};c[d].prototype.defineInstance=function(){};c[d].prototype.metaInfo=function(){};c[d].prototype.base=null;c[d].prototype.baseType=undefined;if(e&&c[e]){c[d].prototype.baseType=e;}};b.jqx.invoke=function(f,e){if(e.length==0){return}var g=typeof(e)==Array||e.length>0?e[0]:e;var d=typeof(e)==Array||e.length>1?Array.prototype.slice.call(e,1):b({}).toArray();while(f[g]==undefined&&f.base!=null){if(f[g]!=undefined&&b.isFunction(f[g])){return f[g].apply(f,d)}if(typeof g=="string"){var c=g.toLowerCase();if(f[c]!=undefined&&b.isFunction(f[c])){return f[c].apply(f,d)}}f=f.base;}if(f[g]!=undefined&&b.isFunction(f[g])){return f[g].apply(f,d)}if(typeof g=="string"){var c=g.toLowerCase();if(f[c]!=undefined&&b.isFunction(f[c])){return f[c].apply(f,d)}}return};b.jqx.getByPriority=function(c){var e=undefined;for(var d=0;d<c.length&&e==undefined;d++){if(e==undefined&&c[d]!=undefined){e=c[d];}}return e};b.jqx.hasProperty=function(d,c){if(typeof(c)=="object"){for(var f in c){var e=d;while(e){if(e.hasOwnProperty(f)){return true}if(e.hasOwnProperty(f.toLowerCase())){return true}e=e.base;}return false}}else {while(d){if(d.hasOwnProperty(c)){return true}if(d.hasOwnProperty(c.toLowerCase())){return true}d=d.base;}}return false};b.jqx.hasFunction=function(f,e){if(e.length==0){return false}if(f==undefined){return false}var g=typeof(e)==Array||e.length>0?e[0]:e;typeof(e)==Array||e.length>1?Array.prototype.slice.call(e,1):{};while(f[g]==undefined&&f.base!=null){if(f[g]&&b.isFunction(f[g])){return true}if(typeof g=="string"){var c=g.toLowerCase();if(f[c]&&b.isFunction(f[c])){return true}}f=f.base;}if(f[g]&&b.isFunction(f[g])){return true}if(typeof g=="string"){var c=g.toLowerCase();if(f[c]&&b.isFunction(f[c])){return true}}return false};b.jqx.isPropertySetter=function(d,c){if(c.length==1&&typeof(c[0])=="object"){return true}if(c.length==2&&typeof(c[0])=="string"&&!b.jqx.hasFunction(d,c)){return true}return false};b.jqx.validatePropertySetter=function(g,e,c){if(!b.jqx.propertySetterValidation){return true}if(e.length==1&&typeof(e[0])=="object"){for(var f in e[0]){var h=g;while(!h.hasOwnProperty(f)&&h.base){h=h.base;}if(!h||!h.hasOwnProperty(f)){if(!c){var d=h.hasOwnProperty(f.toString().toLowerCase());if(!d){throw "Invalid property: "+f}else {return true}}return false}}return true}if(e.length!=2){if(!c){throw "Invalid property: "+e.length>=0?e[0]:""}return false}while(!g.hasOwnProperty(e[0])&&g.base){g=g.base;}if(!g||!g.hasOwnProperty(e[0])){if(!c){throw "Invalid property: "+e[0]}return false}return true};if(!Object.keys){Object.keys=(function(){var e=Object.prototype.hasOwnProperty,f=!({toString:null}).propertyIsEnumerable("toString"),d=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],c=d.length;return function(j){if(typeof j!=="object"&&(typeof j!=="function"||j===null)){throw new TypeError("Object.keys called on non-object")}var g=[],k,h;for(k in j){if(e.call(j,k)){g.push(k);}}if(f){for(h=0;h<c;h++){if(e.call(j,d[h])){g.push(d[h]);}}}return g}}());}b.jqx.set=function(f,i){var d=0;if(i.length==1&&typeof(i[0])=="object"){if(f.isInitialized&&Object.keys&&Object.keys(i[0]).length>1){var g=!f.base?f.element:f.base.element;var c=b.data(g,f.widgetName).initArgs;if(c&&JSON&&JSON.stringify&&i[0]&&c[0]){try{if(JSON.stringify(i[0])==JSON.stringify(c[0])){var h=true;b.each(i[0],function(l,m){if(f[l]!=m){h=false;return false}});if(h){return}}}catch(e){}}f.batchUpdate=i[0];var j={};var k={};b.each(i[0],function(l,m){var n=f;while(!n.hasOwnProperty(l)&&n.base!=null){n=n.base;}if(n.hasOwnProperty(l)){if(f[l]!=m){j[l]=f[l];k[l]=m;d++;}}else {if(n.hasOwnProperty(l.toLowerCase())){if(f[l.toLowerCase()]!=m){j[l.toLowerCase()]=f[l.toLowerCase()];k[l.toLowerCase()]=m;d++;}}}});if(d<2){f.batchUpdate=null;}}b.each(i[0],function(l,m){var n=f;while(!n.hasOwnProperty(l)&&n.base!=null){n=n.base;}if(n.hasOwnProperty(l)){b.jqx.setvalueraiseevent(n,l,m);}else {if(n.hasOwnProperty(l.toLowerCase())){b.jqx.setvalueraiseevent(n,l.toLowerCase(),m);}else {if(b.jqx.propertySetterValidation){throw "jqxCore: invalid property '"+l+"'"}}}});if(f.batchUpdate!=null){f.batchUpdate=null;if(f.propertiesChangedHandler&&d>1){f.propertiesChangedHandler(f,j,k);}}}else {if(i.length==2){while(!f.hasOwnProperty(i[0])&&f.base){f=f.base;}if(f.hasOwnProperty(i[0])){b.jqx.setvalueraiseevent(f,i[0],i[1]);}else {if(f.hasOwnProperty(i[0].toLowerCase())){b.jqx.setvalueraiseevent(f,i[0].toLowerCase(),i[1]);}else {if(b.jqx.propertySetterValidation){throw "jqxCore: invalid property '"+i[0]+"'"}}}}}};b.jqx.setvalueraiseevent=function(d,e,f){var c=d[e];d[e]=f;if(!d.isInitialized){return}if(d.propertyChangedHandler!=undefined){d.propertyChangedHandler(d,e,c,f);}if(d.propertyChangeMap!=undefined&&d.propertyChangeMap[e]!=undefined){d.propertyChangeMap[e](d,e,c,f);}};b.jqx.get=function(f,e){if(e==undefined||e==null){return undefined}if(f.propertyMap){var d=f.propertyMap(e);if(d!=null){return d}}if(f.hasOwnProperty(e)){return f[e]}if(f.hasOwnProperty(e.toLowerCase())){return f[e.toLowerCase()]}var c=undefined;if(typeof(e)==Array){if(e.length!=1){return undefined}c=e[0];}else {if(typeof(e)=="string"){c=e;}}while(!f.hasOwnProperty(c)&&f.base){f=f.base;}if(f){return f[c]}return undefined};b.jqx.serialize=function(f){var c="";if(b.isArray(f)){c="[";for(var e=0;e<f.length;e++){if(e>0){c+=", ";}c+=b.jqx.serialize(f[e]);}c+="]";}else {if(typeof(f)=="object"){c="{";var d=0;for(var e in f){if(d++>0){c+=", ";}c+=e+": "+b.jqx.serialize(f[e]);}c+="}";}else {c=f.toString();}}return c};b.jqx.propertySetterValidation=true;b.jqx.jqxWidgetProxy=function(h,d,c){b(d);var g=b.data(d,h);if(g==undefined){return undefined}var f=g.instance;if(b.jqx.hasFunction(f,c)){return b.jqx.invoke(f,c)}if(b.jqx.isPropertySetter(f,c)){if(b.jqx.validatePropertySetter(f,c)){b.jqx.set(f,c);return undefined}}else {if(typeof(c)=="object"&&c.length==0){return}else {if(typeof(c)=="object"&&c.length==1&&b.jqx.hasProperty(f,c[0])){return b.jqx.get(f,c[0])}else {if(typeof(c)=="string"&&b.jqx.hasProperty(f,c[0])){return b.jqx.get(f,c)}}}}throw "jqxCore: Invalid parameter '"+b.jqx.serialize(c)+"' does not exist."};b.jqx.applyWidget=function(d,f,l,m){var h=false;try{h=window.MSApp!=undefined;}catch(g){}var n=b(d);if(!m){m=new b.jqx["_"+f]();}else {m.host=n;m.element=d;}if(d.id==""){d.id=b.jqx.utilities.createId();}var k={host:n,element:d,instance:m,initArgs:l};m.widgetName=f;b.data(d,f,k);b.data(d,"jqxWidget",k.instance);var j=new Array();var m=k.instance;while(m){m.isInitialized=false;j.push(m);m=m.base;}j.reverse();j[0].theme=b.jqx.theme||"";b.jqx.jqxWidgetProxy(f,d,l);for(var c in j){m=j[c];if(c==0){m.host=n;m.element=d;m.WinJS=h;}if(m!=undefined){if(m.definedInstance){m.definedInstance();}if(m.createInstance!=null){if(h){MSApp.execUnsafeLocalFunction(function(){m.createInstance(l);});}else {m.createInstance(l);}}}}for(var c in j){if(j[c]!=undefined){j[c].isInitialized=true;}}if(h){MSApp.execUnsafeLocalFunction(function(){k.instance.refresh(true);});}else {k.instance.refresh(true);}};b.jqx.jqxWidget=function(c,d,g){var j=false;try{var l=Array.prototype.slice.call(g,0);}catch(i){var l="";}try{j=window.MSApp!=undefined;}catch(i){}var h=c;var m="";if(d){m="_"+d;}b.jqx.define(b.jqx,"_"+h,m);var k=new Array();if(!window[h]){var f=function(n){if(n==null){return ""}var e=b.type(n);switch(e){case"string":case"number":case"date":case"boolean":case"bool":if(n===null){return ""}return n.toString()}var o="";b.each(n,function(q,r){var t=r;if(q>0){o+=", ";}o+="[";var p=0;if(b.type(t)=="object"){for(var s in t){if(p>0){o+=", ";}o+="{"+s+":"+t[s]+"}";p++;}}else {if(p>0){o+=", ";}o+="{"+q+":"+t+"}";p++;}o+="]";});return o};a[h]=window[h]=function(e,s){var n=[];if(!s){s={};}n.push(s);var o=e;if(b.type(o)==="object"&&e[0]){o=e[0].id;if(o===""){o=e[0].id=b.jqx.utilities.createId();}}else {if(b.type(e)==="object"&&e&&e.nodeName){o=e.id;if(o===""){o=e.id=b.jqx.utilities.createId();}}}if(window.jqxWidgets&&window.jqxWidgets[o]){if(s){b.each(window.jqxWidgets[o],function(t){var u=b(this.element).data();if(u&&u.jqxWidget){b(this.element)[h](s);}});}if(window.jqxWidgets[o].length==1){var q=b(window.jqxWidgets[o][0].widgetInstance.element).data();if(q&&q.jqxWidget){return window.jqxWidgets[o][0]}}var q=b(window.jqxWidgets[o][0].widgetInstance.element).data();if(q&&q.jqxWidget){return window.jqxWidgets[o]}}var p=b(e);if(p.length===0){p=b("<div></div>");if(h==="jqxInput"||h==="jqxPasswordInput"||h==="jqxMaskedInput"){p=b("<input/>");}if(h==="jqxTextArea"){p=b("<textarea></textarea>");}if(h==="jqxButton"||h==="jqxRepeatButton"||h==="jqxToggleButton"){p=b("<button/>");}if(h==="jqxSplitter"){p=b("<div><div>Panel 1</div><div>Panel 2</div></div>");}if(h==="jqxTabs"){p=b("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div>Content 1</div><div>Content 2</div></div>");}if(h==="jqxRibbon"){p=b("<div><ul><li>Tab 1</li><li>Tab 2</li></ul><div><div>Content 1</div><div>Content 2</div></div></div>");}if(h==="jqxDocking"){p=b("<div><div><div><div>Title 1</div><div>Content 1</div></div></div></div>");}if(h==="jqxWindow"){p=b("<div><div>Title 1</div><div>Content 1</div></div>");}}var r=[];b.each(p,function(w){var y=p[w];b.jqx.applyWidget(y,h,n,undefined);if(!k[h]){var u=b.data(y,"jqxWidget");var x=b.jqx["_"+h].prototype.defineInstance();if(b.jqx["_"+h].prototype.metaInfo){b.jqx["_"+h].prototype.metaInfo();}if(h=="jqxDockingLayout"){x=b.extend(x,b.jqx._jqxLayout.prototype.defineInstance());}if(h=="jqxToggleButton"||h=="jqxRepeatButton"){x=b.extend(x,b.jqx._jqxButton.prototype.defineInstance());}if(h=="jqxTreeGrid"){x=b.extend(x,b.jqx._jqxDataTable.prototype.defineInstance());}var t=function(A){var z=b.data(A,"jqxWidget");this.widgetInstance=z;var B=b.extend(this,z);B.on=B.addEventListener=function(D,E){B.addHandler(!B.base?B.host:B.base.host,D,E);};B.off=B.removeEventListener=function(D){B.removeHandler(!B.base?B.host:B.base.host,D);};for(var C in z){if(b.type(z[C])=="function"){B[C]=b.proxy(z[C],z);}}return B};k[h]=t;b.each(x,function(A,z){Object.defineProperty(t.prototype,A,{get:function(){if(this.widgetInstance){return this.widgetInstance[A]}return z},set:function(H){if(this.widgetInstance&&(this.widgetInstance[A]!=H||A==="width"||A==="height")){var F=this.widgetInstance[A];var E=H;var D=b.type(F);var B=b.type(E);var G=false;if(D!=B||A==="source"||A==="width"||A==="height"){G=true;}if(G||(f(F)!=f(E))){var C={};C[A]=H;if(this.widgetInstance.host){this.widgetInstance.host[h](C);}else {this.widgetInstance.base.host[h](C);}this.widgetInstance[A]=H;if(this.widgetInstance.propertyUpdated){this.widgetInstance.propertyUpdated(A,F,H);}}}}});});}var u=new k[h](y);r.push(u);if(!window.jqxWidgets){window.jqxWidgets=new Array();}if(!window.jqxWidgets[o]){window.jqxWidgets[o]=new Array();}window.jqxWidgets[o].push(u);});if(r.length===1){return r[0]}return r};}b.fn[h]=function(){var e=Array.prototype.slice.call(arguments,0);if(e.length==0||(e.length==1&&typeof(e[0])=="object")){if(this.length==0){if(this.selector){throw new Error("Invalid Selector - "+this.selector+"! Please, check whether the used ID or CSS Class name is correct.")}else {throw new Error("Invalid Selector! Please, check whether the used ID or CSS Class name is correct.")}}return this.each(function(){b(this);var p=this;var r=b.data(p,h);if(r==null){b.jqx.applyWidget(p,h,e,undefined);}else {b.jqx.jqxWidgetProxy(h,this,e);}})}else {if(this.length==0){if(this.selector){throw new Error("Invalid Selector - "+this.selector+"! Please, check whether the used ID or CSS Class name is correct.")}else {throw new Error("Invalid Selector! Please, check whether the used ID or CSS Class name is correct.")}}var o=null;var n=0;this.each(function(){var p=b.jqx.jqxWidgetProxy(h,this,e);if(n==0){o=p;n++;}else {if(n==1){var q=[];q.push(o);o=q;}o.push(p);}});}return o};try{b.extend(b.jqx["_"+h].prototype,Array.prototype.slice.call(g,0)[0]);}catch(i){}b.extend(b.jqx["_"+h].prototype,{toThemeProperty:function(e,n){return b.jqx.toThemeProperty(this,e,n)},isMaterialized:function(){if(!this.theme){return false}if(this.theme==="light"){return true}if(this.theme==="dark"){return true}if(this.theme==="deepblue"){return true}if(this.theme.indexOf("material")>=0){return true}},isModern:function(){if(!this.theme){return false}if(this.theme.indexOf("light")>=0){return true}if(this.theme==="dark"){return true}},_addBarAndLabel:function(p){var o=this;var e=b("<label></label");e[0].innerHTML=this.placeHolder;e.addClass(o.toThemeProperty("jqx-input-label"));p.after(e);o.label=e;var n=b("<span></span>");p.after(n);n.addClass(o.toThemeProperty("jqx-input-bar"));o.bar=n;o.bar.css("top",this.host.height());}});b.jqx["_"+h].prototype.refresh=function(){if(this.base){this.base.refresh(true);}};b.jqx["_"+h].prototype.createInstance=function(){};b.jqx.isPassiveSupported=function(){var o=this;if(o.supportsPassive!==undefined){return o.supportsPassive}o.supportsPassive=false;try{var n=Object.defineProperty({},"passive",{get:function(){o.supportsPassive=true;}});window.addEventListener("testPassive",null,n);window.removeEventListener("testPassive",null,n);}catch(p){}return o.supportsPassive};b.jqx["_"+h].prototype.addEventHandler=function(n,e){if(this.base){this.base.host.on(n,e);}else {this.host.on(n,e);}};b.jqx["_"+h].prototype.removeEventHandler=function(n,e){if(this.base){this.base.host.off(n);}else {this.host.off(n);}};b.jqx["_"+h].prototype.applyTo=function(o,n){if(!(n instanceof Array)){var e=[];e.push(n);n=e;}b.jqx.applyWidget(o,h,n,this);};b.jqx["_"+h].prototype.getInstance=function(){return this};b.jqx["_"+h].prototype.propertyChangeMap={};b.jqx["_"+h].prototype.addHandler=function(p,e,n,o){b.jqx.addHandler(b(p),e,n,o);};b.jqx["_"+h].prototype.removeHandler=function(o,e,n){b.jqx.removeHandler(b(o),e,n);};b.jqx["_"+h].prototype.setOptions=function(){if(!this.host||!this.host.length||this.host.length!=1){return}return b.jqx.jqxWidgetProxy(h,this.host[0],arguments)};};b.jqx.toThemeProperty=function(d,e,j){if(d.theme==""){return e}var h=e.split(" ");var c="";for(var g=0;g<h.length;g++){if(g>0){c+=" ";}var f=h[g];if(j!=null&&j){c+=f+"-"+d.theme;}else {c+=f+" "+f+"-"+d.theme;}}return c};b.jqx.addHandler=function(h,j,f,g){var d=j.split(" ");for(var c=0;c<d.length;c++){var e=d[c];if(window.addEventListener&&h[0]){switch(e){case"mousewheel":if(b.jqx.browser.mozilla){h[0].addEventListener("DOMMouseScroll",f,b.jqx.isPassiveSupported()?{passive:false}:false);}else {h[0].addEventListener("mousewheel",f,b.jqx.isPassiveSupported()?{passive:false}:false);}continue;case"mousemove":if(!g){h[0].addEventListener("mousemove",f,false);continue}break;case"touchmove":if(!g){h[0].addEventListener("touchmove",f,false);continue}else {if(g&&g.passive){h[0].addEventListener("touchmove",f,g);continue}}break}}if(g==undefined||g==null){if(h.on){h.on(e,f);}else {h.bind(e,f);}}else {if(h.on){h.on(e,g,f);}else {h.bind(e,g,f);}}}};b.jqx.removeHandler=function(g,h,f){if(!h){if(g.off){g.off();}else {g.unbind();}return}var d=h.split(" ");for(var c=0;c<d.length;c++){var e=d[c];if(window.removeEventListener){switch(e){case"mousewheel":if(b.jqx.browser.mozilla){g[0].removeEventListener("DOMMouseScroll",f,false);}else {g[0].removeEventListener("mousewheel",f,false);}continue;case"mousemove":if(f){g[0].removeEventListener("mousemove",f,false);continue}break;case"touchmove":if(f){g[0].removeEventListener("touchmove",f,false);continue}break}}if(e==undefined){if(g.off){g.off();}else {g.unbind();}continue}if(f==undefined){if(g.off){g.off(e);}else {g.unbind(e);}}else {if(g.off){g.off(e,f);}else {g.unbind(e,f);}}}};b.jqx.credits=b.jqx.credits||"";b.jqx.theme=b.jqx.theme||"";b.jqx.scrollAnimation=b.jqx.scrollAnimation||false;b.jqx.resizeDelay=b.jqx.resizeDelay||10;b.jqx.ready=function(){b(window).trigger("jqxReady");};b.jqx.init=function(){b.each(arguments[0],function(c,d){if(c=="theme"){b.jqx.theme=d;}if(c=="scrollBarSize"){b.jqx.utilities.scrollBarSize=d;}if(c=="touchScrollBarSize"){b.jqx.utilities.touchScrollBarSize=d;}if(c=="scrollBarButtonsVisibility"){b.jqx.utilities.scrollBarButtonsVisibility=d;}});};b.jqx.utilities=b.jqx.utilities||{};b.extend(b.jqx.utilities,{scrollBarSize:13,touchScrollBarSize:8,scrollBarButtonsVisibility:"visible",createId:function(){var c=function(){return (((1+Math.random())*65536)|0).toString(16).substring(1)};return "jqxWidget"+c()+c()+c()},setTheme:function(g,h,f){if(typeof f==="undefined"){return}if(!f[0].className.split){return}if(g===undefined){g="";}if(h===undefined){h="";}var j=f[0].className.split(" "),c=[],k=[],e=f.children();for(var d=0;d<j.length;d+=1){if(j[d].indexOf(g)>=0){if(g.length>0){c.push(j[d]);k.push(j[d].replace(g,h));}else {k.push(j[d].replace("-"+h,"")+"-"+h);}}}this._removeOldClasses(c,f);this._addNewClasses(k,f);for(var d=0;d<e.length;d+=1){this.setTheme(g,h,b(e[d]));}},_removeOldClasses:function(e,d){for(var c=0;c<e.length;c+=1){d.removeClass(e[c]);}},_addNewClasses:function(e,d){for(var c=0;c<e.length;c+=1){d.addClass(e[c]);}},getOffset:function(c){var e=b.jqx.mobile.getLeftPos(c[0]);var d=b.jqx.mobile.getTopPos(c[0]);return {top:d,left:e}},resize:function(h,t,q,p){if(p===undefined){p=true;}var m=-1;var l=this;var e=function(v){if(!l.hiddenWidgets){return -1}var w=-1;for(var u=0;u<l.hiddenWidgets.length;u++){if(v.id){if(l.hiddenWidgets[u].id==v.id){w=u;break}}else {if(l.hiddenWidgets[u].id==v[0].id){w=u;break}}}return w};if(this.resizeHandlers){for(var j=0;j<this.resizeHandlers.length;j++){if(h.id){if(this.resizeHandlers[j].id==h.id){m=j;break}}else {if(this.resizeHandlers[j].id==h[0].id){m=j;break}}}if(q===true){if(m!=-1){this.resizeHandlers.splice(m,1);if(this.watchedElementData&&this.watchedElementData.length>0){this.watchedElementData.splice(m,1);}}if(this.resizeHandlers.length==0){var o=b(window);if(o.off){o.off("resize.jqx");o.off("orientationchange.jqx");o.off("orientationchanged.jqx");}else {o.unbind("resize.jqx");o.unbind("orientationchange.jqx");o.unbind("orientationchanged.jqx");}this.resizeHandlers=null;}var c=e(h);if(c!=-1&&this.hiddenWidgets){this.hiddenWidgets.splice(c,1);}return}}else {if(q===true){var c=e(h);if(c!=-1&&this.hiddenWidgets){this.hiddenWidgets.splice(c,1);}return}}var l=this;var n=function(w,F){if(!l.resizeHandlers){return}var G=function(J){var i=-1;var K=J.parentNode;while(K){i++;K=K.parentNode;}return i};var v=function(L,J){if(!L.widget||!J.widget){return 0}var K=G(L.widget[0]);var i=G(J.widget[0]);try{if(K<i){return -1}if(K>i){return 1}}catch(M){}return 0};var x=function(J){if(l.hiddenWidgets.length>0){l.hiddenWidgets.sort(v);var i=function(){var L=false;var N=new Array();for(var M=0;M<l.hiddenWidgets.length;M++){var K=l.hiddenWidgets[M];if(b.jqx.isHidden(K.widget)){L=true;N.push(K);}else {if(K.callback){K.callback(F);}}}l.hiddenWidgets=N;if(!L){clearInterval(l.__resizeInterval);}};if(J==false){i();if(l.__resizeInterval){clearInterval(l.__resizeInterval);}return}if(l.__resizeInterval){clearInterval(l.__resizeInterval);}l.__resizeInterval=setInterval(function(){i();},100);}};if(l.hiddenWidgets&&l.hiddenWidgets.length>0){x(false);}l.hiddenWidgets=new Array();l.resizeHandlers.sort(v);for(var C=0;C<l.resizeHandlers.length;C++){var I=l.resizeHandlers[C];var E=I.widget;var B=I.data;if(!B){continue}if(!B.jqxWidget){continue}var u=B.jqxWidget.width;var H=B.jqxWidget.height;if(B.jqxWidget.base){if(u==undefined){u=B.jqxWidget.base.width;}if(H==undefined){H=B.jqxWidget.base.height;}}if(u===undefined&&H===undefined){u=B.jqxWidget.element.style.width;H=B.jqxWidget.element.style.height;}var D=false;if(u!=null&&u.toString().indexOf("%")!=-1){D=true;}if(H!=null&&H.toString().indexOf("%")!=-1){D=true;}if(b.jqx.isHidden(E)){if(e(E)===-1){if(D||w===true){if(I.data.nestedWidget!==true){l.hiddenWidgets.push(I);}}}}else {if(w===undefined||w!==true){if(D){I.callback(F);if(l.watchedElementData){for(var z=0;z<l.watchedElementData.length;z++){if(l.watchedElementData[z].element==B.jqxWidget.element){l.watchedElementData[z].offsetWidth=B.jqxWidget.element.offsetWidth;l.watchedElementData[z].offsetHeight=B.jqxWidget.element.offsetHeight;break}}}if(l.hiddenWidgets.indexOf(I)>=0){l.hiddenWidgets.splice(l.hiddenWidgets.indexOf(I),1);}}if(B.jqxWidget.element){var y=B.jqxWidget.element.className;if(y.indexOf("dropdownlist")>=0||y.indexOf("datetimeinput")>=0||y.indexOf("combobox")>=0||y.indexOf("menu")>=0){if(B.jqxWidget.isOpened){var A=B.jqxWidget.isOpened();if(A){if(F&&F=="resize"&&b.jqx.mobile.isTouchDevice()){continue}B.jqxWidget.close();}}}}}}}x();};if(!this.resizeHandlers){this.resizeHandlers=new Array();var o=b(window);if(o.on){this._resizeTimer=null;this._initResize=null;o.on("resize.jqx",function(i){if(l._resizeTimer!=undefined){clearTimeout(l._resizeTimer);}if(!l._initResize){l._initResize=true;n(null,"resize");}else {l._resizeTimer=setTimeout(function(){n(null,"resize");},b.jqx.resizeDelay);}});o.on("orientationchange.jqx",function(i){n(null,"orientationchange");});o.on("orientationchanged.jqx",function(i){n(null,"orientationchange");});}else {o.bind("resize.jqx",function(i){n(null,"orientationchange");});o.bind("orientationchange.jqx",function(i){n(null,"orientationchange");});o.bind("orientationchanged.jqx",function(i){n(null,"orientationchange");});}}var f=h.data();if(p){if(m===-1){this.resizeHandlers.push({id:h[0].id,widget:h,callback:t,data:f});}}try{var d=f.jqxWidget.width;var s=f.jqxWidget.height;if(f.jqxWidget.base){if(d==undefined){d=f.jqxWidget.base.width;}if(s==undefined){s=f.jqxWidget.base.height;}}if(d===undefined&&s===undefined){d=f.jqxWidget.element.style.width;s=f.jqxWidget.element.style.height;}var k=false;if(d!=null&&d.toString().indexOf("%")!=-1){k=true;}if(s!=null&&s.toString().indexOf("%")!=-1){k=true;}if(k){if(!this.watchedElementData){this.watchedElementData=[];}var l=this;var g=function(i){if(l.watchedElementData.forEach){l.watchedElementData.forEach(function(u){if(u.element.offsetWidth!==u.offsetWidth||u.element.offsetHeight!==u.offsetHeight){u.offsetWidth=u.element.offsetWidth;u.offsetHeight=u.element.offsetHeight;if(u.timer){clearTimeout(u.timer);}u.timer=setTimeout(function(){if(!b.jqx.isHidden(b(u.element))){u.callback();}else {u.timer=setInterval(function(){if(!b.jqx.isHidden(b(u.element))){clearInterval(u.timer);u.callback();}},100);}});}});}};l.watchedElementData.push({element:h[0],offsetWidth:h[0].offsetWidth,offsetHeight:h[0].offsetHeight,callback:t});if(!l.observer){l.observer=new MutationObserver(g);l.observer.observe(document.body,{attributes:true,childList:true,characterData:true});}}}catch(r){}if(b.jqx.isHidden(h)&&p===true){n(true);}b.jqx.resize=function(){n(null,"resize");};},parseJSON:function(e){if(!e||typeof e!=="string"){return null}var c=/^[\],:{}\s]*$/,g=/(?:^|:|,)(?:\s*\[)+/g,d=/\\(?:["\\\/bfnrt]|u[\da-fA-F]{4})/g,f=/"[^"\\\r\n]*"|true|false|null|-?(?:\d\d*\.|)\d+(?:[eE][\-+]?\d+|)/g;e=b.trim(e);if(window.JSON&&window.JSON.parse){return window.JSON.parse(e)}if(c.test(e.replace(d,"@").replace(f,"]").replace(g,""))){return (new Function("return "+e))()}throw new Error("Invalid JSON: "+e)},html:function(d,e){if(!b(d).on){return b(d).html(e)}try{return b.access(d,function(s){var f=d[0]||{},m=0,j=d.length;if(s===undefined){return f.nodeType===1?f.innerHTML.replace(rinlinejQuery,""):undefined}var r=/<(?:script|style|link)/i,n="abbr|article|aside|audio|bdi|canvas|data|datalist|details|figcaption|figure|footer|header|hgroup|mark|meter|nav|output|progress|section|summary|time|video",h=/<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:]+)[^>]*)\/>/gi,p=/<([\w:]+)/,g=/<(?:script|object|embed|option|style)/i,k=new RegExp("<(?:"+n+")[\\s/>]","i"),q=/^\s+/,t={option:[1,"<select multiple='multiple'>","</select>"],legend:[1,"<fieldset>","</fieldset>"],thead:[1,"<table>","</table>"],tr:[2,"<table><tbody>","</tbody></table>"],td:[3,"<table><tbody><tr>","</tr></tbody></table>"],col:[2,"<table><tbody></tbody><colgroup>","</colgroup></table>"],area:[1,"<map>","</map>"],_default:[0,"",""]};if(typeof s==="string"&&!r.test(s)&&(b.support.htmlSerialize||!k.test(s))&&(b.support.leadingWhitespace||!q.test(s))&&!t[(p.exec(s)||["",""])[1].toLowerCase()]){s=s.replace(h,"<$1></$2>");try{for(;m<j;m++){f=this[m]||{};if(f.nodeType===1){b.cleanData(f.getElementsByTagName("*"));f.innerHTML=s;}}f=0;}catch(o){}}if(f){d.empty().append(s);}},null,e,arguments.length)}catch(c){return b(d).html(e)}},hasTransform:function(e){var d="";d=e.css("transform");if(d==""||d=="none"){d=e.parents().css("transform");if(d==""||d=="none"){var c=b.jqx.utilities.getBrowser();if(c.browser=="msie"){d=e.css("-ms-transform");if(d==""||d=="none"){d=e.parents().css("-ms-transform");}}else {if(c.browser=="chrome"){d=e.css("-webkit-transform");if(d==""||d=="none"){d=e.parents().css("-webkit-transform");}}else {if(c.browser=="opera"){d=e.css("-o-transform");if(d==""||d=="none"){d=e.parents().css("-o-transform");}}else {if(c.browser=="mozilla"){d=e.css("-moz-transform");if(d==""||d=="none"){d=e.parents().css("-moz-transform");}}}}}}else {return d!=""&&d!="none"}}if(d==""||d=="none"){d=b(document.body).css("transform");}return d!=""&&d!="none"&&d!=null},getBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=/(chrome)[ \/]([\w.]+)/.exec(d)||/(webkit)[ \/]([\w.]+)/.exec(d)||/(opera)(?:.*version|)[ \/]([\w.]+)/.exec(d)||/(msie) ([\w.]+)/.exec(d)||d.indexOf("compatible")<0&&/(mozilla)(?:.*? rv:([\w.]+)|)/.exec(d)||[];var e={browser:c[1]||"",version:c[2]||"0"};if(d.indexOf("rv:11.0")>=0&&d.indexOf(".net4.0c")>=0){e.browser="msie";e.version="11";c[1]="msie";}if(d.indexOf("edge")>=0){e.browser="msie";e.version="12";c[1]="msie";}e[c[1]]=c[1];return e}});b.jqx.browser=b.jqx.utilities.getBrowser();b.jqx.isHidden=function(d){if(!d||!d[0]){return false}var c=d[0].offsetWidth,e=d[0].offsetHeight;if(c===0||e===0){return true}else {return false}};b.jqx.ariaEnabled=true;b.jqx.aria=function(d,f,e){if(!b.jqx.ariaEnabled){return}if(f==undefined){b.each(d.aria,function(h,i){var k=!d.base?d.host.attr(h):d.base.host.attr(h);if(k!=undefined&&!b.isFunction(k)){var j=k;switch(i.type){case"number":j=new Number(k);if(isNaN(j)){j=k;}break;case"boolean":j=k=="true"?true:false;break;case"date":j=new Date(k);if(j=="Invalid Date"||isNaN(j)){j=k;}break}d[i.name]=j;}else {var k=d[i.name];if(b.isFunction(k)){k=d[i.name]();}if(k==undefined){k="";}try{!d.base?d.host.attr(h,k.toString()):d.base.host.attr(h,k.toString());}catch(g){}}});}else {try{if(d.host){if(!d.base){if(d.host){if(d.element.setAttribute){d.element.setAttribute(f,e.toString());}else {d.host.attr(f,e.toString());}}else {d.attr(f,e.toString());}}else {if(d.base.host){d.base.host.attr(f,e.toString());}else {d.attr(f,e.toString());}}}else {if(d.setAttribute){d.setAttribute(f,e.toString());}}}catch(c){}}};if(!Array.prototype.indexOf){Array.prototype.indexOf=function(d){var c=this.length;var e=Number(arguments[1])||0;e=(e<0)?Math.ceil(e):Math.floor(e);if(e<0){e+=c;}for(;e<c;e++){if(e in this&&this[e]===d){return e}}return -1};}b.jqx.mobile=b.jqx.mobile||{};b.jqx.position=function(c){var f=parseInt(c.pageX);var e=parseInt(c.pageY);if(b.jqx.mobile.isTouchDevice()){var d=b.jqx.mobile.getTouches(c);var g=d[0];f=parseInt(g.pageX);e=parseInt(g.pageY);}return {left:f,top:e}};b.extend(b.jqx.mobile,{_touchListener:function(i,g){var c=function(j,l){var k=document.createEvent("MouseEvents");k.initMouseEvent(j,l.bubbles,l.cancelable,l.view,l.detail,l.screenX,l.screenY,l.clientX,l.clientY,l.ctrlKey,l.altKey,l.shiftKey,l.metaKey,l.button,l.relatedTarget);k._pageX=l.pageX;k._pageY=l.pageY;return k};var h={mousedown:"touchstart",mouseup:"touchend",mousemove:"touchmove"};var f=c(h[i.type],i);i.target.dispatchEvent(f);var d=i.target["on"+h[i.type]];if(typeof d==="function"){d(i);}},setMobileSimulator:function(d,f){if(this.isTouchDevice()){return}this.simulatetouches=true;if(f==false){this.simulatetouches=false;}var e={mousedown:"touchstart",mouseup:"touchend",mousemove:"touchmove"};var c=this;if(window.addEventListener){var g=function(){for(var h in e){if(d.addEventListener){d.removeEventListener(h,c._touchListener);d.addEventListener(h,c._touchListener,false);}}};if(b.jqx.browser.msie){g();}else {g();}}},isTouchDevice:function(){if(this.touchDevice!=undefined){return this.touchDevice}var d="Browser CodeName: "+navigator.appCodeName+"";d+="Browser Name: "+navigator.appName+"";d+="Browser Version: "+navigator.appVersion+"";d+="Platform: "+navigator.platform+"";d+="User-agent header: "+navigator.userAgent+"";if(d.indexOf("Android")!=-1){return true}if(d.indexOf("IEMobile")!=-1){return true}if(d.indexOf("Windows Phone")!=-1){return true}if(d.indexOf("WPDesktop")!=-1){return true}if(d.indexOf("ZuneWP7")!=-1){return true}if(d.indexOf("BlackBerry")!=-1&&d.indexOf("Mobile Safari")!=-1){return true}if(d.indexOf("ipod")!=-1){return true}if(d.indexOf("nokia")!=-1||d.indexOf("Nokia")!=-1){return true}if(d.indexOf("Chrome/17")!=-1){return false}if(d.indexOf("CrOS")!=-1){return false}if(d.indexOf("Opera")!=-1&&d.indexOf("Mobi")==-1&&d.indexOf("Mini")==-1&&d.indexOf("Platform: Win")!=-1){return false}if(d.indexOf("HybridDeviceTouch")!=-1){return true}if(d.indexOf("HybridDeviceMouse")!=-1){return false}if(d.indexOf("Opera")!=-1&&d.indexOf("Mobi")!=-1&&d.indexOf("Opera Mobi")!=-1){return true}if(d.indexOf("Mozilla/5.0 (X11; Linux x86_64)")!=-1){return false}var f={ios:"i(?:Pad|Phone|Pod)(?:.*)CPU(?: iPhone)? OS ",android:"(Android |HTC_|Silk/)",blackberry:"BlackBerry(?:.*)Version/",rimTablet:"RIM Tablet OS ",webos:"(?:webOS|hpwOS)/",bada:"Bada/"};try{if(this.touchDevice!=undefined){return this.touchDevice}this.touchDevice=false;for(var h in f){if(f.hasOwnProperty(h)){var k=f[h];var g=d.match(new RegExp("(?:"+k+")([^\\s;]+)"));if(g){if(h.toString()=="blackberry"){this.touchDevice=false;return false}this.touchDevice=true;return true}}}var j=navigator.userAgent;if(navigator.platform.toLowerCase().indexOf("win")!=-1){if(j.indexOf("Windows Phone")>=0||j.indexOf("WPDesktop")>=0||j.indexOf("IEMobile")>=0||j.indexOf("ZuneWP7")>=0){this.touchDevice=true;return true}else {if(j.indexOf("Touch")>=0){var c=("MSPointerDown" in window)||("pointerdown" in window);if(c){this.touchDevice=true;return true}if(j.indexOf("ARM")>=0){this.touchDevice=true;return true}this.touchDevice=false;return false}}}if(navigator.platform.toLowerCase().indexOf("win")!=-1){this.touchDevice=false;return false}if(("ontouchstart" in window)||window.DocumentTouch&&document instanceof DocumentTouch){this.touchDevice=true;}return this.touchDevice}catch(l){this.touchDevice=false;return false}},getLeftPos:function(c){var d=c.offsetLeft;while((c=c.offsetParent)!=null){if(c.tagName!="HTML"){d+=c.offsetLeft;if(document.all){d+=c.clientLeft;}}}return d},getTopPos:function(d){var f=d.offsetTop;var c=b(d).coord();while((d=d.offsetParent)!=null){if(d.tagName!="HTML"){f+=(d.offsetTop-d.scrollTop);if(document.all){f+=d.clientTop;}}}var e=navigator.userAgent.toLowerCase();var g=(e.indexOf("windows phone")!=-1||e.indexOf("WPDesktop")!=-1||e.indexOf("ZuneWP7")!=-1||e.indexOf("msie 9")!=-1||e.indexOf("msie 11")!=-1||e.indexOf("msie 10")!=-1)&&e.indexOf("touch")!=-1;if(g){return c.top}if(this.isSafariMobileBrowser()){if(this.isSafari4MobileBrowser()&&this.isIPadSafariMobileBrowser()){return f}if(e.indexOf("version/7")!=-1){return c.top}if(e.indexOf("version/6")!=-1||e.indexOf("version/5")!=-1){f=f+b(window).scrollTop();}if(/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)){return f+b(window).scrollTop()}if(/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)){return f+b(window).scrollTop()}return c.top}return f},isChromeMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("android")!=-1;return c},isOperaMiniMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("opera mini")!=-1||d.indexOf("opera mobi")!=-1;return c},isOperaMiniBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("opera mini")!=-1;return c},isNewSafariMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("ipad")!=-1||d.indexOf("iphone")!=-1||d.indexOf("ipod")!=-1;c=c&&(d.indexOf("version/5")!=-1);return c},isSafari4MobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("ipad")!=-1||d.indexOf("iphone")!=-1||d.indexOf("ipod")!=-1;c=c&&(d.indexOf("version/4")!=-1);return c},isWindowsPhone:function(){var d=navigator.userAgent.toLowerCase();var c=(d.indexOf("windows phone")!=-1||d.indexOf("WPDesktop")!=-1||d.indexOf("ZuneWP7")!=-1||d.indexOf("msie 9")!=-1||d.indexOf("msie 11")!=-1||d.indexOf("msie 10")!=-1&&d.indexOf("touch")!=-1);return c},isSafariMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();if(/(Android.*Chrome\/[.0-9]* (!?Mobile))/.exec(navigator.userAgent)){return true}if(/(Android.*Chrome\/[.0-9]* Mobile)/.exec(navigator.userAgent)){return true}var c=d.indexOf("ipad")!=-1||d.indexOf("iphone")!=-1||d.indexOf("ipod")!=-1||d.indexOf("mobile safari")!=-1;return c},isIPadSafariMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("ipad")!=-1;return c},isMobileBrowser:function(){var d=navigator.userAgent.toLowerCase();var c=d.indexOf("ipad")!=-1||d.indexOf("iphone")!=-1||d.indexOf("android")!=-1;return c},getTouches:function(c){if(c.originalEvent){if(c.originalEvent.touches&&c.originalEvent.touches.length){return c.originalEvent.touches}else {if(c.originalEvent.changedTouches&&c.originalEvent.changedTouches.length){return c.originalEvent.changedTouches}}}if(!c.touches){c.touches=new Array();c.touches[0]=c.originalEvent!=undefined?c.originalEvent:c;if(c.originalEvent!=undefined&&c.pageX){c.touches[0]=c;}if(c.type=="mousemove"){c.touches[0]=c;}}return c.touches},getTouchEventName:function(c){if(this.isWindowsPhone()){var d=navigator.userAgent.toLowerCase();if(d.indexOf("windows phone 7")!=-1){if(c.toLowerCase().indexOf("start")!=-1){return "MSPointerDown"}if(c.toLowerCase().indexOf("move")!=-1){return "MSPointerMove"}if(c.toLowerCase().indexOf("end")!=-1){return "MSPointerUp"}}if(c.toLowerCase().indexOf("start")!=-1){return "pointerdown"}if(c.toLowerCase().indexOf("move")!=-1){return "pointermove"}if(c.toLowerCase().indexOf("end")!=-1){return "pointerup"}}else {return c}},dispatchMouseEvent:function(c,g,f){if(this.simulatetouches){return}var d=document.createEvent("MouseEvent");d.initMouseEvent(c,true,true,g.view,1,g.screenX,g.screenY,g.clientX,g.clientY,false,false,false,false,0,null);if(f!=null){f.dispatchEvent(d);}},getRootNode:function(c){while(c.nodeType!==1){c=c.parentNode;}return c},setTouchScroll:function(c,d){if(!this.enableScrolling){this.enableScrolling=[];}this.enableScrolling[d]=c;},touchScroll:function(B,M,Z,H,x,n){if(B==null){return}var G=this;if(!this.scrolling){this.scrolling=[];}this.scrolling[H]=false;var k=false;var p=b(B);var R=["select","input","textarea"];var X=0;if(!this.enableScrolling){this.enableScrolling=[];}this.enableScrolling[H]=true;var H=H;var w=this.getTouchEventName("touchstart")+".touchScroll";var D=this.getTouchEventName("touchend")+".touchScroll";var ab=this.getTouchEventName("touchmove")+".touchScroll";var ah,V,Y,aj,Q,aa,d,F,af,O,e,v,u,S,c,E,ag,o;Q=M;var aj=0;var aa=0;var h=0;var T=0;var ai=0;var Y=x.jqxScrollBar("max");var o=325;function A(am){if(am.targetTouches&&(am.targetTouches.length>=1)){return am.targetTouches[0].clientY}else {if(am.originalEvent&&am.originalEvent.clientY!==undefined){return am.originalEvent.clientY}else {var al=G.getTouches(am);return al[0].clientY}}}function ae(am){if(am.targetTouches&&(am.targetTouches.length>=1)){return am.targetTouches[0].clientX}else {if(am.originalEvent&&am.originalEvent.clientX!==undefined){return am.originalEvent.clientX}else {var al=G.getTouches(am);return al[0].clientX}}}var I=function(){var ap,am,aq,ao;ap=Date.now();am=ap-v;v=ap;aq=aa-e;var an=h-ah;e=aa;ah=h;F=true;ao=1000*aq/(1+am);var al=1000*an/(1+am);af=0.8*ao+0.2*af;O=0.8*al+0.2*O;};var C=false;var X=function(am){if(!G.enableScrolling[H]){return true}if(b.inArray(am.target.tagName.toLowerCase(),R)!==-1){return}aa=n.jqxScrollBar("value");h=x.jqxScrollBar("value");var an=G.getTouches(am);var ao=an[0];if(an.length==1){G.dispatchMouseEvent("mousedown",ao,G.getRootNode(ao.target));}Y=x.jqxScrollBar("max");Q=n.jqxScrollBar("max");function al(ap){C=false;F=true;d=A(ap);ag=ae(ap);af=S=O=0;e=aa;ah=h;v=Date.now();clearInterval(u);u=setInterval(I,100);T=aa;ai=h;if(aa>0&&aa<Q&&n[0].style.visibility!="hidden");}al(am);k=false;if(G.simulatetouches){if(ao._pageY!=undefined);}G.scrolling[H]=true;return true};if(p.on){p.on(w,X);}else {p.bind(w,X);}var ac=function(am,al){aa=(am>Q)?Q:(am<aj)?aj:am;Z(null,am,0,0,al);return (am>Q)?"max":(am<aj)?"min":"value"};var m=function(am,al){h=(am>Y)?Y:(am<aj)?aj:am;Z(am,null,0,0,al);return (am>Y)?"max":(am<aj)?"min":"value"};function U(){var al,am;if(S){al=Date.now()-v;am=-S*Math.exp(-al/o);if(am>0.5||am<-0.5){ac(c+am);requestAnimationFrame(U);}else {ac(c);}}}function N(){var al,am;if(S){al=Date.now()-v;am=-S*Math.exp(-al/o);if(am>0.5||am<-0.5){m(E+am);requestAnimationFrame(N);}else {m(E);}}}var y=function(al){if(!G.enableScrolling[H]){return true}if(!G.scrolling[H]){return true}if(C){al.preventDefault();al.stopPropagation();}var aq=G.getTouches(al);if(aq.length>1){return true}aq[0].pageY;aq[0].pageX;if(G.simulatetouches){if(aq[0]._pageY!=undefined){aq[0]._pageY;aq[0]._pageX;}}k=true;var an=x!=null?x[0].style.visibility!="hidden":true;var ar=n!=null?n[0].style.visibility!="hidden":true;function ap(ay){var aA,az,ax;if(F){aA=A(ay);ax=ae(ay);az=d-aA;V=ag-ax;var aw="value";if(az>2||az<-2){d=aA;aw=ac(aa+az,ay);I();if(aw=="min"&&T===0){return true}if(aw=="max"&&T===Q){return true}if(!ar){return true}ay.preventDefault();ay.stopPropagation();C=true;return false}else {if(V>2||V<-2){ag=ax;aw=m(h+V,ay);I();if(aw=="min"&&ai===0){return true}if(aw=="max"&&ai===Y){return true}if(!an){return true}C=true;ay.preventDefault();ay.stopPropagation();return false}}ay.preventDefault();}}if(an||ar){if((an)||(ar)){ap(al);}}};if(p.on){p.on(ab,y);}else {p.bind(ab,y);}var s=function(am){if(!G.enableScrolling[H]){return true}var an=G.getTouches(am)[0];if(!G.scrolling[H]){return true}F=false;clearInterval(u);if(af>10||af<-10){S=0.8*af;c=Math.round(aa+S);v=Date.now();requestAnimationFrame(U);}else {if(O>10||O<-10){S=0.8*O;E=Math.round(h+S);v=Date.now();requestAnimationFrame(N);}}G.scrolling[H]=false;if(k){G.dispatchMouseEvent("mouseup",an,am.target);}else {var an=G.getTouches(am)[0],al=G.getRootNode(an.target);G.dispatchMouseEvent("mouseup",an,al);G.dispatchMouseEvent("click",an,al);return true}};if(this.simulatetouches){b(window).on!=undefined||b(window).bind;var P=function(al){try{s(al);}catch(am){}G.scrolling[H]=false;};b(window).on!=undefined?b(document).on("mouseup.touchScroll",P):b(document).bind("mouseup.touchScroll",P);if(window.frameElement){if(window.top!=null){var L=function(al){try{s(al);}catch(am){}G.scrolling[H]=false;};if(window.top.document){b(window.top.document).on?b(window.top.document).on("mouseup",L):b(window.top.document).bind("mouseup",L);}}}b(document).on!=undefined||b(document).bind;var K=function(al){if(!G.scrolling[H]){return true}G.scrolling[H]=false;var an=G.getTouches(al)[0],am=G.getRootNode(an.target);G.dispatchMouseEvent("mouseup",an,am);G.dispatchMouseEvent("click",an,am);};b(document).on!=undefined?b(document).on("touchend",K):b(document).bind("touchend",K);}if(p.on){p.on("dragstart",function(al){al.preventDefault();});p.on("selectstart",function(al){al.preventDefault();});}p.on?p.on(D+" touchcancel.touchScroll",s):p.bind(D+" touchcancel.touchScroll",s);}});b.jqx.cookie=b.jqx.cookie||{};b.extend(b.jqx.cookie,{cookie:function(f,g,d){if(arguments.length>1&&String(g)!=="[object Object]"){d=b.extend({},d);if(g===null||g===undefined){d.expires=-1;}if(typeof d.expires==="number"){var i=d.expires,e=d.expires=new Date();e.setDate(e.getDate()+i);}g=String(g);return(document.cookie=[encodeURIComponent(f),"=",d.raw?g:encodeURIComponent(g),d.expires?"; expires="+d.expires.toUTCString():"",d.path?"; path="+d.path:"",d.domain?"; domain="+d.domain:"",d.secure?"; secure":""].join(""))}d=g||{};var c,h=d.raw?function(j){return j}:decodeURIComponent;return (c=new RegExp("(?:^|; )"+encodeURIComponent(f)+"=([^;]*)").exec(document.cookie))?h(c[1]):null}});b.jqx.string=b.jqx.string||{};b.extend(b.jqx.string,{replace:function(g,e,f){if(e===f){return this}var c=g;var d=c.indexOf(e);while(d!=-1){c=c.replace(e,f);d=c.indexOf(e);}return c},contains:function(c,d){if(c==null||d==null){return false}return c.indexOf(d)!=-1},containsIgnoreCase:function(c,d){if(c==null||d==null){return false}return c.toString().toUpperCase().indexOf(d.toString().toUpperCase())!=-1},equals:function(c,d){if(c==null||d==null){return false}c=this.normalize(c);if(d.length==c.length){return c.slice(0,d.length)==d}return false},equalsIgnoreCase:function(c,d){if(c==null||d==null){return false}c=this.normalize(c);if(d.length==c.length){return c.toUpperCase().slice(0,d.length)==d.toUpperCase()}return false},startsWith:function(c,d){if(c==null||d==null){return false}return c.slice(0,d.length)==d},startsWithIgnoreCase:function(c,d){if(c==null||d==null){return false}return c.toUpperCase().slice(0,d.length)==d.toUpperCase()},normalize:function(c){if(c.charCodeAt(c.length-1)==65279){c=c.substring(0,c.length-1);}return c},endsWith:function(c,d){if(c==null||d==null){return false}c=this.normalize(c);return c.slice(-d.length)==d},endsWithIgnoreCase:function(c,d){if(c==null||d==null){return false}c=this.normalize(c);return c.toUpperCase().slice(-d.length)==d.toUpperCase()}});b.extend(b.easing,{easeOutBack:function(f,g,e,j,i,h){if(h==undefined){h=1.70158;}return j*((g=g/i-1)*g*((h+1)*g+h)+1)+e},easeInQuad:function(f,g,e,i,h){return i*(g/=h)*g+e},easeInOutCirc:function(f,g,e,i,h){if((g/=h/2)<1){return -i/2*(Math.sqrt(1-g*g)-1)+e}return i/2*(Math.sqrt(1-(g-=2)*g)+1)+e},easeInOutSine:function(f,g,e,i,h){return -i/2*(Math.cos(Math.PI*g/h)-1)+e},easeInCubic:function(f,g,e,i,h){return i*(g/=h)*g*g+e},easeOutCubic:function(f,g,e,i,h){return i*((g=g/h-1)*g*g+1)+e},easeInOutCubic:function(f,g,e,i,h){if((g/=h/2)<1){return i/2*g*g*g+e}return i/2*((g-=2)*g*g+2)+e},easeInSine:function(f,g,e,i,h){return -i*Math.cos(g/h*(Math.PI/2))+i+e},easeOutSine:function(f,g,e,i,h){return i*Math.sin(g/h*(Math.PI/2))+e},easeInOutSine:function(f,g,e,i,h){return -i/2*(Math.cos(Math.PI*g/h)-1)+e}});})(jqxBaseFramework$1);(function(b){if(b.event&&b.event.special){b.extend(b.event.special,{close:{noBubble:true},open:{noBubble:true},cellclick:{noBubble:true},rowclick:{noBubble:true},tabclick:{noBubble:true},selected:{noBubble:true},expanded:{noBubble:true},collapsed:{noBubble:true},valuechanged:{noBubble:true},expandedItem:{noBubble:true},collapsedItem:{noBubble:true},expandingItem:{noBubble:true},collapsingItem:{noBubble:true}});}if(b.fn.extend){b.fn.extend({ischildof:function(g){if(!b(this).parents){var c=g.element.contains(this.element);return c}var e=b(this).parents().get();for(var d=0;d<e.length;d++){if(typeof g!="string"){var f=e[d];if(g!==undefined){if(f==g[0]){return true}}}else {if(g!==undefined){if(b(e[d]).is(g)){return true}}}}return false}});}b.fn.jqxProxy=function(){var e=b(this).data().jqxWidget;var c=Array.prototype.slice.call(arguments,0);var d=e.element;if(!d){d=e.base.element;}return b.jqx.jqxWidgetProxy(e.widgetName,d,c)};var a=b.originalVal=b.fn.val;b.fn.val=function(d){if(typeof d=="undefined"){if(b(this).hasClass("jqx-widget")||b(this).hasClass("jqx-input-group")){var c=b(this).data().jqxWidget;if(c&&c.val){return c.val()}}if(this[0]&&this[0].tagName.toLowerCase().indexOf("angular")>=0){var c=b(this).find(".jqx-widget").data().jqxWidget;if(c&&c.val){return c.val()}}return a.call(this)}else {if(b(this).hasClass("jqx-widget")||b(this).hasClass("jqx-input-group")){var c=b(this).data().jqxWidget;if(c&&c.val){if(arguments.length!=2){return c.val(d)}else {return c.val(d,arguments[1])}}}if(this[0]&&this[0].tagName.toLowerCase().indexOf("angular")>=0){var c=b(this).find(".jqx-widget").data().jqxWidget;if(c&&c.val){if(arguments.length!=2){return c.val(d)}else {return c.val(d,arguments[1])}}}return a.call(this,d)}};if(b.fn.modal&&b.fn.modal.Constructor){b.fn.modal.Constructor.prototype.enforceFocus=function(){b(document).off("focusin.bs.modal").on("focusin.bs.modal",b.proxy(function(c){if(this.$element[0]!==c.target&&!this.$element.has(c.target).length){if(b(c.target).parents().hasClass("jqx-popup")){return true}this.$element.trigger("focus");}},this));};}b.fn.coord=function(n){var e,j,i={top:0,left:0},f=this[0],l=f&&f.ownerDocument;if(!l){return}e=l.documentElement;if(!b.contains(e,f)){return i}if(typeof f.getBoundingClientRect!==undefined){i=f.getBoundingClientRect();}var d=function(o){return b.isWindow(o)?o:o.nodeType===9?o.defaultView||o.parentWindow:false};j=d(l);var h=0;var c=0;var g=navigator.userAgent.toLowerCase();var m=g.indexOf("ipad")!=-1||g.indexOf("iphone")!=-1;if(m){h=2;}if(true==n){if(document.body.style.position!="static"&&document.body.style.position!=""){var k=b(document.body).coord();h=-k.left;c=-k.top;}}return {top:c+i.top+(j.pageYOffset||e.scrollTop)-(e.clientTop||0),left:h+i.left+(j.pageXOffset||e.scrollLeft)-(e.clientLeft||0)}};b.jqx.ripplers=[];b.jqx.ripple=function(f,e,o){if(!e){e=f;}var h=b(f);h.append("<span class='ink'></span>");var p=h.find(".ink");var c=false;for(var g=0;g<b.jqx.ripplers.length;g++){var k=b.jqx.ripplers[g];if(k.element[0]===f[0]){c=true;break}}if(!c){b.jqx.ripplers.push({ink:p,element:f,hostElement:e,hostElementType:o});}if(o==="checkbox"||o==="radiobutton"){var l=Math.max(h.outerWidth(),h.outerHeight());p.css({height:l,width:l});var n=h.width()/2-p.width()/2;var m=h.height()/2-p.height()/2;p.css({top:m+"px",left:n+"px"});}if(b.jqx.ripplers.length===1){b(document).on("mouseup",function(r){b.jqx.ripple.mouseCaptured=false;for(var q=0;q<b.jqx.ripplers.length;q++){var d=b.jqx.ripplers[q];d.ink.removeClass("active");d.element.removeClass("active");if(o!=="checkbox"&&o!=="radiobutton"){if(d.ink.hasClass("animate")){d.ink.removeClass("animate");}}}});}e.off("mousedown.ripple");e.on("mousedown.ripple",function(i){var d=b(f);b.jqx.ripple.mouseCaptured=true;setTimeout(function(){if(d.find(".ink").length==0){d.append("<span class='ink'></span>");}var r=d.find(".ink");r.removeClass("animate");if(!r.height()&&!r.width()){var s=Math.max(d.outerWidth(),d.outerHeight());r.css({height:s,width:s});}if(o==="checkbox"||o==="radiobutton"){if(o==="checkbox"){if(e.jqxCheckBox("disabled")){return}}if(o==="radiobutton"){if(e.jqxRadioButton("disabled")){return}}var q=d.width()/2-r.width()/2;var t=d.height()/2-r.height()/2;r.css({top:t+"px",left:q+"px"}).addClass("animate");r.on("animationend",function(){if(b.jqx.ripple.mouseCaptured){r.removeClass("animate");r.addClass("active");f.addClass("active");}});return}var q=i.pageX-d.offset().left-r.width()/2;var t=i.pageY-d.offset().top-r.height()/2;r.css({top:t+"px",left:q+"px"}).addClass("animate");});});};})(jqxBaseFramework$1);

/*
jQWidgets v12.1.2 (2021-July)
Copyright (c) 2011-2021 jQWidgets.
License: https://jqwidgets.com/license/
*/
/* eslint-disable */

(function(a){a.jqx.jqxWidget("jqxMenu","",{});a.extend(a.jqx._jqxMenu.prototype,{defineInstance:function(){var b={items:new Array(),mode:"horizontal",width:null,height:null,minimizeWidth:"auto",easing:"easeInOutSine",animationShowDuration:200,animationHideDuration:200,autoCloseInterval:0,animationHideDelay:100,animationShowDelay:10,menuElements:new Array(),autoSizeMainItems:false,autoCloseOnClick:true,autoCloseOnMouseLeave:true,enableRoundedCorners:true,disabled:false,autoOpenPopup:true,enableHover:true,autoOpen:true,autoGenerate:true,clickToOpen:false,showTopLevelArrows:false,touchMode:"auto",source:null,popupZIndex:1000,rtl:false,keyboardNavigation:false,lockFocus:false,title:"",events:["shown","closed","itemclick","initialized","open","close"]};if(this===a.jqx._jqxMenu.prototype){return b}a.extend(true,this,b);return b},createInstance:function(c){var b=this;this.host.attr("role","menubar");a.jqx.utilities.resize(this.host,function(){b.refresh();},false,this.mode!="popup");if(this.minimizeWidth!="auto"&&this.minimizeWidth!=null&&this.width&&this.width.toString().indexOf("%")==-1){a(window).resize(function(){b.refresh();});}if(b.isMaterialized()){var g=window.getComputedStyle(this.element);var f=g.getPropertyValue("--jqx-dropdown-animation");if(f){this.animationType=f.trim();if(this.animationType==="transform"){this.animationShowDuration=0;this.animationHideDuration=0;this.animationShowDelay=0;}}}this.host.css("outline","none");if(this.source){if(this.source!=null){var d=this.loadItems(this.source);this.element.innerHTML=d;}}this._tmpHTML=this.element.innerHTML;if(this.element.innerHTML.indexOf("UL")){var e=this.host.find("ul:first");if(e.length>0){this._createMenu(e[0]);}}this.host.data("autoclose",{});this._render();this._setSize();if(a.jqx.browser.msie&&a.jqx.browser.version<8){this.host.attr("hideFocus",true);}},focus:function(){try{if(this.mode==="popup"&&this.keyboardNavigation){var d=this.host.closest("div.jqx-menu-wrapper");d.focus();}if(this.keyboardNavigation){this.host.focus();var c=this;var e=function(){if(!a.jqx.isHidden(a(c.items[0].element))){a(c.items[0].element).addClass(c.toThemeProperty("jqx-fill-state-focus"));c.activeItem=c.items[0];}else {var f=c._nextVisibleItem(c.items[0],0);if(f){a(f.element).addClass(c.toThemeProperty("jqx-fill-state-focus"));c.activeItem=f;}}};if(!this.activeItem){e();}else {if(!a.jqx.isHidden(a(this.activeItem.element))){a(this.activeItem.element).addClass(this.toThemeProperty("jqx-fill-state-focus"));}else {a(this.activeItem.element).removeClass(this.toThemeProperty("jqx-fill-state-focus"));e();}}}}catch(b){}},loadItems:function(c,e){if(c==null){return}if(c.length==0){return ""}var b=this;this.items=new Array();var d='<ul class="jqx-menu-ul">';if(e){d='<ul class="jqx-menu-ul" style="width:'+e+';">';}a.map(c,function(f){if(f==undefined){return null}d+=b._parseItem(f);});d+="</ul>";return d},_parseItem:function(f){var c="";if(f==undefined){return null}var b=f.label;if(!f.label&&f.html){b=f.html;}if(!b){b="Item";}if(typeof f==="string"){b=f;}if(f.selected!=undefined&&f.selected);var d=false;if(f.disabled!=undefined&&f.disabled){d=true;}c+="<li";if(d){c+=' item-disabled="true" ';}if(f.label&&!f.html){c+=' item-label="'+b+'" ';}if(f.value!=null){c+=' item-value="'+f.value+'" ';}if(f.id!=undefined){c+=' id="'+f.id+'" ';}c+=">"+b;if(f.items){if(f.subMenuWidth){c+=this.loadItems(f.items,f.subMenuWidth);}else {c+=this.loadItems(f.items);}}c+="</li>";return c},_setSize:function(){if(this.width!=null&&this.width.toString().indexOf("%")!=-1){this.host.width(this.width);}else {if(this.width!=null&&this.width.toString().indexOf("px")!=-1){this.host.width(this.width);}else {if(this.width!=undefined&&!isNaN(this.width)){this.host.width(this.width);}}}if(this.height!=null&&this.height.toString().indexOf("%")!=-1){this.host.height(this.height);}else {if(this.height!=null&&this.height.toString().indexOf("px")!=-1){this.host.height(this.height);}else {if(this.height!=undefined&&!isNaN(this.height)){this.host.height(this.height);}}}if(this.height===null){this.host.height("auto");}if(this.minimizeWidth!=null&&this.mode!="popup"){var f=a(window).width();if(!a.jqx.response){var e=false;if(navigator.userAgent.match(/Windows|Linux|MacOS/)){var b=navigator.userAgent.indexOf("Windows Phone")>=0||navigator.userAgent.indexOf("WPDesktop")>=0||navigator.userAgent.indexOf("IEMobile")>=0||navigator.userAgent.indexOf("ZuneWP7")>=0;if(!b){e=true;}}var c=this.minimizeWidth;if(e&&this.minimizeWidth=="auto"){return}}if(this.minimizeWidth=="auto"&&a.jqx.response){var d=new a.jqx.response();if(d.device.type=="Phone"||d.device.type=="Tablet"){if(!this.minimized){this.minimize();}}}else {if((f<c)&&!this.minimized){this.minimize();}else {if(this.minimized&&f>=c){this.restore();}}}}},minimize:function(){if(this.minimized){return}var e=this;this.host.addClass(this.toThemeProperty("jqx-menu-minimized"));this.minimized=true;this._tmpMode=this.mode;this.mode="simple";var h=this.host.closest("div.jqx-menu-wrapper");h.remove();a("#menuWrapper"+this.element.id).remove();a.each(this.items,function(){var k=this;a(k.element);var i=a(k.subMenuElement);var l=i.closest("div.jqx-menu-popup");l.remove();});if(this.source){var d=this.loadItems(this.source);this.element.innerHTML=d;this._tmpHTML=this.element.innerHTML;}this.element.innerHTML=this._tmpHTML;if(this.element.innerHTML.indexOf("UL")){var g=this.host.find("ul:first");if(g.length>0){this._createMenu(g[0]);}}this._render();var c=this.host.find("ul:first");c.wrap('<div class="jqx-menu-wrapper" style="z-index:'+this.popupZIndex+'; padding: 0px; display: none; margin: 0px; height: auto; width: auto; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>');var h=c.closest("div.jqx-menu-wrapper");h[0].id="menuWrapper"+this.element.id;h.detach();h.appendTo(a(document.body));h.addClass(this.toThemeProperty("jqx-widget"));h.addClass(this.toThemeProperty("jqx-menu"));h.addClass(this.toThemeProperty("jqx-menu-minimized"));h.addClass(this.toThemeProperty("jqx-widget-header"));c.children().hide();h.hide();h.find("ul").addClass(this.toThemeProperty("jqx-menu-ul-minimized"));this.minimizedItem=a("<div></div>");this.minimizedItem.addClass(this.toThemeProperty("jqx-item"));this.minimizedItem.addClass(this.toThemeProperty("jqx-menu-item-top"));this.addHandler(h,"keydown",function(i){return e.handleKeyDown(i)});this.minimizedItem.addClass(this.toThemeProperty("jqx-menu-minimized-button"));this.minimizedItem.prependTo(this.host);this.titleElement=a("<div>"+this.title+"</div>");this.titleElement.addClass(this.toThemeProperty("jqx-item"));this.titleElement.addClass(this.toThemeProperty("jqx-menu-title"));this.titleElement.prependTo(this.host);a("<div style='clear:both;'></div>").insertAfter(this.minimizedItem);e.minimizedHidden=true;var b=function(j){e.minimizedHidden=true;e.minimizedItem.show();var i=false;if(e.minimizedItem.css("float")=="right"){i=true;}h.animate({left:!i?-h.outerWidth():e.host.coord().left+e.host.width()+h.width(),opacity:0},e.animationHideDuration,function(){h.find("ul:first").children().hide();h.hide();});};var f=function(k){if(e.minimizedHidden){h.find("ul:first").children().show();e.minimizedHidden=false;h.show();h.css("opacity",0);h.css("left",-h.outerWidth());var j=false;var i=h.width();if(e.minimizedItem.css("float")=="right"){h.css("left",e.host.coord().left+e.host.width()+i);j=true;}h.css("top",e.host.coord().top+e.host.height());h.animate({left:!j?e.host.coord().left:e.host.coord().left+e.host.width()-i,opacity:0.95},e.animationShowDuration,function(){});}else {b();}e._raiseEvent("2",{type:"mouse",item:e.minimizedItem[0],event:k});e._setSize();};this.addHandler(a(window),"orientationchange.jqxmenu"+this.element.id,function(i){setTimeout(function(){if(!e.minimizedHidden){var j=h.width();var k=false;var j=h.width();if(e.minimizedItem.css("float")=="right"){k=true;}h.css("top",e.host.coord().top+e.host.height());h.css({left:!k?e.host.coord().left:e.host.coord().left+e.host.width()-j});}},25);});this.addHandler(this.minimizedItem,"click",function(i){f(i);});},restore:function(){if(!this.minimized){return}this.host.find("ul").removeClass(this.toThemeProperty("jqx-menu-ul-minimized"));this.host.removeClass(this.toThemeProperty("jqx-menu-minimized"));this.minimized=false;this.mode=this._tmpMode;if(this.minimizedItem){this.minimizedItem.remove();}var d=a("#menuWrapper"+this.element.id);d.remove();if(this.source){var b=this.loadItems(this.source);this.element.innerHTML=b;this._tmpHTML=b;}this.element.innerHTML=this._tmpHTML;if(this.element.innerHTML.indexOf("UL")){var c=this.host.find("ul:first");if(c.length>0){this._createMenu(c[0]);}}this._setSize();this._render();},isTouchDevice:function(){if(this._isTouchDevice!=undefined){return this._isTouchDevice}var b=a.jqx.mobile.isTouchDevice();if(this.touchMode==true){b=true;}else {if(this.touchMode==false){b=false;}}if(b){this.host.addClass(this.toThemeProperty("jqx-touch"));a(".jqx-menu-item").addClass(this.toThemeProperty("jqx-touch"));}this._isTouchDevice=b;return b},refresh:function(b){if(!b){this._setSize();}},resize:function(c,b){this.width=c;this.height=b;this.refresh();},_closeAll:function(f){var d=f!=null?f.data:this;var b=d.items;a.each(b,function(){var e=this;if(e.hasItems==true){if(e.isOpen){d._closeItem(d,e);}}});if(d.mode=="popup"){if(f!=null){var c=d._isRightClick(f);if(!c){d.close();}}}},closeItem:function(e){if(e==null){return false}var b=e;var c=document.getElementById(b);var d=this;a.each(d.items,function(){var f=this;if(f.isOpen==true&&f.element==c){d._closeItem(d,f);if(f.parentId);}});return true},openItem:function(e){if(e==null){return false}var b=e;var c=document.getElementById(b);var d=this;a.each(d.items,function(){var f=this;if(f.isOpen==false&&f.element==c){d._openItem(d,f);if(f.parentId){d.openItem(f.parentId);}}});return true},_getClosedSubMenuOffset:function(c){var b=a(c.subMenuElement);var f=-b.outerHeight();var e=-b.outerWidth();var d=c.level==0&&this.mode=="horizontal";if(d){e=0;}else {f=0;}switch(c.openVerticalDirection){case"up":case"center":f=b.outerHeight();break}switch(c.openHorizontalDirection){case this._getDir("left"):if(d){e=0;}else {e=b.outerWidth();}break;case"center":if(d){e=0;}else {e=b.outerWidth();}break}return {left:e,top:f}},_closeItem:function(l,o,g,c){if(l==null||o==null){return false}var j=a(o.subMenuElement);var b=o.level==0&&this.mode=="horizontal";var f=this._getClosedSubMenuOffset(o);var m=f.top;var e=f.left;a(o.element);var k=j.closest("div.jqx-menu-popup");if(k!=null){k.removeClass("show");var h=l.animationHideDelay;if(c==true){h=0;}if(j.data("timer")&&j.data("timer").show!=null){clearTimeout(j.data("timer").show);j.data("timer").show=null;}var n=function(){o.isOpen=false;if(b){j.stop().animate({top:m},l.animationHideDuration,function(){a(o.element).removeClass(l.toThemeProperty("jqx-fill-state-pressed"));a(o.element).removeClass(l.toThemeProperty("jqx-menu-item-top-selected"));a(o.element).removeClass(l.toThemeProperty("jqx-rc-b-expanded"));k.removeClass(l.toThemeProperty("jqx-rc-t-expanded"));var p=a(o.arrow);if(p.length>0&&l.showTopLevelArrows){p.removeClass();if(o.openVerticalDirection=="down"){p.addClass(l.toThemeProperty("jqx-menu-item-arrow-down"));p.addClass(l.toThemeProperty("jqx-icon-arrow-down"));}else {p.addClass(l.toThemeProperty("jqx-menu-item-arrow-up"));p.addClass(l.toThemeProperty("jqx-icon-arrow-up"));}}a.jqx.aria(a(o.element),"aria-expanded",false);k.css({display:"none"});if(l.animationHideDuration==0){j.css({top:m});}l._raiseEvent("1",o);});}else {if(!a.jqx.browser.msie);j.stop().animate({left:e},l.animationHideDuration,function(){if(l.animationHideDuration==0){j.css({left:e});}if(o.level>0){a(o.element).removeClass(l.toThemeProperty("jqx-fill-state-pressed"));a(o.element).removeClass(l.toThemeProperty("jqx-menu-item-selected"));var p=a(o.arrow);if(p.length>0){p.removeClass();if(o.openHorizontalDirection!="left"){p.addClass(l.toThemeProperty("jqx-menu-item-arrow-"+l._getDir("right")));p.addClass(l.toThemeProperty("jqx-icon-arrow-"+l._getDir("right")));}else {p.addClass(l.toThemeProperty("jqx-menu-item-arrow-"+l._getDir("left")));p.addClass(l.toThemeProperty("jqx-icon-arrow-"+l._getDir("left")));}}}else {a(o.element).removeClass(l.toThemeProperty("jqx-fill-state-pressed"));a(o.element).removeClass(l.toThemeProperty("jqx-menu-item-top-selected"));var p=a(o.arrow);if(p.length>0){p.removeClass();if(o.openHorizontalDirection!="left"){p.addClass(l.toThemeProperty("jqx-menu-item-arrow-top-"+l._getDir("right")));p.addClass(l.toThemeProperty("jqx-icon-arrow-"+l._getDir("right")));}else {p.addClass(l.toThemeProperty("jqx-menu-item-arrow-top-"+l._getDir("left")));p.addClass(l.toThemeProperty("jqx-icon-arrow-"+l._getDir("left")));}}}a.jqx.aria(a(o.element),"aria-expanded",false);k.css({display:"none"});l._raiseEvent("1",o);});}};if(h>0){if(j.data("timer")){j.data("timer").hide=setTimeout(function(){n();},h);}}else {n();}if(g!=undefined&&g){var d=j.children();a.each(d,function(){if(l.menuElements[this.id]&&l.menuElements[this.id].isOpen){a(l.menuElements[this.id].subMenuElement);l._closeItem(l,l.menuElements[this.id],true,true);}});}}},getSubItems:function(i,h){if(i==null){return false}var g=this;var c=new Array();if(h!=null){a.extend(c,h);}var d=i;var f=this.menuElements[d];var b=a(f.subMenuElement);var e=b.find(".jqx-menu-item");a.each(e,function(){c[this.id]=g.menuElements[this.id];var j=g.getSubItems(this.id,c);a.extend(c,j);});return c},disable:function(g,d){if(g==null){return}var c=g;var f=this;if(this.menuElements[c]){var e=this.menuElements[c];e.disabled=d;var b=a(e.element);e.element.disabled=d;a.each(b.children(),function(){this.disabled=d;});if(d){b.addClass(f.toThemeProperty("jqx-menu-item-disabled"));b.addClass(f.toThemeProperty("jqx-fill-state-disabled"));}else {b.removeClass(f.toThemeProperty("jqx-menu-item-disabled"));b.removeClass(f.toThemeProperty("jqx-fill-state-disabled"));}}},getItem:function(c){if(this.menuElements[c]){var b=this.menuElements[c];return b}return null},disableItem:function(b){this.disable(b,true);},hideItem:function(c){if(this.menuElements[c]){var b=this.menuElements[c];a(b.element).hide();}},showItem:function(c){if(this.menuElements[c]){var b=this.menuElements[c];a(b.element).show();}},enableItem:function(b){this.disable(b,false);},_setItemProperty:function(g,c,f){if(g==null){return}var b=g;if(this.menuElements[b]){var d=this.menuElements[b];if(d[c]){d[c]=f;}}},setItemOpenDirection:function(d,c,e){if(d==null){return}var j=d;var g=this;var f=a.jqx.browser.msie&&a.jqx.browser.version<8;if(this.menuElements[j]){var i=this.menuElements[j];if(c!=null){i.openHorizontalDirection=c;if(i.hasItems&&i.level>0){var h=a(i.element);if(h!=undefined){var b=a(i.arrow);if(i.arrow==null){b=a('<span id="arrow'+h[0].id+'"></span>');if(!f){b.prependTo(h);}else {b.appendTo(h);}i.arrow=b[0];}b.removeClass();if(i.openHorizontalDirection=="left"){b.addClass(g.toThemeProperty("jqx-menu-item-arrow-"+g._getDir("left")));b.addClass(g.toThemeProperty("jqx-icon-arrow-"+g._getDir("left")));}else {b.addClass(g.toThemeProperty("jqx-menu-item-arrow-"+g._getDir("right")));b.addClass(g.toThemeProperty("jqx-icon-arrow-"+g._getDir("right")));}b.css("visibility","inherit");if(!f){b.css("display","block");b.css("float","right");}else {b.css("display","inline-block");b.css("float","none");}}}}if(e!=null){i.openVerticalDirection=e;var b=a(i.arrow);var h=a(i.element);if(!g.showTopLevelArrows){return}if(h!=undefined){if(i.arrow==null){b=a('<span id="arrow'+h[0].id+'"></span>');if(!f){b.prependTo(h);}else {b.appendTo(h);}i.arrow=b[0];}b.removeClass();if(i.openVerticalDirection=="down"){b.addClass(g.toThemeProperty("jqx-menu-item-arrow-down"));b.addClass(g.toThemeProperty("jqx-icon-arrow-down"));}else {b.addClass(g.toThemeProperty("jqx-menu-item-arrow-up"));b.addClass(g.toThemeProperty("jqx-icon-arrow-up"));}b.css("visibility","inherit");if(!f){b.css("display","block");b.css("float","right");}else {b.css("display","inline-block");b.css("float","none");}}}}},_getSiblings:function(d){var e=new Array();var b=0;for(var c=0;c<this.items.length;c++){if(this.items[c]==d){continue}if(this.items[c].parentId==d.parentId&&this.items[c].hasItems){e[b++]=this.items[c];}}return e},_openItem:function(s,r,q){if(s==null||r==null){return false}if(r.isOpen){return false}if(r.disabled){return false}if(s.disabled){return false}var l=s.popupZIndex;if(q!=undefined){l=q;}var e=s.animationHideDuration;s.animationHideDuration=0;s._closeItem(s,r,true,true);s.animationHideDuration=e;a(r.element).focus();var f=[5,5];var t=a(r.subMenuElement);if(t!=null){t.stop();}if(t.data("timer")&&t.data("timer").hide!=null){clearTimeout(t.data("timer").hide);}var o=t.closest("div.jqx-menu-popup");var h=a(r.element);var i=r.level==0?this._getOffset(r.element):h.position();if(r.level>0&&this.hasTransform){var p=parseInt(h.coord().top)-parseInt(this._getOffset(r.element).top);i.top+=p;}if(r.level==0&&this.mode=="popup"){i=h.coord();}var j=r.level==0&&this.mode=="horizontal";var b=j?i.left:this.menuElements[r.parentId]!=null&&this.menuElements[r.parentId].subMenuElement!=null?parseInt(a(a(this.menuElements[r.parentId].subMenuElement).closest("div.jqx-menu-popup")).outerWidth())-f[0]:parseInt(t.outerWidth());o.css({visibility:"visible",display:"block",left:b,top:j?i.top+h.outerHeight():i.top,zIndex:l});t.css("display","block");if(this.mode!="horizontal"&&r.level==0){var d=this._getOffset(this.element);o.css("left",-1+d.left+this.host.outerWidth());t.css("left",-t.outerWidth());}else {var c=this._getClosedSubMenuOffset(r);t.css("left",c.left);t.css("top",c.top);}o.css({height:parseInt(t.outerHeight())+parseInt(f[1])+"px"});var n=0;var g=0;switch(r.openVerticalDirection){case"up":if(j){t.css("top",t.outerHeight());n=f[1];var k=parseInt(t.parent().css("padding-bottom"));if(isNaN(k)){k=0;}if(k>0){o.addClass(this.toThemeProperty("jqx-menu-popup-clear"));}t.css("top",t.outerHeight()-k);o.css({display:"block",top:i.top-o.outerHeight(),zIndex:l});}else {n=f[1];t.css("top",t.outerHeight());o.css({display:"block",top:i.top-o.outerHeight()+f[1]+h.outerHeight(),zIndex:l});}break;case"center":if(j){t.css("top",0);o.css({display:"block",top:i.top-o.outerHeight()/2+f[1],zIndex:l});}else {t.css("top",0);o.css({display:"block",top:i.top+h.outerHeight()/2-o.outerHeight()/2+f[1],zIndex:l});}break}switch(r.openHorizontalDirection){case this._getDir("left"):if(j){o.css({left:i.left-(o.outerWidth()-h.outerWidth()-f[0])});}else {g=0;t.css("left",o.outerWidth());o.css({left:i.left-(o.outerWidth())+2*r.level});}break;case"center":if(j){o.css({left:i.left-(o.outerWidth()/2-h.outerWidth()/2-f[0]/2)});}else {o.css({left:i.left-(o.outerWidth()/2-h.outerWidth()/2-f[0]/2)});t.css("left",o.outerWidth());}break}if(j){if(parseInt(t.css("top"))==n){r.isOpen=true;return}}else {if(parseInt(t.css("left"))==g){r.isOpen==true;return}}a.each(s._getSiblings(r),function(){s._closeItem(s,this,true,true);});var m=a.data(s.element,"animationHideDelay");s.animationHideDelay=m;if(this.autoCloseInterval>0){if(this.host.data("autoclose")!=null&&this.host.data("autoclose").close!=null){clearTimeout(this.host.data("autoclose").close);}if(this.host.data("autoclose")!=null){this.host.data("autoclose").close=setTimeout(function(){s._closeAll();},this.autoCloseInterval);}}if(t.data("timer")){t.data("timer").show=setTimeout(function(){if(o!=null){if(j){t.stop();t.css("left",g);if(!a.jqx.browser.msie);h.addClass(s.toThemeProperty("jqx-fill-state-pressed"));h.addClass(s.toThemeProperty("jqx-menu-item-top-selected"));if(r.openVerticalDirection=="down"){a(r.element).addClass(s.toThemeProperty("jqx-rc-b-expanded"));o.addClass(s.toThemeProperty("jqx-rc-t-expanded"));o.addClass(s.toThemeProperty("show"));}else {a(r.element).addClass(s.toThemeProperty("jqx-rc-t-expanded"));o.addClass(s.toThemeProperty("jqx-rc-b-expanded"));o.addClass(s.toThemeProperty("show"));}var u=a(r.arrow);if(u.length>0&&s.showTopLevelArrows){u.removeClass();if(r.openVerticalDirection=="down"){u.addClass(s.toThemeProperty("jqx-menu-item-arrow-down-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-down"));}else {u.addClass(s.toThemeProperty("jqx-menu-item-arrow-up-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-up"));}}if(s.animationShowDuration==0){t.css({top:n});r.isOpen=true;s._raiseEvent("0",r);a.jqx.aria(a(r.element),"aria-expanded",true);}else {t.animate({top:n},s.animationShowDuration,s.easing,function(){r.isOpen=true;a.jqx.aria(a(r.element),"aria-expanded",true);s._raiseEvent("0",r);});}}else {t.stop();t.css("top",n);o.addClass(s.toThemeProperty("show"));if(!a.jqx.browser.msie);if(r.level>0){h.addClass(s.toThemeProperty("jqx-fill-state-pressed"));h.addClass(s.toThemeProperty("jqx-menu-item-selected"));var u=a(r.arrow);if(u.length>0){u.removeClass();if(r.openHorizontalDirection!="left"){u.addClass(s.toThemeProperty("jqx-menu-item-arrow-"+s._getDir("right")+"-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-"+s._getDir("right")));}else {u.addClass(s.toThemeProperty("jqx-menu-item-arrow-"+s._getDir("left")+"-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-"+s._getDir("left")));}}}else {h.addClass(s.toThemeProperty("jqx-fill-state-pressed"));h.addClass(s.toThemeProperty("jqx-menu-item-top-selected"));var u=a(r.arrow);if(u.length>0){u.removeClass();if(r.openHorizontalDirection!="left"){u.addClass(s.toThemeProperty("jqx-menu-item-arrow-"+s._getDir("right")+"-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-"+s._getDir("right")));}else {u.addClass(s.toThemeProperty("jqx-menu-item-arrow-"+s._getDir("left")+"-selected"));u.addClass(s.toThemeProperty("jqx-icon-arrow-"+s._getDir("left")));}}}if(!a.jqx.browser.msie);if(s.animationShowDuration==0){t.css({left:g});s._raiseEvent("0",r);r.isOpen=true;a.jqx.aria(a(r.element),"aria-expanded",true);}else {t.animate({left:g},s.animationShowDuration,s.easing,function(){s._raiseEvent("0",r);r.isOpen=true;a.jqx.aria(a(r.element),"aria-expanded",true);});}}}},this.animationShowDelay);}},_getDir:function(b){switch(b){case"left":return !this.rtl?"left":"right";case"right":return this.rtl?"left":"right"}return "left"},_applyOrientation:function(i,d){var g=this;var f=0;g.host.removeClass(g.toThemeProperty("jqx-menu-horizontal"));g.host.removeClass(g.toThemeProperty("jqx-menu-vertical"));g.host.removeClass(g.toThemeProperty("jqx-menu"));g.host.removeClass(g.toThemeProperty("jqx-widget"));g.host.addClass(g.toThemeProperty("jqx-widget"));g.host.addClass(g.toThemeProperty("jqx-menu"));if(i!=undefined&&d!=undefined&&d=="popup"){if(g.host.parent().length>0&&g.host.parent().parent().length>0&&g.host.parent().parent()[0]==document.body){var h=a.data(document.body,"jqxMenuOldHost"+g.element.id);if(h!=null){var e=g.host.closest("div.jqx-menu-wrapper");e.remove();e.appendTo(h);g.host.css("display","block");g.host.css("visibility","visible");e.css("display","block");e.css("visibility","visible");}}}else {if(i==undefined&&d==undefined){a.data(document.body,"jqxMenuOldHost"+g.element.id,g.host.parent()[0]);}}if(g.autoOpenPopup){if(g.mode=="popup"){g.addHandler(a(document),"contextmenu."+g.element.id,function(j){return false});g.addHandler(a(document),"mousedown.menu"+g.element.id,function(j){g._openContextMenu(j);});}else {g.removeHandler(a(document),"contextmenu."+g.element.id);g.removeHandler(a(document),"mousedown.menu"+g.element.id);}}else {g.removeHandler(a(document),"contextmenu."+g.element.id);g.removeHandler(a(document),"mousedown.menu"+g.element.id);g.addHandler(a(document),"contextmenu."+g.element.id,function(j){if(j.target&&j.target.className.indexOf&&j.target.className.indexOf("jqx-menu")>=0){return false}});}if(g.rtl){g.host.addClass(g.toThemeProperty("jqx-rtl"));}switch(g.mode){case"horizontal":g.host.addClass(g.toThemeProperty("jqx-widget-header"));g.host.addClass(g.toThemeProperty("jqx-menu-horizontal"));a.each(g.items,function(){var m=this;var k=a(m.element);var l=a(m.arrow);l.removeClass();if(m.hasItems&&m.level>0){var l=a('<span style="border: none; background-color: transparent;" id="arrow'+k[0].id+'"></span>');l.prependTo(k);l.css("float",g._getDir("right"));l.addClass(g.toThemeProperty("jqx-menu-item-arrow-"+g._getDir("right")));l.addClass(g.toThemeProperty("jqx-icon-arrow-"+g._getDir("right")));m.arrow=l[0];}if(m.level==0){a(m.element).css("float",g._getDir("left"));if(!m.ignoretheme&&m.hasItems&&g.showTopLevelArrows){var l=a('<span style="border: none; background-color: transparent;" id="arrow'+k[0].id+'"></span>');var j=a.jqx.browser.msie&&a.jqx.browser.version<8;if(m.arrow==null){if(!j){l.prependTo(k);}else {l.appendTo(k);}}else {l=a(m.arrow);}if(m.openVerticalDirection=="down"){l.addClass(g.toThemeProperty("jqx-menu-item-arrow-down"));l.addClass(g.toThemeProperty("jqx-icon-arrow-down"));}else {l.addClass(g.toThemeProperty("jqx-menu-item-arrow-up"));l.addClass(g.toThemeProperty("jqx-icon-arrow-up"));}l.css("visibility","inherit");if(!j){l.css("display","block");l.css("float","right");}else {l.css("display","inline-block");}m.arrow=l[0];}else {if(!m.ignoretheme&&m.hasItems&&!g.showTopLevelArrows){if(m.arrow!=null){var l=a(m.arrow);l.remove();m.arrow=null;}}}f=Math.max(f,k.height());}});break;case"vertical":case"popup":case"simple":g.host.addClass(g.toThemeProperty("jqx-menu-vertical"));a.each(g.items,function(){var l=this;var j=a(l.element);if(l.hasItems&&!l.ignoretheme){if(l.arrow){a(l.arrow).remove();}if(g.mode=="simple"){return true}var k=a('<span style="border: none; background-color: transparent;" id="arrow'+j[0].id+'"></span>');k.prependTo(j);k.css("float","right");if(l.level==0){k.addClass(g.toThemeProperty("jqx-menu-item-arrow-top-"+g._getDir("right")));k.addClass(g.toThemeProperty("jqx-icon-arrow-"+g._getDir("right")));}else {k.addClass(g.toThemeProperty("jqx-menu-item-arrow-"+g._getDir("right")));k.addClass(g.toThemeProperty("jqx-icon-arrow-"+g._getDir("right")));}l.arrow=k[0];}j.css("float","none");});if(g.mode=="popup"){g.host.addClass(g.toThemeProperty("jqx-widget-content"));g.host.wrap('<div tabindex=0 class="jqx-menu-wrapper" style="z-index:'+g.popupZIndex+'; border: none; background-color: transparent; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: visible;"></div>');var e=g.host.closest("div.jqx-menu-wrapper");g.host.addClass(g.toThemeProperty("jqx-popup"));e[0].id="menuWrapper"+g.element.id;e.appendTo(a(document.body));g.addHandler(e,"keydown",function(j){return g.handleKeyDown(j)});}else {g.host.addClass(g.toThemeProperty("jqx-widget-header"));}if(g.mode=="popup"){var b=g.host.height();g.host.css("position","absolute");g.host.css("top","0");g.host.css("left","0");if(g.mode!="simple"){g.host.height(b);g.host.css("display","none");}}break}var c=g.isTouchDevice();if(g.autoCloseOnClick){g.removeHandler(a(document),"mousedown.menu"+g.element.id,g._closeAfterClick);g.addHandler(a(document),"mousedown.menu"+g.element.id,g._closeAfterClick,g);if(c){g.removeHandler(a(document),a.jqx.mobile.getTouchEventName("touchstart")+".menu"+g.element.id,g._closeAfterClick,g);g.addHandler(a(document),a.jqx.mobile.getTouchEventName("touchstart")+".menu"+g.element.id,g._closeAfterClick,g);}}},_getBodyOffset:function(){var c=0;var b=0;if(a("body").css("border-top-width")!="0px"){c=parseInt(a("body").css("border-top-width"));if(isNaN(c)){c=0;}}if(a("body").css("border-left-width")!="0px"){b=parseInt(a("body").css("border-left-width"));if(isNaN(b)){b=0;}}return {left:b,top:c}},_getOffset:function(c){var e=a.jqx.mobile.isSafariMobileBrowser();var i=a(c).coord(true);var h=i.top;var g=i.left;if(a("body").css("border-top-width")!="0px"){h=parseInt(h)+this._getBodyOffset().top;}if(a("body").css("border-left-width")!="0px"){g=parseInt(g)+this._getBodyOffset().left;}var d=a.jqx.mobile.isWindowsPhone();var f=a.jqx.mobile.isTouchDevice();if(this.hasTransform||(e!=null&&e)||d||f){var b={left:a.jqx.mobile.getLeftPos(c),top:a.jqx.mobile.getTopPos(c)};return b}else {return {left:g,top:h}}},_isRightClick:function(c){var b;if(!c){var c=window.event;}if(c.which){b=(c.which==3);}else {if(c.button){b=(c.button==2);}}return b},_openContextMenu:function(d){var c=this;var b=c._isRightClick(d);if(b){c.open(parseInt(d.clientX)+5,parseInt(d.clientY)+5);}},close:function(){var c=this;var d=a.data(this.element,"contextMenuOpened"+this.element.id);if(d){this.host;c.host.removeClass("jqx-popup-show");a.each(c.items,function(){var e=this;if(e.hasItems){c._closeItem(c,e);}});a.each(c.items,function(){var f=this;if(f.isOpen==true){var e=a(f.subMenuElement);var g=e.closest("div.jqx-menu-popup");g.hide(this.animationHideDuration);}});this.host.hide(this.animationHideDuration);a.data(c.element,"contextMenuOpened"+this.element.id,false);c._raiseEvent("1",c);c._raiseEvent("5");}},open:function(e,d){if(this.mode=="popup"){var c=0;if(this.host.css("display")=="block"){this.close();c=this.animationHideDuration;}var b=this;if(e==undefined||e==null){e=0;}if(d==undefined||d==null){d=0;}setTimeout(function(){b.host.show(b.animationShowDuration);b.host.css("visibility","visible");b.host.addClass("jqx-popup-show");a.data(b.element,"contextMenuOpened"+b.element.id,true);b._raiseEvent("0",b);b._raiseEvent("4",{left:e,top:d});b.host.css("z-index",b.popupZIndex);if(e!=undefined&&d!=undefined){b.host.css({left:e,top:d});}b.focus();},c);}},_renderHover:function(c,e,b){var d=this;if(!e.ignoretheme){this.addHandler(c,"mouseenter",function(){d.hoveredItem=e;if(!e.disabled&&!e.separator&&d.enableHover&&!d.disabled){if(e.level>0){c.addClass(d.toThemeProperty("jqx-fill-state-hover"));c.addClass(d.toThemeProperty("jqx-menu-item-hover"));}else {c.addClass(d.toThemeProperty("jqx-fill-state-hover"));c.addClass(d.toThemeProperty("jqx-menu-item-top-hover"));}}});this.addHandler(c,"mouseleave",function(){if(!e.disabled&&!e.separator&&d.enableHover&&!d.disabled){if(e.level>0){c.removeClass(d.toThemeProperty("jqx-fill-state-hover"));c.removeClass(d.toThemeProperty("jqx-menu-item-hover"));}else {c.removeClass(d.toThemeProperty("jqx-fill-state-hover"));c.removeClass(d.toThemeProperty("jqx-menu-item-top-hover"));}}});}},_closeAfterClick:function(c){var b=c!=null?c.data:this;var d=false;if(b.autoCloseOnClick){a.each(a(c.target).parents(),function(){if(this.className.indexOf){if(this.className.indexOf("jqx-menu")!=-1){d=true;return false}}});if(!d){c.data=b;b._closeAll(c);}}},_autoSizeHorizontalMenuItems:function(){var c=this;if(c.autoSizeMainItems&&this.mode=="horizontal"){var b=this.maxHeight;if(parseInt(b)>parseInt(this.host.height())){b=parseInt(this.host.height());}b=parseInt(this.host.height());a.each(this.items,function(){var m=this;var j=a(m.element);if(m.level==0&&b>0){var d=j.children().length>0?parseInt(j.children().height()):j.height();var g=c.host.find("ul:first");var h=parseInt(g.css("padding-top"));var n=parseInt(g.css("margin-top"));var k=b-2*(n+h);var i=parseInt(k)/2-d/2;var e=parseInt(i);var l=parseInt(i);j.css("padding-top",e);j.css("padding-bottom",l);if(parseInt(j.outerHeight())>k){var f=1;j.css("padding-top",e-f);e=e-f;}}});}a.each(this.items,function(){var g=this;a(g.element);if(g.hasItems&&g.level>0){if(g.arrow){var f=a(g.arrow);var d=a(g.element).height();if(d>15){f.css("margin-top",(d-15)/2);}}}});},_nextVisibleItem:function(c,d){if(c==null||c==undefined){return null}var b=c;while(b!=null){b=b.nextItem;if(this._isVisible(b)&&!b.disabled&&b.type!=="separator"){if(this.minimized){return b}if(d!=undefined){if(b&&b.level!=d){continue}}return b}}return null},_prevVisibleItem:function(c,d){if(c==null||c==undefined){return null}var b=c;while(b!=null){b=b.prevItem;if(this._isVisible(b)&&!b.disabled&&b.type!=="separator"){if(this.minimized){return b}if(d!=undefined){if(b&&b.level!=d){continue}}return b}}return null},_parentItem:function(d){if(d==null||d==undefined){return null}var c=d.parentElement;if(!c){return null}var b=null;a.each(this.items,function(){if(this.element==c){b=this;return false}});return b},_isElementVisible:function(b){if(b==null){return false}if(a(b).css("display")!="none"&&a(b).css("visibility")!="hidden"){return true}return false},_isVisible:function(c){if(c==null||c==undefined){return false}if(!this._isElementVisible(c.element)){return false}var b=this._parentItem(c);if(b==null){return true}if(this.minimized){return true}if(b!=null){if(!this._isElementVisible(b.element)){return false}if(b.isOpen||this.minimized){while(b!=null){b=this._parentItem(b);if(b!=null&&!this._isElementVisible(b.element)){return false}if(b!=null&&!b.isOpen){return false}}}else {return false}}return true},_render:function(f,g){if(this.disabled){this.host.addClass(this.toThemeProperty("jqx-fill-state-disabled"));this.host.addClass(this.toThemeProperty("jqx-menu-disabled"));}if(this.host.attr("tabindex")==undefined){this.host.attr("tabindex",0);}var i=this.popupZIndex;var d=[5,5];var h=this;a.data(h.element,"animationHideDelay",h.animationHideDelay);var e=this.isTouchDevice();var c=e&&(a.jqx.mobile.isWindowsPhone()||navigator.userAgent.indexOf("Touch")>=0);if(navigator.platform.toLowerCase().indexOf("win")!=-1){if(navigator.userAgent.indexOf("Windows Phone")>=0||navigator.userAgent.indexOf("WPDesktop")>=0||navigator.userAgent.indexOf("IEMobile")>=0||navigator.userAgent.indexOf("ZuneWP7")>=0){this.touchDevice=true;}else {if(navigator.userAgent.indexOf("Touch")>=0){var b=("MSPointerDown" in window);if(b||a.jqx.mobile.isWindowsPhone()||navigator.userAgent.indexOf("ARM")>=0){c=true;h.clickToOpen=true;h.autoCloseOnClick=false;h.enableHover=false;}}}}a.data(document.body,"menuel",this);this.hasTransform=a.jqx.utilities.hasTransform(this.host);this._applyOrientation(f,g);this.removeHandler(this.host,"blur");this.removeHandler(this.host,"focus");this.addHandler(this.host,"blur",function(k){if(h.keyboardNavigation){if(h.activeItem){if(h.mode==="popup"){if(document.activeElement&&document.activeElement.className.indexOf("jqx-menu-wrapper")>=0){return}}a(h.activeItem.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=null;}}});this.addHandler(this.host,"focus",function(k){if(h.keyboardNavigation){if(!h.activeItem){if(h.hoveredItem){a(h.hoveredItem.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=h.hoveredItem;}else {var l=function(){if(!a.jqx.isHidden(a(h.items[0].element))){a(h.items[0].element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=h.items[0];}else {var m=h._nextVisibleItem(h.items[0],0);if(m){a(m.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=m;}}};if(!h.activeItem){l();}else {if(!a.jqx.isHidden(a(h.activeItem.element))){a(h.activeItem.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));}else {a(h.activeItem.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));l();}}}}}});this.removeHandler(this.host,"keydown.menu"+this.element.id);h.handleKeyDown=function(k){if(h.keyboardNavigation){if(k.target.nodeName.toLowerCase()==="input"){return true}var q=null;var o=null;a.each(h.items,function(){if(this.disabled){return true}if(this.element.className.indexOf("pressed")>=0){o=this;}if(this.element.className.indexOf("focus")>=0){q=this;return false}});if(!q&&o){q=o;return false}if(!q){a(h.items[0].element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=h.items[0];q=h.activeItem;return false}if(k.keyCode==27){k.data=h;h._closeAll(k);if(q){var z=q;while(z!=null){if(z.parentItem){z=z.parentItem;}else {a(h.activeItem.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=z;a(h.activeItem.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));z=z.parentItem;}}}}if(k.keyCode==13){if(q){h._raiseEvent("2",{item:q.element,event:k,type:"keyboard"});var r=q.anchor!=null?a(q.anchor):null;if(r!=null&&r.length>0){var l=r.attr("href");var u=r.attr("target");if(l!=null){if(u!=null){window.open(l,u);}else {window.location=l;}}}k.preventDefault();k.stopPropagation();a(q.element).focus();}}var n=function(D){if(D==null){return new Array()}var C=new Array();var A=0;for(var B=0;B<h.items.length;B++){if(h.items[B].parentId==D.parentId){C[A++]=h.items[B];}}return C};var v="";switch(k.keyCode){case 40:v="down";break;case 38:v="up";break;case 39:v="right";break;case 37:v="left";break}if(q&&q.openHorizontalDirection==="left"&&v==="left"){v="right";}if(q&&q.openHorizontalDirection==="left"&&v==="right"){v="left";}if(q&&q.openVerticalDirection==="top"&&v==="top"){v="bottom";}if(q&&q.openVerticalDirection==="top"&&v==="bottom"){v="top";}if(h.rtl){if(v==="right"){v="left";}else {if(v==="left"){v="right";}}}if(v==="right"&&!h.minimized){if(k.altKey&&(q.level!=0&&q.hasItems||h.mode!="horizontal")){h._openItem(h,q);}else {var x=h._nextVisibleItem(q,0);var m=h._nextVisibleItem(q);var w=n(m);if(!x){x=m;}if(x&&((x.parentId===q.parentId&&x.level==0&&h.mode=="horizontal")||(m.id==w[0].id&&m.level!=0))){if(m.id==w[0].id&&((q.level!=0)||(q.level==0&&h.mode!="horizontal"))){x=m;}a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}}k.preventDefault();k.stopPropagation();}if(v==="left"&&!h.minimized){if(k.altKey&&((q.level!=0&&h.mode!=="horizontal")||(q.level>1&&h.mode==="horizontal")||(q.level==1&&q.hasItems&&h.mode==="horizontal"))){if(q.hasItems){h._closeItem(h,q);}else {if(q.parentItem){h._closeItem(h,q.parentItem);a(q.parentItem.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=q.parentItem;}}}else {var x=h._prevVisibleItem(q,0);var y=q.parentItem;if(x&&(x.parentId===q.parentId&&x.level==0&&h.mode=="horizontal")){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}else {if(!(y&&y.level==0&&h.mode=="horizontal")&&y&&y.level==q.level-1){a(y.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=y;}}}k.preventDefault();k.stopPropagation();}if(v==="down"){if(k.altKey){if(q.level==0&&q.hasItems){h._openItem(h,q);}if(h.minimized){if(h.minimizedHidden){h.minimizedItem.trigger("click");}}}else {var x=h._nextVisibleItem(q,q.level);var w=n(x);if(h.minimized&&x){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}else {if(x&&(x.parentId===q.parentId||(x.id==w[0].id&&h.mode=="horizontal"))){if(!(x.level==0&&h.mode=="horizontal")){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}}if(h.mode==="horizontal"&&q.level===0&&q.isOpen&&q.hasItems){var x=h._nextVisibleItem(q);a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}}}k.preventDefault();k.stopPropagation();}else {if(v==="up"){if(k.altKey){if(q.parentItem&&q.parentItem.level==0){h._closeItem(h,q.parentItem);a(q.parentItem.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=q.parentItem;}else {if(q.parentItem===null&&q.level===0&&h.mode==="horizontal"){h._closeItem(h,q);}}if(h.minimized){if(!h.minimizedHidden){h.minimizedItem.trigger("click");}}}else {var x=h._prevVisibleItem(q,q.level);var w=n(q);if(h.minimized&&x){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}else {if(x&&(x.parentId===q.parentId||(x.id==q.parentId&&x.level==0&&h.mode=="horizontal"))){if(!(x.level==0&&h.mode==="horizontal"&&q.level===0)){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}}else {if(q&&q.id==w[0].id&&q.parentItem&&q.parentItem.level===0&&h.mode==="horizontal"){var x=q.parentItem;a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;}}}}k.preventDefault();k.stopPropagation();}}if(k.keyCode==9){var x=k.shiftKey?h._prevVisibleItem(q):h._nextVisibleItem(q);if(x){a(x.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=x;k.preventDefault();k.stopPropagation();}else {if(h.lockFocus){var w=new Array();var s=0;for(var p=0;p<h.items.length;p++){if(h.items[p]==q){continue}if(h.items[p].parentId==q.parentId){w[s++]=h.items[p];}}if(w.length>0){if(k.shiftKey){a(w[w.length-1].element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=w[w.length-1];}else {a(w[0].element).addClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=w[0];}a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));}k.preventDefault();k.stopPropagation();}else {if(q){a(q.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));h.activeItem=null;}}}}}else {return true}};this.addHandler(this.host,"keydown.menu"+this.element.id,function(k){h.handleKeyDown(k);});if(h.enableRoundedCorners){this.host.addClass(h.toThemeProperty("jqx-rc-all"));}a.each(this.items,function(){var r=this;var n=a(r.element);n.attr("role","menuitem");if(h.enableRoundedCorners){n.addClass(h.toThemeProperty("jqx-rc-all"));}h.removeHandler(n,"click");h.addHandler(n,"click",function(w){if(r.disabled){return}if(h.disabled){return}if(h.keyboardNavigation){if(h.activeItem){a(h.activeItem.element).removeClass(h.toThemeProperty("jqx-fill-state-focus"));}h.activeItem=r;a(r.element).addClass(h.toThemeProperty("jqx-fill-state-focus"));if(h.minimized){w.stopPropagation();}}h._raiseEvent("2",{type:"mouse",item:r.element,event:w});if(!h.autoOpen){if(r.level>0){if(h.autoCloseOnClick&&!e&&!h.clickToOpen){w.data=h;h._closeAll(w);}}}else {if(h.autoCloseOnClick&&!e&&!h.clickToOpen){if(r.closeOnClick){w.data=h;h._closeAll(w);}}}if(e&&h.autoCloseOnClick){w.data=h;if(!r.hasItems){h._closeAll(w);}}if(w.target.tagName!="A"&&w.target.tagName!="a"){var u=r.anchor!=null?a(r.anchor):null;if(u!=null&&u.length>0){var t=u.attr("href");var v=u.attr("target");if(t!=null){if(v!=null){window.open(t,v);}else {window.location=t;}}}}});h.removeHandler(n,"mouseenter");h.removeHandler(n,"mouseleave");if(!c&&h.mode!="simple"){h._renderHover(n,r,e);}if(r.subMenuElement!=null){var o=a(r.subMenuElement);if(h.mode=="simple"){o.show();return true}o.wrap('<div class="jqx-menu-popup '+h.toThemeProperty("jqx-menu-popup")+'" style="border: none; background-color: transparent; z-index:'+i+'; padding: 0px; margin: 0px; position: absolute; top: 0; left: 0; display: block; visibility: hidden;"><div style="background-color: transparent; border: none; position:absolute; overflow:hidden; left: 0; top: 0; right: 0; width: 100%; height: 100%;"></div></div>');o.css({overflow:"hidden",position:"absolute",left:0,display:"inherit",top:-o.outerHeight()});o.data("timer",{});if(r.level>0){o.css("left",-o.outerWidth());}else {if(h.mode=="horizontal"){o.css("left",0);}}i++;var q=a(r.subMenuElement).closest("div.jqx-menu-popup").css({width:parseInt(a(r.subMenuElement).outerWidth())+parseInt(d[0])+"px",height:parseInt(a(r.subMenuElement).outerHeight())+parseInt(d[1])+"px"});var s=n.closest("div.jqx-menu-popup");if(s.length>0){var k=o.css("margin-left");var m=o.css("margin-right");var l=o.css("padding-left");var p=o.css("padding-right");q.addClass("horizontal");q.appendTo(s);o.css("margin-left",k);o.css("margin-right",m);o.css("padding-left",l);o.css("padding-right",p);}else {var k=o.css("margin-left");var m=o.css("margin-right");var l=o.css("padding-left");var p=o.css("padding-right");if(h.mode==="horizontal"){q.addClass("top");}else {q.addClass("horizontal");}q.appendTo(a(document.body));o.css("margin-left",k);o.css("margin-right",m);o.css("padding-left",l);o.css("padding-right",p);}if(!h.clickToOpen){if(e||c){h.removeHandler(n,a.jqx.mobile.getTouchEventName("touchstart"));h.addHandler(n,a.jqx.mobile.getTouchEventName("touchstart"),function(t){clearTimeout(o.data("timer").hide);if(o!=null){o.stop();}if(r.level==0&&!r.isOpen&&h.mode!="popup"){t.data=h;h._closeAll(t);}if(!r.isOpen){h._openItem(h,r);}else {h._closeItem(h,r,true);}return false});}if(!c){h.addHandler(n,"mouseenter",function(){if(h.autoOpen||(r.level>0&&!h.autoOpen)){clearTimeout(o.data("timer").hide);}if(r.parentId&&r.parentId!=0){if(h.menuElements[r.parentId]){var t=h.menuElements[r.parentId].isOpen;if(!t){return}}}if(h.autoOpen||(r.level>0&&!h.autoOpen)){h._openItem(h,r);}return false});h.addHandler(n,"mousedown",function(){if(!h.autoOpen&&r.level==0){clearTimeout(o.data("timer").hide);if(o!=null){o.stop();}if(!r.isOpen){h._openItem(h,r);}else {h._closeItem(h,r,true);}}});h.addHandler(n,"mouseleave",function(u){if(h.autoCloseOnMouseLeave){clearTimeout(o.data("timer").hide);var x=a(r.subMenuElement);var t={left:parseInt(u.pageX),top:parseInt(u.pageY)};var w={left:parseInt(x.coord().left),top:parseInt(x.coord().top),width:parseInt(x.outerWidth()),height:parseInt(x.outerHeight())};var v=true;if(w.left-5<=t.left&&t.left<=w.left+w.width+5){if(w.top<=t.top&&t.top<=w.top+w.height){v=false;}}if(v){h._closeItem(h,r,true);}}});h.removeHandler(q,"mouseenter");h.addHandler(q,"mouseenter",function(){clearTimeout(o.data("timer").hide);});h.removeHandler(q,"mouseleave");h.addHandler(q,"mouseleave",function(t){if(h.autoCloseOnMouseLeave){clearTimeout(o.data("timer").hide);clearTimeout(o.data("timer").show);if(o!=null){o.stop();}h._closeItem(h,r,true);}});}}else {h.removeHandler(n,"mousedown");h.addHandler(n,"mousedown",function(t){clearTimeout(o.data("timer").hide);if(o!=null){o.stop();}if(r.level==0&&!r.isOpen){t.data=h;h._closeAll(t);}if(!r.isOpen){h._openItem(h,r);}else {h._closeItem(h,r,true);}});}}});if(this.mode=="simple"){this._renderSimpleMode();}this._autoSizeHorizontalMenuItems();this._raiseEvent("3",this);},_renderSimpleMode:function(){this.host.show();},createID:function(){var b=Math.random()+"";b=b.replace(".","");b="99"+b;b=b/1;while(this.items[b]){b=Math.random()+"";b=b.replace(".","");b=b/1;}return "menuItem"+b},_createMenu:function(c,f){if(c==null){return}if(f==undefined){f=true;}if(f==null){f=true;}a(c).addClass("jqx-menu-ul");var u=a(c).find("li");var q=0;this.itemMapping=new Array();for(var j=0;j<u.length;j++){var m=u[j];var s=a(m);if(m.className.indexOf("jqx-menu")==-1&&this.autoGenerate==false){continue}var p=m.id;if(!p){p=this.createID();}if(f){m.id=p;this.items[q]=new a.jqx._jqxMenu.jqxMenuItem();this.menuElements[p]=this.items[q];}q+=1;var t=0;var x=this;var h=s.children();h.each(function(){if(!f){this.className="";if(x.autoGenerate){a(x.items[q-1].subMenuElement)[0].className="";if(!x.minimized){a(x.items[q-1].subMenuElement).addClass(x.toThemeProperty("jqx-widget-content"));}a(x.items[q-1].subMenuElement).addClass(x.toThemeProperty("jqx-menu-dropdown"));a(x.items[q-1].subMenuElement).addClass(x.toThemeProperty("jqx-popup"));}}if(this.className.indexOf("jqx-menu-dropdown")!=-1){if(f){x.items[q-1].subMenuElement=this;}return false}else {if(x.autoGenerate&&(this.tagName=="ul"||this.tagName=="UL")){if(f){x.items[q-1].subMenuElement=this;}this.className="";if(!x.minimized){a(this).addClass(x.toThemeProperty("jqx-widget-content"));}a(this).addClass(x.toThemeProperty("jqx-menu-dropdown"));a(this).addClass(x.toThemeProperty("jqx-popup"));a(this).attr("role","menu");if(x.rtl){a(this).addClass(x.toThemeProperty("jqx-rc-l"));}else {a(this).addClass(x.toThemeProperty("jqx-rc-r"));}a(this).addClass(x.toThemeProperty("jqx-rc-b"));return false}}});var w=s.parents();w.each(function(){if(this.className.indexOf("jqx-menu-item")!=-1){t=this.id;return false}else {if(x.autoGenerate&&(this.tagName=="li"||this.tagName=="LI")){t=this.id;return false}}});var e=false;var d=m.getAttribute("type");var b=m.getAttribute("ignoretheme")||m.getAttribute("data-ignoretheme");if(b){if(b=="true"||b==true){b=true;}}else {b=false;}if(!d){d=m.type;}else {if(d=="separator"){var e=true;}}if(!e){if(t){d="sub";}else {d="top";}}var g=this.items[q-1];if(f){g.id=p;g.parentId=t;g.type=d;g.separator=e;g.element=u[j];var l=s.children("a");g.disabled=m.getAttribute("item-disabled")=="true"?true:false;g.level=s.parents("li").length;g.anchor=l.length>0?l:null;if(g.anchor){a(g.anchor).attr("tabindex",-1);}}g.ignoretheme=b;var n=this.menuElements[t];if(n!=null){if(n.ignoretheme){g.ignoretheme=n.ignoretheme;b=n.ignoretheme;}g.parentItem=n;g.parentElement=n.element;}if(this.autoGenerate){if(d=="separator"){s.removeClass();s.addClass(this.toThemeProperty("jqx-menu-item-separator"));s.attr("role","separator");}else {if(!b){if(s[0].className.indexOf("jqx-grid-menu-item-touch")>=0){s[0].className=this.toThemeProperty("jqx-grid-menu-item-touch");}else {s[0].className="";}if(this.rtl){s.addClass(this.toThemeProperty("jqx-rtl"));}if(g.level>0&&!x.minimized){s.addClass(this.toThemeProperty("jqx-item"));s.addClass(this.toThemeProperty("jqx-menu-item"));}else {s.addClass(this.toThemeProperty("jqx-item"));s.addClass(this.toThemeProperty("jqx-menu-item-top"));}}}}if(g.disabled){s.addClass(x.toThemeProperty("jqx-menu-item-disabled"));s.addClass(x.toThemeProperty("jqx-fill-state-disabled"));}this.itemMapping[j]={element:u[j],item:g};this.itemMapping["id"+u[j].id]=this.itemMapping[j];if(f&&!b){g.hasItems=s.find("li").length>0;if(g.hasItems){if(g.element){a.jqx.aria(a(g.element),"aria-haspopup",true);if(!g.subMenuElement.id){g.subMenuElement.id=a.jqx.utilities.createId();}a.jqx.aria(a(g.element),"aria-owns",g.subMenuElement.id);}}}}for(var r=0;r<u.length;r++){var v=u[r];if(this.itemMapping["id"+v.id]){var g=this.itemMapping["id"+v.id].item;if(!g){continue}g.prevItem=null;g.nextItem=null;if(r>0){if(this.itemMapping["id"+u[r-1].id]){g.prevItem=this.itemMapping["id"+u[r-1].id].item;}}if(r<u.length-1){if(this.itemMapping["id"+u[r+1].id]){g.nextItem=this.itemMapping["id"+u[r+1].id].item;}}}}},destroy:function(){var b=this;a.jqx.utilities.resize(b.host,null,true);var d=b.host.closest("div.jqx-menu-wrapper");b.removeHandler(d,"keydown");d.remove();b.removeHandler(a("#menuWrapper"+b.element.id),"keydown");a("#menuWrapper"+b.element.id).remove();b.removeHandler(b.host,"keydown");b.removeHandler(b.host,"focus");b.removeHandler(b.host,"blur");b.removeHandler(a(document),"mousedown.menu"+b.element.id,b._closeAfterClick);b.removeHandler(a(document),"mouseup.menu"+b.element.id,b._closeAfterClick);b.removeHandler(a(document),"contextmenu."+b.element.id);b.removeHandler(b.host,"contextmenu."+b.element.id);a.data(document.body,"jqxMenuOldHost"+b.element.id,null);if(b.isTouchDevice()){b.removeHandler(a(document),a.jqx.mobile.getTouchEventName("touchstart")+".menu"+b.element.id,b._closeAfterClick,this);}if(a(window).off){a(window).off("resize.menu"+b.element.id);}a.each(b.items,function(){var g=this;var f=a(g.element);b.removeHandler(f,"click");b.removeHandler(f,"selectstart");b.removeHandler(f,"mouseenter");b.removeHandler(f,"mouseleave");b.removeHandler(f,"mousedown");b.removeHandler(f,"mouseleave");var e=a(g.subMenuElement);var h=e.closest("div.jqx-menu-popup");h.remove();delete this.subMenuElement;delete this.element;});a.data(document.body,"menuel",null);delete b.menuElements;b.items=new Array();delete b.items;var c=a.data(b.element,"jqxMenu");if(c){delete c.instance;}b.host.removeClass();b.host.remove();delete b.host;delete b.element;},_raiseEvent:function(g,c){if(c==undefined){c={owner:null};}var d=this.events[g];var e=c;e.owner=this;var f=new a.Event(d);if(g=="2"){e=c.item;e.owner=this;e.clickType=c.type;a.extend(f,c.event);f.type="itemclick";}f.owner=this;f.args=e;var b=this.host.trigger(f);return b},propertiesChangedHandler:function(b,c,e){if(e.width&&e.height&&Object.keys(e).length==2){b._setSize();if(b.mode==="popup"){var d=this.host.closest("div.jqx-menu-wrapper");d[c](e);var f=this.host[0].id;a("#"+f)[c](e);}}},propertyChangedHandler:function(b,d,h,g){if(this.isInitialized==undefined||this.isInitialized==false){return}if(b.batchUpdate&&b.batchUpdate.width&&b.batchUpdate.height&&Object.keys(b.batchUpdate).length==2){return}if(d=="disabled"){if(b.disabled){b.host.addClass(b.toThemeProperty("jqx-fill-state-disabled"));b.host.addClass(b.toThemeProperty("jqx-menu-disabled"));}else {b.host.removeClass(b.toThemeProperty("jqx-fill-state-disabled"));b.host.removeClass(b.toThemeProperty("jqx-menu-disabled"));}}if(g==h){return}if(d=="touchMode"){this._isTouchDevice=null;b._render(g,h);}if(d==="width"||d==="height"){b._setSize();if(b.mode==="popup"){var e=this.host.closest("div.jqx-menu-wrapper");e[d](g);var i=this.host[0].id;a("#"+i)[d](g);}return}if(d=="source"){if(b.source!=null){var c=b.loadItems(b.source);b.element.innerHTML=c;var f=b.host.find("ul:first");if(f.length>0){b.refresh();b._createMenu(f[0]);b._render();}}}if(d=="autoCloseOnClick"){if(g==false){b.removeHandler(a(document),"mousedown.menu"+this.element.id,b._closeAll);}else {b.addHandler(a(document),"mousedown.menu"+this.element.id,b,b._closeAll);}}else {if(d=="mode"||d=="width"||d=="height"||d=="showTopLevelArrows"){b.refresh();if(d=="mode"){b._render(g,h);}else {b._applyOrientation();}}else {if(d=="theme"){a.jqx.utilities.setTheme(h,g,b.host);}}}}});})(jqxBaseFramework);(function(a){a.jqx._jqxMenu.jqxMenuItem=function(e,d,c){var b={id:e,parentId:d,parentItem:null,anchor:null,type:c,disabled:false,level:0,isOpen:false,hasItems:false,element:null,subMenuElement:null,arrow:null,openHorizontalDirection:"right",openVerticalDirection:"down",closeOnClick:true};return b};})(jqxBaseFramework);

/*
       outer_bound_factor = 1.1
       inner_bound_factor = 0.9
       
       move = 180
       outer_boundary = move*outer_bound_factor
       
       inner_boundary = user defined
       inner_boundary = move*inner_bound_factor

  new Job({
	name: "my_job",
	do_list: [calibrate]})new Job({
	name: "my_job",
	do_list: [calibrate]})
       
*/

function calibrate_build_tables({
	J_move_max = [180, 100, 165, 110, 180],
    J_move_min = [-180, -100, -165, -110, -180],
    inner_factor = 1,
    outer_factor = 1.1,
    diff_beta = 5,
    xyz_beta = 5,
    move_speed = 35,
    cal_speed = 30
} = {}){
	
	let DIFF_BETA = 52;
	let XYZ_BETA = 28;
	let J_boundary_max_defaults = [150, 90, 150, 90, 140];
    let J_boundary_min_defaults = [-150, -90, -150, -90, -140];


	let J_move_max_final = [0, 0, 0, 0, 0];
    let J_move_min_final = [0, 0, 0, 0, 0];
	for(let i = 0; i < 5; i++){
        let def_move_max = J_boundary_max_defaults[i];
        let def_move_min = J_boundary_min_defaults[i];
        
        
        if(J_move_max[i] == null){
        	J_move_max_final[i] = def_move_max;
        }else {
        	J_move_max_final[i] = J_move_max[i];
        }
        if(J_move_min[i] == null){
        	J_move_min_final[i] = def_move_min;
        }else {
        	J_move_min_final[i] = J_move_min[i];
        }
        
    }
    
    //Joint 3 moves the opposite direction (2=3)
    J_move_max_final[2] *= -1;
    J_move_min_final[2] *= -1;
    
	let J_outer_max = Vector.multiply(outer_factor, J_move_max_final); 
	let J_outer_min = Vector.multiply(outer_factor, J_move_min_final); 

    let J_inner_max = Vector.multiply(inner_factor, J_move_max_final); 
	let J_inner_min = Vector.multiply(inner_factor, J_move_min_final); 

    
    return [
    	make_ins("w", 42, 832),
        make_ins("w", 42, 512),
        make_ins("w", 79, 50 ^ 100 ),
        make_ins("w", 80, 50 ^ 100 ),
        make_ins("w", 81, 200 ^ 100 ),
        
        //Setting Outer Boundaries. Must be larger than move.
        Dexter.set_parameter("J1BoundryHigh", J_outer_max[0]),
        Dexter.set_parameter("J1BoundryLow", J_outer_min[0]),
        Dexter.set_parameter("J2BoundryHigh", J_outer_max[1]),
        Dexter.set_parameter("J2BoundryLow", J_outer_min[1]),
        Dexter.set_parameter("J3BoundryHigh", J_outer_max[2]),
        Dexter.set_parameter("J3BoundryLow", J_outer_min[2]),
        Dexter.set_parameter("J4BoundryHigh", J_outer_max[3]),
        Dexter.set_parameter("J4BoundryLow", J_outer_min[3]),
        Dexter.set_parameter("J5BoundryHigh", J_outer_max[4]),
        Dexter.set_parameter("J5BoundryLow", J_outer_min[4]),

		//Actual calibration movement:
		make_ins("S", "MaxSpeed", move_speed),
        Dexter.move_all_joints(J_move_max_final),
        make_ins("F"),
        make_ins("S", "MaxSpeed", cal_speed),
        make_ins("w", 42, 3079),
        Dexter.move_all_joints(J_move_min_final),
        make_ins("F"),
        make_ins("w", 42, 0),
        make_ins("S", "MaxSpeed", move_speed),
        make_ins("a", ...[0, 0, 0, 0, 0].arcsec()),

		//Take a bow, loads tables:
        //make_ins("a", ...[20000,20000,20000,20000,20000].arcsec()),
        make_ins("a", [2, 2, 2, 2, 2]),
        make_ins("a", ...[0, 0, 0, 0, 0].arcsec()),
        make_ins("F"),

        Dexter.set_parameter("J1BoundryHigh", J_inner_max[0]),
        Dexter.set_parameter("J1BoundryLow", J_inner_min[0]),
        Dexter.set_parameter("J2BoundryHigh", J_inner_max[1]),
        Dexter.set_parameter("J2BoundryLow", J_inner_min[1]),
        Dexter.set_parameter("J3BoundryHigh", J_inner_max[2]),
        Dexter.set_parameter("J3BoundryLow", J_inner_min[2]),
        Dexter.set_parameter("J4BoundryHigh", J_inner_max[3]),
        Dexter.set_parameter("J4BoundryLow", J_inner_min[3]),
        Dexter.set_parameter("J5BoundryHigh", J_inner_max[4]),
        Dexter.set_parameter("J5BoundryLow", J_inner_min[4]),
        make_ins("w", 79, 50 ^ 100 ),
        make_ins("w", 80, 50 ^ 100 ),
        make_ins("w", 81, 200 ^ 100 ),

        make_ins("w", DIFF_BETA, 5),
        make_ins("w", XYZ_BETA, 5),


        Dexter.sleep(1),
        make_ins("w", 42, 12960),
        
        //Set calibration state
        make_ins("F")
    ]
}

var hasOwn = Object.prototype.hasOwnProperty;
var toStr = Object.prototype.toString;
var defineProperty = Object.defineProperty;
var gOPD = Object.getOwnPropertyDescriptor;

var isArray$1 = function isArray(arr) {
	if (typeof Array.isArray === 'function') {
		return Array.isArray(arr);
	}

	return toStr.call(arr) === '[object Array]';
};

var isPlainObject = function isPlainObject(obj) {
	if (!obj || toStr.call(obj) !== '[object Object]') {
		return false;
	}

	var hasOwnConstructor = hasOwn.call(obj, 'constructor');
	var hasIsPrototypeOf = obj.constructor && obj.constructor.prototype && hasOwn.call(obj.constructor.prototype, 'isPrototypeOf');
	// Not own constructor property must be Object
	if (obj.constructor && !hasOwnConstructor && !hasIsPrototypeOf) {
		return false;
	}

	// Own properties are enumerated firstly, so to speed up,
	// if last one is own, then all properties are own.
	var key;
	for (key in obj) { /**/ }

	return typeof key === 'undefined' || hasOwn.call(obj, key);
};

// If name is '__proto__', and Object.defineProperty is available, define __proto__ as an own property on target
var setProperty = function setProperty(target, options) {
	if (defineProperty && options.name === '__proto__') {
		defineProperty(target, options.name, {
			enumerable: true,
			configurable: true,
			value: options.newValue,
			writable: true
		});
	} else {
		target[options.name] = options.newValue;
	}
};

// Return undefined instead of __proto__ if '__proto__' is not an own property
var getProperty$1 = function getProperty(obj, name) {
	if (name === '__proto__') {
		if (!hasOwn.call(obj, name)) {
			return void 0;
		} else if (gOPD) {
			// In early versions of node, obj['__proto__'] is buggy when obj has
			// __proto__ as an own property. Object.getOwnPropertyDescriptor() works.
			return gOPD(obj, name).value;
		}
	}

	return obj[name];
};

var extend = function extend() {
	var options, name, src, copy, copyIsArray, clone;
	var target = arguments[0];
	var i = 1;
	var length = arguments.length;
	var deep = false;

	// Handle a deep copy situation
	if (typeof target === 'boolean') {
		deep = target;
		target = arguments[1] || {};
		// skip the boolean and the target
		i = 2;
	}
	if (target == null || (typeof target !== 'object' && typeof target !== 'function')) {
		target = {};
	}

	for (; i < length; ++i) {
		options = arguments[i];
		// Only deal with non-null/undefined values
		if (options != null) {
			// Extend the base object
			for (name in options) {
				src = getProperty$1(target, name);
				copy = getProperty$1(options, name);

				// Prevent never-ending loop
				if (target !== copy) {
					// Recurse if we're merging plain objects or arrays
					if (deep && copy && (isPlainObject(copy) || (copyIsArray = isArray$1(copy)))) {
						if (copyIsArray) {
							copyIsArray = false;
							clone = src && isArray$1(src) ? src : [];
						} else {
							clone = src && isPlainObject(src) ? src : {};
						}

						// Never move original objects, clone them
						setProperty(target, { name: name, newValue: extend(deep, clone, copy) });

					// Don't bring in undefined values
					} else if (typeof copy !== 'undefined') {
						setProperty(target, { name: name, newValue: copy });
					}
				}
			}
		}
	}

	// Return the modified object
	return target;
};

var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function createCommonjsModule(fn) {
  var module = { exports: {} };
	return fn(module, module.exports), module.exports;
}

function commonjsRequire (target) {
	throw new Error('Could not dynamically require "' + target + '". Please configure the dynamicRequireTargets option of @rollup/plugin-commonjs appropriately for this require call to behave properly.');
}

var require$$0$4 = [
	"ac",
	"com.ac",
	"edu.ac",
	"gov.ac",
	"net.ac",
	"mil.ac",
	"org.ac",
	"ad",
	"nom.ad",
	"ae",
	"co.ae",
	"net.ae",
	"org.ae",
	"sch.ae",
	"ac.ae",
	"gov.ae",
	"mil.ae",
	"aero",
	"accident-investigation.aero",
	"accident-prevention.aero",
	"aerobatic.aero",
	"aeroclub.aero",
	"aerodrome.aero",
	"agents.aero",
	"aircraft.aero",
	"airline.aero",
	"airport.aero",
	"air-surveillance.aero",
	"airtraffic.aero",
	"air-traffic-control.aero",
	"ambulance.aero",
	"amusement.aero",
	"association.aero",
	"author.aero",
	"ballooning.aero",
	"broker.aero",
	"caa.aero",
	"cargo.aero",
	"catering.aero",
	"certification.aero",
	"championship.aero",
	"charter.aero",
	"civilaviation.aero",
	"club.aero",
	"conference.aero",
	"consultant.aero",
	"consulting.aero",
	"control.aero",
	"council.aero",
	"crew.aero",
	"design.aero",
	"dgca.aero",
	"educator.aero",
	"emergency.aero",
	"engine.aero",
	"engineer.aero",
	"entertainment.aero",
	"equipment.aero",
	"exchange.aero",
	"express.aero",
	"federation.aero",
	"flight.aero",
	"freight.aero",
	"fuel.aero",
	"gliding.aero",
	"government.aero",
	"groundhandling.aero",
	"group.aero",
	"hanggliding.aero",
	"homebuilt.aero",
	"insurance.aero",
	"journal.aero",
	"journalist.aero",
	"leasing.aero",
	"logistics.aero",
	"magazine.aero",
	"maintenance.aero",
	"media.aero",
	"microlight.aero",
	"modelling.aero",
	"navigation.aero",
	"parachuting.aero",
	"paragliding.aero",
	"passenger-association.aero",
	"pilot.aero",
	"press.aero",
	"production.aero",
	"recreation.aero",
	"repbody.aero",
	"res.aero",
	"research.aero",
	"rotorcraft.aero",
	"safety.aero",
	"scientist.aero",
	"services.aero",
	"show.aero",
	"skydiving.aero",
	"software.aero",
	"student.aero",
	"trader.aero",
	"trading.aero",
	"trainer.aero",
	"union.aero",
	"workinggroup.aero",
	"works.aero",
	"af",
	"gov.af",
	"com.af",
	"org.af",
	"net.af",
	"edu.af",
	"ag",
	"com.ag",
	"org.ag",
	"net.ag",
	"co.ag",
	"nom.ag",
	"ai",
	"off.ai",
	"com.ai",
	"net.ai",
	"org.ai",
	"al",
	"com.al",
	"edu.al",
	"gov.al",
	"mil.al",
	"net.al",
	"org.al",
	"am",
	"co.am",
	"com.am",
	"commune.am",
	"net.am",
	"org.am",
	"ao",
	"ed.ao",
	"gv.ao",
	"og.ao",
	"co.ao",
	"pb.ao",
	"it.ao",
	"aq",
	"ar",
	"com.ar",
	"edu.ar",
	"gob.ar",
	"gov.ar",
	"int.ar",
	"mil.ar",
	"musica.ar",
	"net.ar",
	"org.ar",
	"tur.ar",
	"arpa",
	"e164.arpa",
	"in-addr.arpa",
	"ip6.arpa",
	"iris.arpa",
	"uri.arpa",
	"urn.arpa",
	"as",
	"gov.as",
	"asia",
	"at",
	"ac.at",
	"co.at",
	"gv.at",
	"or.at",
	"au",
	"com.au",
	"net.au",
	"org.au",
	"edu.au",
	"gov.au",
	"asn.au",
	"id.au",
	"info.au",
	"conf.au",
	"oz.au",
	"act.au",
	"nsw.au",
	"nt.au",
	"qld.au",
	"sa.au",
	"tas.au",
	"vic.au",
	"wa.au",
	"act.edu.au",
	"catholic.edu.au",
	"nsw.edu.au",
	"nt.edu.au",
	"qld.edu.au",
	"sa.edu.au",
	"tas.edu.au",
	"vic.edu.au",
	"wa.edu.au",
	"qld.gov.au",
	"sa.gov.au",
	"tas.gov.au",
	"vic.gov.au",
	"wa.gov.au",
	"education.tas.edu.au",
	"schools.nsw.edu.au",
	"aw",
	"com.aw",
	"ax",
	"az",
	"com.az",
	"net.az",
	"int.az",
	"gov.az",
	"org.az",
	"edu.az",
	"info.az",
	"pp.az",
	"mil.az",
	"name.az",
	"pro.az",
	"biz.az",
	"ba",
	"com.ba",
	"edu.ba",
	"gov.ba",
	"mil.ba",
	"net.ba",
	"org.ba",
	"bb",
	"biz.bb",
	"co.bb",
	"com.bb",
	"edu.bb",
	"gov.bb",
	"info.bb",
	"net.bb",
	"org.bb",
	"store.bb",
	"tv.bb",
	"*.bd",
	"be",
	"ac.be",
	"bf",
	"gov.bf",
	"bg",
	"a.bg",
	"b.bg",
	"c.bg",
	"d.bg",
	"e.bg",
	"f.bg",
	"g.bg",
	"h.bg",
	"i.bg",
	"j.bg",
	"k.bg",
	"l.bg",
	"m.bg",
	"n.bg",
	"o.bg",
	"p.bg",
	"q.bg",
	"r.bg",
	"s.bg",
	"t.bg",
	"u.bg",
	"v.bg",
	"w.bg",
	"x.bg",
	"y.bg",
	"z.bg",
	"0.bg",
	"1.bg",
	"2.bg",
	"3.bg",
	"4.bg",
	"5.bg",
	"6.bg",
	"7.bg",
	"8.bg",
	"9.bg",
	"bh",
	"com.bh",
	"edu.bh",
	"net.bh",
	"org.bh",
	"gov.bh",
	"bi",
	"co.bi",
	"com.bi",
	"edu.bi",
	"or.bi",
	"org.bi",
	"biz",
	"bj",
	"asso.bj",
	"barreau.bj",
	"gouv.bj",
	"bm",
	"com.bm",
	"edu.bm",
	"gov.bm",
	"net.bm",
	"org.bm",
	"bn",
	"com.bn",
	"edu.bn",
	"gov.bn",
	"net.bn",
	"org.bn",
	"bo",
	"com.bo",
	"edu.bo",
	"gob.bo",
	"int.bo",
	"org.bo",
	"net.bo",
	"mil.bo",
	"tv.bo",
	"web.bo",
	"academia.bo",
	"agro.bo",
	"arte.bo",
	"blog.bo",
	"bolivia.bo",
	"ciencia.bo",
	"cooperativa.bo",
	"democracia.bo",
	"deporte.bo",
	"ecologia.bo",
	"economia.bo",
	"empresa.bo",
	"indigena.bo",
	"industria.bo",
	"info.bo",
	"medicina.bo",
	"movimiento.bo",
	"musica.bo",
	"natural.bo",
	"nombre.bo",
	"noticias.bo",
	"patria.bo",
	"politica.bo",
	"profesional.bo",
	"plurinacional.bo",
	"pueblo.bo",
	"revista.bo",
	"salud.bo",
	"tecnologia.bo",
	"tksat.bo",
	"transporte.bo",
	"wiki.bo",
	"br",
	"9guacu.br",
	"abc.br",
	"adm.br",
	"adv.br",
	"agr.br",
	"aju.br",
	"am.br",
	"anani.br",
	"aparecida.br",
	"arq.br",
	"art.br",
	"ato.br",
	"b.br",
	"barueri.br",
	"belem.br",
	"bhz.br",
	"bio.br",
	"blog.br",
	"bmd.br",
	"boavista.br",
	"bsb.br",
	"campinagrande.br",
	"campinas.br",
	"caxias.br",
	"cim.br",
	"cng.br",
	"cnt.br",
	"com.br",
	"contagem.br",
	"coop.br",
	"cri.br",
	"cuiaba.br",
	"curitiba.br",
	"def.br",
	"ecn.br",
	"eco.br",
	"edu.br",
	"emp.br",
	"eng.br",
	"esp.br",
	"etc.br",
	"eti.br",
	"far.br",
	"feira.br",
	"flog.br",
	"floripa.br",
	"fm.br",
	"fnd.br",
	"fortal.br",
	"fot.br",
	"foz.br",
	"fst.br",
	"g12.br",
	"ggf.br",
	"goiania.br",
	"gov.br",
	"ac.gov.br",
	"al.gov.br",
	"am.gov.br",
	"ap.gov.br",
	"ba.gov.br",
	"ce.gov.br",
	"df.gov.br",
	"es.gov.br",
	"go.gov.br",
	"ma.gov.br",
	"mg.gov.br",
	"ms.gov.br",
	"mt.gov.br",
	"pa.gov.br",
	"pb.gov.br",
	"pe.gov.br",
	"pi.gov.br",
	"pr.gov.br",
	"rj.gov.br",
	"rn.gov.br",
	"ro.gov.br",
	"rr.gov.br",
	"rs.gov.br",
	"sc.gov.br",
	"se.gov.br",
	"sp.gov.br",
	"to.gov.br",
	"gru.br",
	"imb.br",
	"ind.br",
	"inf.br",
	"jab.br",
	"jampa.br",
	"jdf.br",
	"joinville.br",
	"jor.br",
	"jus.br",
	"leg.br",
	"lel.br",
	"londrina.br",
	"macapa.br",
	"maceio.br",
	"manaus.br",
	"maringa.br",
	"mat.br",
	"med.br",
	"mil.br",
	"morena.br",
	"mp.br",
	"mus.br",
	"natal.br",
	"net.br",
	"niteroi.br",
	"*.nom.br",
	"not.br",
	"ntr.br",
	"odo.br",
	"ong.br",
	"org.br",
	"osasco.br",
	"palmas.br",
	"poa.br",
	"ppg.br",
	"pro.br",
	"psc.br",
	"psi.br",
	"pvh.br",
	"qsl.br",
	"radio.br",
	"rec.br",
	"recife.br",
	"ribeirao.br",
	"rio.br",
	"riobranco.br",
	"riopreto.br",
	"salvador.br",
	"sampa.br",
	"santamaria.br",
	"santoandre.br",
	"saobernardo.br",
	"saogonca.br",
	"sjc.br",
	"slg.br",
	"slz.br",
	"sorocaba.br",
	"srv.br",
	"taxi.br",
	"tc.br",
	"teo.br",
	"the.br",
	"tmp.br",
	"trd.br",
	"tur.br",
	"tv.br",
	"udi.br",
	"vet.br",
	"vix.br",
	"vlog.br",
	"wiki.br",
	"zlg.br",
	"bs",
	"com.bs",
	"net.bs",
	"org.bs",
	"edu.bs",
	"gov.bs",
	"bt",
	"com.bt",
	"edu.bt",
	"gov.bt",
	"net.bt",
	"org.bt",
	"bv",
	"bw",
	"co.bw",
	"org.bw",
	"by",
	"gov.by",
	"mil.by",
	"com.by",
	"of.by",
	"bz",
	"com.bz",
	"net.bz",
	"org.bz",
	"edu.bz",
	"gov.bz",
	"ca",
	"ab.ca",
	"bc.ca",
	"mb.ca",
	"nb.ca",
	"nf.ca",
	"nl.ca",
	"ns.ca",
	"nt.ca",
	"nu.ca",
	"on.ca",
	"pe.ca",
	"qc.ca",
	"sk.ca",
	"yk.ca",
	"gc.ca",
	"cat",
	"cc",
	"cd",
	"gov.cd",
	"cf",
	"cg",
	"ch",
	"ci",
	"org.ci",
	"or.ci",
	"com.ci",
	"co.ci",
	"edu.ci",
	"ed.ci",
	"ac.ci",
	"net.ci",
	"go.ci",
	"asso.ci",
	"aéroport.ci",
	"int.ci",
	"presse.ci",
	"md.ci",
	"gouv.ci",
	"*.ck",
	"!www.ck",
	"cl",
	"aprendemas.cl",
	"co.cl",
	"gob.cl",
	"gov.cl",
	"mil.cl",
	"cm",
	"co.cm",
	"com.cm",
	"gov.cm",
	"net.cm",
	"cn",
	"ac.cn",
	"com.cn",
	"edu.cn",
	"gov.cn",
	"net.cn",
	"org.cn",
	"mil.cn",
	"公司.cn",
	"网络.cn",
	"網絡.cn",
	"ah.cn",
	"bj.cn",
	"cq.cn",
	"fj.cn",
	"gd.cn",
	"gs.cn",
	"gz.cn",
	"gx.cn",
	"ha.cn",
	"hb.cn",
	"he.cn",
	"hi.cn",
	"hl.cn",
	"hn.cn",
	"jl.cn",
	"js.cn",
	"jx.cn",
	"ln.cn",
	"nm.cn",
	"nx.cn",
	"qh.cn",
	"sc.cn",
	"sd.cn",
	"sh.cn",
	"sn.cn",
	"sx.cn",
	"tj.cn",
	"xj.cn",
	"xz.cn",
	"yn.cn",
	"zj.cn",
	"hk.cn",
	"mo.cn",
	"tw.cn",
	"co",
	"arts.co",
	"com.co",
	"edu.co",
	"firm.co",
	"gov.co",
	"info.co",
	"int.co",
	"mil.co",
	"net.co",
	"nom.co",
	"org.co",
	"rec.co",
	"web.co",
	"com",
	"coop",
	"cr",
	"ac.cr",
	"co.cr",
	"ed.cr",
	"fi.cr",
	"go.cr",
	"or.cr",
	"sa.cr",
	"cu",
	"com.cu",
	"edu.cu",
	"org.cu",
	"net.cu",
	"gov.cu",
	"inf.cu",
	"cv",
	"cw",
	"com.cw",
	"edu.cw",
	"net.cw",
	"org.cw",
	"cx",
	"gov.cx",
	"cy",
	"ac.cy",
	"biz.cy",
	"com.cy",
	"ekloges.cy",
	"gov.cy",
	"ltd.cy",
	"name.cy",
	"net.cy",
	"org.cy",
	"parliament.cy",
	"press.cy",
	"pro.cy",
	"tm.cy",
	"cz",
	"de",
	"dj",
	"dk",
	"dm",
	"com.dm",
	"net.dm",
	"org.dm",
	"edu.dm",
	"gov.dm",
	"do",
	"art.do",
	"com.do",
	"edu.do",
	"gob.do",
	"gov.do",
	"mil.do",
	"net.do",
	"org.do",
	"sld.do",
	"web.do",
	"dz",
	"com.dz",
	"org.dz",
	"net.dz",
	"gov.dz",
	"edu.dz",
	"asso.dz",
	"pol.dz",
	"art.dz",
	"ec",
	"com.ec",
	"info.ec",
	"net.ec",
	"fin.ec",
	"k12.ec",
	"med.ec",
	"pro.ec",
	"org.ec",
	"edu.ec",
	"gov.ec",
	"gob.ec",
	"mil.ec",
	"edu",
	"ee",
	"edu.ee",
	"gov.ee",
	"riik.ee",
	"lib.ee",
	"med.ee",
	"com.ee",
	"pri.ee",
	"aip.ee",
	"org.ee",
	"fie.ee",
	"eg",
	"com.eg",
	"edu.eg",
	"eun.eg",
	"gov.eg",
	"mil.eg",
	"name.eg",
	"net.eg",
	"org.eg",
	"sci.eg",
	"*.er",
	"es",
	"com.es",
	"nom.es",
	"org.es",
	"gob.es",
	"edu.es",
	"et",
	"com.et",
	"gov.et",
	"org.et",
	"edu.et",
	"biz.et",
	"name.et",
	"info.et",
	"net.et",
	"eu",
	"fi",
	"aland.fi",
	"fj",
	"ac.fj",
	"biz.fj",
	"com.fj",
	"gov.fj",
	"info.fj",
	"mil.fj",
	"name.fj",
	"net.fj",
	"org.fj",
	"pro.fj",
	"*.fk",
	"fm",
	"fo",
	"fr",
	"asso.fr",
	"com.fr",
	"gouv.fr",
	"nom.fr",
	"prd.fr",
	"tm.fr",
	"aeroport.fr",
	"avocat.fr",
	"avoues.fr",
	"cci.fr",
	"chambagri.fr",
	"chirurgiens-dentistes.fr",
	"experts-comptables.fr",
	"geometre-expert.fr",
	"greta.fr",
	"huissier-justice.fr",
	"medecin.fr",
	"notaires.fr",
	"pharmacien.fr",
	"port.fr",
	"veterinaire.fr",
	"ga",
	"gb",
	"gd",
	"ge",
	"com.ge",
	"edu.ge",
	"gov.ge",
	"org.ge",
	"mil.ge",
	"net.ge",
	"pvt.ge",
	"gf",
	"gg",
	"co.gg",
	"net.gg",
	"org.gg",
	"gh",
	"com.gh",
	"edu.gh",
	"gov.gh",
	"org.gh",
	"mil.gh",
	"gi",
	"com.gi",
	"ltd.gi",
	"gov.gi",
	"mod.gi",
	"edu.gi",
	"org.gi",
	"gl",
	"co.gl",
	"com.gl",
	"edu.gl",
	"net.gl",
	"org.gl",
	"gm",
	"gn",
	"ac.gn",
	"com.gn",
	"edu.gn",
	"gov.gn",
	"org.gn",
	"net.gn",
	"gov",
	"gp",
	"com.gp",
	"net.gp",
	"mobi.gp",
	"edu.gp",
	"org.gp",
	"asso.gp",
	"gq",
	"gr",
	"com.gr",
	"edu.gr",
	"net.gr",
	"org.gr",
	"gov.gr",
	"gs",
	"gt",
	"com.gt",
	"edu.gt",
	"gob.gt",
	"ind.gt",
	"mil.gt",
	"net.gt",
	"org.gt",
	"gu",
	"com.gu",
	"edu.gu",
	"gov.gu",
	"guam.gu",
	"info.gu",
	"net.gu",
	"org.gu",
	"web.gu",
	"gw",
	"gy",
	"co.gy",
	"com.gy",
	"edu.gy",
	"gov.gy",
	"net.gy",
	"org.gy",
	"hk",
	"com.hk",
	"edu.hk",
	"gov.hk",
	"idv.hk",
	"net.hk",
	"org.hk",
	"公司.hk",
	"教育.hk",
	"敎育.hk",
	"政府.hk",
	"個人.hk",
	"个人.hk",
	"箇人.hk",
	"網络.hk",
	"网络.hk",
	"组織.hk",
	"網絡.hk",
	"网絡.hk",
	"组织.hk",
	"組織.hk",
	"組织.hk",
	"hm",
	"hn",
	"com.hn",
	"edu.hn",
	"org.hn",
	"net.hn",
	"mil.hn",
	"gob.hn",
	"hr",
	"iz.hr",
	"from.hr",
	"name.hr",
	"com.hr",
	"ht",
	"com.ht",
	"shop.ht",
	"firm.ht",
	"info.ht",
	"adult.ht",
	"net.ht",
	"pro.ht",
	"org.ht",
	"med.ht",
	"art.ht",
	"coop.ht",
	"pol.ht",
	"asso.ht",
	"edu.ht",
	"rel.ht",
	"gouv.ht",
	"perso.ht",
	"hu",
	"co.hu",
	"info.hu",
	"org.hu",
	"priv.hu",
	"sport.hu",
	"tm.hu",
	"2000.hu",
	"agrar.hu",
	"bolt.hu",
	"casino.hu",
	"city.hu",
	"erotica.hu",
	"erotika.hu",
	"film.hu",
	"forum.hu",
	"games.hu",
	"hotel.hu",
	"ingatlan.hu",
	"jogasz.hu",
	"konyvelo.hu",
	"lakas.hu",
	"media.hu",
	"news.hu",
	"reklam.hu",
	"sex.hu",
	"shop.hu",
	"suli.hu",
	"szex.hu",
	"tozsde.hu",
	"utazas.hu",
	"video.hu",
	"id",
	"ac.id",
	"biz.id",
	"co.id",
	"desa.id",
	"go.id",
	"mil.id",
	"my.id",
	"net.id",
	"or.id",
	"ponpes.id",
	"sch.id",
	"web.id",
	"ie",
	"gov.ie",
	"il",
	"ac.il",
	"co.il",
	"gov.il",
	"idf.il",
	"k12.il",
	"muni.il",
	"net.il",
	"org.il",
	"im",
	"ac.im",
	"co.im",
	"com.im",
	"ltd.co.im",
	"net.im",
	"org.im",
	"plc.co.im",
	"tt.im",
	"tv.im",
	"in",
	"co.in",
	"firm.in",
	"net.in",
	"org.in",
	"gen.in",
	"ind.in",
	"nic.in",
	"ac.in",
	"edu.in",
	"res.in",
	"gov.in",
	"mil.in",
	"info",
	"int",
	"eu.int",
	"io",
	"com.io",
	"iq",
	"gov.iq",
	"edu.iq",
	"mil.iq",
	"com.iq",
	"org.iq",
	"net.iq",
	"ir",
	"ac.ir",
	"co.ir",
	"gov.ir",
	"id.ir",
	"net.ir",
	"org.ir",
	"sch.ir",
	"ایران.ir",
	"ايران.ir",
	"is",
	"net.is",
	"com.is",
	"edu.is",
	"gov.is",
	"org.is",
	"int.is",
	"it",
	"gov.it",
	"edu.it",
	"abr.it",
	"abruzzo.it",
	"aosta-valley.it",
	"aostavalley.it",
	"bas.it",
	"basilicata.it",
	"cal.it",
	"calabria.it",
	"cam.it",
	"campania.it",
	"emilia-romagna.it",
	"emiliaromagna.it",
	"emr.it",
	"friuli-v-giulia.it",
	"friuli-ve-giulia.it",
	"friuli-vegiulia.it",
	"friuli-venezia-giulia.it",
	"friuli-veneziagiulia.it",
	"friuli-vgiulia.it",
	"friuliv-giulia.it",
	"friulive-giulia.it",
	"friulivegiulia.it",
	"friulivenezia-giulia.it",
	"friuliveneziagiulia.it",
	"friulivgiulia.it",
	"fvg.it",
	"laz.it",
	"lazio.it",
	"lig.it",
	"liguria.it",
	"lom.it",
	"lombardia.it",
	"lombardy.it",
	"lucania.it",
	"mar.it",
	"marche.it",
	"mol.it",
	"molise.it",
	"piedmont.it",
	"piemonte.it",
	"pmn.it",
	"pug.it",
	"puglia.it",
	"sar.it",
	"sardegna.it",
	"sardinia.it",
	"sic.it",
	"sicilia.it",
	"sicily.it",
	"taa.it",
	"tos.it",
	"toscana.it",
	"trentin-sud-tirol.it",
	"trentin-süd-tirol.it",
	"trentin-sudtirol.it",
	"trentin-südtirol.it",
	"trentin-sued-tirol.it",
	"trentin-suedtirol.it",
	"trentino-a-adige.it",
	"trentino-aadige.it",
	"trentino-alto-adige.it",
	"trentino-altoadige.it",
	"trentino-s-tirol.it",
	"trentino-stirol.it",
	"trentino-sud-tirol.it",
	"trentino-süd-tirol.it",
	"trentino-sudtirol.it",
	"trentino-südtirol.it",
	"trentino-sued-tirol.it",
	"trentino-suedtirol.it",
	"trentino.it",
	"trentinoa-adige.it",
	"trentinoaadige.it",
	"trentinoalto-adige.it",
	"trentinoaltoadige.it",
	"trentinos-tirol.it",
	"trentinostirol.it",
	"trentinosud-tirol.it",
	"trentinosüd-tirol.it",
	"trentinosudtirol.it",
	"trentinosüdtirol.it",
	"trentinosued-tirol.it",
	"trentinosuedtirol.it",
	"trentinsud-tirol.it",
	"trentinsüd-tirol.it",
	"trentinsudtirol.it",
	"trentinsüdtirol.it",
	"trentinsued-tirol.it",
	"trentinsuedtirol.it",
	"tuscany.it",
	"umb.it",
	"umbria.it",
	"val-d-aosta.it",
	"val-daosta.it",
	"vald-aosta.it",
	"valdaosta.it",
	"valle-aosta.it",
	"valle-d-aosta.it",
	"valle-daosta.it",
	"valleaosta.it",
	"valled-aosta.it",
	"valledaosta.it",
	"vallee-aoste.it",
	"vallée-aoste.it",
	"vallee-d-aoste.it",
	"vallée-d-aoste.it",
	"valleeaoste.it",
	"valléeaoste.it",
	"valleedaoste.it",
	"valléedaoste.it",
	"vao.it",
	"vda.it",
	"ven.it",
	"veneto.it",
	"ag.it",
	"agrigento.it",
	"al.it",
	"alessandria.it",
	"alto-adige.it",
	"altoadige.it",
	"an.it",
	"ancona.it",
	"andria-barletta-trani.it",
	"andria-trani-barletta.it",
	"andriabarlettatrani.it",
	"andriatranibarletta.it",
	"ao.it",
	"aosta.it",
	"aoste.it",
	"ap.it",
	"aq.it",
	"aquila.it",
	"ar.it",
	"arezzo.it",
	"ascoli-piceno.it",
	"ascolipiceno.it",
	"asti.it",
	"at.it",
	"av.it",
	"avellino.it",
	"ba.it",
	"balsan-sudtirol.it",
	"balsan-südtirol.it",
	"balsan-suedtirol.it",
	"balsan.it",
	"bari.it",
	"barletta-trani-andria.it",
	"barlettatraniandria.it",
	"belluno.it",
	"benevento.it",
	"bergamo.it",
	"bg.it",
	"bi.it",
	"biella.it",
	"bl.it",
	"bn.it",
	"bo.it",
	"bologna.it",
	"bolzano-altoadige.it",
	"bolzano.it",
	"bozen-sudtirol.it",
	"bozen-südtirol.it",
	"bozen-suedtirol.it",
	"bozen.it",
	"br.it",
	"brescia.it",
	"brindisi.it",
	"bs.it",
	"bt.it",
	"bulsan-sudtirol.it",
	"bulsan-südtirol.it",
	"bulsan-suedtirol.it",
	"bulsan.it",
	"bz.it",
	"ca.it",
	"cagliari.it",
	"caltanissetta.it",
	"campidano-medio.it",
	"campidanomedio.it",
	"campobasso.it",
	"carbonia-iglesias.it",
	"carboniaiglesias.it",
	"carrara-massa.it",
	"carraramassa.it",
	"caserta.it",
	"catania.it",
	"catanzaro.it",
	"cb.it",
	"ce.it",
	"cesena-forli.it",
	"cesena-forlì.it",
	"cesenaforli.it",
	"cesenaforlì.it",
	"ch.it",
	"chieti.it",
	"ci.it",
	"cl.it",
	"cn.it",
	"co.it",
	"como.it",
	"cosenza.it",
	"cr.it",
	"cremona.it",
	"crotone.it",
	"cs.it",
	"ct.it",
	"cuneo.it",
	"cz.it",
	"dell-ogliastra.it",
	"dellogliastra.it",
	"en.it",
	"enna.it",
	"fc.it",
	"fe.it",
	"fermo.it",
	"ferrara.it",
	"fg.it",
	"fi.it",
	"firenze.it",
	"florence.it",
	"fm.it",
	"foggia.it",
	"forli-cesena.it",
	"forlì-cesena.it",
	"forlicesena.it",
	"forlìcesena.it",
	"fr.it",
	"frosinone.it",
	"ge.it",
	"genoa.it",
	"genova.it",
	"go.it",
	"gorizia.it",
	"gr.it",
	"grosseto.it",
	"iglesias-carbonia.it",
	"iglesiascarbonia.it",
	"im.it",
	"imperia.it",
	"is.it",
	"isernia.it",
	"kr.it",
	"la-spezia.it",
	"laquila.it",
	"laspezia.it",
	"latina.it",
	"lc.it",
	"le.it",
	"lecce.it",
	"lecco.it",
	"li.it",
	"livorno.it",
	"lo.it",
	"lodi.it",
	"lt.it",
	"lu.it",
	"lucca.it",
	"macerata.it",
	"mantova.it",
	"massa-carrara.it",
	"massacarrara.it",
	"matera.it",
	"mb.it",
	"mc.it",
	"me.it",
	"medio-campidano.it",
	"mediocampidano.it",
	"messina.it",
	"mi.it",
	"milan.it",
	"milano.it",
	"mn.it",
	"mo.it",
	"modena.it",
	"monza-brianza.it",
	"monza-e-della-brianza.it",
	"monza.it",
	"monzabrianza.it",
	"monzaebrianza.it",
	"monzaedellabrianza.it",
	"ms.it",
	"mt.it",
	"na.it",
	"naples.it",
	"napoli.it",
	"no.it",
	"novara.it",
	"nu.it",
	"nuoro.it",
	"og.it",
	"ogliastra.it",
	"olbia-tempio.it",
	"olbiatempio.it",
	"or.it",
	"oristano.it",
	"ot.it",
	"pa.it",
	"padova.it",
	"padua.it",
	"palermo.it",
	"parma.it",
	"pavia.it",
	"pc.it",
	"pd.it",
	"pe.it",
	"perugia.it",
	"pesaro-urbino.it",
	"pesarourbino.it",
	"pescara.it",
	"pg.it",
	"pi.it",
	"piacenza.it",
	"pisa.it",
	"pistoia.it",
	"pn.it",
	"po.it",
	"pordenone.it",
	"potenza.it",
	"pr.it",
	"prato.it",
	"pt.it",
	"pu.it",
	"pv.it",
	"pz.it",
	"ra.it",
	"ragusa.it",
	"ravenna.it",
	"rc.it",
	"re.it",
	"reggio-calabria.it",
	"reggio-emilia.it",
	"reggiocalabria.it",
	"reggioemilia.it",
	"rg.it",
	"ri.it",
	"rieti.it",
	"rimini.it",
	"rm.it",
	"rn.it",
	"ro.it",
	"roma.it",
	"rome.it",
	"rovigo.it",
	"sa.it",
	"salerno.it",
	"sassari.it",
	"savona.it",
	"si.it",
	"siena.it",
	"siracusa.it",
	"so.it",
	"sondrio.it",
	"sp.it",
	"sr.it",
	"ss.it",
	"suedtirol.it",
	"südtirol.it",
	"sv.it",
	"ta.it",
	"taranto.it",
	"te.it",
	"tempio-olbia.it",
	"tempioolbia.it",
	"teramo.it",
	"terni.it",
	"tn.it",
	"to.it",
	"torino.it",
	"tp.it",
	"tr.it",
	"trani-andria-barletta.it",
	"trani-barletta-andria.it",
	"traniandriabarletta.it",
	"tranibarlettaandria.it",
	"trapani.it",
	"trento.it",
	"treviso.it",
	"trieste.it",
	"ts.it",
	"turin.it",
	"tv.it",
	"ud.it",
	"udine.it",
	"urbino-pesaro.it",
	"urbinopesaro.it",
	"va.it",
	"varese.it",
	"vb.it",
	"vc.it",
	"ve.it",
	"venezia.it",
	"venice.it",
	"verbania.it",
	"vercelli.it",
	"verona.it",
	"vi.it",
	"vibo-valentia.it",
	"vibovalentia.it",
	"vicenza.it",
	"viterbo.it",
	"vr.it",
	"vs.it",
	"vt.it",
	"vv.it",
	"je",
	"co.je",
	"net.je",
	"org.je",
	"*.jm",
	"jo",
	"com.jo",
	"org.jo",
	"net.jo",
	"edu.jo",
	"sch.jo",
	"gov.jo",
	"mil.jo",
	"name.jo",
	"jobs",
	"jp",
	"ac.jp",
	"ad.jp",
	"co.jp",
	"ed.jp",
	"go.jp",
	"gr.jp",
	"lg.jp",
	"ne.jp",
	"or.jp",
	"aichi.jp",
	"akita.jp",
	"aomori.jp",
	"chiba.jp",
	"ehime.jp",
	"fukui.jp",
	"fukuoka.jp",
	"fukushima.jp",
	"gifu.jp",
	"gunma.jp",
	"hiroshima.jp",
	"hokkaido.jp",
	"hyogo.jp",
	"ibaraki.jp",
	"ishikawa.jp",
	"iwate.jp",
	"kagawa.jp",
	"kagoshima.jp",
	"kanagawa.jp",
	"kochi.jp",
	"kumamoto.jp",
	"kyoto.jp",
	"mie.jp",
	"miyagi.jp",
	"miyazaki.jp",
	"nagano.jp",
	"nagasaki.jp",
	"nara.jp",
	"niigata.jp",
	"oita.jp",
	"okayama.jp",
	"okinawa.jp",
	"osaka.jp",
	"saga.jp",
	"saitama.jp",
	"shiga.jp",
	"shimane.jp",
	"shizuoka.jp",
	"tochigi.jp",
	"tokushima.jp",
	"tokyo.jp",
	"tottori.jp",
	"toyama.jp",
	"wakayama.jp",
	"yamagata.jp",
	"yamaguchi.jp",
	"yamanashi.jp",
	"栃木.jp",
	"愛知.jp",
	"愛媛.jp",
	"兵庫.jp",
	"熊本.jp",
	"茨城.jp",
	"北海道.jp",
	"千葉.jp",
	"和歌山.jp",
	"長崎.jp",
	"長野.jp",
	"新潟.jp",
	"青森.jp",
	"静岡.jp",
	"東京.jp",
	"石川.jp",
	"埼玉.jp",
	"三重.jp",
	"京都.jp",
	"佐賀.jp",
	"大分.jp",
	"大阪.jp",
	"奈良.jp",
	"宮城.jp",
	"宮崎.jp",
	"富山.jp",
	"山口.jp",
	"山形.jp",
	"山梨.jp",
	"岩手.jp",
	"岐阜.jp",
	"岡山.jp",
	"島根.jp",
	"広島.jp",
	"徳島.jp",
	"沖縄.jp",
	"滋賀.jp",
	"神奈川.jp",
	"福井.jp",
	"福岡.jp",
	"福島.jp",
	"秋田.jp",
	"群馬.jp",
	"香川.jp",
	"高知.jp",
	"鳥取.jp",
	"鹿児島.jp",
	"*.kawasaki.jp",
	"*.kitakyushu.jp",
	"*.kobe.jp",
	"*.nagoya.jp",
	"*.sapporo.jp",
	"*.sendai.jp",
	"*.yokohama.jp",
	"!city.kawasaki.jp",
	"!city.kitakyushu.jp",
	"!city.kobe.jp",
	"!city.nagoya.jp",
	"!city.sapporo.jp",
	"!city.sendai.jp",
	"!city.yokohama.jp",
	"aisai.aichi.jp",
	"ama.aichi.jp",
	"anjo.aichi.jp",
	"asuke.aichi.jp",
	"chiryu.aichi.jp",
	"chita.aichi.jp",
	"fuso.aichi.jp",
	"gamagori.aichi.jp",
	"handa.aichi.jp",
	"hazu.aichi.jp",
	"hekinan.aichi.jp",
	"higashiura.aichi.jp",
	"ichinomiya.aichi.jp",
	"inazawa.aichi.jp",
	"inuyama.aichi.jp",
	"isshiki.aichi.jp",
	"iwakura.aichi.jp",
	"kanie.aichi.jp",
	"kariya.aichi.jp",
	"kasugai.aichi.jp",
	"kira.aichi.jp",
	"kiyosu.aichi.jp",
	"komaki.aichi.jp",
	"konan.aichi.jp",
	"kota.aichi.jp",
	"mihama.aichi.jp",
	"miyoshi.aichi.jp",
	"nishio.aichi.jp",
	"nisshin.aichi.jp",
	"obu.aichi.jp",
	"oguchi.aichi.jp",
	"oharu.aichi.jp",
	"okazaki.aichi.jp",
	"owariasahi.aichi.jp",
	"seto.aichi.jp",
	"shikatsu.aichi.jp",
	"shinshiro.aichi.jp",
	"shitara.aichi.jp",
	"tahara.aichi.jp",
	"takahama.aichi.jp",
	"tobishima.aichi.jp",
	"toei.aichi.jp",
	"togo.aichi.jp",
	"tokai.aichi.jp",
	"tokoname.aichi.jp",
	"toyoake.aichi.jp",
	"toyohashi.aichi.jp",
	"toyokawa.aichi.jp",
	"toyone.aichi.jp",
	"toyota.aichi.jp",
	"tsushima.aichi.jp",
	"yatomi.aichi.jp",
	"akita.akita.jp",
	"daisen.akita.jp",
	"fujisato.akita.jp",
	"gojome.akita.jp",
	"hachirogata.akita.jp",
	"happou.akita.jp",
	"higashinaruse.akita.jp",
	"honjo.akita.jp",
	"honjyo.akita.jp",
	"ikawa.akita.jp",
	"kamikoani.akita.jp",
	"kamioka.akita.jp",
	"katagami.akita.jp",
	"kazuno.akita.jp",
	"kitaakita.akita.jp",
	"kosaka.akita.jp",
	"kyowa.akita.jp",
	"misato.akita.jp",
	"mitane.akita.jp",
	"moriyoshi.akita.jp",
	"nikaho.akita.jp",
	"noshiro.akita.jp",
	"odate.akita.jp",
	"oga.akita.jp",
	"ogata.akita.jp",
	"semboku.akita.jp",
	"yokote.akita.jp",
	"yurihonjo.akita.jp",
	"aomori.aomori.jp",
	"gonohe.aomori.jp",
	"hachinohe.aomori.jp",
	"hashikami.aomori.jp",
	"hiranai.aomori.jp",
	"hirosaki.aomori.jp",
	"itayanagi.aomori.jp",
	"kuroishi.aomori.jp",
	"misawa.aomori.jp",
	"mutsu.aomori.jp",
	"nakadomari.aomori.jp",
	"noheji.aomori.jp",
	"oirase.aomori.jp",
	"owani.aomori.jp",
	"rokunohe.aomori.jp",
	"sannohe.aomori.jp",
	"shichinohe.aomori.jp",
	"shingo.aomori.jp",
	"takko.aomori.jp",
	"towada.aomori.jp",
	"tsugaru.aomori.jp",
	"tsuruta.aomori.jp",
	"abiko.chiba.jp",
	"asahi.chiba.jp",
	"chonan.chiba.jp",
	"chosei.chiba.jp",
	"choshi.chiba.jp",
	"chuo.chiba.jp",
	"funabashi.chiba.jp",
	"futtsu.chiba.jp",
	"hanamigawa.chiba.jp",
	"ichihara.chiba.jp",
	"ichikawa.chiba.jp",
	"ichinomiya.chiba.jp",
	"inzai.chiba.jp",
	"isumi.chiba.jp",
	"kamagaya.chiba.jp",
	"kamogawa.chiba.jp",
	"kashiwa.chiba.jp",
	"katori.chiba.jp",
	"katsuura.chiba.jp",
	"kimitsu.chiba.jp",
	"kisarazu.chiba.jp",
	"kozaki.chiba.jp",
	"kujukuri.chiba.jp",
	"kyonan.chiba.jp",
	"matsudo.chiba.jp",
	"midori.chiba.jp",
	"mihama.chiba.jp",
	"minamiboso.chiba.jp",
	"mobara.chiba.jp",
	"mutsuzawa.chiba.jp",
	"nagara.chiba.jp",
	"nagareyama.chiba.jp",
	"narashino.chiba.jp",
	"narita.chiba.jp",
	"noda.chiba.jp",
	"oamishirasato.chiba.jp",
	"omigawa.chiba.jp",
	"onjuku.chiba.jp",
	"otaki.chiba.jp",
	"sakae.chiba.jp",
	"sakura.chiba.jp",
	"shimofusa.chiba.jp",
	"shirako.chiba.jp",
	"shiroi.chiba.jp",
	"shisui.chiba.jp",
	"sodegaura.chiba.jp",
	"sosa.chiba.jp",
	"tako.chiba.jp",
	"tateyama.chiba.jp",
	"togane.chiba.jp",
	"tohnosho.chiba.jp",
	"tomisato.chiba.jp",
	"urayasu.chiba.jp",
	"yachimata.chiba.jp",
	"yachiyo.chiba.jp",
	"yokaichiba.chiba.jp",
	"yokoshibahikari.chiba.jp",
	"yotsukaido.chiba.jp",
	"ainan.ehime.jp",
	"honai.ehime.jp",
	"ikata.ehime.jp",
	"imabari.ehime.jp",
	"iyo.ehime.jp",
	"kamijima.ehime.jp",
	"kihoku.ehime.jp",
	"kumakogen.ehime.jp",
	"masaki.ehime.jp",
	"matsuno.ehime.jp",
	"matsuyama.ehime.jp",
	"namikata.ehime.jp",
	"niihama.ehime.jp",
	"ozu.ehime.jp",
	"saijo.ehime.jp",
	"seiyo.ehime.jp",
	"shikokuchuo.ehime.jp",
	"tobe.ehime.jp",
	"toon.ehime.jp",
	"uchiko.ehime.jp",
	"uwajima.ehime.jp",
	"yawatahama.ehime.jp",
	"echizen.fukui.jp",
	"eiheiji.fukui.jp",
	"fukui.fukui.jp",
	"ikeda.fukui.jp",
	"katsuyama.fukui.jp",
	"mihama.fukui.jp",
	"minamiechizen.fukui.jp",
	"obama.fukui.jp",
	"ohi.fukui.jp",
	"ono.fukui.jp",
	"sabae.fukui.jp",
	"sakai.fukui.jp",
	"takahama.fukui.jp",
	"tsuruga.fukui.jp",
	"wakasa.fukui.jp",
	"ashiya.fukuoka.jp",
	"buzen.fukuoka.jp",
	"chikugo.fukuoka.jp",
	"chikuho.fukuoka.jp",
	"chikujo.fukuoka.jp",
	"chikushino.fukuoka.jp",
	"chikuzen.fukuoka.jp",
	"chuo.fukuoka.jp",
	"dazaifu.fukuoka.jp",
	"fukuchi.fukuoka.jp",
	"hakata.fukuoka.jp",
	"higashi.fukuoka.jp",
	"hirokawa.fukuoka.jp",
	"hisayama.fukuoka.jp",
	"iizuka.fukuoka.jp",
	"inatsuki.fukuoka.jp",
	"kaho.fukuoka.jp",
	"kasuga.fukuoka.jp",
	"kasuya.fukuoka.jp",
	"kawara.fukuoka.jp",
	"keisen.fukuoka.jp",
	"koga.fukuoka.jp",
	"kurate.fukuoka.jp",
	"kurogi.fukuoka.jp",
	"kurume.fukuoka.jp",
	"minami.fukuoka.jp",
	"miyako.fukuoka.jp",
	"miyama.fukuoka.jp",
	"miyawaka.fukuoka.jp",
	"mizumaki.fukuoka.jp",
	"munakata.fukuoka.jp",
	"nakagawa.fukuoka.jp",
	"nakama.fukuoka.jp",
	"nishi.fukuoka.jp",
	"nogata.fukuoka.jp",
	"ogori.fukuoka.jp",
	"okagaki.fukuoka.jp",
	"okawa.fukuoka.jp",
	"oki.fukuoka.jp",
	"omuta.fukuoka.jp",
	"onga.fukuoka.jp",
	"onojo.fukuoka.jp",
	"oto.fukuoka.jp",
	"saigawa.fukuoka.jp",
	"sasaguri.fukuoka.jp",
	"shingu.fukuoka.jp",
	"shinyoshitomi.fukuoka.jp",
	"shonai.fukuoka.jp",
	"soeda.fukuoka.jp",
	"sue.fukuoka.jp",
	"tachiarai.fukuoka.jp",
	"tagawa.fukuoka.jp",
	"takata.fukuoka.jp",
	"toho.fukuoka.jp",
	"toyotsu.fukuoka.jp",
	"tsuiki.fukuoka.jp",
	"ukiha.fukuoka.jp",
	"umi.fukuoka.jp",
	"usui.fukuoka.jp",
	"yamada.fukuoka.jp",
	"yame.fukuoka.jp",
	"yanagawa.fukuoka.jp",
	"yukuhashi.fukuoka.jp",
	"aizubange.fukushima.jp",
	"aizumisato.fukushima.jp",
	"aizuwakamatsu.fukushima.jp",
	"asakawa.fukushima.jp",
	"bandai.fukushima.jp",
	"date.fukushima.jp",
	"fukushima.fukushima.jp",
	"furudono.fukushima.jp",
	"futaba.fukushima.jp",
	"hanawa.fukushima.jp",
	"higashi.fukushima.jp",
	"hirata.fukushima.jp",
	"hirono.fukushima.jp",
	"iitate.fukushima.jp",
	"inawashiro.fukushima.jp",
	"ishikawa.fukushima.jp",
	"iwaki.fukushima.jp",
	"izumizaki.fukushima.jp",
	"kagamiishi.fukushima.jp",
	"kaneyama.fukushima.jp",
	"kawamata.fukushima.jp",
	"kitakata.fukushima.jp",
	"kitashiobara.fukushima.jp",
	"koori.fukushima.jp",
	"koriyama.fukushima.jp",
	"kunimi.fukushima.jp",
	"miharu.fukushima.jp",
	"mishima.fukushima.jp",
	"namie.fukushima.jp",
	"nango.fukushima.jp",
	"nishiaizu.fukushima.jp",
	"nishigo.fukushima.jp",
	"okuma.fukushima.jp",
	"omotego.fukushima.jp",
	"ono.fukushima.jp",
	"otama.fukushima.jp",
	"samegawa.fukushima.jp",
	"shimogo.fukushima.jp",
	"shirakawa.fukushima.jp",
	"showa.fukushima.jp",
	"soma.fukushima.jp",
	"sukagawa.fukushima.jp",
	"taishin.fukushima.jp",
	"tamakawa.fukushima.jp",
	"tanagura.fukushima.jp",
	"tenei.fukushima.jp",
	"yabuki.fukushima.jp",
	"yamato.fukushima.jp",
	"yamatsuri.fukushima.jp",
	"yanaizu.fukushima.jp",
	"yugawa.fukushima.jp",
	"anpachi.gifu.jp",
	"ena.gifu.jp",
	"gifu.gifu.jp",
	"ginan.gifu.jp",
	"godo.gifu.jp",
	"gujo.gifu.jp",
	"hashima.gifu.jp",
	"hichiso.gifu.jp",
	"hida.gifu.jp",
	"higashishirakawa.gifu.jp",
	"ibigawa.gifu.jp",
	"ikeda.gifu.jp",
	"kakamigahara.gifu.jp",
	"kani.gifu.jp",
	"kasahara.gifu.jp",
	"kasamatsu.gifu.jp",
	"kawaue.gifu.jp",
	"kitagata.gifu.jp",
	"mino.gifu.jp",
	"minokamo.gifu.jp",
	"mitake.gifu.jp",
	"mizunami.gifu.jp",
	"motosu.gifu.jp",
	"nakatsugawa.gifu.jp",
	"ogaki.gifu.jp",
	"sakahogi.gifu.jp",
	"seki.gifu.jp",
	"sekigahara.gifu.jp",
	"shirakawa.gifu.jp",
	"tajimi.gifu.jp",
	"takayama.gifu.jp",
	"tarui.gifu.jp",
	"toki.gifu.jp",
	"tomika.gifu.jp",
	"wanouchi.gifu.jp",
	"yamagata.gifu.jp",
	"yaotsu.gifu.jp",
	"yoro.gifu.jp",
	"annaka.gunma.jp",
	"chiyoda.gunma.jp",
	"fujioka.gunma.jp",
	"higashiagatsuma.gunma.jp",
	"isesaki.gunma.jp",
	"itakura.gunma.jp",
	"kanna.gunma.jp",
	"kanra.gunma.jp",
	"katashina.gunma.jp",
	"kawaba.gunma.jp",
	"kiryu.gunma.jp",
	"kusatsu.gunma.jp",
	"maebashi.gunma.jp",
	"meiwa.gunma.jp",
	"midori.gunma.jp",
	"minakami.gunma.jp",
	"naganohara.gunma.jp",
	"nakanojo.gunma.jp",
	"nanmoku.gunma.jp",
	"numata.gunma.jp",
	"oizumi.gunma.jp",
	"ora.gunma.jp",
	"ota.gunma.jp",
	"shibukawa.gunma.jp",
	"shimonita.gunma.jp",
	"shinto.gunma.jp",
	"showa.gunma.jp",
	"takasaki.gunma.jp",
	"takayama.gunma.jp",
	"tamamura.gunma.jp",
	"tatebayashi.gunma.jp",
	"tomioka.gunma.jp",
	"tsukiyono.gunma.jp",
	"tsumagoi.gunma.jp",
	"ueno.gunma.jp",
	"yoshioka.gunma.jp",
	"asaminami.hiroshima.jp",
	"daiwa.hiroshima.jp",
	"etajima.hiroshima.jp",
	"fuchu.hiroshima.jp",
	"fukuyama.hiroshima.jp",
	"hatsukaichi.hiroshima.jp",
	"higashihiroshima.hiroshima.jp",
	"hongo.hiroshima.jp",
	"jinsekikogen.hiroshima.jp",
	"kaita.hiroshima.jp",
	"kui.hiroshima.jp",
	"kumano.hiroshima.jp",
	"kure.hiroshima.jp",
	"mihara.hiroshima.jp",
	"miyoshi.hiroshima.jp",
	"naka.hiroshima.jp",
	"onomichi.hiroshima.jp",
	"osakikamijima.hiroshima.jp",
	"otake.hiroshima.jp",
	"saka.hiroshima.jp",
	"sera.hiroshima.jp",
	"seranishi.hiroshima.jp",
	"shinichi.hiroshima.jp",
	"shobara.hiroshima.jp",
	"takehara.hiroshima.jp",
	"abashiri.hokkaido.jp",
	"abira.hokkaido.jp",
	"aibetsu.hokkaido.jp",
	"akabira.hokkaido.jp",
	"akkeshi.hokkaido.jp",
	"asahikawa.hokkaido.jp",
	"ashibetsu.hokkaido.jp",
	"ashoro.hokkaido.jp",
	"assabu.hokkaido.jp",
	"atsuma.hokkaido.jp",
	"bibai.hokkaido.jp",
	"biei.hokkaido.jp",
	"bifuka.hokkaido.jp",
	"bihoro.hokkaido.jp",
	"biratori.hokkaido.jp",
	"chippubetsu.hokkaido.jp",
	"chitose.hokkaido.jp",
	"date.hokkaido.jp",
	"ebetsu.hokkaido.jp",
	"embetsu.hokkaido.jp",
	"eniwa.hokkaido.jp",
	"erimo.hokkaido.jp",
	"esan.hokkaido.jp",
	"esashi.hokkaido.jp",
	"fukagawa.hokkaido.jp",
	"fukushima.hokkaido.jp",
	"furano.hokkaido.jp",
	"furubira.hokkaido.jp",
	"haboro.hokkaido.jp",
	"hakodate.hokkaido.jp",
	"hamatonbetsu.hokkaido.jp",
	"hidaka.hokkaido.jp",
	"higashikagura.hokkaido.jp",
	"higashikawa.hokkaido.jp",
	"hiroo.hokkaido.jp",
	"hokuryu.hokkaido.jp",
	"hokuto.hokkaido.jp",
	"honbetsu.hokkaido.jp",
	"horokanai.hokkaido.jp",
	"horonobe.hokkaido.jp",
	"ikeda.hokkaido.jp",
	"imakane.hokkaido.jp",
	"ishikari.hokkaido.jp",
	"iwamizawa.hokkaido.jp",
	"iwanai.hokkaido.jp",
	"kamifurano.hokkaido.jp",
	"kamikawa.hokkaido.jp",
	"kamishihoro.hokkaido.jp",
	"kamisunagawa.hokkaido.jp",
	"kamoenai.hokkaido.jp",
	"kayabe.hokkaido.jp",
	"kembuchi.hokkaido.jp",
	"kikonai.hokkaido.jp",
	"kimobetsu.hokkaido.jp",
	"kitahiroshima.hokkaido.jp",
	"kitami.hokkaido.jp",
	"kiyosato.hokkaido.jp",
	"koshimizu.hokkaido.jp",
	"kunneppu.hokkaido.jp",
	"kuriyama.hokkaido.jp",
	"kuromatsunai.hokkaido.jp",
	"kushiro.hokkaido.jp",
	"kutchan.hokkaido.jp",
	"kyowa.hokkaido.jp",
	"mashike.hokkaido.jp",
	"matsumae.hokkaido.jp",
	"mikasa.hokkaido.jp",
	"minamifurano.hokkaido.jp",
	"mombetsu.hokkaido.jp",
	"moseushi.hokkaido.jp",
	"mukawa.hokkaido.jp",
	"muroran.hokkaido.jp",
	"naie.hokkaido.jp",
	"nakagawa.hokkaido.jp",
	"nakasatsunai.hokkaido.jp",
	"nakatombetsu.hokkaido.jp",
	"nanae.hokkaido.jp",
	"nanporo.hokkaido.jp",
	"nayoro.hokkaido.jp",
	"nemuro.hokkaido.jp",
	"niikappu.hokkaido.jp",
	"niki.hokkaido.jp",
	"nishiokoppe.hokkaido.jp",
	"noboribetsu.hokkaido.jp",
	"numata.hokkaido.jp",
	"obihiro.hokkaido.jp",
	"obira.hokkaido.jp",
	"oketo.hokkaido.jp",
	"okoppe.hokkaido.jp",
	"otaru.hokkaido.jp",
	"otobe.hokkaido.jp",
	"otofuke.hokkaido.jp",
	"otoineppu.hokkaido.jp",
	"oumu.hokkaido.jp",
	"ozora.hokkaido.jp",
	"pippu.hokkaido.jp",
	"rankoshi.hokkaido.jp",
	"rebun.hokkaido.jp",
	"rikubetsu.hokkaido.jp",
	"rishiri.hokkaido.jp",
	"rishirifuji.hokkaido.jp",
	"saroma.hokkaido.jp",
	"sarufutsu.hokkaido.jp",
	"shakotan.hokkaido.jp",
	"shari.hokkaido.jp",
	"shibecha.hokkaido.jp",
	"shibetsu.hokkaido.jp",
	"shikabe.hokkaido.jp",
	"shikaoi.hokkaido.jp",
	"shimamaki.hokkaido.jp",
	"shimizu.hokkaido.jp",
	"shimokawa.hokkaido.jp",
	"shinshinotsu.hokkaido.jp",
	"shintoku.hokkaido.jp",
	"shiranuka.hokkaido.jp",
	"shiraoi.hokkaido.jp",
	"shiriuchi.hokkaido.jp",
	"sobetsu.hokkaido.jp",
	"sunagawa.hokkaido.jp",
	"taiki.hokkaido.jp",
	"takasu.hokkaido.jp",
	"takikawa.hokkaido.jp",
	"takinoue.hokkaido.jp",
	"teshikaga.hokkaido.jp",
	"tobetsu.hokkaido.jp",
	"tohma.hokkaido.jp",
	"tomakomai.hokkaido.jp",
	"tomari.hokkaido.jp",
	"toya.hokkaido.jp",
	"toyako.hokkaido.jp",
	"toyotomi.hokkaido.jp",
	"toyoura.hokkaido.jp",
	"tsubetsu.hokkaido.jp",
	"tsukigata.hokkaido.jp",
	"urakawa.hokkaido.jp",
	"urausu.hokkaido.jp",
	"uryu.hokkaido.jp",
	"utashinai.hokkaido.jp",
	"wakkanai.hokkaido.jp",
	"wassamu.hokkaido.jp",
	"yakumo.hokkaido.jp",
	"yoichi.hokkaido.jp",
	"aioi.hyogo.jp",
	"akashi.hyogo.jp",
	"ako.hyogo.jp",
	"amagasaki.hyogo.jp",
	"aogaki.hyogo.jp",
	"asago.hyogo.jp",
	"ashiya.hyogo.jp",
	"awaji.hyogo.jp",
	"fukusaki.hyogo.jp",
	"goshiki.hyogo.jp",
	"harima.hyogo.jp",
	"himeji.hyogo.jp",
	"ichikawa.hyogo.jp",
	"inagawa.hyogo.jp",
	"itami.hyogo.jp",
	"kakogawa.hyogo.jp",
	"kamigori.hyogo.jp",
	"kamikawa.hyogo.jp",
	"kasai.hyogo.jp",
	"kasuga.hyogo.jp",
	"kawanishi.hyogo.jp",
	"miki.hyogo.jp",
	"minamiawaji.hyogo.jp",
	"nishinomiya.hyogo.jp",
	"nishiwaki.hyogo.jp",
	"ono.hyogo.jp",
	"sanda.hyogo.jp",
	"sannan.hyogo.jp",
	"sasayama.hyogo.jp",
	"sayo.hyogo.jp",
	"shingu.hyogo.jp",
	"shinonsen.hyogo.jp",
	"shiso.hyogo.jp",
	"sumoto.hyogo.jp",
	"taishi.hyogo.jp",
	"taka.hyogo.jp",
	"takarazuka.hyogo.jp",
	"takasago.hyogo.jp",
	"takino.hyogo.jp",
	"tamba.hyogo.jp",
	"tatsuno.hyogo.jp",
	"toyooka.hyogo.jp",
	"yabu.hyogo.jp",
	"yashiro.hyogo.jp",
	"yoka.hyogo.jp",
	"yokawa.hyogo.jp",
	"ami.ibaraki.jp",
	"asahi.ibaraki.jp",
	"bando.ibaraki.jp",
	"chikusei.ibaraki.jp",
	"daigo.ibaraki.jp",
	"fujishiro.ibaraki.jp",
	"hitachi.ibaraki.jp",
	"hitachinaka.ibaraki.jp",
	"hitachiomiya.ibaraki.jp",
	"hitachiota.ibaraki.jp",
	"ibaraki.ibaraki.jp",
	"ina.ibaraki.jp",
	"inashiki.ibaraki.jp",
	"itako.ibaraki.jp",
	"iwama.ibaraki.jp",
	"joso.ibaraki.jp",
	"kamisu.ibaraki.jp",
	"kasama.ibaraki.jp",
	"kashima.ibaraki.jp",
	"kasumigaura.ibaraki.jp",
	"koga.ibaraki.jp",
	"miho.ibaraki.jp",
	"mito.ibaraki.jp",
	"moriya.ibaraki.jp",
	"naka.ibaraki.jp",
	"namegata.ibaraki.jp",
	"oarai.ibaraki.jp",
	"ogawa.ibaraki.jp",
	"omitama.ibaraki.jp",
	"ryugasaki.ibaraki.jp",
	"sakai.ibaraki.jp",
	"sakuragawa.ibaraki.jp",
	"shimodate.ibaraki.jp",
	"shimotsuma.ibaraki.jp",
	"shirosato.ibaraki.jp",
	"sowa.ibaraki.jp",
	"suifu.ibaraki.jp",
	"takahagi.ibaraki.jp",
	"tamatsukuri.ibaraki.jp",
	"tokai.ibaraki.jp",
	"tomobe.ibaraki.jp",
	"tone.ibaraki.jp",
	"toride.ibaraki.jp",
	"tsuchiura.ibaraki.jp",
	"tsukuba.ibaraki.jp",
	"uchihara.ibaraki.jp",
	"ushiku.ibaraki.jp",
	"yachiyo.ibaraki.jp",
	"yamagata.ibaraki.jp",
	"yawara.ibaraki.jp",
	"yuki.ibaraki.jp",
	"anamizu.ishikawa.jp",
	"hakui.ishikawa.jp",
	"hakusan.ishikawa.jp",
	"kaga.ishikawa.jp",
	"kahoku.ishikawa.jp",
	"kanazawa.ishikawa.jp",
	"kawakita.ishikawa.jp",
	"komatsu.ishikawa.jp",
	"nakanoto.ishikawa.jp",
	"nanao.ishikawa.jp",
	"nomi.ishikawa.jp",
	"nonoichi.ishikawa.jp",
	"noto.ishikawa.jp",
	"shika.ishikawa.jp",
	"suzu.ishikawa.jp",
	"tsubata.ishikawa.jp",
	"tsurugi.ishikawa.jp",
	"uchinada.ishikawa.jp",
	"wajima.ishikawa.jp",
	"fudai.iwate.jp",
	"fujisawa.iwate.jp",
	"hanamaki.iwate.jp",
	"hiraizumi.iwate.jp",
	"hirono.iwate.jp",
	"ichinohe.iwate.jp",
	"ichinoseki.iwate.jp",
	"iwaizumi.iwate.jp",
	"iwate.iwate.jp",
	"joboji.iwate.jp",
	"kamaishi.iwate.jp",
	"kanegasaki.iwate.jp",
	"karumai.iwate.jp",
	"kawai.iwate.jp",
	"kitakami.iwate.jp",
	"kuji.iwate.jp",
	"kunohe.iwate.jp",
	"kuzumaki.iwate.jp",
	"miyako.iwate.jp",
	"mizusawa.iwate.jp",
	"morioka.iwate.jp",
	"ninohe.iwate.jp",
	"noda.iwate.jp",
	"ofunato.iwate.jp",
	"oshu.iwate.jp",
	"otsuchi.iwate.jp",
	"rikuzentakata.iwate.jp",
	"shiwa.iwate.jp",
	"shizukuishi.iwate.jp",
	"sumita.iwate.jp",
	"tanohata.iwate.jp",
	"tono.iwate.jp",
	"yahaba.iwate.jp",
	"yamada.iwate.jp",
	"ayagawa.kagawa.jp",
	"higashikagawa.kagawa.jp",
	"kanonji.kagawa.jp",
	"kotohira.kagawa.jp",
	"manno.kagawa.jp",
	"marugame.kagawa.jp",
	"mitoyo.kagawa.jp",
	"naoshima.kagawa.jp",
	"sanuki.kagawa.jp",
	"tadotsu.kagawa.jp",
	"takamatsu.kagawa.jp",
	"tonosho.kagawa.jp",
	"uchinomi.kagawa.jp",
	"utazu.kagawa.jp",
	"zentsuji.kagawa.jp",
	"akune.kagoshima.jp",
	"amami.kagoshima.jp",
	"hioki.kagoshima.jp",
	"isa.kagoshima.jp",
	"isen.kagoshima.jp",
	"izumi.kagoshima.jp",
	"kagoshima.kagoshima.jp",
	"kanoya.kagoshima.jp",
	"kawanabe.kagoshima.jp",
	"kinko.kagoshima.jp",
	"kouyama.kagoshima.jp",
	"makurazaki.kagoshima.jp",
	"matsumoto.kagoshima.jp",
	"minamitane.kagoshima.jp",
	"nakatane.kagoshima.jp",
	"nishinoomote.kagoshima.jp",
	"satsumasendai.kagoshima.jp",
	"soo.kagoshima.jp",
	"tarumizu.kagoshima.jp",
	"yusui.kagoshima.jp",
	"aikawa.kanagawa.jp",
	"atsugi.kanagawa.jp",
	"ayase.kanagawa.jp",
	"chigasaki.kanagawa.jp",
	"ebina.kanagawa.jp",
	"fujisawa.kanagawa.jp",
	"hadano.kanagawa.jp",
	"hakone.kanagawa.jp",
	"hiratsuka.kanagawa.jp",
	"isehara.kanagawa.jp",
	"kaisei.kanagawa.jp",
	"kamakura.kanagawa.jp",
	"kiyokawa.kanagawa.jp",
	"matsuda.kanagawa.jp",
	"minamiashigara.kanagawa.jp",
	"miura.kanagawa.jp",
	"nakai.kanagawa.jp",
	"ninomiya.kanagawa.jp",
	"odawara.kanagawa.jp",
	"oi.kanagawa.jp",
	"oiso.kanagawa.jp",
	"sagamihara.kanagawa.jp",
	"samukawa.kanagawa.jp",
	"tsukui.kanagawa.jp",
	"yamakita.kanagawa.jp",
	"yamato.kanagawa.jp",
	"yokosuka.kanagawa.jp",
	"yugawara.kanagawa.jp",
	"zama.kanagawa.jp",
	"zushi.kanagawa.jp",
	"aki.kochi.jp",
	"geisei.kochi.jp",
	"hidaka.kochi.jp",
	"higashitsuno.kochi.jp",
	"ino.kochi.jp",
	"kagami.kochi.jp",
	"kami.kochi.jp",
	"kitagawa.kochi.jp",
	"kochi.kochi.jp",
	"mihara.kochi.jp",
	"motoyama.kochi.jp",
	"muroto.kochi.jp",
	"nahari.kochi.jp",
	"nakamura.kochi.jp",
	"nankoku.kochi.jp",
	"nishitosa.kochi.jp",
	"niyodogawa.kochi.jp",
	"ochi.kochi.jp",
	"okawa.kochi.jp",
	"otoyo.kochi.jp",
	"otsuki.kochi.jp",
	"sakawa.kochi.jp",
	"sukumo.kochi.jp",
	"susaki.kochi.jp",
	"tosa.kochi.jp",
	"tosashimizu.kochi.jp",
	"toyo.kochi.jp",
	"tsuno.kochi.jp",
	"umaji.kochi.jp",
	"yasuda.kochi.jp",
	"yusuhara.kochi.jp",
	"amakusa.kumamoto.jp",
	"arao.kumamoto.jp",
	"aso.kumamoto.jp",
	"choyo.kumamoto.jp",
	"gyokuto.kumamoto.jp",
	"kamiamakusa.kumamoto.jp",
	"kikuchi.kumamoto.jp",
	"kumamoto.kumamoto.jp",
	"mashiki.kumamoto.jp",
	"mifune.kumamoto.jp",
	"minamata.kumamoto.jp",
	"minamioguni.kumamoto.jp",
	"nagasu.kumamoto.jp",
	"nishihara.kumamoto.jp",
	"oguni.kumamoto.jp",
	"ozu.kumamoto.jp",
	"sumoto.kumamoto.jp",
	"takamori.kumamoto.jp",
	"uki.kumamoto.jp",
	"uto.kumamoto.jp",
	"yamaga.kumamoto.jp",
	"yamato.kumamoto.jp",
	"yatsushiro.kumamoto.jp",
	"ayabe.kyoto.jp",
	"fukuchiyama.kyoto.jp",
	"higashiyama.kyoto.jp",
	"ide.kyoto.jp",
	"ine.kyoto.jp",
	"joyo.kyoto.jp",
	"kameoka.kyoto.jp",
	"kamo.kyoto.jp",
	"kita.kyoto.jp",
	"kizu.kyoto.jp",
	"kumiyama.kyoto.jp",
	"kyotamba.kyoto.jp",
	"kyotanabe.kyoto.jp",
	"kyotango.kyoto.jp",
	"maizuru.kyoto.jp",
	"minami.kyoto.jp",
	"minamiyamashiro.kyoto.jp",
	"miyazu.kyoto.jp",
	"muko.kyoto.jp",
	"nagaokakyo.kyoto.jp",
	"nakagyo.kyoto.jp",
	"nantan.kyoto.jp",
	"oyamazaki.kyoto.jp",
	"sakyo.kyoto.jp",
	"seika.kyoto.jp",
	"tanabe.kyoto.jp",
	"uji.kyoto.jp",
	"ujitawara.kyoto.jp",
	"wazuka.kyoto.jp",
	"yamashina.kyoto.jp",
	"yawata.kyoto.jp",
	"asahi.mie.jp",
	"inabe.mie.jp",
	"ise.mie.jp",
	"kameyama.mie.jp",
	"kawagoe.mie.jp",
	"kiho.mie.jp",
	"kisosaki.mie.jp",
	"kiwa.mie.jp",
	"komono.mie.jp",
	"kumano.mie.jp",
	"kuwana.mie.jp",
	"matsusaka.mie.jp",
	"meiwa.mie.jp",
	"mihama.mie.jp",
	"minamiise.mie.jp",
	"misugi.mie.jp",
	"miyama.mie.jp",
	"nabari.mie.jp",
	"shima.mie.jp",
	"suzuka.mie.jp",
	"tado.mie.jp",
	"taiki.mie.jp",
	"taki.mie.jp",
	"tamaki.mie.jp",
	"toba.mie.jp",
	"tsu.mie.jp",
	"udono.mie.jp",
	"ureshino.mie.jp",
	"watarai.mie.jp",
	"yokkaichi.mie.jp",
	"furukawa.miyagi.jp",
	"higashimatsushima.miyagi.jp",
	"ishinomaki.miyagi.jp",
	"iwanuma.miyagi.jp",
	"kakuda.miyagi.jp",
	"kami.miyagi.jp",
	"kawasaki.miyagi.jp",
	"marumori.miyagi.jp",
	"matsushima.miyagi.jp",
	"minamisanriku.miyagi.jp",
	"misato.miyagi.jp",
	"murata.miyagi.jp",
	"natori.miyagi.jp",
	"ogawara.miyagi.jp",
	"ohira.miyagi.jp",
	"onagawa.miyagi.jp",
	"osaki.miyagi.jp",
	"rifu.miyagi.jp",
	"semine.miyagi.jp",
	"shibata.miyagi.jp",
	"shichikashuku.miyagi.jp",
	"shikama.miyagi.jp",
	"shiogama.miyagi.jp",
	"shiroishi.miyagi.jp",
	"tagajo.miyagi.jp",
	"taiwa.miyagi.jp",
	"tome.miyagi.jp",
	"tomiya.miyagi.jp",
	"wakuya.miyagi.jp",
	"watari.miyagi.jp",
	"yamamoto.miyagi.jp",
	"zao.miyagi.jp",
	"aya.miyazaki.jp",
	"ebino.miyazaki.jp",
	"gokase.miyazaki.jp",
	"hyuga.miyazaki.jp",
	"kadogawa.miyazaki.jp",
	"kawaminami.miyazaki.jp",
	"kijo.miyazaki.jp",
	"kitagawa.miyazaki.jp",
	"kitakata.miyazaki.jp",
	"kitaura.miyazaki.jp",
	"kobayashi.miyazaki.jp",
	"kunitomi.miyazaki.jp",
	"kushima.miyazaki.jp",
	"mimata.miyazaki.jp",
	"miyakonojo.miyazaki.jp",
	"miyazaki.miyazaki.jp",
	"morotsuka.miyazaki.jp",
	"nichinan.miyazaki.jp",
	"nishimera.miyazaki.jp",
	"nobeoka.miyazaki.jp",
	"saito.miyazaki.jp",
	"shiiba.miyazaki.jp",
	"shintomi.miyazaki.jp",
	"takaharu.miyazaki.jp",
	"takanabe.miyazaki.jp",
	"takazaki.miyazaki.jp",
	"tsuno.miyazaki.jp",
	"achi.nagano.jp",
	"agematsu.nagano.jp",
	"anan.nagano.jp",
	"aoki.nagano.jp",
	"asahi.nagano.jp",
	"azumino.nagano.jp",
	"chikuhoku.nagano.jp",
	"chikuma.nagano.jp",
	"chino.nagano.jp",
	"fujimi.nagano.jp",
	"hakuba.nagano.jp",
	"hara.nagano.jp",
	"hiraya.nagano.jp",
	"iida.nagano.jp",
	"iijima.nagano.jp",
	"iiyama.nagano.jp",
	"iizuna.nagano.jp",
	"ikeda.nagano.jp",
	"ikusaka.nagano.jp",
	"ina.nagano.jp",
	"karuizawa.nagano.jp",
	"kawakami.nagano.jp",
	"kiso.nagano.jp",
	"kisofukushima.nagano.jp",
	"kitaaiki.nagano.jp",
	"komagane.nagano.jp",
	"komoro.nagano.jp",
	"matsukawa.nagano.jp",
	"matsumoto.nagano.jp",
	"miasa.nagano.jp",
	"minamiaiki.nagano.jp",
	"minamimaki.nagano.jp",
	"minamiminowa.nagano.jp",
	"minowa.nagano.jp",
	"miyada.nagano.jp",
	"miyota.nagano.jp",
	"mochizuki.nagano.jp",
	"nagano.nagano.jp",
	"nagawa.nagano.jp",
	"nagiso.nagano.jp",
	"nakagawa.nagano.jp",
	"nakano.nagano.jp",
	"nozawaonsen.nagano.jp",
	"obuse.nagano.jp",
	"ogawa.nagano.jp",
	"okaya.nagano.jp",
	"omachi.nagano.jp",
	"omi.nagano.jp",
	"ookuwa.nagano.jp",
	"ooshika.nagano.jp",
	"otaki.nagano.jp",
	"otari.nagano.jp",
	"sakae.nagano.jp",
	"sakaki.nagano.jp",
	"saku.nagano.jp",
	"sakuho.nagano.jp",
	"shimosuwa.nagano.jp",
	"shinanomachi.nagano.jp",
	"shiojiri.nagano.jp",
	"suwa.nagano.jp",
	"suzaka.nagano.jp",
	"takagi.nagano.jp",
	"takamori.nagano.jp",
	"takayama.nagano.jp",
	"tateshina.nagano.jp",
	"tatsuno.nagano.jp",
	"togakushi.nagano.jp",
	"togura.nagano.jp",
	"tomi.nagano.jp",
	"ueda.nagano.jp",
	"wada.nagano.jp",
	"yamagata.nagano.jp",
	"yamanouchi.nagano.jp",
	"yasaka.nagano.jp",
	"yasuoka.nagano.jp",
	"chijiwa.nagasaki.jp",
	"futsu.nagasaki.jp",
	"goto.nagasaki.jp",
	"hasami.nagasaki.jp",
	"hirado.nagasaki.jp",
	"iki.nagasaki.jp",
	"isahaya.nagasaki.jp",
	"kawatana.nagasaki.jp",
	"kuchinotsu.nagasaki.jp",
	"matsuura.nagasaki.jp",
	"nagasaki.nagasaki.jp",
	"obama.nagasaki.jp",
	"omura.nagasaki.jp",
	"oseto.nagasaki.jp",
	"saikai.nagasaki.jp",
	"sasebo.nagasaki.jp",
	"seihi.nagasaki.jp",
	"shimabara.nagasaki.jp",
	"shinkamigoto.nagasaki.jp",
	"togitsu.nagasaki.jp",
	"tsushima.nagasaki.jp",
	"unzen.nagasaki.jp",
	"ando.nara.jp",
	"gose.nara.jp",
	"heguri.nara.jp",
	"higashiyoshino.nara.jp",
	"ikaruga.nara.jp",
	"ikoma.nara.jp",
	"kamikitayama.nara.jp",
	"kanmaki.nara.jp",
	"kashiba.nara.jp",
	"kashihara.nara.jp",
	"katsuragi.nara.jp",
	"kawai.nara.jp",
	"kawakami.nara.jp",
	"kawanishi.nara.jp",
	"koryo.nara.jp",
	"kurotaki.nara.jp",
	"mitsue.nara.jp",
	"miyake.nara.jp",
	"nara.nara.jp",
	"nosegawa.nara.jp",
	"oji.nara.jp",
	"ouda.nara.jp",
	"oyodo.nara.jp",
	"sakurai.nara.jp",
	"sango.nara.jp",
	"shimoichi.nara.jp",
	"shimokitayama.nara.jp",
	"shinjo.nara.jp",
	"soni.nara.jp",
	"takatori.nara.jp",
	"tawaramoto.nara.jp",
	"tenkawa.nara.jp",
	"tenri.nara.jp",
	"uda.nara.jp",
	"yamatokoriyama.nara.jp",
	"yamatotakada.nara.jp",
	"yamazoe.nara.jp",
	"yoshino.nara.jp",
	"aga.niigata.jp",
	"agano.niigata.jp",
	"gosen.niigata.jp",
	"itoigawa.niigata.jp",
	"izumozaki.niigata.jp",
	"joetsu.niigata.jp",
	"kamo.niigata.jp",
	"kariwa.niigata.jp",
	"kashiwazaki.niigata.jp",
	"minamiuonuma.niigata.jp",
	"mitsuke.niigata.jp",
	"muika.niigata.jp",
	"murakami.niigata.jp",
	"myoko.niigata.jp",
	"nagaoka.niigata.jp",
	"niigata.niigata.jp",
	"ojiya.niigata.jp",
	"omi.niigata.jp",
	"sado.niigata.jp",
	"sanjo.niigata.jp",
	"seiro.niigata.jp",
	"seirou.niigata.jp",
	"sekikawa.niigata.jp",
	"shibata.niigata.jp",
	"tagami.niigata.jp",
	"tainai.niigata.jp",
	"tochio.niigata.jp",
	"tokamachi.niigata.jp",
	"tsubame.niigata.jp",
	"tsunan.niigata.jp",
	"uonuma.niigata.jp",
	"yahiko.niigata.jp",
	"yoita.niigata.jp",
	"yuzawa.niigata.jp",
	"beppu.oita.jp",
	"bungoono.oita.jp",
	"bungotakada.oita.jp",
	"hasama.oita.jp",
	"hiji.oita.jp",
	"himeshima.oita.jp",
	"hita.oita.jp",
	"kamitsue.oita.jp",
	"kokonoe.oita.jp",
	"kuju.oita.jp",
	"kunisaki.oita.jp",
	"kusu.oita.jp",
	"oita.oita.jp",
	"saiki.oita.jp",
	"taketa.oita.jp",
	"tsukumi.oita.jp",
	"usa.oita.jp",
	"usuki.oita.jp",
	"yufu.oita.jp",
	"akaiwa.okayama.jp",
	"asakuchi.okayama.jp",
	"bizen.okayama.jp",
	"hayashima.okayama.jp",
	"ibara.okayama.jp",
	"kagamino.okayama.jp",
	"kasaoka.okayama.jp",
	"kibichuo.okayama.jp",
	"kumenan.okayama.jp",
	"kurashiki.okayama.jp",
	"maniwa.okayama.jp",
	"misaki.okayama.jp",
	"nagi.okayama.jp",
	"niimi.okayama.jp",
	"nishiawakura.okayama.jp",
	"okayama.okayama.jp",
	"satosho.okayama.jp",
	"setouchi.okayama.jp",
	"shinjo.okayama.jp",
	"shoo.okayama.jp",
	"soja.okayama.jp",
	"takahashi.okayama.jp",
	"tamano.okayama.jp",
	"tsuyama.okayama.jp",
	"wake.okayama.jp",
	"yakage.okayama.jp",
	"aguni.okinawa.jp",
	"ginowan.okinawa.jp",
	"ginoza.okinawa.jp",
	"gushikami.okinawa.jp",
	"haebaru.okinawa.jp",
	"higashi.okinawa.jp",
	"hirara.okinawa.jp",
	"iheya.okinawa.jp",
	"ishigaki.okinawa.jp",
	"ishikawa.okinawa.jp",
	"itoman.okinawa.jp",
	"izena.okinawa.jp",
	"kadena.okinawa.jp",
	"kin.okinawa.jp",
	"kitadaito.okinawa.jp",
	"kitanakagusuku.okinawa.jp",
	"kumejima.okinawa.jp",
	"kunigami.okinawa.jp",
	"minamidaito.okinawa.jp",
	"motobu.okinawa.jp",
	"nago.okinawa.jp",
	"naha.okinawa.jp",
	"nakagusuku.okinawa.jp",
	"nakijin.okinawa.jp",
	"nanjo.okinawa.jp",
	"nishihara.okinawa.jp",
	"ogimi.okinawa.jp",
	"okinawa.okinawa.jp",
	"onna.okinawa.jp",
	"shimoji.okinawa.jp",
	"taketomi.okinawa.jp",
	"tarama.okinawa.jp",
	"tokashiki.okinawa.jp",
	"tomigusuku.okinawa.jp",
	"tonaki.okinawa.jp",
	"urasoe.okinawa.jp",
	"uruma.okinawa.jp",
	"yaese.okinawa.jp",
	"yomitan.okinawa.jp",
	"yonabaru.okinawa.jp",
	"yonaguni.okinawa.jp",
	"zamami.okinawa.jp",
	"abeno.osaka.jp",
	"chihayaakasaka.osaka.jp",
	"chuo.osaka.jp",
	"daito.osaka.jp",
	"fujiidera.osaka.jp",
	"habikino.osaka.jp",
	"hannan.osaka.jp",
	"higashiosaka.osaka.jp",
	"higashisumiyoshi.osaka.jp",
	"higashiyodogawa.osaka.jp",
	"hirakata.osaka.jp",
	"ibaraki.osaka.jp",
	"ikeda.osaka.jp",
	"izumi.osaka.jp",
	"izumiotsu.osaka.jp",
	"izumisano.osaka.jp",
	"kadoma.osaka.jp",
	"kaizuka.osaka.jp",
	"kanan.osaka.jp",
	"kashiwara.osaka.jp",
	"katano.osaka.jp",
	"kawachinagano.osaka.jp",
	"kishiwada.osaka.jp",
	"kita.osaka.jp",
	"kumatori.osaka.jp",
	"matsubara.osaka.jp",
	"minato.osaka.jp",
	"minoh.osaka.jp",
	"misaki.osaka.jp",
	"moriguchi.osaka.jp",
	"neyagawa.osaka.jp",
	"nishi.osaka.jp",
	"nose.osaka.jp",
	"osakasayama.osaka.jp",
	"sakai.osaka.jp",
	"sayama.osaka.jp",
	"sennan.osaka.jp",
	"settsu.osaka.jp",
	"shijonawate.osaka.jp",
	"shimamoto.osaka.jp",
	"suita.osaka.jp",
	"tadaoka.osaka.jp",
	"taishi.osaka.jp",
	"tajiri.osaka.jp",
	"takaishi.osaka.jp",
	"takatsuki.osaka.jp",
	"tondabayashi.osaka.jp",
	"toyonaka.osaka.jp",
	"toyono.osaka.jp",
	"yao.osaka.jp",
	"ariake.saga.jp",
	"arita.saga.jp",
	"fukudomi.saga.jp",
	"genkai.saga.jp",
	"hamatama.saga.jp",
	"hizen.saga.jp",
	"imari.saga.jp",
	"kamimine.saga.jp",
	"kanzaki.saga.jp",
	"karatsu.saga.jp",
	"kashima.saga.jp",
	"kitagata.saga.jp",
	"kitahata.saga.jp",
	"kiyama.saga.jp",
	"kouhoku.saga.jp",
	"kyuragi.saga.jp",
	"nishiarita.saga.jp",
	"ogi.saga.jp",
	"omachi.saga.jp",
	"ouchi.saga.jp",
	"saga.saga.jp",
	"shiroishi.saga.jp",
	"taku.saga.jp",
	"tara.saga.jp",
	"tosu.saga.jp",
	"yoshinogari.saga.jp",
	"arakawa.saitama.jp",
	"asaka.saitama.jp",
	"chichibu.saitama.jp",
	"fujimi.saitama.jp",
	"fujimino.saitama.jp",
	"fukaya.saitama.jp",
	"hanno.saitama.jp",
	"hanyu.saitama.jp",
	"hasuda.saitama.jp",
	"hatogaya.saitama.jp",
	"hatoyama.saitama.jp",
	"hidaka.saitama.jp",
	"higashichichibu.saitama.jp",
	"higashimatsuyama.saitama.jp",
	"honjo.saitama.jp",
	"ina.saitama.jp",
	"iruma.saitama.jp",
	"iwatsuki.saitama.jp",
	"kamiizumi.saitama.jp",
	"kamikawa.saitama.jp",
	"kamisato.saitama.jp",
	"kasukabe.saitama.jp",
	"kawagoe.saitama.jp",
	"kawaguchi.saitama.jp",
	"kawajima.saitama.jp",
	"kazo.saitama.jp",
	"kitamoto.saitama.jp",
	"koshigaya.saitama.jp",
	"kounosu.saitama.jp",
	"kuki.saitama.jp",
	"kumagaya.saitama.jp",
	"matsubushi.saitama.jp",
	"minano.saitama.jp",
	"misato.saitama.jp",
	"miyashiro.saitama.jp",
	"miyoshi.saitama.jp",
	"moroyama.saitama.jp",
	"nagatoro.saitama.jp",
	"namegawa.saitama.jp",
	"niiza.saitama.jp",
	"ogano.saitama.jp",
	"ogawa.saitama.jp",
	"ogose.saitama.jp",
	"okegawa.saitama.jp",
	"omiya.saitama.jp",
	"otaki.saitama.jp",
	"ranzan.saitama.jp",
	"ryokami.saitama.jp",
	"saitama.saitama.jp",
	"sakado.saitama.jp",
	"satte.saitama.jp",
	"sayama.saitama.jp",
	"shiki.saitama.jp",
	"shiraoka.saitama.jp",
	"soka.saitama.jp",
	"sugito.saitama.jp",
	"toda.saitama.jp",
	"tokigawa.saitama.jp",
	"tokorozawa.saitama.jp",
	"tsurugashima.saitama.jp",
	"urawa.saitama.jp",
	"warabi.saitama.jp",
	"yashio.saitama.jp",
	"yokoze.saitama.jp",
	"yono.saitama.jp",
	"yorii.saitama.jp",
	"yoshida.saitama.jp",
	"yoshikawa.saitama.jp",
	"yoshimi.saitama.jp",
	"aisho.shiga.jp",
	"gamo.shiga.jp",
	"higashiomi.shiga.jp",
	"hikone.shiga.jp",
	"koka.shiga.jp",
	"konan.shiga.jp",
	"kosei.shiga.jp",
	"koto.shiga.jp",
	"kusatsu.shiga.jp",
	"maibara.shiga.jp",
	"moriyama.shiga.jp",
	"nagahama.shiga.jp",
	"nishiazai.shiga.jp",
	"notogawa.shiga.jp",
	"omihachiman.shiga.jp",
	"otsu.shiga.jp",
	"ritto.shiga.jp",
	"ryuoh.shiga.jp",
	"takashima.shiga.jp",
	"takatsuki.shiga.jp",
	"torahime.shiga.jp",
	"toyosato.shiga.jp",
	"yasu.shiga.jp",
	"akagi.shimane.jp",
	"ama.shimane.jp",
	"gotsu.shimane.jp",
	"hamada.shimane.jp",
	"higashiizumo.shimane.jp",
	"hikawa.shimane.jp",
	"hikimi.shimane.jp",
	"izumo.shimane.jp",
	"kakinoki.shimane.jp",
	"masuda.shimane.jp",
	"matsue.shimane.jp",
	"misato.shimane.jp",
	"nishinoshima.shimane.jp",
	"ohda.shimane.jp",
	"okinoshima.shimane.jp",
	"okuizumo.shimane.jp",
	"shimane.shimane.jp",
	"tamayu.shimane.jp",
	"tsuwano.shimane.jp",
	"unnan.shimane.jp",
	"yakumo.shimane.jp",
	"yasugi.shimane.jp",
	"yatsuka.shimane.jp",
	"arai.shizuoka.jp",
	"atami.shizuoka.jp",
	"fuji.shizuoka.jp",
	"fujieda.shizuoka.jp",
	"fujikawa.shizuoka.jp",
	"fujinomiya.shizuoka.jp",
	"fukuroi.shizuoka.jp",
	"gotemba.shizuoka.jp",
	"haibara.shizuoka.jp",
	"hamamatsu.shizuoka.jp",
	"higashiizu.shizuoka.jp",
	"ito.shizuoka.jp",
	"iwata.shizuoka.jp",
	"izu.shizuoka.jp",
	"izunokuni.shizuoka.jp",
	"kakegawa.shizuoka.jp",
	"kannami.shizuoka.jp",
	"kawanehon.shizuoka.jp",
	"kawazu.shizuoka.jp",
	"kikugawa.shizuoka.jp",
	"kosai.shizuoka.jp",
	"makinohara.shizuoka.jp",
	"matsuzaki.shizuoka.jp",
	"minamiizu.shizuoka.jp",
	"mishima.shizuoka.jp",
	"morimachi.shizuoka.jp",
	"nishiizu.shizuoka.jp",
	"numazu.shizuoka.jp",
	"omaezaki.shizuoka.jp",
	"shimada.shizuoka.jp",
	"shimizu.shizuoka.jp",
	"shimoda.shizuoka.jp",
	"shizuoka.shizuoka.jp",
	"susono.shizuoka.jp",
	"yaizu.shizuoka.jp",
	"yoshida.shizuoka.jp",
	"ashikaga.tochigi.jp",
	"bato.tochigi.jp",
	"haga.tochigi.jp",
	"ichikai.tochigi.jp",
	"iwafune.tochigi.jp",
	"kaminokawa.tochigi.jp",
	"kanuma.tochigi.jp",
	"karasuyama.tochigi.jp",
	"kuroiso.tochigi.jp",
	"mashiko.tochigi.jp",
	"mibu.tochigi.jp",
	"moka.tochigi.jp",
	"motegi.tochigi.jp",
	"nasu.tochigi.jp",
	"nasushiobara.tochigi.jp",
	"nikko.tochigi.jp",
	"nishikata.tochigi.jp",
	"nogi.tochigi.jp",
	"ohira.tochigi.jp",
	"ohtawara.tochigi.jp",
	"oyama.tochigi.jp",
	"sakura.tochigi.jp",
	"sano.tochigi.jp",
	"shimotsuke.tochigi.jp",
	"shioya.tochigi.jp",
	"takanezawa.tochigi.jp",
	"tochigi.tochigi.jp",
	"tsuga.tochigi.jp",
	"ujiie.tochigi.jp",
	"utsunomiya.tochigi.jp",
	"yaita.tochigi.jp",
	"aizumi.tokushima.jp",
	"anan.tokushima.jp",
	"ichiba.tokushima.jp",
	"itano.tokushima.jp",
	"kainan.tokushima.jp",
	"komatsushima.tokushima.jp",
	"matsushige.tokushima.jp",
	"mima.tokushima.jp",
	"minami.tokushima.jp",
	"miyoshi.tokushima.jp",
	"mugi.tokushima.jp",
	"nakagawa.tokushima.jp",
	"naruto.tokushima.jp",
	"sanagochi.tokushima.jp",
	"shishikui.tokushima.jp",
	"tokushima.tokushima.jp",
	"wajiki.tokushima.jp",
	"adachi.tokyo.jp",
	"akiruno.tokyo.jp",
	"akishima.tokyo.jp",
	"aogashima.tokyo.jp",
	"arakawa.tokyo.jp",
	"bunkyo.tokyo.jp",
	"chiyoda.tokyo.jp",
	"chofu.tokyo.jp",
	"chuo.tokyo.jp",
	"edogawa.tokyo.jp",
	"fuchu.tokyo.jp",
	"fussa.tokyo.jp",
	"hachijo.tokyo.jp",
	"hachioji.tokyo.jp",
	"hamura.tokyo.jp",
	"higashikurume.tokyo.jp",
	"higashimurayama.tokyo.jp",
	"higashiyamato.tokyo.jp",
	"hino.tokyo.jp",
	"hinode.tokyo.jp",
	"hinohara.tokyo.jp",
	"inagi.tokyo.jp",
	"itabashi.tokyo.jp",
	"katsushika.tokyo.jp",
	"kita.tokyo.jp",
	"kiyose.tokyo.jp",
	"kodaira.tokyo.jp",
	"koganei.tokyo.jp",
	"kokubunji.tokyo.jp",
	"komae.tokyo.jp",
	"koto.tokyo.jp",
	"kouzushima.tokyo.jp",
	"kunitachi.tokyo.jp",
	"machida.tokyo.jp",
	"meguro.tokyo.jp",
	"minato.tokyo.jp",
	"mitaka.tokyo.jp",
	"mizuho.tokyo.jp",
	"musashimurayama.tokyo.jp",
	"musashino.tokyo.jp",
	"nakano.tokyo.jp",
	"nerima.tokyo.jp",
	"ogasawara.tokyo.jp",
	"okutama.tokyo.jp",
	"ome.tokyo.jp",
	"oshima.tokyo.jp",
	"ota.tokyo.jp",
	"setagaya.tokyo.jp",
	"shibuya.tokyo.jp",
	"shinagawa.tokyo.jp",
	"shinjuku.tokyo.jp",
	"suginami.tokyo.jp",
	"sumida.tokyo.jp",
	"tachikawa.tokyo.jp",
	"taito.tokyo.jp",
	"tama.tokyo.jp",
	"toshima.tokyo.jp",
	"chizu.tottori.jp",
	"hino.tottori.jp",
	"kawahara.tottori.jp",
	"koge.tottori.jp",
	"kotoura.tottori.jp",
	"misasa.tottori.jp",
	"nanbu.tottori.jp",
	"nichinan.tottori.jp",
	"sakaiminato.tottori.jp",
	"tottori.tottori.jp",
	"wakasa.tottori.jp",
	"yazu.tottori.jp",
	"yonago.tottori.jp",
	"asahi.toyama.jp",
	"fuchu.toyama.jp",
	"fukumitsu.toyama.jp",
	"funahashi.toyama.jp",
	"himi.toyama.jp",
	"imizu.toyama.jp",
	"inami.toyama.jp",
	"johana.toyama.jp",
	"kamiichi.toyama.jp",
	"kurobe.toyama.jp",
	"nakaniikawa.toyama.jp",
	"namerikawa.toyama.jp",
	"nanto.toyama.jp",
	"nyuzen.toyama.jp",
	"oyabe.toyama.jp",
	"taira.toyama.jp",
	"takaoka.toyama.jp",
	"tateyama.toyama.jp",
	"toga.toyama.jp",
	"tonami.toyama.jp",
	"toyama.toyama.jp",
	"unazuki.toyama.jp",
	"uozu.toyama.jp",
	"yamada.toyama.jp",
	"arida.wakayama.jp",
	"aridagawa.wakayama.jp",
	"gobo.wakayama.jp",
	"hashimoto.wakayama.jp",
	"hidaka.wakayama.jp",
	"hirogawa.wakayama.jp",
	"inami.wakayama.jp",
	"iwade.wakayama.jp",
	"kainan.wakayama.jp",
	"kamitonda.wakayama.jp",
	"katsuragi.wakayama.jp",
	"kimino.wakayama.jp",
	"kinokawa.wakayama.jp",
	"kitayama.wakayama.jp",
	"koya.wakayama.jp",
	"koza.wakayama.jp",
	"kozagawa.wakayama.jp",
	"kudoyama.wakayama.jp",
	"kushimoto.wakayama.jp",
	"mihama.wakayama.jp",
	"misato.wakayama.jp",
	"nachikatsuura.wakayama.jp",
	"shingu.wakayama.jp",
	"shirahama.wakayama.jp",
	"taiji.wakayama.jp",
	"tanabe.wakayama.jp",
	"wakayama.wakayama.jp",
	"yuasa.wakayama.jp",
	"yura.wakayama.jp",
	"asahi.yamagata.jp",
	"funagata.yamagata.jp",
	"higashine.yamagata.jp",
	"iide.yamagata.jp",
	"kahoku.yamagata.jp",
	"kaminoyama.yamagata.jp",
	"kaneyama.yamagata.jp",
	"kawanishi.yamagata.jp",
	"mamurogawa.yamagata.jp",
	"mikawa.yamagata.jp",
	"murayama.yamagata.jp",
	"nagai.yamagata.jp",
	"nakayama.yamagata.jp",
	"nanyo.yamagata.jp",
	"nishikawa.yamagata.jp",
	"obanazawa.yamagata.jp",
	"oe.yamagata.jp",
	"oguni.yamagata.jp",
	"ohkura.yamagata.jp",
	"oishida.yamagata.jp",
	"sagae.yamagata.jp",
	"sakata.yamagata.jp",
	"sakegawa.yamagata.jp",
	"shinjo.yamagata.jp",
	"shirataka.yamagata.jp",
	"shonai.yamagata.jp",
	"takahata.yamagata.jp",
	"tendo.yamagata.jp",
	"tozawa.yamagata.jp",
	"tsuruoka.yamagata.jp",
	"yamagata.yamagata.jp",
	"yamanobe.yamagata.jp",
	"yonezawa.yamagata.jp",
	"yuza.yamagata.jp",
	"abu.yamaguchi.jp",
	"hagi.yamaguchi.jp",
	"hikari.yamaguchi.jp",
	"hofu.yamaguchi.jp",
	"iwakuni.yamaguchi.jp",
	"kudamatsu.yamaguchi.jp",
	"mitou.yamaguchi.jp",
	"nagato.yamaguchi.jp",
	"oshima.yamaguchi.jp",
	"shimonoseki.yamaguchi.jp",
	"shunan.yamaguchi.jp",
	"tabuse.yamaguchi.jp",
	"tokuyama.yamaguchi.jp",
	"toyota.yamaguchi.jp",
	"ube.yamaguchi.jp",
	"yuu.yamaguchi.jp",
	"chuo.yamanashi.jp",
	"doshi.yamanashi.jp",
	"fuefuki.yamanashi.jp",
	"fujikawa.yamanashi.jp",
	"fujikawaguchiko.yamanashi.jp",
	"fujiyoshida.yamanashi.jp",
	"hayakawa.yamanashi.jp",
	"hokuto.yamanashi.jp",
	"ichikawamisato.yamanashi.jp",
	"kai.yamanashi.jp",
	"kofu.yamanashi.jp",
	"koshu.yamanashi.jp",
	"kosuge.yamanashi.jp",
	"minami-alps.yamanashi.jp",
	"minobu.yamanashi.jp",
	"nakamichi.yamanashi.jp",
	"nanbu.yamanashi.jp",
	"narusawa.yamanashi.jp",
	"nirasaki.yamanashi.jp",
	"nishikatsura.yamanashi.jp",
	"oshino.yamanashi.jp",
	"otsuki.yamanashi.jp",
	"showa.yamanashi.jp",
	"tabayama.yamanashi.jp",
	"tsuru.yamanashi.jp",
	"uenohara.yamanashi.jp",
	"yamanakako.yamanashi.jp",
	"yamanashi.yamanashi.jp",
	"ke",
	"ac.ke",
	"co.ke",
	"go.ke",
	"info.ke",
	"me.ke",
	"mobi.ke",
	"ne.ke",
	"or.ke",
	"sc.ke",
	"kg",
	"org.kg",
	"net.kg",
	"com.kg",
	"edu.kg",
	"gov.kg",
	"mil.kg",
	"*.kh",
	"ki",
	"edu.ki",
	"biz.ki",
	"net.ki",
	"org.ki",
	"gov.ki",
	"info.ki",
	"com.ki",
	"km",
	"org.km",
	"nom.km",
	"gov.km",
	"prd.km",
	"tm.km",
	"edu.km",
	"mil.km",
	"ass.km",
	"com.km",
	"coop.km",
	"asso.km",
	"presse.km",
	"medecin.km",
	"notaires.km",
	"pharmaciens.km",
	"veterinaire.km",
	"gouv.km",
	"kn",
	"net.kn",
	"org.kn",
	"edu.kn",
	"gov.kn",
	"kp",
	"com.kp",
	"edu.kp",
	"gov.kp",
	"org.kp",
	"rep.kp",
	"tra.kp",
	"kr",
	"ac.kr",
	"co.kr",
	"es.kr",
	"go.kr",
	"hs.kr",
	"kg.kr",
	"mil.kr",
	"ms.kr",
	"ne.kr",
	"or.kr",
	"pe.kr",
	"re.kr",
	"sc.kr",
	"busan.kr",
	"chungbuk.kr",
	"chungnam.kr",
	"daegu.kr",
	"daejeon.kr",
	"gangwon.kr",
	"gwangju.kr",
	"gyeongbuk.kr",
	"gyeonggi.kr",
	"gyeongnam.kr",
	"incheon.kr",
	"jeju.kr",
	"jeonbuk.kr",
	"jeonnam.kr",
	"seoul.kr",
	"ulsan.kr",
	"kw",
	"com.kw",
	"edu.kw",
	"emb.kw",
	"gov.kw",
	"ind.kw",
	"net.kw",
	"org.kw",
	"ky",
	"edu.ky",
	"gov.ky",
	"com.ky",
	"org.ky",
	"net.ky",
	"kz",
	"org.kz",
	"edu.kz",
	"net.kz",
	"gov.kz",
	"mil.kz",
	"com.kz",
	"la",
	"int.la",
	"net.la",
	"info.la",
	"edu.la",
	"gov.la",
	"per.la",
	"com.la",
	"org.la",
	"lb",
	"com.lb",
	"edu.lb",
	"gov.lb",
	"net.lb",
	"org.lb",
	"lc",
	"com.lc",
	"net.lc",
	"co.lc",
	"org.lc",
	"edu.lc",
	"gov.lc",
	"li",
	"lk",
	"gov.lk",
	"sch.lk",
	"net.lk",
	"int.lk",
	"com.lk",
	"org.lk",
	"edu.lk",
	"ngo.lk",
	"soc.lk",
	"web.lk",
	"ltd.lk",
	"assn.lk",
	"grp.lk",
	"hotel.lk",
	"ac.lk",
	"lr",
	"com.lr",
	"edu.lr",
	"gov.lr",
	"org.lr",
	"net.lr",
	"ls",
	"ac.ls",
	"biz.ls",
	"co.ls",
	"edu.ls",
	"gov.ls",
	"info.ls",
	"net.ls",
	"org.ls",
	"sc.ls",
	"lt",
	"gov.lt",
	"lu",
	"lv",
	"com.lv",
	"edu.lv",
	"gov.lv",
	"org.lv",
	"mil.lv",
	"id.lv",
	"net.lv",
	"asn.lv",
	"conf.lv",
	"ly",
	"com.ly",
	"net.ly",
	"gov.ly",
	"plc.ly",
	"edu.ly",
	"sch.ly",
	"med.ly",
	"org.ly",
	"id.ly",
	"ma",
	"co.ma",
	"net.ma",
	"gov.ma",
	"org.ma",
	"ac.ma",
	"press.ma",
	"mc",
	"tm.mc",
	"asso.mc",
	"md",
	"me",
	"co.me",
	"net.me",
	"org.me",
	"edu.me",
	"ac.me",
	"gov.me",
	"its.me",
	"priv.me",
	"mg",
	"org.mg",
	"nom.mg",
	"gov.mg",
	"prd.mg",
	"tm.mg",
	"edu.mg",
	"mil.mg",
	"com.mg",
	"co.mg",
	"mh",
	"mil",
	"mk",
	"com.mk",
	"org.mk",
	"net.mk",
	"edu.mk",
	"gov.mk",
	"inf.mk",
	"name.mk",
	"ml",
	"com.ml",
	"edu.ml",
	"gouv.ml",
	"gov.ml",
	"net.ml",
	"org.ml",
	"presse.ml",
	"*.mm",
	"mn",
	"gov.mn",
	"edu.mn",
	"org.mn",
	"mo",
	"com.mo",
	"net.mo",
	"org.mo",
	"edu.mo",
	"gov.mo",
	"mobi",
	"mp",
	"mq",
	"mr",
	"gov.mr",
	"ms",
	"com.ms",
	"edu.ms",
	"gov.ms",
	"net.ms",
	"org.ms",
	"mt",
	"com.mt",
	"edu.mt",
	"net.mt",
	"org.mt",
	"mu",
	"com.mu",
	"net.mu",
	"org.mu",
	"gov.mu",
	"ac.mu",
	"co.mu",
	"or.mu",
	"museum",
	"academy.museum",
	"agriculture.museum",
	"air.museum",
	"airguard.museum",
	"alabama.museum",
	"alaska.museum",
	"amber.museum",
	"ambulance.museum",
	"american.museum",
	"americana.museum",
	"americanantiques.museum",
	"americanart.museum",
	"amsterdam.museum",
	"and.museum",
	"annefrank.museum",
	"anthro.museum",
	"anthropology.museum",
	"antiques.museum",
	"aquarium.museum",
	"arboretum.museum",
	"archaeological.museum",
	"archaeology.museum",
	"architecture.museum",
	"art.museum",
	"artanddesign.museum",
	"artcenter.museum",
	"artdeco.museum",
	"arteducation.museum",
	"artgallery.museum",
	"arts.museum",
	"artsandcrafts.museum",
	"asmatart.museum",
	"assassination.museum",
	"assisi.museum",
	"association.museum",
	"astronomy.museum",
	"atlanta.museum",
	"austin.museum",
	"australia.museum",
	"automotive.museum",
	"aviation.museum",
	"axis.museum",
	"badajoz.museum",
	"baghdad.museum",
	"bahn.museum",
	"bale.museum",
	"baltimore.museum",
	"barcelona.museum",
	"baseball.museum",
	"basel.museum",
	"baths.museum",
	"bauern.museum",
	"beauxarts.museum",
	"beeldengeluid.museum",
	"bellevue.museum",
	"bergbau.museum",
	"berkeley.museum",
	"berlin.museum",
	"bern.museum",
	"bible.museum",
	"bilbao.museum",
	"bill.museum",
	"birdart.museum",
	"birthplace.museum",
	"bonn.museum",
	"boston.museum",
	"botanical.museum",
	"botanicalgarden.museum",
	"botanicgarden.museum",
	"botany.museum",
	"brandywinevalley.museum",
	"brasil.museum",
	"bristol.museum",
	"british.museum",
	"britishcolumbia.museum",
	"broadcast.museum",
	"brunel.museum",
	"brussel.museum",
	"brussels.museum",
	"bruxelles.museum",
	"building.museum",
	"burghof.museum",
	"bus.museum",
	"bushey.museum",
	"cadaques.museum",
	"california.museum",
	"cambridge.museum",
	"can.museum",
	"canada.museum",
	"capebreton.museum",
	"carrier.museum",
	"cartoonart.museum",
	"casadelamoneda.museum",
	"castle.museum",
	"castres.museum",
	"celtic.museum",
	"center.museum",
	"chattanooga.museum",
	"cheltenham.museum",
	"chesapeakebay.museum",
	"chicago.museum",
	"children.museum",
	"childrens.museum",
	"childrensgarden.museum",
	"chiropractic.museum",
	"chocolate.museum",
	"christiansburg.museum",
	"cincinnati.museum",
	"cinema.museum",
	"circus.museum",
	"civilisation.museum",
	"civilization.museum",
	"civilwar.museum",
	"clinton.museum",
	"clock.museum",
	"coal.museum",
	"coastaldefence.museum",
	"cody.museum",
	"coldwar.museum",
	"collection.museum",
	"colonialwilliamsburg.museum",
	"coloradoplateau.museum",
	"columbia.museum",
	"columbus.museum",
	"communication.museum",
	"communications.museum",
	"community.museum",
	"computer.museum",
	"computerhistory.museum",
	"comunicações.museum",
	"contemporary.museum",
	"contemporaryart.museum",
	"convent.museum",
	"copenhagen.museum",
	"corporation.museum",
	"correios-e-telecomunicações.museum",
	"corvette.museum",
	"costume.museum",
	"countryestate.museum",
	"county.museum",
	"crafts.museum",
	"cranbrook.museum",
	"creation.museum",
	"cultural.museum",
	"culturalcenter.museum",
	"culture.museum",
	"cyber.museum",
	"cymru.museum",
	"dali.museum",
	"dallas.museum",
	"database.museum",
	"ddr.museum",
	"decorativearts.museum",
	"delaware.museum",
	"delmenhorst.museum",
	"denmark.museum",
	"depot.museum",
	"design.museum",
	"detroit.museum",
	"dinosaur.museum",
	"discovery.museum",
	"dolls.museum",
	"donostia.museum",
	"durham.museum",
	"eastafrica.museum",
	"eastcoast.museum",
	"education.museum",
	"educational.museum",
	"egyptian.museum",
	"eisenbahn.museum",
	"elburg.museum",
	"elvendrell.museum",
	"embroidery.museum",
	"encyclopedic.museum",
	"england.museum",
	"entomology.museum",
	"environment.museum",
	"environmentalconservation.museum",
	"epilepsy.museum",
	"essex.museum",
	"estate.museum",
	"ethnology.museum",
	"exeter.museum",
	"exhibition.museum",
	"family.museum",
	"farm.museum",
	"farmequipment.museum",
	"farmers.museum",
	"farmstead.museum",
	"field.museum",
	"figueres.museum",
	"filatelia.museum",
	"film.museum",
	"fineart.museum",
	"finearts.museum",
	"finland.museum",
	"flanders.museum",
	"florida.museum",
	"force.museum",
	"fortmissoula.museum",
	"fortworth.museum",
	"foundation.museum",
	"francaise.museum",
	"frankfurt.museum",
	"franziskaner.museum",
	"freemasonry.museum",
	"freiburg.museum",
	"fribourg.museum",
	"frog.museum",
	"fundacio.museum",
	"furniture.museum",
	"gallery.museum",
	"garden.museum",
	"gateway.museum",
	"geelvinck.museum",
	"gemological.museum",
	"geology.museum",
	"georgia.museum",
	"giessen.museum",
	"glas.museum",
	"glass.museum",
	"gorge.museum",
	"grandrapids.museum",
	"graz.museum",
	"guernsey.museum",
	"halloffame.museum",
	"hamburg.museum",
	"handson.museum",
	"harvestcelebration.museum",
	"hawaii.museum",
	"health.museum",
	"heimatunduhren.museum",
	"hellas.museum",
	"helsinki.museum",
	"hembygdsforbund.museum",
	"heritage.museum",
	"histoire.museum",
	"historical.museum",
	"historicalsociety.museum",
	"historichouses.museum",
	"historisch.museum",
	"historisches.museum",
	"history.museum",
	"historyofscience.museum",
	"horology.museum",
	"house.museum",
	"humanities.museum",
	"illustration.museum",
	"imageandsound.museum",
	"indian.museum",
	"indiana.museum",
	"indianapolis.museum",
	"indianmarket.museum",
	"intelligence.museum",
	"interactive.museum",
	"iraq.museum",
	"iron.museum",
	"isleofman.museum",
	"jamison.museum",
	"jefferson.museum",
	"jerusalem.museum",
	"jewelry.museum",
	"jewish.museum",
	"jewishart.museum",
	"jfk.museum",
	"journalism.museum",
	"judaica.museum",
	"judygarland.museum",
	"juedisches.museum",
	"juif.museum",
	"karate.museum",
	"karikatur.museum",
	"kids.museum",
	"koebenhavn.museum",
	"koeln.museum",
	"kunst.museum",
	"kunstsammlung.museum",
	"kunstunddesign.museum",
	"labor.museum",
	"labour.museum",
	"lajolla.museum",
	"lancashire.museum",
	"landes.museum",
	"lans.museum",
	"läns.museum",
	"larsson.museum",
	"lewismiller.museum",
	"lincoln.museum",
	"linz.museum",
	"living.museum",
	"livinghistory.museum",
	"localhistory.museum",
	"london.museum",
	"losangeles.museum",
	"louvre.museum",
	"loyalist.museum",
	"lucerne.museum",
	"luxembourg.museum",
	"luzern.museum",
	"mad.museum",
	"madrid.museum",
	"mallorca.museum",
	"manchester.museum",
	"mansion.museum",
	"mansions.museum",
	"manx.museum",
	"marburg.museum",
	"maritime.museum",
	"maritimo.museum",
	"maryland.museum",
	"marylhurst.museum",
	"media.museum",
	"medical.museum",
	"medizinhistorisches.museum",
	"meeres.museum",
	"memorial.museum",
	"mesaverde.museum",
	"michigan.museum",
	"midatlantic.museum",
	"military.museum",
	"mill.museum",
	"miners.museum",
	"mining.museum",
	"minnesota.museum",
	"missile.museum",
	"missoula.museum",
	"modern.museum",
	"moma.museum",
	"money.museum",
	"monmouth.museum",
	"monticello.museum",
	"montreal.museum",
	"moscow.museum",
	"motorcycle.museum",
	"muenchen.museum",
	"muenster.museum",
	"mulhouse.museum",
	"muncie.museum",
	"museet.museum",
	"museumcenter.museum",
	"museumvereniging.museum",
	"music.museum",
	"national.museum",
	"nationalfirearms.museum",
	"nationalheritage.museum",
	"nativeamerican.museum",
	"naturalhistory.museum",
	"naturalhistorymuseum.museum",
	"naturalsciences.museum",
	"nature.museum",
	"naturhistorisches.museum",
	"natuurwetenschappen.museum",
	"naumburg.museum",
	"naval.museum",
	"nebraska.museum",
	"neues.museum",
	"newhampshire.museum",
	"newjersey.museum",
	"newmexico.museum",
	"newport.museum",
	"newspaper.museum",
	"newyork.museum",
	"niepce.museum",
	"norfolk.museum",
	"north.museum",
	"nrw.museum",
	"nyc.museum",
	"nyny.museum",
	"oceanographic.museum",
	"oceanographique.museum",
	"omaha.museum",
	"online.museum",
	"ontario.museum",
	"openair.museum",
	"oregon.museum",
	"oregontrail.museum",
	"otago.museum",
	"oxford.museum",
	"pacific.museum",
	"paderborn.museum",
	"palace.museum",
	"paleo.museum",
	"palmsprings.museum",
	"panama.museum",
	"paris.museum",
	"pasadena.museum",
	"pharmacy.museum",
	"philadelphia.museum",
	"philadelphiaarea.museum",
	"philately.museum",
	"phoenix.museum",
	"photography.museum",
	"pilots.museum",
	"pittsburgh.museum",
	"planetarium.museum",
	"plantation.museum",
	"plants.museum",
	"plaza.museum",
	"portal.museum",
	"portland.museum",
	"portlligat.museum",
	"posts-and-telecommunications.museum",
	"preservation.museum",
	"presidio.museum",
	"press.museum",
	"project.museum",
	"public.museum",
	"pubol.museum",
	"quebec.museum",
	"railroad.museum",
	"railway.museum",
	"research.museum",
	"resistance.museum",
	"riodejaneiro.museum",
	"rochester.museum",
	"rockart.museum",
	"roma.museum",
	"russia.museum",
	"saintlouis.museum",
	"salem.museum",
	"salvadordali.museum",
	"salzburg.museum",
	"sandiego.museum",
	"sanfrancisco.museum",
	"santabarbara.museum",
	"santacruz.museum",
	"santafe.museum",
	"saskatchewan.museum",
	"satx.museum",
	"savannahga.museum",
	"schlesisches.museum",
	"schoenbrunn.museum",
	"schokoladen.museum",
	"school.museum",
	"schweiz.museum",
	"science.museum",
	"scienceandhistory.museum",
	"scienceandindustry.museum",
	"sciencecenter.museum",
	"sciencecenters.museum",
	"science-fiction.museum",
	"sciencehistory.museum",
	"sciences.museum",
	"sciencesnaturelles.museum",
	"scotland.museum",
	"seaport.museum",
	"settlement.museum",
	"settlers.museum",
	"shell.museum",
	"sherbrooke.museum",
	"sibenik.museum",
	"silk.museum",
	"ski.museum",
	"skole.museum",
	"society.museum",
	"sologne.museum",
	"soundandvision.museum",
	"southcarolina.museum",
	"southwest.museum",
	"space.museum",
	"spy.museum",
	"square.museum",
	"stadt.museum",
	"stalbans.museum",
	"starnberg.museum",
	"state.museum",
	"stateofdelaware.museum",
	"station.museum",
	"steam.museum",
	"steiermark.museum",
	"stjohn.museum",
	"stockholm.museum",
	"stpetersburg.museum",
	"stuttgart.museum",
	"suisse.museum",
	"surgeonshall.museum",
	"surrey.museum",
	"svizzera.museum",
	"sweden.museum",
	"sydney.museum",
	"tank.museum",
	"tcm.museum",
	"technology.museum",
	"telekommunikation.museum",
	"television.museum",
	"texas.museum",
	"textile.museum",
	"theater.museum",
	"time.museum",
	"timekeeping.museum",
	"topology.museum",
	"torino.museum",
	"touch.museum",
	"town.museum",
	"transport.museum",
	"tree.museum",
	"trolley.museum",
	"trust.museum",
	"trustee.museum",
	"uhren.museum",
	"ulm.museum",
	"undersea.museum",
	"university.museum",
	"usa.museum",
	"usantiques.museum",
	"usarts.museum",
	"uscountryestate.museum",
	"usculture.museum",
	"usdecorativearts.museum",
	"usgarden.museum",
	"ushistory.museum",
	"ushuaia.museum",
	"uslivinghistory.museum",
	"utah.museum",
	"uvic.museum",
	"valley.museum",
	"vantaa.museum",
	"versailles.museum",
	"viking.museum",
	"village.museum",
	"virginia.museum",
	"virtual.museum",
	"virtuel.museum",
	"vlaanderen.museum",
	"volkenkunde.museum",
	"wales.museum",
	"wallonie.museum",
	"war.museum",
	"washingtondc.museum",
	"watchandclock.museum",
	"watch-and-clock.museum",
	"western.museum",
	"westfalen.museum",
	"whaling.museum",
	"wildlife.museum",
	"williamsburg.museum",
	"windmill.museum",
	"workshop.museum",
	"york.museum",
	"yorkshire.museum",
	"yosemite.museum",
	"youth.museum",
	"zoological.museum",
	"zoology.museum",
	"ירושלים.museum",
	"иком.museum",
	"mv",
	"aero.mv",
	"biz.mv",
	"com.mv",
	"coop.mv",
	"edu.mv",
	"gov.mv",
	"info.mv",
	"int.mv",
	"mil.mv",
	"museum.mv",
	"name.mv",
	"net.mv",
	"org.mv",
	"pro.mv",
	"mw",
	"ac.mw",
	"biz.mw",
	"co.mw",
	"com.mw",
	"coop.mw",
	"edu.mw",
	"gov.mw",
	"int.mw",
	"museum.mw",
	"net.mw",
	"org.mw",
	"mx",
	"com.mx",
	"org.mx",
	"gob.mx",
	"edu.mx",
	"net.mx",
	"my",
	"com.my",
	"net.my",
	"org.my",
	"gov.my",
	"edu.my",
	"mil.my",
	"name.my",
	"mz",
	"ac.mz",
	"adv.mz",
	"co.mz",
	"edu.mz",
	"gov.mz",
	"mil.mz",
	"net.mz",
	"org.mz",
	"na",
	"info.na",
	"pro.na",
	"name.na",
	"school.na",
	"or.na",
	"dr.na",
	"us.na",
	"mx.na",
	"ca.na",
	"in.na",
	"cc.na",
	"tv.na",
	"ws.na",
	"mobi.na",
	"co.na",
	"com.na",
	"org.na",
	"name",
	"nc",
	"asso.nc",
	"nom.nc",
	"ne",
	"net",
	"nf",
	"com.nf",
	"net.nf",
	"per.nf",
	"rec.nf",
	"web.nf",
	"arts.nf",
	"firm.nf",
	"info.nf",
	"other.nf",
	"store.nf",
	"ng",
	"com.ng",
	"edu.ng",
	"gov.ng",
	"i.ng",
	"mil.ng",
	"mobi.ng",
	"name.ng",
	"net.ng",
	"org.ng",
	"sch.ng",
	"ni",
	"ac.ni",
	"biz.ni",
	"co.ni",
	"com.ni",
	"edu.ni",
	"gob.ni",
	"in.ni",
	"info.ni",
	"int.ni",
	"mil.ni",
	"net.ni",
	"nom.ni",
	"org.ni",
	"web.ni",
	"nl",
	"no",
	"fhs.no",
	"vgs.no",
	"fylkesbibl.no",
	"folkebibl.no",
	"museum.no",
	"idrett.no",
	"priv.no",
	"mil.no",
	"stat.no",
	"dep.no",
	"kommune.no",
	"herad.no",
	"aa.no",
	"ah.no",
	"bu.no",
	"fm.no",
	"hl.no",
	"hm.no",
	"jan-mayen.no",
	"mr.no",
	"nl.no",
	"nt.no",
	"of.no",
	"ol.no",
	"oslo.no",
	"rl.no",
	"sf.no",
	"st.no",
	"svalbard.no",
	"tm.no",
	"tr.no",
	"va.no",
	"vf.no",
	"gs.aa.no",
	"gs.ah.no",
	"gs.bu.no",
	"gs.fm.no",
	"gs.hl.no",
	"gs.hm.no",
	"gs.jan-mayen.no",
	"gs.mr.no",
	"gs.nl.no",
	"gs.nt.no",
	"gs.of.no",
	"gs.ol.no",
	"gs.oslo.no",
	"gs.rl.no",
	"gs.sf.no",
	"gs.st.no",
	"gs.svalbard.no",
	"gs.tm.no",
	"gs.tr.no",
	"gs.va.no",
	"gs.vf.no",
	"akrehamn.no",
	"åkrehamn.no",
	"algard.no",
	"ålgård.no",
	"arna.no",
	"brumunddal.no",
	"bryne.no",
	"bronnoysund.no",
	"brønnøysund.no",
	"drobak.no",
	"drøbak.no",
	"egersund.no",
	"fetsund.no",
	"floro.no",
	"florø.no",
	"fredrikstad.no",
	"hokksund.no",
	"honefoss.no",
	"hønefoss.no",
	"jessheim.no",
	"jorpeland.no",
	"jørpeland.no",
	"kirkenes.no",
	"kopervik.no",
	"krokstadelva.no",
	"langevag.no",
	"langevåg.no",
	"leirvik.no",
	"mjondalen.no",
	"mjøndalen.no",
	"mo-i-rana.no",
	"mosjoen.no",
	"mosjøen.no",
	"nesoddtangen.no",
	"orkanger.no",
	"osoyro.no",
	"osøyro.no",
	"raholt.no",
	"råholt.no",
	"sandnessjoen.no",
	"sandnessjøen.no",
	"skedsmokorset.no",
	"slattum.no",
	"spjelkavik.no",
	"stathelle.no",
	"stavern.no",
	"stjordalshalsen.no",
	"stjørdalshalsen.no",
	"tananger.no",
	"tranby.no",
	"vossevangen.no",
	"afjord.no",
	"åfjord.no",
	"agdenes.no",
	"al.no",
	"ål.no",
	"alesund.no",
	"ålesund.no",
	"alstahaug.no",
	"alta.no",
	"áltá.no",
	"alaheadju.no",
	"álaheadju.no",
	"alvdal.no",
	"amli.no",
	"åmli.no",
	"amot.no",
	"åmot.no",
	"andebu.no",
	"andoy.no",
	"andøy.no",
	"andasuolo.no",
	"ardal.no",
	"årdal.no",
	"aremark.no",
	"arendal.no",
	"ås.no",
	"aseral.no",
	"åseral.no",
	"asker.no",
	"askim.no",
	"askvoll.no",
	"askoy.no",
	"askøy.no",
	"asnes.no",
	"åsnes.no",
	"audnedaln.no",
	"aukra.no",
	"aure.no",
	"aurland.no",
	"aurskog-holand.no",
	"aurskog-høland.no",
	"austevoll.no",
	"austrheim.no",
	"averoy.no",
	"averøy.no",
	"balestrand.no",
	"ballangen.no",
	"balat.no",
	"bálát.no",
	"balsfjord.no",
	"bahccavuotna.no",
	"báhccavuotna.no",
	"bamble.no",
	"bardu.no",
	"beardu.no",
	"beiarn.no",
	"bajddar.no",
	"bájddar.no",
	"baidar.no",
	"báidár.no",
	"berg.no",
	"bergen.no",
	"berlevag.no",
	"berlevåg.no",
	"bearalvahki.no",
	"bearalváhki.no",
	"bindal.no",
	"birkenes.no",
	"bjarkoy.no",
	"bjarkøy.no",
	"bjerkreim.no",
	"bjugn.no",
	"bodo.no",
	"bodø.no",
	"badaddja.no",
	"bådåddjå.no",
	"budejju.no",
	"bokn.no",
	"bremanger.no",
	"bronnoy.no",
	"brønnøy.no",
	"bygland.no",
	"bykle.no",
	"barum.no",
	"bærum.no",
	"bo.telemark.no",
	"bø.telemark.no",
	"bo.nordland.no",
	"bø.nordland.no",
	"bievat.no",
	"bievát.no",
	"bomlo.no",
	"bømlo.no",
	"batsfjord.no",
	"båtsfjord.no",
	"bahcavuotna.no",
	"báhcavuotna.no",
	"dovre.no",
	"drammen.no",
	"drangedal.no",
	"dyroy.no",
	"dyrøy.no",
	"donna.no",
	"dønna.no",
	"eid.no",
	"eidfjord.no",
	"eidsberg.no",
	"eidskog.no",
	"eidsvoll.no",
	"eigersund.no",
	"elverum.no",
	"enebakk.no",
	"engerdal.no",
	"etne.no",
	"etnedal.no",
	"evenes.no",
	"evenassi.no",
	"evenášši.no",
	"evje-og-hornnes.no",
	"farsund.no",
	"fauske.no",
	"fuossko.no",
	"fuoisku.no",
	"fedje.no",
	"fet.no",
	"finnoy.no",
	"finnøy.no",
	"fitjar.no",
	"fjaler.no",
	"fjell.no",
	"flakstad.no",
	"flatanger.no",
	"flekkefjord.no",
	"flesberg.no",
	"flora.no",
	"fla.no",
	"flå.no",
	"folldal.no",
	"forsand.no",
	"fosnes.no",
	"frei.no",
	"frogn.no",
	"froland.no",
	"frosta.no",
	"frana.no",
	"fræna.no",
	"froya.no",
	"frøya.no",
	"fusa.no",
	"fyresdal.no",
	"forde.no",
	"førde.no",
	"gamvik.no",
	"gangaviika.no",
	"gáŋgaviika.no",
	"gaular.no",
	"gausdal.no",
	"gildeskal.no",
	"gildeskål.no",
	"giske.no",
	"gjemnes.no",
	"gjerdrum.no",
	"gjerstad.no",
	"gjesdal.no",
	"gjovik.no",
	"gjøvik.no",
	"gloppen.no",
	"gol.no",
	"gran.no",
	"grane.no",
	"granvin.no",
	"gratangen.no",
	"grimstad.no",
	"grong.no",
	"kraanghke.no",
	"kråanghke.no",
	"grue.no",
	"gulen.no",
	"hadsel.no",
	"halden.no",
	"halsa.no",
	"hamar.no",
	"hamaroy.no",
	"habmer.no",
	"hábmer.no",
	"hapmir.no",
	"hápmir.no",
	"hammerfest.no",
	"hammarfeasta.no",
	"hámmárfeasta.no",
	"haram.no",
	"hareid.no",
	"harstad.no",
	"hasvik.no",
	"aknoluokta.no",
	"ákŋoluokta.no",
	"hattfjelldal.no",
	"aarborte.no",
	"haugesund.no",
	"hemne.no",
	"hemnes.no",
	"hemsedal.no",
	"heroy.more-og-romsdal.no",
	"herøy.møre-og-romsdal.no",
	"heroy.nordland.no",
	"herøy.nordland.no",
	"hitra.no",
	"hjartdal.no",
	"hjelmeland.no",
	"hobol.no",
	"hobøl.no",
	"hof.no",
	"hol.no",
	"hole.no",
	"holmestrand.no",
	"holtalen.no",
	"holtålen.no",
	"hornindal.no",
	"horten.no",
	"hurdal.no",
	"hurum.no",
	"hvaler.no",
	"hyllestad.no",
	"hagebostad.no",
	"hægebostad.no",
	"hoyanger.no",
	"høyanger.no",
	"hoylandet.no",
	"høylandet.no",
	"ha.no",
	"hå.no",
	"ibestad.no",
	"inderoy.no",
	"inderøy.no",
	"iveland.no",
	"jevnaker.no",
	"jondal.no",
	"jolster.no",
	"jølster.no",
	"karasjok.no",
	"karasjohka.no",
	"kárášjohka.no",
	"karlsoy.no",
	"galsa.no",
	"gálsá.no",
	"karmoy.no",
	"karmøy.no",
	"kautokeino.no",
	"guovdageaidnu.no",
	"klepp.no",
	"klabu.no",
	"klæbu.no",
	"kongsberg.no",
	"kongsvinger.no",
	"kragero.no",
	"kragerø.no",
	"kristiansand.no",
	"kristiansund.no",
	"krodsherad.no",
	"krødsherad.no",
	"kvalsund.no",
	"rahkkeravju.no",
	"ráhkkerávju.no",
	"kvam.no",
	"kvinesdal.no",
	"kvinnherad.no",
	"kviteseid.no",
	"kvitsoy.no",
	"kvitsøy.no",
	"kvafjord.no",
	"kvæfjord.no",
	"giehtavuoatna.no",
	"kvanangen.no",
	"kvænangen.no",
	"navuotna.no",
	"návuotna.no",
	"kafjord.no",
	"kåfjord.no",
	"gaivuotna.no",
	"gáivuotna.no",
	"larvik.no",
	"lavangen.no",
	"lavagis.no",
	"loabat.no",
	"loabát.no",
	"lebesby.no",
	"davvesiida.no",
	"leikanger.no",
	"leirfjord.no",
	"leka.no",
	"leksvik.no",
	"lenvik.no",
	"leangaviika.no",
	"leaŋgaviika.no",
	"lesja.no",
	"levanger.no",
	"lier.no",
	"lierne.no",
	"lillehammer.no",
	"lillesand.no",
	"lindesnes.no",
	"lindas.no",
	"lindås.no",
	"lom.no",
	"loppa.no",
	"lahppi.no",
	"láhppi.no",
	"lund.no",
	"lunner.no",
	"luroy.no",
	"lurøy.no",
	"luster.no",
	"lyngdal.no",
	"lyngen.no",
	"ivgu.no",
	"lardal.no",
	"lerdal.no",
	"lærdal.no",
	"lodingen.no",
	"lødingen.no",
	"lorenskog.no",
	"lørenskog.no",
	"loten.no",
	"løten.no",
	"malvik.no",
	"masoy.no",
	"måsøy.no",
	"muosat.no",
	"muosát.no",
	"mandal.no",
	"marker.no",
	"marnardal.no",
	"masfjorden.no",
	"meland.no",
	"meldal.no",
	"melhus.no",
	"meloy.no",
	"meløy.no",
	"meraker.no",
	"meråker.no",
	"moareke.no",
	"moåreke.no",
	"midsund.no",
	"midtre-gauldal.no",
	"modalen.no",
	"modum.no",
	"molde.no",
	"moskenes.no",
	"moss.no",
	"mosvik.no",
	"malselv.no",
	"målselv.no",
	"malatvuopmi.no",
	"málatvuopmi.no",
	"namdalseid.no",
	"aejrie.no",
	"namsos.no",
	"namsskogan.no",
	"naamesjevuemie.no",
	"nååmesjevuemie.no",
	"laakesvuemie.no",
	"nannestad.no",
	"narvik.no",
	"narviika.no",
	"naustdal.no",
	"nedre-eiker.no",
	"nes.akershus.no",
	"nes.buskerud.no",
	"nesna.no",
	"nesodden.no",
	"nesseby.no",
	"unjarga.no",
	"unjárga.no",
	"nesset.no",
	"nissedal.no",
	"nittedal.no",
	"nord-aurdal.no",
	"nord-fron.no",
	"nord-odal.no",
	"norddal.no",
	"nordkapp.no",
	"davvenjarga.no",
	"davvenjárga.no",
	"nordre-land.no",
	"nordreisa.no",
	"raisa.no",
	"ráisa.no",
	"nore-og-uvdal.no",
	"notodden.no",
	"naroy.no",
	"nærøy.no",
	"notteroy.no",
	"nøtterøy.no",
	"odda.no",
	"oksnes.no",
	"øksnes.no",
	"oppdal.no",
	"oppegard.no",
	"oppegård.no",
	"orkdal.no",
	"orland.no",
	"ørland.no",
	"orskog.no",
	"ørskog.no",
	"orsta.no",
	"ørsta.no",
	"os.hedmark.no",
	"os.hordaland.no",
	"osen.no",
	"osteroy.no",
	"osterøy.no",
	"ostre-toten.no",
	"østre-toten.no",
	"overhalla.no",
	"ovre-eiker.no",
	"øvre-eiker.no",
	"oyer.no",
	"øyer.no",
	"oygarden.no",
	"øygarden.no",
	"oystre-slidre.no",
	"øystre-slidre.no",
	"porsanger.no",
	"porsangu.no",
	"porsáŋgu.no",
	"porsgrunn.no",
	"radoy.no",
	"radøy.no",
	"rakkestad.no",
	"rana.no",
	"ruovat.no",
	"randaberg.no",
	"rauma.no",
	"rendalen.no",
	"rennebu.no",
	"rennesoy.no",
	"rennesøy.no",
	"rindal.no",
	"ringebu.no",
	"ringerike.no",
	"ringsaker.no",
	"rissa.no",
	"risor.no",
	"risør.no",
	"roan.no",
	"rollag.no",
	"rygge.no",
	"ralingen.no",
	"rælingen.no",
	"rodoy.no",
	"rødøy.no",
	"romskog.no",
	"rømskog.no",
	"roros.no",
	"røros.no",
	"rost.no",
	"røst.no",
	"royken.no",
	"røyken.no",
	"royrvik.no",
	"røyrvik.no",
	"rade.no",
	"råde.no",
	"salangen.no",
	"siellak.no",
	"saltdal.no",
	"salat.no",
	"sálát.no",
	"sálat.no",
	"samnanger.no",
	"sande.more-og-romsdal.no",
	"sande.møre-og-romsdal.no",
	"sande.vestfold.no",
	"sandefjord.no",
	"sandnes.no",
	"sandoy.no",
	"sandøy.no",
	"sarpsborg.no",
	"sauda.no",
	"sauherad.no",
	"sel.no",
	"selbu.no",
	"selje.no",
	"seljord.no",
	"sigdal.no",
	"siljan.no",
	"sirdal.no",
	"skaun.no",
	"skedsmo.no",
	"ski.no",
	"skien.no",
	"skiptvet.no",
	"skjervoy.no",
	"skjervøy.no",
	"skierva.no",
	"skiervá.no",
	"skjak.no",
	"skjåk.no",
	"skodje.no",
	"skanland.no",
	"skånland.no",
	"skanit.no",
	"skánit.no",
	"smola.no",
	"smøla.no",
	"snillfjord.no",
	"snasa.no",
	"snåsa.no",
	"snoasa.no",
	"snaase.no",
	"snåase.no",
	"sogndal.no",
	"sokndal.no",
	"sola.no",
	"solund.no",
	"songdalen.no",
	"sortland.no",
	"spydeberg.no",
	"stange.no",
	"stavanger.no",
	"steigen.no",
	"steinkjer.no",
	"stjordal.no",
	"stjørdal.no",
	"stokke.no",
	"stor-elvdal.no",
	"stord.no",
	"stordal.no",
	"storfjord.no",
	"omasvuotna.no",
	"strand.no",
	"stranda.no",
	"stryn.no",
	"sula.no",
	"suldal.no",
	"sund.no",
	"sunndal.no",
	"surnadal.no",
	"sveio.no",
	"svelvik.no",
	"sykkylven.no",
	"sogne.no",
	"søgne.no",
	"somna.no",
	"sømna.no",
	"sondre-land.no",
	"søndre-land.no",
	"sor-aurdal.no",
	"sør-aurdal.no",
	"sor-fron.no",
	"sør-fron.no",
	"sor-odal.no",
	"sør-odal.no",
	"sor-varanger.no",
	"sør-varanger.no",
	"matta-varjjat.no",
	"mátta-várjjat.no",
	"sorfold.no",
	"sørfold.no",
	"sorreisa.no",
	"sørreisa.no",
	"sorum.no",
	"sørum.no",
	"tana.no",
	"deatnu.no",
	"time.no",
	"tingvoll.no",
	"tinn.no",
	"tjeldsund.no",
	"dielddanuorri.no",
	"tjome.no",
	"tjøme.no",
	"tokke.no",
	"tolga.no",
	"torsken.no",
	"tranoy.no",
	"tranøy.no",
	"tromso.no",
	"tromsø.no",
	"tromsa.no",
	"romsa.no",
	"trondheim.no",
	"troandin.no",
	"trysil.no",
	"trana.no",
	"træna.no",
	"trogstad.no",
	"trøgstad.no",
	"tvedestrand.no",
	"tydal.no",
	"tynset.no",
	"tysfjord.no",
	"divtasvuodna.no",
	"divttasvuotna.no",
	"tysnes.no",
	"tysvar.no",
	"tysvær.no",
	"tonsberg.no",
	"tønsberg.no",
	"ullensaker.no",
	"ullensvang.no",
	"ulvik.no",
	"utsira.no",
	"vadso.no",
	"vadsø.no",
	"cahcesuolo.no",
	"čáhcesuolo.no",
	"vaksdal.no",
	"valle.no",
	"vang.no",
	"vanylven.no",
	"vardo.no",
	"vardø.no",
	"varggat.no",
	"várggát.no",
	"vefsn.no",
	"vaapste.no",
	"vega.no",
	"vegarshei.no",
	"vegårshei.no",
	"vennesla.no",
	"verdal.no",
	"verran.no",
	"vestby.no",
	"vestnes.no",
	"vestre-slidre.no",
	"vestre-toten.no",
	"vestvagoy.no",
	"vestvågøy.no",
	"vevelstad.no",
	"vik.no",
	"vikna.no",
	"vindafjord.no",
	"volda.no",
	"voss.no",
	"varoy.no",
	"værøy.no",
	"vagan.no",
	"vågan.no",
	"voagat.no",
	"vagsoy.no",
	"vågsøy.no",
	"vaga.no",
	"vågå.no",
	"valer.ostfold.no",
	"våler.østfold.no",
	"valer.hedmark.no",
	"våler.hedmark.no",
	"*.np",
	"nr",
	"biz.nr",
	"info.nr",
	"gov.nr",
	"edu.nr",
	"org.nr",
	"net.nr",
	"com.nr",
	"nu",
	"nz",
	"ac.nz",
	"co.nz",
	"cri.nz",
	"geek.nz",
	"gen.nz",
	"govt.nz",
	"health.nz",
	"iwi.nz",
	"kiwi.nz",
	"maori.nz",
	"mil.nz",
	"māori.nz",
	"net.nz",
	"org.nz",
	"parliament.nz",
	"school.nz",
	"om",
	"co.om",
	"com.om",
	"edu.om",
	"gov.om",
	"med.om",
	"museum.om",
	"net.om",
	"org.om",
	"pro.om",
	"onion",
	"org",
	"pa",
	"ac.pa",
	"gob.pa",
	"com.pa",
	"org.pa",
	"sld.pa",
	"edu.pa",
	"net.pa",
	"ing.pa",
	"abo.pa",
	"med.pa",
	"nom.pa",
	"pe",
	"edu.pe",
	"gob.pe",
	"nom.pe",
	"mil.pe",
	"org.pe",
	"com.pe",
	"net.pe",
	"pf",
	"com.pf",
	"org.pf",
	"edu.pf",
	"*.pg",
	"ph",
	"com.ph",
	"net.ph",
	"org.ph",
	"gov.ph",
	"edu.ph",
	"ngo.ph",
	"mil.ph",
	"i.ph",
	"pk",
	"com.pk",
	"net.pk",
	"edu.pk",
	"org.pk",
	"fam.pk",
	"biz.pk",
	"web.pk",
	"gov.pk",
	"gob.pk",
	"gok.pk",
	"gon.pk",
	"gop.pk",
	"gos.pk",
	"info.pk",
	"pl",
	"com.pl",
	"net.pl",
	"org.pl",
	"aid.pl",
	"agro.pl",
	"atm.pl",
	"auto.pl",
	"biz.pl",
	"edu.pl",
	"gmina.pl",
	"gsm.pl",
	"info.pl",
	"mail.pl",
	"miasta.pl",
	"media.pl",
	"mil.pl",
	"nieruchomosci.pl",
	"nom.pl",
	"pc.pl",
	"powiat.pl",
	"priv.pl",
	"realestate.pl",
	"rel.pl",
	"sex.pl",
	"shop.pl",
	"sklep.pl",
	"sos.pl",
	"szkola.pl",
	"targi.pl",
	"tm.pl",
	"tourism.pl",
	"travel.pl",
	"turystyka.pl",
	"gov.pl",
	"ap.gov.pl",
	"ic.gov.pl",
	"is.gov.pl",
	"us.gov.pl",
	"kmpsp.gov.pl",
	"kppsp.gov.pl",
	"kwpsp.gov.pl",
	"psp.gov.pl",
	"wskr.gov.pl",
	"kwp.gov.pl",
	"mw.gov.pl",
	"ug.gov.pl",
	"um.gov.pl",
	"umig.gov.pl",
	"ugim.gov.pl",
	"upow.gov.pl",
	"uw.gov.pl",
	"starostwo.gov.pl",
	"pa.gov.pl",
	"po.gov.pl",
	"psse.gov.pl",
	"pup.gov.pl",
	"rzgw.gov.pl",
	"sa.gov.pl",
	"so.gov.pl",
	"sr.gov.pl",
	"wsa.gov.pl",
	"sko.gov.pl",
	"uzs.gov.pl",
	"wiih.gov.pl",
	"winb.gov.pl",
	"pinb.gov.pl",
	"wios.gov.pl",
	"witd.gov.pl",
	"wzmiuw.gov.pl",
	"piw.gov.pl",
	"wiw.gov.pl",
	"griw.gov.pl",
	"wif.gov.pl",
	"oum.gov.pl",
	"sdn.gov.pl",
	"zp.gov.pl",
	"uppo.gov.pl",
	"mup.gov.pl",
	"wuoz.gov.pl",
	"konsulat.gov.pl",
	"oirm.gov.pl",
	"augustow.pl",
	"babia-gora.pl",
	"bedzin.pl",
	"beskidy.pl",
	"bialowieza.pl",
	"bialystok.pl",
	"bielawa.pl",
	"bieszczady.pl",
	"boleslawiec.pl",
	"bydgoszcz.pl",
	"bytom.pl",
	"cieszyn.pl",
	"czeladz.pl",
	"czest.pl",
	"dlugoleka.pl",
	"elblag.pl",
	"elk.pl",
	"glogow.pl",
	"gniezno.pl",
	"gorlice.pl",
	"grajewo.pl",
	"ilawa.pl",
	"jaworzno.pl",
	"jelenia-gora.pl",
	"jgora.pl",
	"kalisz.pl",
	"kazimierz-dolny.pl",
	"karpacz.pl",
	"kartuzy.pl",
	"kaszuby.pl",
	"katowice.pl",
	"kepno.pl",
	"ketrzyn.pl",
	"klodzko.pl",
	"kobierzyce.pl",
	"kolobrzeg.pl",
	"konin.pl",
	"konskowola.pl",
	"kutno.pl",
	"lapy.pl",
	"lebork.pl",
	"legnica.pl",
	"lezajsk.pl",
	"limanowa.pl",
	"lomza.pl",
	"lowicz.pl",
	"lubin.pl",
	"lukow.pl",
	"malbork.pl",
	"malopolska.pl",
	"mazowsze.pl",
	"mazury.pl",
	"mielec.pl",
	"mielno.pl",
	"mragowo.pl",
	"naklo.pl",
	"nowaruda.pl",
	"nysa.pl",
	"olawa.pl",
	"olecko.pl",
	"olkusz.pl",
	"olsztyn.pl",
	"opoczno.pl",
	"opole.pl",
	"ostroda.pl",
	"ostroleka.pl",
	"ostrowiec.pl",
	"ostrowwlkp.pl",
	"pila.pl",
	"pisz.pl",
	"podhale.pl",
	"podlasie.pl",
	"polkowice.pl",
	"pomorze.pl",
	"pomorskie.pl",
	"prochowice.pl",
	"pruszkow.pl",
	"przeworsk.pl",
	"pulawy.pl",
	"radom.pl",
	"rawa-maz.pl",
	"rybnik.pl",
	"rzeszow.pl",
	"sanok.pl",
	"sejny.pl",
	"slask.pl",
	"slupsk.pl",
	"sosnowiec.pl",
	"stalowa-wola.pl",
	"skoczow.pl",
	"starachowice.pl",
	"stargard.pl",
	"suwalki.pl",
	"swidnica.pl",
	"swiebodzin.pl",
	"swinoujscie.pl",
	"szczecin.pl",
	"szczytno.pl",
	"tarnobrzeg.pl",
	"tgory.pl",
	"turek.pl",
	"tychy.pl",
	"ustka.pl",
	"walbrzych.pl",
	"warmia.pl",
	"warszawa.pl",
	"waw.pl",
	"wegrow.pl",
	"wielun.pl",
	"wlocl.pl",
	"wloclawek.pl",
	"wodzislaw.pl",
	"wolomin.pl",
	"wroclaw.pl",
	"zachpomor.pl",
	"zagan.pl",
	"zarow.pl",
	"zgora.pl",
	"zgorzelec.pl",
	"pm",
	"pn",
	"gov.pn",
	"co.pn",
	"org.pn",
	"edu.pn",
	"net.pn",
	"post",
	"pr",
	"com.pr",
	"net.pr",
	"org.pr",
	"gov.pr",
	"edu.pr",
	"isla.pr",
	"pro.pr",
	"biz.pr",
	"info.pr",
	"name.pr",
	"est.pr",
	"prof.pr",
	"ac.pr",
	"pro",
	"aaa.pro",
	"aca.pro",
	"acct.pro",
	"avocat.pro",
	"bar.pro",
	"cpa.pro",
	"eng.pro",
	"jur.pro",
	"law.pro",
	"med.pro",
	"recht.pro",
	"ps",
	"edu.ps",
	"gov.ps",
	"sec.ps",
	"plo.ps",
	"com.ps",
	"org.ps",
	"net.ps",
	"pt",
	"net.pt",
	"gov.pt",
	"org.pt",
	"edu.pt",
	"int.pt",
	"publ.pt",
	"com.pt",
	"nome.pt",
	"pw",
	"co.pw",
	"ne.pw",
	"or.pw",
	"ed.pw",
	"go.pw",
	"belau.pw",
	"py",
	"com.py",
	"coop.py",
	"edu.py",
	"gov.py",
	"mil.py",
	"net.py",
	"org.py",
	"qa",
	"com.qa",
	"edu.qa",
	"gov.qa",
	"mil.qa",
	"name.qa",
	"net.qa",
	"org.qa",
	"sch.qa",
	"re",
	"asso.re",
	"com.re",
	"nom.re",
	"ro",
	"arts.ro",
	"com.ro",
	"firm.ro",
	"info.ro",
	"nom.ro",
	"nt.ro",
	"org.ro",
	"rec.ro",
	"store.ro",
	"tm.ro",
	"www.ro",
	"rs",
	"ac.rs",
	"co.rs",
	"edu.rs",
	"gov.rs",
	"in.rs",
	"org.rs",
	"ru",
	"rw",
	"ac.rw",
	"co.rw",
	"coop.rw",
	"gov.rw",
	"mil.rw",
	"net.rw",
	"org.rw",
	"sa",
	"com.sa",
	"net.sa",
	"org.sa",
	"gov.sa",
	"med.sa",
	"pub.sa",
	"edu.sa",
	"sch.sa",
	"sb",
	"com.sb",
	"edu.sb",
	"gov.sb",
	"net.sb",
	"org.sb",
	"sc",
	"com.sc",
	"gov.sc",
	"net.sc",
	"org.sc",
	"edu.sc",
	"sd",
	"com.sd",
	"net.sd",
	"org.sd",
	"edu.sd",
	"med.sd",
	"tv.sd",
	"gov.sd",
	"info.sd",
	"se",
	"a.se",
	"ac.se",
	"b.se",
	"bd.se",
	"brand.se",
	"c.se",
	"d.se",
	"e.se",
	"f.se",
	"fh.se",
	"fhsk.se",
	"fhv.se",
	"g.se",
	"h.se",
	"i.se",
	"k.se",
	"komforb.se",
	"kommunalforbund.se",
	"komvux.se",
	"l.se",
	"lanbib.se",
	"m.se",
	"n.se",
	"naturbruksgymn.se",
	"o.se",
	"org.se",
	"p.se",
	"parti.se",
	"pp.se",
	"press.se",
	"r.se",
	"s.se",
	"t.se",
	"tm.se",
	"u.se",
	"w.se",
	"x.se",
	"y.se",
	"z.se",
	"sg",
	"com.sg",
	"net.sg",
	"org.sg",
	"gov.sg",
	"edu.sg",
	"per.sg",
	"sh",
	"com.sh",
	"net.sh",
	"gov.sh",
	"org.sh",
	"mil.sh",
	"si",
	"sj",
	"sk",
	"sl",
	"com.sl",
	"net.sl",
	"edu.sl",
	"gov.sl",
	"org.sl",
	"sm",
	"sn",
	"art.sn",
	"com.sn",
	"edu.sn",
	"gouv.sn",
	"org.sn",
	"perso.sn",
	"univ.sn",
	"so",
	"com.so",
	"edu.so",
	"gov.so",
	"me.so",
	"net.so",
	"org.so",
	"sr",
	"ss",
	"biz.ss",
	"com.ss",
	"edu.ss",
	"gov.ss",
	"net.ss",
	"org.ss",
	"st",
	"co.st",
	"com.st",
	"consulado.st",
	"edu.st",
	"embaixada.st",
	"gov.st",
	"mil.st",
	"net.st",
	"org.st",
	"principe.st",
	"saotome.st",
	"store.st",
	"su",
	"sv",
	"com.sv",
	"edu.sv",
	"gob.sv",
	"org.sv",
	"red.sv",
	"sx",
	"gov.sx",
	"sy",
	"edu.sy",
	"gov.sy",
	"net.sy",
	"mil.sy",
	"com.sy",
	"org.sy",
	"sz",
	"co.sz",
	"ac.sz",
	"org.sz",
	"tc",
	"td",
	"tel",
	"tf",
	"tg",
	"th",
	"ac.th",
	"co.th",
	"go.th",
	"in.th",
	"mi.th",
	"net.th",
	"or.th",
	"tj",
	"ac.tj",
	"biz.tj",
	"co.tj",
	"com.tj",
	"edu.tj",
	"go.tj",
	"gov.tj",
	"int.tj",
	"mil.tj",
	"name.tj",
	"net.tj",
	"nic.tj",
	"org.tj",
	"test.tj",
	"web.tj",
	"tk",
	"tl",
	"gov.tl",
	"tm",
	"com.tm",
	"co.tm",
	"org.tm",
	"net.tm",
	"nom.tm",
	"gov.tm",
	"mil.tm",
	"edu.tm",
	"tn",
	"com.tn",
	"ens.tn",
	"fin.tn",
	"gov.tn",
	"ind.tn",
	"intl.tn",
	"nat.tn",
	"net.tn",
	"org.tn",
	"info.tn",
	"perso.tn",
	"tourism.tn",
	"edunet.tn",
	"rnrt.tn",
	"rns.tn",
	"rnu.tn",
	"mincom.tn",
	"agrinet.tn",
	"defense.tn",
	"turen.tn",
	"to",
	"com.to",
	"gov.to",
	"net.to",
	"org.to",
	"edu.to",
	"mil.to",
	"tr",
	"av.tr",
	"bbs.tr",
	"bel.tr",
	"biz.tr",
	"com.tr",
	"dr.tr",
	"edu.tr",
	"gen.tr",
	"gov.tr",
	"info.tr",
	"mil.tr",
	"k12.tr",
	"kep.tr",
	"name.tr",
	"net.tr",
	"org.tr",
	"pol.tr",
	"tel.tr",
	"tsk.tr",
	"tv.tr",
	"web.tr",
	"nc.tr",
	"gov.nc.tr",
	"tt",
	"co.tt",
	"com.tt",
	"org.tt",
	"net.tt",
	"biz.tt",
	"info.tt",
	"pro.tt",
	"int.tt",
	"coop.tt",
	"jobs.tt",
	"mobi.tt",
	"travel.tt",
	"museum.tt",
	"aero.tt",
	"name.tt",
	"gov.tt",
	"edu.tt",
	"tv",
	"tw",
	"edu.tw",
	"gov.tw",
	"mil.tw",
	"com.tw",
	"net.tw",
	"org.tw",
	"idv.tw",
	"game.tw",
	"ebiz.tw",
	"club.tw",
	"網路.tw",
	"組織.tw",
	"商業.tw",
	"tz",
	"ac.tz",
	"co.tz",
	"go.tz",
	"hotel.tz",
	"info.tz",
	"me.tz",
	"mil.tz",
	"mobi.tz",
	"ne.tz",
	"or.tz",
	"sc.tz",
	"tv.tz",
	"ua",
	"com.ua",
	"edu.ua",
	"gov.ua",
	"in.ua",
	"net.ua",
	"org.ua",
	"cherkassy.ua",
	"cherkasy.ua",
	"chernigov.ua",
	"chernihiv.ua",
	"chernivtsi.ua",
	"chernovtsy.ua",
	"ck.ua",
	"cn.ua",
	"cr.ua",
	"crimea.ua",
	"cv.ua",
	"dn.ua",
	"dnepropetrovsk.ua",
	"dnipropetrovsk.ua",
	"dominic.ua",
	"donetsk.ua",
	"dp.ua",
	"if.ua",
	"ivano-frankivsk.ua",
	"kh.ua",
	"kharkiv.ua",
	"kharkov.ua",
	"kherson.ua",
	"khmelnitskiy.ua",
	"khmelnytskyi.ua",
	"kiev.ua",
	"kirovograd.ua",
	"km.ua",
	"kr.ua",
	"krym.ua",
	"ks.ua",
	"kv.ua",
	"kyiv.ua",
	"lg.ua",
	"lt.ua",
	"lugansk.ua",
	"lutsk.ua",
	"lv.ua",
	"lviv.ua",
	"mk.ua",
	"mykolaiv.ua",
	"nikolaev.ua",
	"od.ua",
	"odesa.ua",
	"odessa.ua",
	"pl.ua",
	"poltava.ua",
	"rivne.ua",
	"rovno.ua",
	"rv.ua",
	"sb.ua",
	"sebastopol.ua",
	"sevastopol.ua",
	"sm.ua",
	"sumy.ua",
	"te.ua",
	"ternopil.ua",
	"uz.ua",
	"uzhgorod.ua",
	"vinnica.ua",
	"vinnytsia.ua",
	"vn.ua",
	"volyn.ua",
	"yalta.ua",
	"zaporizhzhe.ua",
	"zaporizhzhia.ua",
	"zhitomir.ua",
	"zhytomyr.ua",
	"zp.ua",
	"zt.ua",
	"ug",
	"co.ug",
	"or.ug",
	"ac.ug",
	"sc.ug",
	"go.ug",
	"ne.ug",
	"com.ug",
	"org.ug",
	"uk",
	"ac.uk",
	"co.uk",
	"gov.uk",
	"ltd.uk",
	"me.uk",
	"net.uk",
	"nhs.uk",
	"org.uk",
	"plc.uk",
	"police.uk",
	"*.sch.uk",
	"us",
	"dni.us",
	"fed.us",
	"isa.us",
	"kids.us",
	"nsn.us",
	"ak.us",
	"al.us",
	"ar.us",
	"as.us",
	"az.us",
	"ca.us",
	"co.us",
	"ct.us",
	"dc.us",
	"de.us",
	"fl.us",
	"ga.us",
	"gu.us",
	"hi.us",
	"ia.us",
	"id.us",
	"il.us",
	"in.us",
	"ks.us",
	"ky.us",
	"la.us",
	"ma.us",
	"md.us",
	"me.us",
	"mi.us",
	"mn.us",
	"mo.us",
	"ms.us",
	"mt.us",
	"nc.us",
	"nd.us",
	"ne.us",
	"nh.us",
	"nj.us",
	"nm.us",
	"nv.us",
	"ny.us",
	"oh.us",
	"ok.us",
	"or.us",
	"pa.us",
	"pr.us",
	"ri.us",
	"sc.us",
	"sd.us",
	"tn.us",
	"tx.us",
	"ut.us",
	"vi.us",
	"vt.us",
	"va.us",
	"wa.us",
	"wi.us",
	"wv.us",
	"wy.us",
	"k12.ak.us",
	"k12.al.us",
	"k12.ar.us",
	"k12.as.us",
	"k12.az.us",
	"k12.ca.us",
	"k12.co.us",
	"k12.ct.us",
	"k12.dc.us",
	"k12.de.us",
	"k12.fl.us",
	"k12.ga.us",
	"k12.gu.us",
	"k12.ia.us",
	"k12.id.us",
	"k12.il.us",
	"k12.in.us",
	"k12.ks.us",
	"k12.ky.us",
	"k12.la.us",
	"k12.ma.us",
	"k12.md.us",
	"k12.me.us",
	"k12.mi.us",
	"k12.mn.us",
	"k12.mo.us",
	"k12.ms.us",
	"k12.mt.us",
	"k12.nc.us",
	"k12.ne.us",
	"k12.nh.us",
	"k12.nj.us",
	"k12.nm.us",
	"k12.nv.us",
	"k12.ny.us",
	"k12.oh.us",
	"k12.ok.us",
	"k12.or.us",
	"k12.pa.us",
	"k12.pr.us",
	"k12.ri.us",
	"k12.sc.us",
	"k12.tn.us",
	"k12.tx.us",
	"k12.ut.us",
	"k12.vi.us",
	"k12.vt.us",
	"k12.va.us",
	"k12.wa.us",
	"k12.wi.us",
	"k12.wy.us",
	"cc.ak.us",
	"cc.al.us",
	"cc.ar.us",
	"cc.as.us",
	"cc.az.us",
	"cc.ca.us",
	"cc.co.us",
	"cc.ct.us",
	"cc.dc.us",
	"cc.de.us",
	"cc.fl.us",
	"cc.ga.us",
	"cc.gu.us",
	"cc.hi.us",
	"cc.ia.us",
	"cc.id.us",
	"cc.il.us",
	"cc.in.us",
	"cc.ks.us",
	"cc.ky.us",
	"cc.la.us",
	"cc.ma.us",
	"cc.md.us",
	"cc.me.us",
	"cc.mi.us",
	"cc.mn.us",
	"cc.mo.us",
	"cc.ms.us",
	"cc.mt.us",
	"cc.nc.us",
	"cc.nd.us",
	"cc.ne.us",
	"cc.nh.us",
	"cc.nj.us",
	"cc.nm.us",
	"cc.nv.us",
	"cc.ny.us",
	"cc.oh.us",
	"cc.ok.us",
	"cc.or.us",
	"cc.pa.us",
	"cc.pr.us",
	"cc.ri.us",
	"cc.sc.us",
	"cc.sd.us",
	"cc.tn.us",
	"cc.tx.us",
	"cc.ut.us",
	"cc.vi.us",
	"cc.vt.us",
	"cc.va.us",
	"cc.wa.us",
	"cc.wi.us",
	"cc.wv.us",
	"cc.wy.us",
	"lib.ak.us",
	"lib.al.us",
	"lib.ar.us",
	"lib.as.us",
	"lib.az.us",
	"lib.ca.us",
	"lib.co.us",
	"lib.ct.us",
	"lib.dc.us",
	"lib.fl.us",
	"lib.ga.us",
	"lib.gu.us",
	"lib.hi.us",
	"lib.ia.us",
	"lib.id.us",
	"lib.il.us",
	"lib.in.us",
	"lib.ks.us",
	"lib.ky.us",
	"lib.la.us",
	"lib.ma.us",
	"lib.md.us",
	"lib.me.us",
	"lib.mi.us",
	"lib.mn.us",
	"lib.mo.us",
	"lib.ms.us",
	"lib.mt.us",
	"lib.nc.us",
	"lib.nd.us",
	"lib.ne.us",
	"lib.nh.us",
	"lib.nj.us",
	"lib.nm.us",
	"lib.nv.us",
	"lib.ny.us",
	"lib.oh.us",
	"lib.ok.us",
	"lib.or.us",
	"lib.pa.us",
	"lib.pr.us",
	"lib.ri.us",
	"lib.sc.us",
	"lib.sd.us",
	"lib.tn.us",
	"lib.tx.us",
	"lib.ut.us",
	"lib.vi.us",
	"lib.vt.us",
	"lib.va.us",
	"lib.wa.us",
	"lib.wi.us",
	"lib.wy.us",
	"pvt.k12.ma.us",
	"chtr.k12.ma.us",
	"paroch.k12.ma.us",
	"ann-arbor.mi.us",
	"cog.mi.us",
	"dst.mi.us",
	"eaton.mi.us",
	"gen.mi.us",
	"mus.mi.us",
	"tec.mi.us",
	"washtenaw.mi.us",
	"uy",
	"com.uy",
	"edu.uy",
	"gub.uy",
	"mil.uy",
	"net.uy",
	"org.uy",
	"uz",
	"co.uz",
	"com.uz",
	"net.uz",
	"org.uz",
	"va",
	"vc",
	"com.vc",
	"net.vc",
	"org.vc",
	"gov.vc",
	"mil.vc",
	"edu.vc",
	"ve",
	"arts.ve",
	"co.ve",
	"com.ve",
	"e12.ve",
	"edu.ve",
	"firm.ve",
	"gob.ve",
	"gov.ve",
	"info.ve",
	"int.ve",
	"mil.ve",
	"net.ve",
	"org.ve",
	"rec.ve",
	"store.ve",
	"tec.ve",
	"web.ve",
	"vg",
	"vi",
	"co.vi",
	"com.vi",
	"k12.vi",
	"net.vi",
	"org.vi",
	"vn",
	"com.vn",
	"net.vn",
	"org.vn",
	"edu.vn",
	"gov.vn",
	"int.vn",
	"ac.vn",
	"biz.vn",
	"info.vn",
	"name.vn",
	"pro.vn",
	"health.vn",
	"vu",
	"com.vu",
	"edu.vu",
	"net.vu",
	"org.vu",
	"wf",
	"ws",
	"com.ws",
	"net.ws",
	"org.ws",
	"gov.ws",
	"edu.ws",
	"yt",
	"امارات",
	"հայ",
	"বাংলা",
	"бг",
	"бел",
	"中国",
	"中國",
	"الجزائر",
	"مصر",
	"ею",
	"ευ",
	"موريتانيا",
	"გე",
	"ελ",
	"香港",
	"公司.香港",
	"教育.香港",
	"政府.香港",
	"個人.香港",
	"網絡.香港",
	"組織.香港",
	"ಭಾರತ",
	"ଭାରତ",
	"ভাৰত",
	"भारतम्",
	"भारोत",
	"ڀارت",
	"ഭാരതം",
	"भारत",
	"بارت",
	"بھارت",
	"భారత్",
	"ભારત",
	"ਭਾਰਤ",
	"ভারত",
	"இந்தியா",
	"ایران",
	"ايران",
	"عراق",
	"الاردن",
	"한국",
	"қаз",
	"ලංකා",
	"இலங்கை",
	"المغرب",
	"мкд",
	"мон",
	"澳門",
	"澳门",
	"مليسيا",
	"عمان",
	"پاکستان",
	"پاكستان",
	"فلسطين",
	"срб",
	"пр.срб",
	"орг.срб",
	"обр.срб",
	"од.срб",
	"упр.срб",
	"ак.срб",
	"рф",
	"قطر",
	"السعودية",
	"السعودیة",
	"السعودیۃ",
	"السعوديه",
	"سودان",
	"新加坡",
	"சிங்கப்பூர்",
	"سورية",
	"سوريا",
	"ไทย",
	"ศึกษา.ไทย",
	"ธุรกิจ.ไทย",
	"รัฐบาล.ไทย",
	"ทหาร.ไทย",
	"เน็ต.ไทย",
	"องค์กร.ไทย",
	"تونس",
	"台灣",
	"台湾",
	"臺灣",
	"укр",
	"اليمن",
	"xxx",
	"*.ye",
	"ac.za",
	"agric.za",
	"alt.za",
	"co.za",
	"edu.za",
	"gov.za",
	"grondar.za",
	"law.za",
	"mil.za",
	"net.za",
	"ngo.za",
	"nic.za",
	"nis.za",
	"nom.za",
	"org.za",
	"school.za",
	"tm.za",
	"web.za",
	"zm",
	"ac.zm",
	"biz.zm",
	"co.zm",
	"com.zm",
	"edu.zm",
	"gov.zm",
	"info.zm",
	"mil.zm",
	"net.zm",
	"org.zm",
	"sch.zm",
	"zw",
	"ac.zw",
	"co.zw",
	"gov.zw",
	"mil.zw",
	"org.zw",
	"aaa",
	"aarp",
	"abarth",
	"abb",
	"abbott",
	"abbvie",
	"abc",
	"able",
	"abogado",
	"abudhabi",
	"academy",
	"accenture",
	"accountant",
	"accountants",
	"aco",
	"actor",
	"adac",
	"ads",
	"adult",
	"aeg",
	"aetna",
	"afamilycompany",
	"afl",
	"africa",
	"agakhan",
	"agency",
	"aig",
	"aigo",
	"airbus",
	"airforce",
	"airtel",
	"akdn",
	"alfaromeo",
	"alibaba",
	"alipay",
	"allfinanz",
	"allstate",
	"ally",
	"alsace",
	"alstom",
	"amazon",
	"americanexpress",
	"americanfamily",
	"amex",
	"amfam",
	"amica",
	"amsterdam",
	"analytics",
	"android",
	"anquan",
	"anz",
	"aol",
	"apartments",
	"app",
	"apple",
	"aquarelle",
	"arab",
	"aramco",
	"archi",
	"army",
	"art",
	"arte",
	"asda",
	"associates",
	"athleta",
	"attorney",
	"auction",
	"audi",
	"audible",
	"audio",
	"auspost",
	"author",
	"auto",
	"autos",
	"avianca",
	"aws",
	"axa",
	"azure",
	"baby",
	"baidu",
	"banamex",
	"bananarepublic",
	"band",
	"bank",
	"bar",
	"barcelona",
	"barclaycard",
	"barclays",
	"barefoot",
	"bargains",
	"baseball",
	"basketball",
	"bauhaus",
	"bayern",
	"bbc",
	"bbt",
	"bbva",
	"bcg",
	"bcn",
	"beats",
	"beauty",
	"beer",
	"bentley",
	"berlin",
	"best",
	"bestbuy",
	"bet",
	"bharti",
	"bible",
	"bid",
	"bike",
	"bing",
	"bingo",
	"bio",
	"black",
	"blackfriday",
	"blockbuster",
	"blog",
	"bloomberg",
	"blue",
	"bms",
	"bmw",
	"bnpparibas",
	"boats",
	"boehringer",
	"bofa",
	"bom",
	"bond",
	"boo",
	"book",
	"booking",
	"bosch",
	"bostik",
	"boston",
	"bot",
	"boutique",
	"box",
	"bradesco",
	"bridgestone",
	"broadway",
	"broker",
	"brother",
	"brussels",
	"budapest",
	"bugatti",
	"build",
	"builders",
	"business",
	"buy",
	"buzz",
	"bzh",
	"cab",
	"cafe",
	"cal",
	"call",
	"calvinklein",
	"cam",
	"camera",
	"camp",
	"cancerresearch",
	"canon",
	"capetown",
	"capital",
	"capitalone",
	"car",
	"caravan",
	"cards",
	"care",
	"career",
	"careers",
	"cars",
	"casa",
	"case",
	"caseih",
	"cash",
	"casino",
	"catering",
	"catholic",
	"cba",
	"cbn",
	"cbre",
	"cbs",
	"ceb",
	"center",
	"ceo",
	"cern",
	"cfa",
	"cfd",
	"chanel",
	"channel",
	"charity",
	"chase",
	"chat",
	"cheap",
	"chintai",
	"christmas",
	"chrome",
	"church",
	"cipriani",
	"circle",
	"cisco",
	"citadel",
	"citi",
	"citic",
	"city",
	"cityeats",
	"claims",
	"cleaning",
	"click",
	"clinic",
	"clinique",
	"clothing",
	"cloud",
	"club",
	"clubmed",
	"coach",
	"codes",
	"coffee",
	"college",
	"cologne",
	"comcast",
	"commbank",
	"community",
	"company",
	"compare",
	"computer",
	"comsec",
	"condos",
	"construction",
	"consulting",
	"contact",
	"contractors",
	"cooking",
	"cookingchannel",
	"cool",
	"corsica",
	"country",
	"coupon",
	"coupons",
	"courses",
	"cpa",
	"credit",
	"creditcard",
	"creditunion",
	"cricket",
	"crown",
	"crs",
	"cruise",
	"cruises",
	"csc",
	"cuisinella",
	"cymru",
	"cyou",
	"dabur",
	"dad",
	"dance",
	"data",
	"date",
	"dating",
	"datsun",
	"day",
	"dclk",
	"dds",
	"deal",
	"dealer",
	"deals",
	"degree",
	"delivery",
	"dell",
	"deloitte",
	"delta",
	"democrat",
	"dental",
	"dentist",
	"desi",
	"design",
	"dev",
	"dhl",
	"diamonds",
	"diet",
	"digital",
	"direct",
	"directory",
	"discount",
	"discover",
	"dish",
	"diy",
	"dnp",
	"docs",
	"doctor",
	"dog",
	"domains",
	"dot",
	"download",
	"drive",
	"dtv",
	"dubai",
	"duck",
	"dunlop",
	"dupont",
	"durban",
	"dvag",
	"dvr",
	"earth",
	"eat",
	"eco",
	"edeka",
	"education",
	"email",
	"emerck",
	"energy",
	"engineer",
	"engineering",
	"enterprises",
	"epson",
	"equipment",
	"ericsson",
	"erni",
	"esq",
	"estate",
	"esurance",
	"etisalat",
	"eurovision",
	"eus",
	"events",
	"exchange",
	"expert",
	"exposed",
	"express",
	"extraspace",
	"fage",
	"fail",
	"fairwinds",
	"faith",
	"family",
	"fan",
	"fans",
	"farm",
	"farmers",
	"fashion",
	"fast",
	"fedex",
	"feedback",
	"ferrari",
	"ferrero",
	"fiat",
	"fidelity",
	"fido",
	"film",
	"final",
	"finance",
	"financial",
	"fire",
	"firestone",
	"firmdale",
	"fish",
	"fishing",
	"fit",
	"fitness",
	"flickr",
	"flights",
	"flir",
	"florist",
	"flowers",
	"fly",
	"foo",
	"food",
	"foodnetwork",
	"football",
	"ford",
	"forex",
	"forsale",
	"forum",
	"foundation",
	"fox",
	"free",
	"fresenius",
	"frl",
	"frogans",
	"frontdoor",
	"frontier",
	"ftr",
	"fujitsu",
	"fujixerox",
	"fun",
	"fund",
	"furniture",
	"futbol",
	"fyi",
	"gal",
	"gallery",
	"gallo",
	"gallup",
	"game",
	"games",
	"gap",
	"garden",
	"gay",
	"gbiz",
	"gdn",
	"gea",
	"gent",
	"genting",
	"george",
	"ggee",
	"gift",
	"gifts",
	"gives",
	"giving",
	"glade",
	"glass",
	"gle",
	"global",
	"globo",
	"gmail",
	"gmbh",
	"gmo",
	"gmx",
	"godaddy",
	"gold",
	"goldpoint",
	"golf",
	"goo",
	"goodyear",
	"goog",
	"google",
	"gop",
	"got",
	"grainger",
	"graphics",
	"gratis",
	"green",
	"gripe",
	"grocery",
	"group",
	"guardian",
	"gucci",
	"guge",
	"guide",
	"guitars",
	"guru",
	"hair",
	"hamburg",
	"hangout",
	"haus",
	"hbo",
	"hdfc",
	"hdfcbank",
	"health",
	"healthcare",
	"help",
	"helsinki",
	"here",
	"hermes",
	"hgtv",
	"hiphop",
	"hisamitsu",
	"hitachi",
	"hiv",
	"hkt",
	"hockey",
	"holdings",
	"holiday",
	"homedepot",
	"homegoods",
	"homes",
	"homesense",
	"honda",
	"horse",
	"hospital",
	"host",
	"hosting",
	"hot",
	"hoteles",
	"hotels",
	"hotmail",
	"house",
	"how",
	"hsbc",
	"hughes",
	"hyatt",
	"hyundai",
	"ibm",
	"icbc",
	"ice",
	"icu",
	"ieee",
	"ifm",
	"ikano",
	"imamat",
	"imdb",
	"immo",
	"immobilien",
	"inc",
	"industries",
	"infiniti",
	"ing",
	"ink",
	"institute",
	"insurance",
	"insure",
	"intel",
	"international",
	"intuit",
	"investments",
	"ipiranga",
	"irish",
	"ismaili",
	"ist",
	"istanbul",
	"itau",
	"itv",
	"iveco",
	"jaguar",
	"java",
	"jcb",
	"jcp",
	"jeep",
	"jetzt",
	"jewelry",
	"jio",
	"jll",
	"jmp",
	"jnj",
	"joburg",
	"jot",
	"joy",
	"jpmorgan",
	"jprs",
	"juegos",
	"juniper",
	"kaufen",
	"kddi",
	"kerryhotels",
	"kerrylogistics",
	"kerryproperties",
	"kfh",
	"kia",
	"kim",
	"kinder",
	"kindle",
	"kitchen",
	"kiwi",
	"koeln",
	"komatsu",
	"kosher",
	"kpmg",
	"kpn",
	"krd",
	"kred",
	"kuokgroup",
	"kyoto",
	"lacaixa",
	"lamborghini",
	"lamer",
	"lancaster",
	"lancia",
	"land",
	"landrover",
	"lanxess",
	"lasalle",
	"lat",
	"latino",
	"latrobe",
	"law",
	"lawyer",
	"lds",
	"lease",
	"leclerc",
	"lefrak",
	"legal",
	"lego",
	"lexus",
	"lgbt",
	"lidl",
	"life",
	"lifeinsurance",
	"lifestyle",
	"lighting",
	"like",
	"lilly",
	"limited",
	"limo",
	"lincoln",
	"linde",
	"link",
	"lipsy",
	"live",
	"living",
	"lixil",
	"llc",
	"llp",
	"loan",
	"loans",
	"locker",
	"locus",
	"loft",
	"lol",
	"london",
	"lotte",
	"lotto",
	"love",
	"lpl",
	"lplfinancial",
	"ltd",
	"ltda",
	"lundbeck",
	"lupin",
	"luxe",
	"luxury",
	"macys",
	"madrid",
	"maif",
	"maison",
	"makeup",
	"man",
	"management",
	"mango",
	"map",
	"market",
	"marketing",
	"markets",
	"marriott",
	"marshalls",
	"maserati",
	"mattel",
	"mba",
	"mckinsey",
	"med",
	"media",
	"meet",
	"melbourne",
	"meme",
	"memorial",
	"men",
	"menu",
	"merckmsd",
	"metlife",
	"miami",
	"microsoft",
	"mini",
	"mint",
	"mit",
	"mitsubishi",
	"mlb",
	"mls",
	"mma",
	"mobile",
	"moda",
	"moe",
	"moi",
	"mom",
	"monash",
	"money",
	"monster",
	"mormon",
	"mortgage",
	"moscow",
	"moto",
	"motorcycles",
	"mov",
	"movie",
	"msd",
	"mtn",
	"mtr",
	"mutual",
	"nab",
	"nadex",
	"nagoya",
	"nationwide",
	"natura",
	"navy",
	"nba",
	"nec",
	"netbank",
	"netflix",
	"network",
	"neustar",
	"new",
	"newholland",
	"news",
	"next",
	"nextdirect",
	"nexus",
	"nfl",
	"ngo",
	"nhk",
	"nico",
	"nike",
	"nikon",
	"ninja",
	"nissan",
	"nissay",
	"nokia",
	"northwesternmutual",
	"norton",
	"now",
	"nowruz",
	"nowtv",
	"nra",
	"nrw",
	"ntt",
	"nyc",
	"obi",
	"observer",
	"off",
	"office",
	"okinawa",
	"olayan",
	"olayangroup",
	"oldnavy",
	"ollo",
	"omega",
	"one",
	"ong",
	"onl",
	"online",
	"onyourside",
	"ooo",
	"open",
	"oracle",
	"orange",
	"organic",
	"origins",
	"osaka",
	"otsuka",
	"ott",
	"ovh",
	"page",
	"panasonic",
	"paris",
	"pars",
	"partners",
	"parts",
	"party",
	"passagens",
	"pay",
	"pccw",
	"pet",
	"pfizer",
	"pharmacy",
	"phd",
	"philips",
	"phone",
	"photo",
	"photography",
	"photos",
	"physio",
	"pics",
	"pictet",
	"pictures",
	"pid",
	"pin",
	"ping",
	"pink",
	"pioneer",
	"pizza",
	"place",
	"play",
	"playstation",
	"plumbing",
	"plus",
	"pnc",
	"pohl",
	"poker",
	"politie",
	"porn",
	"pramerica",
	"praxi",
	"press",
	"prime",
	"prod",
	"productions",
	"prof",
	"progressive",
	"promo",
	"properties",
	"property",
	"protection",
	"pru",
	"prudential",
	"pub",
	"pwc",
	"qpon",
	"quebec",
	"quest",
	"qvc",
	"racing",
	"radio",
	"raid",
	"read",
	"realestate",
	"realtor",
	"realty",
	"recipes",
	"red",
	"redstone",
	"redumbrella",
	"rehab",
	"reise",
	"reisen",
	"reit",
	"reliance",
	"ren",
	"rent",
	"rentals",
	"repair",
	"report",
	"republican",
	"rest",
	"restaurant",
	"review",
	"reviews",
	"rexroth",
	"rich",
	"richardli",
	"ricoh",
	"rightathome",
	"ril",
	"rio",
	"rip",
	"rmit",
	"rocher",
	"rocks",
	"rodeo",
	"rogers",
	"room",
	"rsvp",
	"rugby",
	"ruhr",
	"run",
	"rwe",
	"ryukyu",
	"saarland",
	"safe",
	"safety",
	"sakura",
	"sale",
	"salon",
	"samsclub",
	"samsung",
	"sandvik",
	"sandvikcoromant",
	"sanofi",
	"sap",
	"sarl",
	"sas",
	"save",
	"saxo",
	"sbi",
	"sbs",
	"sca",
	"scb",
	"schaeffler",
	"schmidt",
	"scholarships",
	"school",
	"schule",
	"schwarz",
	"science",
	"scjohnson",
	"scor",
	"scot",
	"search",
	"seat",
	"secure",
	"security",
	"seek",
	"select",
	"sener",
	"services",
	"ses",
	"seven",
	"sew",
	"sex",
	"sexy",
	"sfr",
	"shangrila",
	"sharp",
	"shaw",
	"shell",
	"shia",
	"shiksha",
	"shoes",
	"shop",
	"shopping",
	"shouji",
	"show",
	"showtime",
	"shriram",
	"silk",
	"sina",
	"singles",
	"site",
	"ski",
	"skin",
	"sky",
	"skype",
	"sling",
	"smart",
	"smile",
	"sncf",
	"soccer",
	"social",
	"softbank",
	"software",
	"sohu",
	"solar",
	"solutions",
	"song",
	"sony",
	"soy",
	"spa",
	"space",
	"sport",
	"spot",
	"spreadbetting",
	"srl",
	"stada",
	"staples",
	"star",
	"statebank",
	"statefarm",
	"stc",
	"stcgroup",
	"stockholm",
	"storage",
	"store",
	"stream",
	"studio",
	"study",
	"style",
	"sucks",
	"supplies",
	"supply",
	"support",
	"surf",
	"surgery",
	"suzuki",
	"swatch",
	"swiftcover",
	"swiss",
	"sydney",
	"symantec",
	"systems",
	"tab",
	"taipei",
	"talk",
	"taobao",
	"target",
	"tatamotors",
	"tatar",
	"tattoo",
	"tax",
	"taxi",
	"tci",
	"tdk",
	"team",
	"tech",
	"technology",
	"temasek",
	"tennis",
	"teva",
	"thd",
	"theater",
	"theatre",
	"tiaa",
	"tickets",
	"tienda",
	"tiffany",
	"tips",
	"tires",
	"tirol",
	"tjmaxx",
	"tjx",
	"tkmaxx",
	"tmall",
	"today",
	"tokyo",
	"tools",
	"top",
	"toray",
	"toshiba",
	"total",
	"tours",
	"town",
	"toyota",
	"toys",
	"trade",
	"trading",
	"training",
	"travel",
	"travelchannel",
	"travelers",
	"travelersinsurance",
	"trust",
	"trv",
	"tube",
	"tui",
	"tunes",
	"tushu",
	"tvs",
	"ubank",
	"ubs",
	"unicom",
	"university",
	"uno",
	"uol",
	"ups",
	"vacations",
	"vana",
	"vanguard",
	"vegas",
	"ventures",
	"verisign",
	"versicherung",
	"vet",
	"viajes",
	"video",
	"vig",
	"viking",
	"villas",
	"vin",
	"vip",
	"virgin",
	"visa",
	"vision",
	"viva",
	"vivo",
	"vlaanderen",
	"vodka",
	"volkswagen",
	"volvo",
	"vote",
	"voting",
	"voto",
	"voyage",
	"vuelos",
	"wales",
	"walmart",
	"walter",
	"wang",
	"wanggou",
	"watch",
	"watches",
	"weather",
	"weatherchannel",
	"webcam",
	"weber",
	"website",
	"wed",
	"wedding",
	"weibo",
	"weir",
	"whoswho",
	"wien",
	"wiki",
	"williamhill",
	"win",
	"windows",
	"wine",
	"winners",
	"wme",
	"wolterskluwer",
	"woodside",
	"work",
	"works",
	"world",
	"wow",
	"wtc",
	"wtf",
	"xbox",
	"xerox",
	"xfinity",
	"xihuan",
	"xin",
	"कॉम",
	"セール",
	"佛山",
	"慈善",
	"集团",
	"在线",
	"大众汽车",
	"点看",
	"คอม",
	"八卦",
	"موقع",
	"公益",
	"公司",
	"香格里拉",
	"网站",
	"移动",
	"我爱你",
	"москва",
	"католик",
	"онлайн",
	"сайт",
	"联通",
	"קום",
	"时尚",
	"微博",
	"淡马锡",
	"ファッション",
	"орг",
	"नेट",
	"ストア",
	"アマゾン",
	"삼성",
	"商标",
	"商店",
	"商城",
	"дети",
	"ポイント",
	"新闻",
	"工行",
	"家電",
	"كوم",
	"中文网",
	"中信",
	"娱乐",
	"谷歌",
	"電訊盈科",
	"购物",
	"クラウド",
	"通販",
	"网店",
	"संगठन",
	"餐厅",
	"网络",
	"ком",
	"亚马逊",
	"诺基亚",
	"食品",
	"飞利浦",
	"手表",
	"手机",
	"ارامكو",
	"العليان",
	"اتصالات",
	"بازار",
	"ابوظبي",
	"كاثوليك",
	"همراه",
	"닷컴",
	"政府",
	"شبكة",
	"بيتك",
	"عرب",
	"机构",
	"组织机构",
	"健康",
	"招聘",
	"рус",
	"珠宝",
	"大拿",
	"みんな",
	"グーグル",
	"世界",
	"書籍",
	"网址",
	"닷넷",
	"コム",
	"天主教",
	"游戏",
	"vermögensberater",
	"vermögensberatung",
	"企业",
	"信息",
	"嘉里大酒店",
	"嘉里",
	"广东",
	"政务",
	"xyz",
	"yachts",
	"yahoo",
	"yamaxun",
	"yandex",
	"yodobashi",
	"yoga",
	"yokohama",
	"you",
	"youtube",
	"yun",
	"zappos",
	"zara",
	"zero",
	"zip",
	"zone",
	"zuerich",
	"cc.ua",
	"inf.ua",
	"ltd.ua",
	"adobeaemcloud.com",
	"adobeaemcloud.net",
	"*.dev.adobeaemcloud.com",
	"beep.pl",
	"barsy.ca",
	"*.compute.estate",
	"*.alces.network",
	"altervista.org",
	"alwaysdata.net",
	"cloudfront.net",
	"*.compute.amazonaws.com",
	"*.compute-1.amazonaws.com",
	"*.compute.amazonaws.com.cn",
	"us-east-1.amazonaws.com",
	"cn-north-1.eb.amazonaws.com.cn",
	"cn-northwest-1.eb.amazonaws.com.cn",
	"elasticbeanstalk.com",
	"ap-northeast-1.elasticbeanstalk.com",
	"ap-northeast-2.elasticbeanstalk.com",
	"ap-northeast-3.elasticbeanstalk.com",
	"ap-south-1.elasticbeanstalk.com",
	"ap-southeast-1.elasticbeanstalk.com",
	"ap-southeast-2.elasticbeanstalk.com",
	"ca-central-1.elasticbeanstalk.com",
	"eu-central-1.elasticbeanstalk.com",
	"eu-west-1.elasticbeanstalk.com",
	"eu-west-2.elasticbeanstalk.com",
	"eu-west-3.elasticbeanstalk.com",
	"sa-east-1.elasticbeanstalk.com",
	"us-east-1.elasticbeanstalk.com",
	"us-east-2.elasticbeanstalk.com",
	"us-gov-west-1.elasticbeanstalk.com",
	"us-west-1.elasticbeanstalk.com",
	"us-west-2.elasticbeanstalk.com",
	"*.elb.amazonaws.com",
	"*.elb.amazonaws.com.cn",
	"s3.amazonaws.com",
	"s3-ap-northeast-1.amazonaws.com",
	"s3-ap-northeast-2.amazonaws.com",
	"s3-ap-south-1.amazonaws.com",
	"s3-ap-southeast-1.amazonaws.com",
	"s3-ap-southeast-2.amazonaws.com",
	"s3-ca-central-1.amazonaws.com",
	"s3-eu-central-1.amazonaws.com",
	"s3-eu-west-1.amazonaws.com",
	"s3-eu-west-2.amazonaws.com",
	"s3-eu-west-3.amazonaws.com",
	"s3-external-1.amazonaws.com",
	"s3-fips-us-gov-west-1.amazonaws.com",
	"s3-sa-east-1.amazonaws.com",
	"s3-us-gov-west-1.amazonaws.com",
	"s3-us-east-2.amazonaws.com",
	"s3-us-west-1.amazonaws.com",
	"s3-us-west-2.amazonaws.com",
	"s3.ap-northeast-2.amazonaws.com",
	"s3.ap-south-1.amazonaws.com",
	"s3.cn-north-1.amazonaws.com.cn",
	"s3.ca-central-1.amazonaws.com",
	"s3.eu-central-1.amazonaws.com",
	"s3.eu-west-2.amazonaws.com",
	"s3.eu-west-3.amazonaws.com",
	"s3.us-east-2.amazonaws.com",
	"s3.dualstack.ap-northeast-1.amazonaws.com",
	"s3.dualstack.ap-northeast-2.amazonaws.com",
	"s3.dualstack.ap-south-1.amazonaws.com",
	"s3.dualstack.ap-southeast-1.amazonaws.com",
	"s3.dualstack.ap-southeast-2.amazonaws.com",
	"s3.dualstack.ca-central-1.amazonaws.com",
	"s3.dualstack.eu-central-1.amazonaws.com",
	"s3.dualstack.eu-west-1.amazonaws.com",
	"s3.dualstack.eu-west-2.amazonaws.com",
	"s3.dualstack.eu-west-3.amazonaws.com",
	"s3.dualstack.sa-east-1.amazonaws.com",
	"s3.dualstack.us-east-1.amazonaws.com",
	"s3.dualstack.us-east-2.amazonaws.com",
	"s3-website-us-east-1.amazonaws.com",
	"s3-website-us-west-1.amazonaws.com",
	"s3-website-us-west-2.amazonaws.com",
	"s3-website-ap-northeast-1.amazonaws.com",
	"s3-website-ap-southeast-1.amazonaws.com",
	"s3-website-ap-southeast-2.amazonaws.com",
	"s3-website-eu-west-1.amazonaws.com",
	"s3-website-sa-east-1.amazonaws.com",
	"s3-website.ap-northeast-2.amazonaws.com",
	"s3-website.ap-south-1.amazonaws.com",
	"s3-website.ca-central-1.amazonaws.com",
	"s3-website.eu-central-1.amazonaws.com",
	"s3-website.eu-west-2.amazonaws.com",
	"s3-website.eu-west-3.amazonaws.com",
	"s3-website.us-east-2.amazonaws.com",
	"amsw.nl",
	"t3l3p0rt.net",
	"tele.amune.org",
	"apigee.io",
	"on-aptible.com",
	"user.aseinet.ne.jp",
	"gv.vc",
	"d.gv.vc",
	"user.party.eus",
	"pimienta.org",
	"poivron.org",
	"potager.org",
	"sweetpepper.org",
	"myasustor.com",
	"myfritz.net",
	"*.awdev.ca",
	"*.advisor.ws",
	"b-data.io",
	"backplaneapp.io",
	"balena-devices.com",
	"app.banzaicloud.io",
	"betainabox.com",
	"bnr.la",
	"blackbaudcdn.net",
	"boomla.net",
	"boxfuse.io",
	"square7.ch",
	"bplaced.com",
	"bplaced.de",
	"square7.de",
	"bplaced.net",
	"square7.net",
	"browsersafetymark.io",
	"uk0.bigv.io",
	"dh.bytemark.co.uk",
	"vm.bytemark.co.uk",
	"mycd.eu",
	"carrd.co",
	"crd.co",
	"uwu.ai",
	"ae.org",
	"ar.com",
	"br.com",
	"cn.com",
	"com.de",
	"com.se",
	"de.com",
	"eu.com",
	"gb.com",
	"gb.net",
	"hu.com",
	"hu.net",
	"jp.net",
	"jpn.com",
	"kr.com",
	"mex.com",
	"no.com",
	"qc.com",
	"ru.com",
	"sa.com",
	"se.net",
	"uk.com",
	"uk.net",
	"us.com",
	"uy.com",
	"za.bz",
	"za.com",
	"africa.com",
	"gr.com",
	"in.net",
	"us.org",
	"co.com",
	"c.la",
	"certmgr.org",
	"xenapponazure.com",
	"discourse.group",
	"discourse.team",
	"virtueeldomein.nl",
	"cleverapps.io",
	"*.lcl.dev",
	"*.stg.dev",
	"c66.me",
	"cloud66.ws",
	"cloud66.zone",
	"jdevcloud.com",
	"wpdevcloud.com",
	"cloudaccess.host",
	"freesite.host",
	"cloudaccess.net",
	"cloudcontrolled.com",
	"cloudcontrolapp.com",
	"cloudera.site",
	"trycloudflare.com",
	"workers.dev",
	"wnext.app",
	"co.ca",
	"*.otap.co",
	"co.cz",
	"c.cdn77.org",
	"cdn77-ssl.net",
	"r.cdn77.net",
	"rsc.cdn77.org",
	"ssl.origin.cdn77-secure.org",
	"cloudns.asia",
	"cloudns.biz",
	"cloudns.club",
	"cloudns.cc",
	"cloudns.eu",
	"cloudns.in",
	"cloudns.info",
	"cloudns.org",
	"cloudns.pro",
	"cloudns.pw",
	"cloudns.us",
	"cloudeity.net",
	"cnpy.gdn",
	"co.nl",
	"co.no",
	"webhosting.be",
	"hosting-cluster.nl",
	"ac.ru",
	"edu.ru",
	"gov.ru",
	"int.ru",
	"mil.ru",
	"test.ru",
	"dyn.cosidns.de",
	"dynamisches-dns.de",
	"dnsupdater.de",
	"internet-dns.de",
	"l-o-g-i-n.de",
	"dynamic-dns.info",
	"feste-ip.net",
	"knx-server.net",
	"static-access.net",
	"realm.cz",
	"*.cryptonomic.net",
	"cupcake.is",
	"*.customer-oci.com",
	"*.oci.customer-oci.com",
	"*.ocp.customer-oci.com",
	"*.ocs.customer-oci.com",
	"cyon.link",
	"cyon.site",
	"daplie.me",
	"localhost.daplie.me",
	"dattolocal.com",
	"dattorelay.com",
	"dattoweb.com",
	"mydatto.com",
	"dattolocal.net",
	"mydatto.net",
	"biz.dk",
	"co.dk",
	"firm.dk",
	"reg.dk",
	"store.dk",
	"*.dapps.earth",
	"*.bzz.dapps.earth",
	"builtwithdark.com",
	"edgestack.me",
	"debian.net",
	"dedyn.io",
	"dnshome.de",
	"online.th",
	"shop.th",
	"drayddns.com",
	"dreamhosters.com",
	"mydrobo.com",
	"drud.io",
	"drud.us",
	"duckdns.org",
	"dy.fi",
	"tunk.org",
	"dyndns-at-home.com",
	"dyndns-at-work.com",
	"dyndns-blog.com",
	"dyndns-free.com",
	"dyndns-home.com",
	"dyndns-ip.com",
	"dyndns-mail.com",
	"dyndns-office.com",
	"dyndns-pics.com",
	"dyndns-remote.com",
	"dyndns-server.com",
	"dyndns-web.com",
	"dyndns-wiki.com",
	"dyndns-work.com",
	"dyndns.biz",
	"dyndns.info",
	"dyndns.org",
	"dyndns.tv",
	"at-band-camp.net",
	"ath.cx",
	"barrel-of-knowledge.info",
	"barrell-of-knowledge.info",
	"better-than.tv",
	"blogdns.com",
	"blogdns.net",
	"blogdns.org",
	"blogsite.org",
	"boldlygoingnowhere.org",
	"broke-it.net",
	"buyshouses.net",
	"cechire.com",
	"dnsalias.com",
	"dnsalias.net",
	"dnsalias.org",
	"dnsdojo.com",
	"dnsdojo.net",
	"dnsdojo.org",
	"does-it.net",
	"doesntexist.com",
	"doesntexist.org",
	"dontexist.com",
	"dontexist.net",
	"dontexist.org",
	"doomdns.com",
	"doomdns.org",
	"dvrdns.org",
	"dyn-o-saur.com",
	"dynalias.com",
	"dynalias.net",
	"dynalias.org",
	"dynathome.net",
	"dyndns.ws",
	"endofinternet.net",
	"endofinternet.org",
	"endoftheinternet.org",
	"est-a-la-maison.com",
	"est-a-la-masion.com",
	"est-le-patron.com",
	"est-mon-blogueur.com",
	"for-better.biz",
	"for-more.biz",
	"for-our.info",
	"for-some.biz",
	"for-the.biz",
	"forgot.her.name",
	"forgot.his.name",
	"from-ak.com",
	"from-al.com",
	"from-ar.com",
	"from-az.net",
	"from-ca.com",
	"from-co.net",
	"from-ct.com",
	"from-dc.com",
	"from-de.com",
	"from-fl.com",
	"from-ga.com",
	"from-hi.com",
	"from-ia.com",
	"from-id.com",
	"from-il.com",
	"from-in.com",
	"from-ks.com",
	"from-ky.com",
	"from-la.net",
	"from-ma.com",
	"from-md.com",
	"from-me.org",
	"from-mi.com",
	"from-mn.com",
	"from-mo.com",
	"from-ms.com",
	"from-mt.com",
	"from-nc.com",
	"from-nd.com",
	"from-ne.com",
	"from-nh.com",
	"from-nj.com",
	"from-nm.com",
	"from-nv.com",
	"from-ny.net",
	"from-oh.com",
	"from-ok.com",
	"from-or.com",
	"from-pa.com",
	"from-pr.com",
	"from-ri.com",
	"from-sc.com",
	"from-sd.com",
	"from-tn.com",
	"from-tx.com",
	"from-ut.com",
	"from-va.com",
	"from-vt.com",
	"from-wa.com",
	"from-wi.com",
	"from-wv.com",
	"from-wy.com",
	"ftpaccess.cc",
	"fuettertdasnetz.de",
	"game-host.org",
	"game-server.cc",
	"getmyip.com",
	"gets-it.net",
	"go.dyndns.org",
	"gotdns.com",
	"gotdns.org",
	"groks-the.info",
	"groks-this.info",
	"ham-radio-op.net",
	"here-for-more.info",
	"hobby-site.com",
	"hobby-site.org",
	"home.dyndns.org",
	"homedns.org",
	"homeftp.net",
	"homeftp.org",
	"homeip.net",
	"homelinux.com",
	"homelinux.net",
	"homelinux.org",
	"homeunix.com",
	"homeunix.net",
	"homeunix.org",
	"iamallama.com",
	"in-the-band.net",
	"is-a-anarchist.com",
	"is-a-blogger.com",
	"is-a-bookkeeper.com",
	"is-a-bruinsfan.org",
	"is-a-bulls-fan.com",
	"is-a-candidate.org",
	"is-a-caterer.com",
	"is-a-celticsfan.org",
	"is-a-chef.com",
	"is-a-chef.net",
	"is-a-chef.org",
	"is-a-conservative.com",
	"is-a-cpa.com",
	"is-a-cubicle-slave.com",
	"is-a-democrat.com",
	"is-a-designer.com",
	"is-a-doctor.com",
	"is-a-financialadvisor.com",
	"is-a-geek.com",
	"is-a-geek.net",
	"is-a-geek.org",
	"is-a-green.com",
	"is-a-guru.com",
	"is-a-hard-worker.com",
	"is-a-hunter.com",
	"is-a-knight.org",
	"is-a-landscaper.com",
	"is-a-lawyer.com",
	"is-a-liberal.com",
	"is-a-libertarian.com",
	"is-a-linux-user.org",
	"is-a-llama.com",
	"is-a-musician.com",
	"is-a-nascarfan.com",
	"is-a-nurse.com",
	"is-a-painter.com",
	"is-a-patsfan.org",
	"is-a-personaltrainer.com",
	"is-a-photographer.com",
	"is-a-player.com",
	"is-a-republican.com",
	"is-a-rockstar.com",
	"is-a-socialist.com",
	"is-a-soxfan.org",
	"is-a-student.com",
	"is-a-teacher.com",
	"is-a-techie.com",
	"is-a-therapist.com",
	"is-an-accountant.com",
	"is-an-actor.com",
	"is-an-actress.com",
	"is-an-anarchist.com",
	"is-an-artist.com",
	"is-an-engineer.com",
	"is-an-entertainer.com",
	"is-by.us",
	"is-certified.com",
	"is-found.org",
	"is-gone.com",
	"is-into-anime.com",
	"is-into-cars.com",
	"is-into-cartoons.com",
	"is-into-games.com",
	"is-leet.com",
	"is-lost.org",
	"is-not-certified.com",
	"is-saved.org",
	"is-slick.com",
	"is-uberleet.com",
	"is-very-bad.org",
	"is-very-evil.org",
	"is-very-good.org",
	"is-very-nice.org",
	"is-very-sweet.org",
	"is-with-theband.com",
	"isa-geek.com",
	"isa-geek.net",
	"isa-geek.org",
	"isa-hockeynut.com",
	"issmarterthanyou.com",
	"isteingeek.de",
	"istmein.de",
	"kicks-ass.net",
	"kicks-ass.org",
	"knowsitall.info",
	"land-4-sale.us",
	"lebtimnetz.de",
	"leitungsen.de",
	"likes-pie.com",
	"likescandy.com",
	"merseine.nu",
	"mine.nu",
	"misconfused.org",
	"mypets.ws",
	"myphotos.cc",
	"neat-url.com",
	"office-on-the.net",
	"on-the-web.tv",
	"podzone.net",
	"podzone.org",
	"readmyblog.org",
	"saves-the-whales.com",
	"scrapper-site.net",
	"scrapping.cc",
	"selfip.biz",
	"selfip.com",
	"selfip.info",
	"selfip.net",
	"selfip.org",
	"sells-for-less.com",
	"sells-for-u.com",
	"sells-it.net",
	"sellsyourhome.org",
	"servebbs.com",
	"servebbs.net",
	"servebbs.org",
	"serveftp.net",
	"serveftp.org",
	"servegame.org",
	"shacknet.nu",
	"simple-url.com",
	"space-to-rent.com",
	"stuff-4-sale.org",
	"stuff-4-sale.us",
	"teaches-yoga.com",
	"thruhere.net",
	"traeumtgerade.de",
	"webhop.biz",
	"webhop.info",
	"webhop.net",
	"webhop.org",
	"worse-than.tv",
	"writesthisblog.com",
	"ddnss.de",
	"dyn.ddnss.de",
	"dyndns.ddnss.de",
	"dyndns1.de",
	"dyn-ip24.de",
	"home-webserver.de",
	"dyn.home-webserver.de",
	"myhome-server.de",
	"ddnss.org",
	"definima.net",
	"definima.io",
	"bci.dnstrace.pro",
	"ddnsfree.com",
	"ddnsgeek.com",
	"giize.com",
	"gleeze.com",
	"kozow.com",
	"loseyourip.com",
	"ooguy.com",
	"theworkpc.com",
	"casacam.net",
	"dynu.net",
	"accesscam.org",
	"camdvr.org",
	"freeddns.org",
	"mywire.org",
	"webredirect.org",
	"myddns.rocks",
	"blogsite.xyz",
	"dynv6.net",
	"e4.cz",
	"en-root.fr",
	"mytuleap.com",
	"onred.one",
	"staging.onred.one",
	"enonic.io",
	"customer.enonic.io",
	"eu.org",
	"al.eu.org",
	"asso.eu.org",
	"at.eu.org",
	"au.eu.org",
	"be.eu.org",
	"bg.eu.org",
	"ca.eu.org",
	"cd.eu.org",
	"ch.eu.org",
	"cn.eu.org",
	"cy.eu.org",
	"cz.eu.org",
	"de.eu.org",
	"dk.eu.org",
	"edu.eu.org",
	"ee.eu.org",
	"es.eu.org",
	"fi.eu.org",
	"fr.eu.org",
	"gr.eu.org",
	"hr.eu.org",
	"hu.eu.org",
	"ie.eu.org",
	"il.eu.org",
	"in.eu.org",
	"int.eu.org",
	"is.eu.org",
	"it.eu.org",
	"jp.eu.org",
	"kr.eu.org",
	"lt.eu.org",
	"lu.eu.org",
	"lv.eu.org",
	"mc.eu.org",
	"me.eu.org",
	"mk.eu.org",
	"mt.eu.org",
	"my.eu.org",
	"net.eu.org",
	"ng.eu.org",
	"nl.eu.org",
	"no.eu.org",
	"nz.eu.org",
	"paris.eu.org",
	"pl.eu.org",
	"pt.eu.org",
	"q-a.eu.org",
	"ro.eu.org",
	"ru.eu.org",
	"se.eu.org",
	"si.eu.org",
	"sk.eu.org",
	"tr.eu.org",
	"uk.eu.org",
	"us.eu.org",
	"eu-1.evennode.com",
	"eu-2.evennode.com",
	"eu-3.evennode.com",
	"eu-4.evennode.com",
	"us-1.evennode.com",
	"us-2.evennode.com",
	"us-3.evennode.com",
	"us-4.evennode.com",
	"twmail.cc",
	"twmail.net",
	"twmail.org",
	"mymailer.com.tw",
	"url.tw",
	"apps.fbsbx.com",
	"ru.net",
	"adygeya.ru",
	"bashkiria.ru",
	"bir.ru",
	"cbg.ru",
	"com.ru",
	"dagestan.ru",
	"grozny.ru",
	"kalmykia.ru",
	"kustanai.ru",
	"marine.ru",
	"mordovia.ru",
	"msk.ru",
	"mytis.ru",
	"nalchik.ru",
	"nov.ru",
	"pyatigorsk.ru",
	"spb.ru",
	"vladikavkaz.ru",
	"vladimir.ru",
	"abkhazia.su",
	"adygeya.su",
	"aktyubinsk.su",
	"arkhangelsk.su",
	"armenia.su",
	"ashgabad.su",
	"azerbaijan.su",
	"balashov.su",
	"bashkiria.su",
	"bryansk.su",
	"bukhara.su",
	"chimkent.su",
	"dagestan.su",
	"east-kazakhstan.su",
	"exnet.su",
	"georgia.su",
	"grozny.su",
	"ivanovo.su",
	"jambyl.su",
	"kalmykia.su",
	"kaluga.su",
	"karacol.su",
	"karaganda.su",
	"karelia.su",
	"khakassia.su",
	"krasnodar.su",
	"kurgan.su",
	"kustanai.su",
	"lenug.su",
	"mangyshlak.su",
	"mordovia.su",
	"msk.su",
	"murmansk.su",
	"nalchik.su",
	"navoi.su",
	"north-kazakhstan.su",
	"nov.su",
	"obninsk.su",
	"penza.su",
	"pokrovsk.su",
	"sochi.su",
	"spb.su",
	"tashkent.su",
	"termez.su",
	"togliatti.su",
	"troitsk.su",
	"tselinograd.su",
	"tula.su",
	"tuva.su",
	"vladikavkaz.su",
	"vladimir.su",
	"vologda.su",
	"channelsdvr.net",
	"u.channelsdvr.net",
	"fastly-terrarium.com",
	"fastlylb.net",
	"map.fastlylb.net",
	"freetls.fastly.net",
	"map.fastly.net",
	"a.prod.fastly.net",
	"global.prod.fastly.net",
	"a.ssl.fastly.net",
	"b.ssl.fastly.net",
	"global.ssl.fastly.net",
	"fastpanel.direct",
	"fastvps-server.com",
	"fhapp.xyz",
	"fedorainfracloud.org",
	"fedorapeople.org",
	"cloud.fedoraproject.org",
	"app.os.fedoraproject.org",
	"app.os.stg.fedoraproject.org",
	"mydobiss.com",
	"filegear.me",
	"filegear-au.me",
	"filegear-de.me",
	"filegear-gb.me",
	"filegear-ie.me",
	"filegear-jp.me",
	"filegear-sg.me",
	"firebaseapp.com",
	"flynnhub.com",
	"flynnhosting.net",
	"0e.vc",
	"freebox-os.com",
	"freeboxos.com",
	"fbx-os.fr",
	"fbxos.fr",
	"freebox-os.fr",
	"freeboxos.fr",
	"freedesktop.org",
	"*.futurecms.at",
	"*.ex.futurecms.at",
	"*.in.futurecms.at",
	"futurehosting.at",
	"futuremailing.at",
	"*.ex.ortsinfo.at",
	"*.kunden.ortsinfo.at",
	"*.statics.cloud",
	"service.gov.uk",
	"gehirn.ne.jp",
	"usercontent.jp",
	"gentapps.com",
	"lab.ms",
	"github.io",
	"githubusercontent.com",
	"gitlab.io",
	"glitch.me",
	"lolipop.io",
	"cloudapps.digital",
	"london.cloudapps.digital",
	"homeoffice.gov.uk",
	"ro.im",
	"shop.ro",
	"goip.de",
	"run.app",
	"a.run.app",
	"web.app",
	"*.0emm.com",
	"appspot.com",
	"*.r.appspot.com",
	"blogspot.ae",
	"blogspot.al",
	"blogspot.am",
	"blogspot.ba",
	"blogspot.be",
	"blogspot.bg",
	"blogspot.bj",
	"blogspot.ca",
	"blogspot.cf",
	"blogspot.ch",
	"blogspot.cl",
	"blogspot.co.at",
	"blogspot.co.id",
	"blogspot.co.il",
	"blogspot.co.ke",
	"blogspot.co.nz",
	"blogspot.co.uk",
	"blogspot.co.za",
	"blogspot.com",
	"blogspot.com.ar",
	"blogspot.com.au",
	"blogspot.com.br",
	"blogspot.com.by",
	"blogspot.com.co",
	"blogspot.com.cy",
	"blogspot.com.ee",
	"blogspot.com.eg",
	"blogspot.com.es",
	"blogspot.com.mt",
	"blogspot.com.ng",
	"blogspot.com.tr",
	"blogspot.com.uy",
	"blogspot.cv",
	"blogspot.cz",
	"blogspot.de",
	"blogspot.dk",
	"blogspot.fi",
	"blogspot.fr",
	"blogspot.gr",
	"blogspot.hk",
	"blogspot.hr",
	"blogspot.hu",
	"blogspot.ie",
	"blogspot.in",
	"blogspot.is",
	"blogspot.it",
	"blogspot.jp",
	"blogspot.kr",
	"blogspot.li",
	"blogspot.lt",
	"blogspot.lu",
	"blogspot.md",
	"blogspot.mk",
	"blogspot.mr",
	"blogspot.mx",
	"blogspot.my",
	"blogspot.nl",
	"blogspot.no",
	"blogspot.pe",
	"blogspot.pt",
	"blogspot.qa",
	"blogspot.re",
	"blogspot.ro",
	"blogspot.rs",
	"blogspot.ru",
	"blogspot.se",
	"blogspot.sg",
	"blogspot.si",
	"blogspot.sk",
	"blogspot.sn",
	"blogspot.td",
	"blogspot.tw",
	"blogspot.ug",
	"blogspot.vn",
	"cloudfunctions.net",
	"cloud.goog",
	"codespot.com",
	"googleapis.com",
	"googlecode.com",
	"pagespeedmobilizer.com",
	"publishproxy.com",
	"withgoogle.com",
	"withyoutube.com",
	"awsmppl.com",
	"fin.ci",
	"free.hr",
	"caa.li",
	"ua.rs",
	"conf.se",
	"hs.zone",
	"hs.run",
	"hashbang.sh",
	"hasura.app",
	"hasura-app.io",
	"hepforge.org",
	"herokuapp.com",
	"herokussl.com",
	"myravendb.com",
	"ravendb.community",
	"ravendb.me",
	"development.run",
	"ravendb.run",
	"bpl.biz",
	"orx.biz",
	"ng.city",
	"biz.gl",
	"ng.ink",
	"col.ng",
	"firm.ng",
	"gen.ng",
	"ltd.ng",
	"ngo.ng",
	"ng.school",
	"sch.so",
	"häkkinen.fi",
	"*.moonscale.io",
	"moonscale.net",
	"iki.fi",
	"dyn-berlin.de",
	"in-berlin.de",
	"in-brb.de",
	"in-butter.de",
	"in-dsl.de",
	"in-dsl.net",
	"in-dsl.org",
	"in-vpn.de",
	"in-vpn.net",
	"in-vpn.org",
	"biz.at",
	"info.at",
	"info.cx",
	"ac.leg.br",
	"al.leg.br",
	"am.leg.br",
	"ap.leg.br",
	"ba.leg.br",
	"ce.leg.br",
	"df.leg.br",
	"es.leg.br",
	"go.leg.br",
	"ma.leg.br",
	"mg.leg.br",
	"ms.leg.br",
	"mt.leg.br",
	"pa.leg.br",
	"pb.leg.br",
	"pe.leg.br",
	"pi.leg.br",
	"pr.leg.br",
	"rj.leg.br",
	"rn.leg.br",
	"ro.leg.br",
	"rr.leg.br",
	"rs.leg.br",
	"sc.leg.br",
	"se.leg.br",
	"sp.leg.br",
	"to.leg.br",
	"pixolino.com",
	"ipifony.net",
	"mein-iserv.de",
	"test-iserv.de",
	"iserv.dev",
	"iobb.net",
	"myjino.ru",
	"*.hosting.myjino.ru",
	"*.landing.myjino.ru",
	"*.spectrum.myjino.ru",
	"*.vps.myjino.ru",
	"*.triton.zone",
	"*.cns.joyent.com",
	"js.org",
	"kaas.gg",
	"khplay.nl",
	"keymachine.de",
	"kinghost.net",
	"uni5.net",
	"knightpoint.systems",
	"oya.to",
	"co.krd",
	"edu.krd",
	"git-repos.de",
	"lcube-server.de",
	"svn-repos.de",
	"leadpages.co",
	"lpages.co",
	"lpusercontent.com",
	"lelux.site",
	"co.business",
	"co.education",
	"co.events",
	"co.financial",
	"co.network",
	"co.place",
	"co.technology",
	"app.lmpm.com",
	"linkitools.space",
	"linkyard.cloud",
	"linkyard-cloud.ch",
	"members.linode.com",
	"nodebalancer.linode.com",
	"we.bs",
	"loginline.app",
	"loginline.dev",
	"loginline.io",
	"loginline.services",
	"loginline.site",
	"krasnik.pl",
	"leczna.pl",
	"lubartow.pl",
	"lublin.pl",
	"poniatowa.pl",
	"swidnik.pl",
	"uklugs.org",
	"glug.org.uk",
	"lug.org.uk",
	"lugs.org.uk",
	"barsy.bg",
	"barsy.co.uk",
	"barsyonline.co.uk",
	"barsycenter.com",
	"barsyonline.com",
	"barsy.club",
	"barsy.de",
	"barsy.eu",
	"barsy.in",
	"barsy.info",
	"barsy.io",
	"barsy.me",
	"barsy.menu",
	"barsy.mobi",
	"barsy.net",
	"barsy.online",
	"barsy.org",
	"barsy.pro",
	"barsy.pub",
	"barsy.shop",
	"barsy.site",
	"barsy.support",
	"barsy.uk",
	"*.magentosite.cloud",
	"mayfirst.info",
	"mayfirst.org",
	"hb.cldmail.ru",
	"miniserver.com",
	"memset.net",
	"cloud.metacentrum.cz",
	"custom.metacentrum.cz",
	"flt.cloud.muni.cz",
	"usr.cloud.muni.cz",
	"meteorapp.com",
	"eu.meteorapp.com",
	"co.pl",
	"azurecontainer.io",
	"azurewebsites.net",
	"azure-mobile.net",
	"cloudapp.net",
	"mozilla-iot.org",
	"bmoattachments.org",
	"net.ru",
	"org.ru",
	"pp.ru",
	"ui.nabu.casa",
	"pony.club",
	"of.fashion",
	"on.fashion",
	"of.football",
	"in.london",
	"of.london",
	"for.men",
	"and.mom",
	"for.mom",
	"for.one",
	"for.sale",
	"of.work",
	"to.work",
	"nctu.me",
	"bitballoon.com",
	"netlify.com",
	"4u.com",
	"ngrok.io",
	"nh-serv.co.uk",
	"nfshost.com",
	"dnsking.ch",
	"mypi.co",
	"n4t.co",
	"001www.com",
	"ddnslive.com",
	"myiphost.com",
	"forumz.info",
	"16-b.it",
	"32-b.it",
	"64-b.it",
	"soundcast.me",
	"tcp4.me",
	"dnsup.net",
	"hicam.net",
	"now-dns.net",
	"ownip.net",
	"vpndns.net",
	"dynserv.org",
	"now-dns.org",
	"x443.pw",
	"now-dns.top",
	"ntdll.top",
	"freeddns.us",
	"crafting.xyz",
	"zapto.xyz",
	"nsupdate.info",
	"nerdpol.ovh",
	"blogsyte.com",
	"brasilia.me",
	"cable-modem.org",
	"ciscofreak.com",
	"collegefan.org",
	"couchpotatofries.org",
	"damnserver.com",
	"ddns.me",
	"ditchyourip.com",
	"dnsfor.me",
	"dnsiskinky.com",
	"dvrcam.info",
	"dynns.com",
	"eating-organic.net",
	"fantasyleague.cc",
	"geekgalaxy.com",
	"golffan.us",
	"health-carereform.com",
	"homesecuritymac.com",
	"homesecuritypc.com",
	"hopto.me",
	"ilovecollege.info",
	"loginto.me",
	"mlbfan.org",
	"mmafan.biz",
	"myactivedirectory.com",
	"mydissent.net",
	"myeffect.net",
	"mymediapc.net",
	"mypsx.net",
	"mysecuritycamera.com",
	"mysecuritycamera.net",
	"mysecuritycamera.org",
	"net-freaks.com",
	"nflfan.org",
	"nhlfan.net",
	"no-ip.ca",
	"no-ip.co.uk",
	"no-ip.net",
	"noip.us",
	"onthewifi.com",
	"pgafan.net",
	"point2this.com",
	"pointto.us",
	"privatizehealthinsurance.net",
	"quicksytes.com",
	"read-books.org",
	"securitytactics.com",
	"serveexchange.com",
	"servehumour.com",
	"servep2p.com",
	"servesarcasm.com",
	"stufftoread.com",
	"ufcfan.org",
	"unusualperson.com",
	"workisboring.com",
	"3utilities.com",
	"bounceme.net",
	"ddns.net",
	"ddnsking.com",
	"gotdns.ch",
	"hopto.org",
	"myftp.biz",
	"myftp.org",
	"myvnc.com",
	"no-ip.biz",
	"no-ip.info",
	"no-ip.org",
	"noip.me",
	"redirectme.net",
	"servebeer.com",
	"serveblog.net",
	"servecounterstrike.com",
	"serveftp.com",
	"servegame.com",
	"servehalflife.com",
	"servehttp.com",
	"serveirc.com",
	"serveminecraft.net",
	"servemp3.com",
	"servepics.com",
	"servequake.com",
	"sytes.net",
	"webhop.me",
	"zapto.org",
	"stage.nodeart.io",
	"nodum.co",
	"nodum.io",
	"pcloud.host",
	"nyc.mn",
	"nom.ae",
	"nom.af",
	"nom.ai",
	"nom.al",
	"nym.by",
	"nom.bz",
	"nym.bz",
	"nom.cl",
	"nym.ec",
	"nom.gd",
	"nom.ge",
	"nom.gl",
	"nym.gr",
	"nom.gt",
	"nym.gy",
	"nym.hk",
	"nom.hn",
	"nym.ie",
	"nom.im",
	"nom.ke",
	"nym.kz",
	"nym.la",
	"nym.lc",
	"nom.li",
	"nym.li",
	"nym.lt",
	"nym.lu",
	"nom.lv",
	"nym.me",
	"nom.mk",
	"nym.mn",
	"nym.mx",
	"nom.nu",
	"nym.nz",
	"nym.pe",
	"nym.pt",
	"nom.pw",
	"nom.qa",
	"nym.ro",
	"nom.rs",
	"nom.si",
	"nym.sk",
	"nom.st",
	"nym.su",
	"nym.sx",
	"nom.tj",
	"nym.tw",
	"nom.ug",
	"nom.uy",
	"nom.vc",
	"nom.vg",
	"static.observableusercontent.com",
	"cya.gg",
	"cloudycluster.net",
	"nid.io",
	"opencraft.hosting",
	"operaunite.com",
	"skygearapp.com",
	"outsystemscloud.com",
	"ownprovider.com",
	"own.pm",
	"ox.rs",
	"oy.lc",
	"pgfog.com",
	"pagefrontapp.com",
	"art.pl",
	"gliwice.pl",
	"krakow.pl",
	"poznan.pl",
	"wroc.pl",
	"zakopane.pl",
	"pantheonsite.io",
	"gotpantheon.com",
	"mypep.link",
	"perspecta.cloud",
	"on-web.fr",
	"*.platform.sh",
	"*.platformsh.site",
	"dyn53.io",
	"co.bn",
	"xen.prgmr.com",
	"priv.at",
	"prvcy.page",
	"*.dweb.link",
	"protonet.io",
	"chirurgiens-dentistes-en-france.fr",
	"byen.site",
	"pubtls.org",
	"qualifioapp.com",
	"qbuser.com",
	"instantcloud.cn",
	"ras.ru",
	"qa2.com",
	"qcx.io",
	"*.sys.qcx.io",
	"dev-myqnapcloud.com",
	"alpha-myqnapcloud.com",
	"myqnapcloud.com",
	"*.quipelements.com",
	"vapor.cloud",
	"vaporcloud.io",
	"rackmaze.com",
	"rackmaze.net",
	"*.on-k3s.io",
	"*.on-rancher.cloud",
	"*.on-rio.io",
	"readthedocs.io",
	"rhcloud.com",
	"app.render.com",
	"onrender.com",
	"repl.co",
	"repl.run",
	"resindevice.io",
	"devices.resinstaging.io",
	"hzc.io",
	"wellbeingzone.eu",
	"ptplus.fit",
	"wellbeingzone.co.uk",
	"git-pages.rit.edu",
	"sandcats.io",
	"logoip.de",
	"logoip.com",
	"schokokeks.net",
	"gov.scot",
	"scrysec.com",
	"firewall-gateway.com",
	"firewall-gateway.de",
	"my-gateway.de",
	"my-router.de",
	"spdns.de",
	"spdns.eu",
	"firewall-gateway.net",
	"my-firewall.org",
	"myfirewall.org",
	"spdns.org",
	"senseering.net",
	"biz.ua",
	"co.ua",
	"pp.ua",
	"shiftedit.io",
	"myshopblocks.com",
	"shopitsite.com",
	"mo-siemens.io",
	"1kapp.com",
	"appchizi.com",
	"applinzi.com",
	"sinaapp.com",
	"vipsinaapp.com",
	"siteleaf.net",
	"bounty-full.com",
	"alpha.bounty-full.com",
	"beta.bounty-full.com",
	"stackhero-network.com",
	"static.land",
	"dev.static.land",
	"sites.static.land",
	"apps.lair.io",
	"*.stolos.io",
	"spacekit.io",
	"customer.speedpartner.de",
	"api.stdlib.com",
	"storj.farm",
	"utwente.io",
	"soc.srcf.net",
	"user.srcf.net",
	"temp-dns.com",
	"applicationcloud.io",
	"scapp.io",
	"*.s5y.io",
	"*.sensiosite.cloud",
	"syncloud.it",
	"diskstation.me",
	"dscloud.biz",
	"dscloud.me",
	"dscloud.mobi",
	"dsmynas.com",
	"dsmynas.net",
	"dsmynas.org",
	"familyds.com",
	"familyds.net",
	"familyds.org",
	"i234.me",
	"myds.me",
	"synology.me",
	"vpnplus.to",
	"direct.quickconnect.to",
	"taifun-dns.de",
	"gda.pl",
	"gdansk.pl",
	"gdynia.pl",
	"med.pl",
	"sopot.pl",
	"edugit.org",
	"telebit.app",
	"telebit.io",
	"*.telebit.xyz",
	"gwiddle.co.uk",
	"thingdustdata.com",
	"cust.dev.thingdust.io",
	"cust.disrec.thingdust.io",
	"cust.prod.thingdust.io",
	"cust.testing.thingdust.io",
	"arvo.network",
	"azimuth.network",
	"bloxcms.com",
	"townnews-staging.com",
	"12hp.at",
	"2ix.at",
	"4lima.at",
	"lima-city.at",
	"12hp.ch",
	"2ix.ch",
	"4lima.ch",
	"lima-city.ch",
	"trafficplex.cloud",
	"de.cool",
	"12hp.de",
	"2ix.de",
	"4lima.de",
	"lima-city.de",
	"1337.pictures",
	"clan.rip",
	"lima-city.rocks",
	"webspace.rocks",
	"lima.zone",
	"*.transurl.be",
	"*.transurl.eu",
	"*.transurl.nl",
	"tuxfamily.org",
	"dd-dns.de",
	"diskstation.eu",
	"diskstation.org",
	"dray-dns.de",
	"draydns.de",
	"dyn-vpn.de",
	"dynvpn.de",
	"mein-vigor.de",
	"my-vigor.de",
	"my-wan.de",
	"syno-ds.de",
	"synology-diskstation.de",
	"synology-ds.de",
	"uber.space",
	"*.uberspace.de",
	"hk.com",
	"hk.org",
	"ltd.hk",
	"inc.hk",
	"virtualuser.de",
	"virtual-user.de",
	"urown.cloud",
	"dnsupdate.info",
	"lib.de.us",
	"2038.io",
	"router.management",
	"v-info.info",
	"voorloper.cloud",
	"v.ua",
	"wafflecell.com",
	"*.webhare.dev",
	"wedeploy.io",
	"wedeploy.me",
	"wedeploy.sh",
	"remotewd.com",
	"wmflabs.org",
	"myforum.community",
	"community-pro.de",
	"diskussionsbereich.de",
	"community-pro.net",
	"meinforum.net",
	"half.host",
	"xnbay.com",
	"u2.xnbay.com",
	"u2-local.xnbay.com",
	"cistron.nl",
	"demon.nl",
	"xs4all.space",
	"yandexcloud.net",
	"storage.yandexcloud.net",
	"website.yandexcloud.net",
	"official.academy",
	"yolasite.com",
	"ybo.faith",
	"yombo.me",
	"homelink.one",
	"ybo.party",
	"ybo.review",
	"ybo.science",
	"ybo.trade",
	"nohost.me",
	"noho.st",
	"za.net",
	"za.org",
	"now.sh",
	"bss.design",
	"basicserver.io",
	"virtualserver.io",
	"enterprisecloud.nu"
];

/*eslint no-var:0, prefer-arrow-callback: 0, object-shorthand: 0 */

var psl = createCommonjsModule(function (module, exports) {





var internals = {};


//
// Read rules from file.
//
internals.rules = require$$0$4.map(function (rule) {

  return {
    rule: rule,
    suffix: rule.replace(/^(\*\.|\!)/, ''),
    punySuffix: -1,
    wildcard: rule.charAt(0) === '*',
    exception: rule.charAt(0) === '!'
  };
});


//
// Check is given string ends with `suffix`.
//
internals.endsWith = function (str, suffix) {

  return str.indexOf(suffix, str.length - suffix.length) !== -1;
};


//
// Find rule for a given domain.
//
internals.findRule = function (domain) {

  var punyDomain = Punycode.toASCII(domain);
  return internals.rules.reduce(function (memo, rule) {

    if (rule.punySuffix === -1){
      rule.punySuffix = Punycode.toASCII(rule.suffix);
    }
    if (!internals.endsWith(punyDomain, '.' + rule.punySuffix) && punyDomain !== rule.punySuffix) {
      return memo;
    }
    // This has been commented out as it never seems to run. This is because
    // sub tlds always appear after their parents and we never find a shorter
    // match.
    //if (memo) {
    //  var memoSuffix = Punycode.toASCII(memo.suffix);
    //  if (memoSuffix.length >= punySuffix.length) {
    //    return memo;
    //  }
    //}
    return rule;
  }, null);
};


//
// Error codes and messages.
//
exports.errorCodes = {
  DOMAIN_TOO_SHORT: 'Domain name too short.',
  DOMAIN_TOO_LONG: 'Domain name too long. It should be no more than 255 chars.',
  LABEL_STARTS_WITH_DASH: 'Domain name label can not start with a dash.',
  LABEL_ENDS_WITH_DASH: 'Domain name label can not end with a dash.',
  LABEL_TOO_LONG: 'Domain name label should be at most 63 chars long.',
  LABEL_TOO_SHORT: 'Domain name label should be at least 1 character long.',
  LABEL_INVALID_CHARS: 'Domain name label can only contain alphanumeric characters or dashes.'
};


//
// Validate domain name and throw if not valid.
//
// From wikipedia:
//
// Hostnames are composed of series of labels concatenated with dots, as are all
// domain names. Each label must be between 1 and 63 characters long, and the
// entire hostname (including the delimiting dots) has a maximum of 255 chars.
//
// Allowed chars:
//
// * `a-z`
// * `0-9`
// * `-` but not as a starting or ending character
// * `.` as a separator for the textual portions of a domain name
//
// * http://en.wikipedia.org/wiki/Domain_name
// * http://en.wikipedia.org/wiki/Hostname
//
internals.validate = function (input) {

  // Before we can validate we need to take care of IDNs with unicode chars.
  var ascii = Punycode.toASCII(input);

  if (ascii.length < 1) {
    return 'DOMAIN_TOO_SHORT';
  }
  if (ascii.length > 255) {
    return 'DOMAIN_TOO_LONG';
  }

  // Check each part's length and allowed chars.
  var labels = ascii.split('.');
  var label;

  for (var i = 0; i < labels.length; ++i) {
    label = labels[i];
    if (!label.length) {
      return 'LABEL_TOO_SHORT';
    }
    if (label.length > 63) {
      return 'LABEL_TOO_LONG';
    }
    if (label.charAt(0) === '-') {
      return 'LABEL_STARTS_WITH_DASH';
    }
    if (label.charAt(label.length - 1) === '-') {
      return 'LABEL_ENDS_WITH_DASH';
    }
    if (!/^[a-z0-9\-]+$/.test(label)) {
      return 'LABEL_INVALID_CHARS';
    }
  }
};


//
// Public API
//


//
// Parse domain.
//
exports.parse = function (input) {

  if (typeof input !== 'string') {
    throw new TypeError('Domain name must be a string.');
  }

  // Force domain to lowercase.
  var domain = input.slice(0).toLowerCase();

  // Handle FQDN.
  // TODO: Simply remove trailing dot?
  if (domain.charAt(domain.length - 1) === '.') {
    domain = domain.slice(0, domain.length - 1);
  }

  // Validate and sanitise input.
  var error = internals.validate(domain);
  if (error) {
    return {
      input: input,
      error: {
        message: exports.errorCodes[error],
        code: error
      }
    };
  }

  var parsed = {
    input: input,
    tld: null,
    sld: null,
    domain: null,
    subdomain: null,
    listed: false
  };

  var domainParts = domain.split('.');

  // Non-Internet TLD
  if (domainParts[domainParts.length - 1] === 'local') {
    return parsed;
  }

  var handlePunycode = function () {

    if (!/xn--/.test(domain)) {
      return parsed;
    }
    if (parsed.domain) {
      parsed.domain = Punycode.toASCII(parsed.domain);
    }
    if (parsed.subdomain) {
      parsed.subdomain = Punycode.toASCII(parsed.subdomain);
    }
    return parsed;
  };

  var rule = internals.findRule(domain);

  // Unlisted tld.
  if (!rule) {
    if (domainParts.length < 2) {
      return parsed;
    }
    parsed.tld = domainParts.pop();
    parsed.sld = domainParts.pop();
    parsed.domain = [parsed.sld, parsed.tld].join('.');
    if (domainParts.length) {
      parsed.subdomain = domainParts.pop();
    }
    return handlePunycode();
  }

  // At this point we know the public suffix is listed.
  parsed.listed = true;

  var tldParts = rule.suffix.split('.');
  var privateParts = domainParts.slice(0, domainParts.length - tldParts.length);

  if (rule.exception) {
    privateParts.push(tldParts.shift());
  }

  parsed.tld = tldParts.join('.');

  if (!privateParts.length) {
    return handlePunycode();
  }

  if (rule.wildcard) {
    tldParts.unshift(privateParts.pop());
    parsed.tld = tldParts.join('.');
  }

  if (!privateParts.length) {
    return handlePunycode();
  }

  parsed.sld = privateParts.pop();
  parsed.domain = [parsed.sld,  parsed.tld].join('.');

  if (privateParts.length) {
    parsed.subdomain = privateParts.join('.');
  }

  return handlePunycode();
};


//
// Get domain.
//
exports.get = function (domain) {

  if (!domain) {
    return null;
  }
  return exports.parse(domain).domain || null;
};


//
// Check whether domain belongs to a known public suffix.
//
exports.isValid = function (domain) {

  var parsed = exports.parse(domain);
  return Boolean(parsed.domain && parsed.listed);
};
});

/*!
 * Copyright (c) 2018, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


function getPublicSuffix$1(domain) {
  return psl.get(domain);
}

var getPublicSuffix_1 = getPublicSuffix$1;

var pubsuffixPsl = {
	getPublicSuffix: getPublicSuffix_1
};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*jshint unused:false */

function Store$2() {
}
var Store_1$1 = Store$2;

// Stores may be synchronous, but are still required to use a
// Continuation-Passing Style API.  The CookieJar itself will expose a "*Sync"
// API that converts from synchronous-callbacks to imperative style.
Store$2.prototype.synchronous = false;

Store$2.prototype.findCookie = function(domain, path, key, cb) {
  throw new Error('findCookie is not implemented');
};

Store$2.prototype.findCookies = function(domain, path, cb) {
  throw new Error('findCookies is not implemented');
};

Store$2.prototype.putCookie = function(cookie, cb) {
  throw new Error('putCookie is not implemented');
};

Store$2.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  // recommended default implementation:
  // return this.putCookie(newCookie, cb);
  throw new Error('updateCookie is not implemented');
};

Store$2.prototype.removeCookie = function(domain, path, key, cb) {
  throw new Error('removeCookie is not implemented');
};

Store$2.prototype.removeCookies = function(domain, path, cb) {
  throw new Error('removeCookies is not implemented');
};

Store$2.prototype.removeAllCookies = function(cb) {
  throw new Error('removeAllCookies is not implemented');
};

Store$2.prototype.getAllCookies = function(cb) {
  throw new Error('getAllCookies is not implemented (therefore jar cannot be serialized)');
};

var store = {
	Store: Store_1$1
};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */


// Gives the permutation of all possible domainMatch()es of a given domain. The
// array is in shortest-to-longest order.  Handy for indexing.
function permuteDomain$2 (domain) {
  var pubSuf = pubsuffixPsl.getPublicSuffix(domain);
  if (!pubSuf) {
    return null;
  }
  if (pubSuf == domain) {
    return [domain];
  }

  var prefix = domain.slice(0, -(pubSuf.length + 1)); // ".example.com"
  var parts = prefix.split('.').reverse();
  var cur = pubSuf;
  var permutations = [cur];
  while (parts.length) {
    cur = parts.shift() + '.' + cur;
    permutations.push(cur);
  }
  return permutations;
}

var permuteDomain_2 = permuteDomain$2;

var permuteDomain_1 = {
	permuteDomain: permuteDomain_2
};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
/*
 * "A request-path path-matches a given cookie-path if at least one of the
 * following conditions holds:"
 */
function pathMatch$2 (reqPath, cookiePath) {
  // "o  The cookie-path and the request-path are identical."
  if (cookiePath === reqPath) {
    return true;
  }

  var idx = reqPath.indexOf(cookiePath);
  if (idx === 0) {
    // "o  The cookie-path is a prefix of the request-path, and the last
    // character of the cookie-path is %x2F ("/")."
    if (cookiePath.substr(-1) === "/") {
      return true;
    }

    // " o  The cookie-path is a prefix of the request-path, and the first
    // character of the request-path that is not included in the cookie- path
    // is a %x2F ("/") character."
    if (reqPath.substr(cookiePath.length, 1) === "/") {
      return true;
    }
  }

  return false;
}

var pathMatch_2 = pathMatch$2;

var pathMatch_1$1 = {
	pathMatch: pathMatch_2
};

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */
var Store$1 = store.Store;
var permuteDomain$1 = permuteDomain_1.permuteDomain;
var pathMatch$1 = pathMatch_1$1.pathMatch;


function MemoryCookieStore$1() {
  Store$1.call(this);
  this.idx = {};
}
util$2.inherits(MemoryCookieStore$1, Store$1);
var MemoryCookieStore_1$1 = MemoryCookieStore$1;
MemoryCookieStore$1.prototype.idx = null;

// Since it's just a struct in RAM, this Store is synchronous
MemoryCookieStore$1.prototype.synchronous = true;

// force a default depth:
MemoryCookieStore$1.prototype.inspect = function() {
  return "{ idx: "+util$2.inspect(this.idx, false, 2)+' }';
};

// Use the new custom inspection symbol to add the custom inspect function if
// available.
if (util$2.inspect.custom) {
  MemoryCookieStore$1.prototype[util$2.inspect.custom] = MemoryCookieStore$1.prototype.inspect;
}

MemoryCookieStore$1.prototype.findCookie = function(domain, path, key, cb) {
  if (!this.idx[domain]) {
    return cb(null,undefined);
  }
  if (!this.idx[domain][path]) {
    return cb(null,undefined);
  }
  return cb(null,this.idx[domain][path][key]||null);
};

MemoryCookieStore$1.prototype.findCookies = function(domain, path, cb) {
  var results = [];
  if (!domain) {
    return cb(null,[]);
  }

  var pathMatcher;
  if (!path) {
    // null means "all paths"
    pathMatcher = function matchAll(domainIndex) {
      for (var curPath in domainIndex) {
        var pathIndex = domainIndex[curPath];
        for (var key in pathIndex) {
          results.push(pathIndex[key]);
        }
      }
    };

  } else {
    pathMatcher = function matchRFC(domainIndex) {
       //NOTE: we should use path-match algorithm from S5.1.4 here
       //(see : https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/canonical_cookie.cc#L299)
       Object.keys(domainIndex).forEach(function (cookiePath) {
         if (pathMatch$1(path, cookiePath)) {
           var pathIndex = domainIndex[cookiePath];

           for (var key in pathIndex) {
             results.push(pathIndex[key]);
           }
         }
       });
     };
  }

  var domains = permuteDomain$1(domain) || [domain];
  var idx = this.idx;
  domains.forEach(function(curDomain) {
    var domainIndex = idx[curDomain];
    if (!domainIndex) {
      return;
    }
    pathMatcher(domainIndex);
  });

  cb(null,results);
};

MemoryCookieStore$1.prototype.putCookie = function(cookie, cb) {
  if (!this.idx[cookie.domain]) {
    this.idx[cookie.domain] = {};
  }
  if (!this.idx[cookie.domain][cookie.path]) {
    this.idx[cookie.domain][cookie.path] = {};
  }
  this.idx[cookie.domain][cookie.path][cookie.key] = cookie;
  cb(null);
};

MemoryCookieStore$1.prototype.updateCookie = function(oldCookie, newCookie, cb) {
  // updateCookie() may avoid updating cookies that are identical.  For example,
  // lastAccessed may not be important to some stores and an equality
  // comparison could exclude that field.
  this.putCookie(newCookie,cb);
};

MemoryCookieStore$1.prototype.removeCookie = function(domain, path, key, cb) {
  if (this.idx[domain] && this.idx[domain][path] && this.idx[domain][path][key]) {
    delete this.idx[domain][path][key];
  }
  cb(null);
};

MemoryCookieStore$1.prototype.removeCookies = function(domain, path, cb) {
  if (this.idx[domain]) {
    if (path) {
      delete this.idx[domain][path];
    } else {
      delete this.idx[domain];
    }
  }
  return cb(null);
};

MemoryCookieStore$1.prototype.removeAllCookies = function(cb) {
  this.idx = {};
  return cb(null);
};

MemoryCookieStore$1.prototype.getAllCookies = function(cb) {
  var cookies = [];
  var idx = this.idx;

  var domains = Object.keys(idx);
  domains.forEach(function(domain) {
    var paths = Object.keys(idx[domain]);
    paths.forEach(function(path) {
      var keys = Object.keys(idx[domain][path]);
      keys.forEach(function(key) {
        if (key !== null) {
          cookies.push(idx[domain][path][key]);
        }
      });
    });
  });

  // Sort by creationIndex so deserializing retains the creation order.
  // When implementing your own store, this SHOULD retain the order too
  cookies.sort(function(a,b) {
    return (a.creationIndex||0) - (b.creationIndex||0);
  });

  cb(null, cookies);
};

var memstore = {
	MemoryCookieStore: MemoryCookieStore_1$1
};

// generated by genversion
var version$3 = '2.5.0';

/*!
 * Copyright (c) 2015, Salesforce.com, Inc.
 * All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *
 * 1. Redistributions of source code must retain the above copyright notice,
 * this list of conditions and the following disclaimer.
 *
 * 2. Redistributions in binary form must reproduce the above copyright notice,
 * this list of conditions and the following disclaimer in the documentation
 * and/or other materials provided with the distribution.
 *
 * 3. Neither the name of Salesforce.com nor the names of its contributors may
 * be used to endorse or promote products derived from this software without
 * specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
 * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
 * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
 * POSSIBILITY OF SUCH DAMAGE.
 */

var urlParse = url.parse;


var Store = store.Store;
var MemoryCookieStore = memstore.MemoryCookieStore;
var pathMatch = pathMatch_1$1.pathMatch;


var punycode;
try {
  punycode = Punycode;
} catch(e) {
  console.warn("tough-cookie: can't load punycode; won't use punycode for domain normalization");
}

// From RFC6265 S4.1.1
// note that it excludes \x3B ";"
var COOKIE_OCTETS = /^[\x21\x23-\x2B\x2D-\x3A\x3C-\x5B\x5D-\x7E]+$/;

var CONTROL_CHARS = /[\x00-\x1F]/;

// From Chromium // '\r', '\n' and '\0' should be treated as a terminator in
// the "relaxed" mode, see:
// https://github.com/ChromiumWebApps/chromium/blob/b3d3b4da8bb94c1b2e061600df106d590fda3620/net/cookies/parsed_cookie.cc#L60
var TERMINATORS = ['\n', '\r', '\0'];

// RFC6265 S4.1.1 defines path value as 'any CHAR except CTLs or ";"'
// Note ';' is \x3B
var PATH_VALUE = /[\x20-\x3A\x3C-\x7E]+/;

// date-time parsing constants (RFC6265 S5.1.1)

var DATE_DELIM = /[\x09\x20-\x2F\x3B-\x40\x5B-\x60\x7B-\x7E]/;

var MONTH_TO_NUM = {
  jan:0, feb:1, mar:2, apr:3, may:4, jun:5,
  jul:6, aug:7, sep:8, oct:9, nov:10, dec:11
};
var NUM_TO_MONTH = [
  'Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'
];
var NUM_TO_DAY = [
  'Sun','Mon','Tue','Wed','Thu','Fri','Sat'
];

var MAX_TIME = 2147483647000; // 31-bit max
var MIN_TIME = 0; // 31-bit min

/*
 * Parses a Natural number (i.e., non-negative integer) with either the
 *    <min>*<max>DIGIT ( non-digit *OCTET )
 * or
 *    <min>*<max>DIGIT
 * grammar (RFC6265 S5.1.1).
 *
 * The "trailingOK" boolean controls if the grammar accepts a
 * "( non-digit *OCTET )" trailer.
 */
function parseDigits(token, minDigits, maxDigits, trailingOK) {
  var count = 0;
  while (count < token.length) {
    var c = token.charCodeAt(count);
    // "non-digit = %x00-2F / %x3A-FF"
    if (c <= 0x2F || c >= 0x3A) {
      break;
    }
    count++;
  }

  // constrain to a minimum and maximum number of digits.
  if (count < minDigits || count > maxDigits) {
    return null;
  }

  if (!trailingOK && count != token.length) {
    return null;
  }

  return parseInt(token.substr(0,count), 10);
}

function parseTime(token) {
  var parts = token.split(':');
  var result = [0,0,0];

  /* RF6256 S5.1.1:
   *      time            = hms-time ( non-digit *OCTET )
   *      hms-time        = time-field ":" time-field ":" time-field
   *      time-field      = 1*2DIGIT
   */

  if (parts.length !== 3) {
    return null;
  }

  for (var i = 0; i < 3; i++) {
    // "time-field" must be strictly "1*2DIGIT", HOWEVER, "hms-time" can be
    // followed by "( non-digit *OCTET )" so therefore the last time-field can
    // have a trailer
    var trailingOK = (i == 2);
    var num = parseDigits(parts[i], 1, 2, trailingOK);
    if (num === null) {
      return null;
    }
    result[i] = num;
  }

  return result;
}

function parseMonth(token) {
  token = String(token).substr(0,3).toLowerCase();
  var num = MONTH_TO_NUM[token];
  return num >= 0 ? num : null;
}

/*
 * RFC6265 S5.1.1 date parser (see RFC for full grammar)
 */
function parseDate(str) {
  if (!str) {
    return;
  }

  /* RFC6265 S5.1.1:
   * 2. Process each date-token sequentially in the order the date-tokens
   * appear in the cookie-date
   */
  var tokens = str.split(DATE_DELIM);
  if (!tokens) {
    return;
  }

  var hour = null;
  var minute = null;
  var second = null;
  var dayOfMonth = null;
  var month = null;
  var year = null;

  for (var i=0; i<tokens.length; i++) {
    var token = tokens[i].trim();
    if (!token.length) {
      continue;
    }

    var result;

    /* 2.1. If the found-time flag is not set and the token matches the time
     * production, set the found-time flag and set the hour- value,
     * minute-value, and second-value to the numbers denoted by the digits in
     * the date-token, respectively.  Skip the remaining sub-steps and continue
     * to the next date-token.
     */
    if (second === null) {
      result = parseTime(token);
      if (result) {
        hour = result[0];
        minute = result[1];
        second = result[2];
        continue;
      }
    }

    /* 2.2. If the found-day-of-month flag is not set and the date-token matches
     * the day-of-month production, set the found-day-of- month flag and set
     * the day-of-month-value to the number denoted by the date-token.  Skip
     * the remaining sub-steps and continue to the next date-token.
     */
    if (dayOfMonth === null) {
      // "day-of-month = 1*2DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 1, 2, true);
      if (result !== null) {
        dayOfMonth = result;
        continue;
      }
    }

    /* 2.3. If the found-month flag is not set and the date-token matches the
     * month production, set the found-month flag and set the month-value to
     * the month denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (month === null) {
      result = parseMonth(token);
      if (result !== null) {
        month = result;
        continue;
      }
    }

    /* 2.4. If the found-year flag is not set and the date-token matches the
     * year production, set the found-year flag and set the year-value to the
     * number denoted by the date-token.  Skip the remaining sub-steps and
     * continue to the next date-token.
     */
    if (year === null) {
      // "year = 2*4DIGIT ( non-digit *OCTET )"
      result = parseDigits(token, 2, 4, true);
      if (result !== null) {
        year = result;
        /* From S5.1.1:
         * 3.  If the year-value is greater than or equal to 70 and less
         * than or equal to 99, increment the year-value by 1900.
         * 4.  If the year-value is greater than or equal to 0 and less
         * than or equal to 69, increment the year-value by 2000.
         */
        if (year >= 70 && year <= 99) {
          year += 1900;
        } else if (year >= 0 && year <= 69) {
          year += 2000;
        }
      }
    }
  }

  /* RFC 6265 S5.1.1
   * "5. Abort these steps and fail to parse the cookie-date if:
   *     *  at least one of the found-day-of-month, found-month, found-
   *        year, or found-time flags is not set,
   *     *  the day-of-month-value is less than 1 or greater than 31,
   *     *  the year-value is less than 1601,
   *     *  the hour-value is greater than 23,
   *     *  the minute-value is greater than 59, or
   *     *  the second-value is greater than 59.
   *     (Note that leap seconds cannot be represented in this syntax.)"
   *
   * So, in order as above:
   */
  if (
    dayOfMonth === null || month === null || year === null || second === null ||
    dayOfMonth < 1 || dayOfMonth > 31 ||
    year < 1601 ||
    hour > 23 ||
    minute > 59 ||
    second > 59
  ) {
    return;
  }

  return new Date(Date.UTC(year, month, dayOfMonth, hour, minute, second));
}

function formatDate(date) {
  var d = date.getUTCDate(); d = d >= 10 ? d : '0'+d;
  var h = date.getUTCHours(); h = h >= 10 ? h : '0'+h;
  var m = date.getUTCMinutes(); m = m >= 10 ? m : '0'+m;
  var s = date.getUTCSeconds(); s = s >= 10 ? s : '0'+s;
  return NUM_TO_DAY[date.getUTCDay()] + ', ' +
    d+' '+ NUM_TO_MONTH[date.getUTCMonth()] +' '+ date.getUTCFullYear() +' '+
    h+':'+m+':'+s+' GMT';
}

// S5.1.2 Canonicalized Host Names
function canonicalDomain(str) {
  if (str == null) {
    return null;
  }
  str = str.trim().replace(/^\./,''); // S4.1.2.3 & S5.2.3: ignore leading .

  // convert to IDN if any non-ASCII characters
  if (punycode && /[^\u0001-\u007f]/.test(str)) {
    str = punycode.toASCII(str);
  }

  return str.toLowerCase();
}

// S5.1.3 Domain Matching
function domainMatch(str, domStr, canonicalize) {
  if (str == null || domStr == null) {
    return null;
  }
  if (canonicalize !== false) {
    str = canonicalDomain(str);
    domStr = canonicalDomain(domStr);
  }

  /*
   * "The domain string and the string are identical. (Note that both the
   * domain string and the string will have been canonicalized to lower case at
   * this point)"
   */
  if (str == domStr) {
    return true;
  }

  /* "All of the following [three] conditions hold:" (order adjusted from the RFC) */

  /* "* The string is a host name (i.e., not an IP address)." */
  if (net$1.isIP(str)) {
    return false;
  }

  /* "* The domain string is a suffix of the string" */
  var idx = str.indexOf(domStr);
  if (idx <= 0) {
    return false; // it's a non-match (-1) or prefix (0)
  }

  // e.g "a.b.c".indexOf("b.c") === 2
  // 5 === 3+2
  if (str.length !== domStr.length + idx) { // it's not a suffix
    return false;
  }

  /* "* The last character of the string that is not included in the domain
  * string is a %x2E (".") character." */
  if (str.substr(idx-1,1) !== '.') {
    return false;
  }

  return true;
}


// RFC6265 S5.1.4 Paths and Path-Match

/*
 * "The user agent MUST use an algorithm equivalent to the following algorithm
 * to compute the default-path of a cookie:"
 *
 * Assumption: the path (and not query part or absolute uri) is passed in.
 */
function defaultPath(path) {
  // "2. If the uri-path is empty or if the first character of the uri-path is not
  // a %x2F ("/") character, output %x2F ("/") and skip the remaining steps.
  if (!path || path.substr(0,1) !== "/") {
    return "/";
  }

  // "3. If the uri-path contains no more than one %x2F ("/") character, output
  // %x2F ("/") and skip the remaining step."
  if (path === "/") {
    return path;
  }

  var rightSlash = path.lastIndexOf("/");
  if (rightSlash === 0) {
    return "/";
  }

  // "4. Output the characters of the uri-path from the first character up to,
  // but not including, the right-most %x2F ("/")."
  return path.slice(0, rightSlash);
}

function trimTerminator(str) {
  for (var t = 0; t < TERMINATORS.length; t++) {
    var terminatorIdx = str.indexOf(TERMINATORS[t]);
    if (terminatorIdx !== -1) {
      str = str.substr(0,terminatorIdx);
    }
  }

  return str;
}

function parseCookiePair(cookiePair, looseMode) {
  cookiePair = trimTerminator(cookiePair);

  var firstEq = cookiePair.indexOf('=');
  if (looseMode) {
    if (firstEq === 0) { // '=' is immediately at start
      cookiePair = cookiePair.substr(1);
      firstEq = cookiePair.indexOf('='); // might still need to split on '='
    }
  } else { // non-loose mode
    if (firstEq <= 0) { // no '=' or is at start
      return; // needs to have non-empty "cookie-name"
    }
  }

  var cookieName, cookieValue;
  if (firstEq <= 0) {
    cookieName = "";
    cookieValue = cookiePair.trim();
  } else {
    cookieName = cookiePair.substr(0, firstEq).trim();
    cookieValue = cookiePair.substr(firstEq+1).trim();
  }

  if (CONTROL_CHARS.test(cookieName) || CONTROL_CHARS.test(cookieValue)) {
    return;
  }

  var c = new Cookie$1();
  c.key = cookieName;
  c.value = cookieValue;
  return c;
}

function parse$4(str, options) {
  if (!options || typeof options !== 'object') {
    options = {};
  }
  str = str.trim();

  // We use a regex to parse the "name-value-pair" part of S5.2
  var firstSemi = str.indexOf(';'); // S5.2 step 1
  var cookiePair = (firstSemi === -1) ? str : str.substr(0, firstSemi);
  var c = parseCookiePair(cookiePair, !!options.loose);
  if (!c) {
    return;
  }

  if (firstSemi === -1) {
    return c;
  }

  // S5.2.3 "unparsed-attributes consist of the remainder of the set-cookie-string
  // (including the %x3B (";") in question)." plus later on in the same section
  // "discard the first ";" and trim".
  var unparsed = str.slice(firstSemi + 1).trim();

  // "If the unparsed-attributes string is empty, skip the rest of these
  // steps."
  if (unparsed.length === 0) {
    return c;
  }

  /*
   * S5.2 says that when looping over the items "[p]rocess the attribute-name
   * and attribute-value according to the requirements in the following
   * subsections" for every item.  Plus, for many of the individual attributes
   * in S5.3 it says to use the "attribute-value of the last attribute in the
   * cookie-attribute-list".  Therefore, in this implementation, we overwrite
   * the previous value.
   */
  var cookie_avs = unparsed.split(';');
  while (cookie_avs.length) {
    var av = cookie_avs.shift().trim();
    if (av.length === 0) { // happens if ";;" appears
      continue;
    }
    var av_sep = av.indexOf('=');
    var av_key, av_value;

    if (av_sep === -1) {
      av_key = av;
      av_value = null;
    } else {
      av_key = av.substr(0,av_sep);
      av_value = av.substr(av_sep+1);
    }

    av_key = av_key.trim().toLowerCase();

    if (av_value) {
      av_value = av_value.trim();
    }

    switch(av_key) {
    case 'expires': // S5.2.1
      if (av_value) {
        var exp = parseDate(av_value);
        // "If the attribute-value failed to parse as a cookie date, ignore the
        // cookie-av."
        if (exp) {
          // over and underflow not realistically a concern: V8's getTime() seems to
          // store something larger than a 32-bit time_t (even with 32-bit node)
          c.expires = exp;
        }
      }
      break;

    case 'max-age': // S5.2.2
      if (av_value) {
        // "If the first character of the attribute-value is not a DIGIT or a "-"
        // character ...[or]... If the remainder of attribute-value contains a
        // non-DIGIT character, ignore the cookie-av."
        if (/^-?[0-9]+$/.test(av_value)) {
          var delta = parseInt(av_value, 10);
          // "If delta-seconds is less than or equal to zero (0), let expiry-time
          // be the earliest representable date and time."
          c.setMaxAge(delta);
        }
      }
      break;

    case 'domain': // S5.2.3
      // "If the attribute-value is empty, the behavior is undefined.  However,
      // the user agent SHOULD ignore the cookie-av entirely."
      if (av_value) {
        // S5.2.3 "Let cookie-domain be the attribute-value without the leading %x2E
        // (".") character."
        var domain = av_value.trim().replace(/^\./, '');
        if (domain) {
          // "Convert the cookie-domain to lower case."
          c.domain = domain.toLowerCase();
        }
      }
      break;

    case 'path': // S5.2.4
      /*
       * "If the attribute-value is empty or if the first character of the
       * attribute-value is not %x2F ("/"):
       *   Let cookie-path be the default-path.
       * Otherwise:
       *   Let cookie-path be the attribute-value."
       *
       * We'll represent the default-path as null since it depends on the
       * context of the parsing.
       */
      c.path = av_value && av_value[0] === "/" ? av_value : null;
      break;

    case 'secure': // S5.2.5
      /*
       * "If the attribute-name case-insensitively matches the string "Secure",
       * the user agent MUST append an attribute to the cookie-attribute-list
       * with an attribute-name of Secure and an empty attribute-value."
       */
      c.secure = true;
      break;

    case 'httponly': // S5.2.6 -- effectively the same as 'secure'
      c.httpOnly = true;
      break;

    default:
      c.extensions = c.extensions || [];
      c.extensions.push(av);
      break;
    }
  }

  return c;
}

// avoid the V8 deoptimization monster!
function jsonParse(str) {
  var obj;
  try {
    obj = JSON.parse(str);
  } catch (e) {
    return e;
  }
  return obj;
}

function fromJSON(str) {
  if (!str) {
    return null;
  }

  var obj;
  if (typeof str === 'string') {
    obj = jsonParse(str);
    if (obj instanceof Error) {
      return null;
    }
  } else {
    // assume it's an Object
    obj = str;
  }

  var c = new Cookie$1();
  for (var i=0; i<Cookie$1.serializableProperties.length; i++) {
    var prop = Cookie$1.serializableProperties[i];
    if (obj[prop] === undefined ||
        obj[prop] === Cookie$1.prototype[prop])
    {
      continue; // leave as prototype default
    }

    if (prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed')
    {
      if (obj[prop] === null) {
        c[prop] = null;
      } else {
        c[prop] = obj[prop] == "Infinity" ?
          "Infinity" : new Date(obj[prop]);
      }
    } else {
      c[prop] = obj[prop];
    }
  }

  return c;
}

/* Section 5.4 part 2:
 * "*  Cookies with longer paths are listed before cookies with
 *     shorter paths.
 *
 *  *  Among cookies that have equal-length path fields, cookies with
 *     earlier creation-times are listed before cookies with later
 *     creation-times."
 */

function cookieCompare(a,b) {
  var cmp = 0;

  // descending for length: b CMP a
  var aPathLen = a.path ? a.path.length : 0;
  var bPathLen = b.path ? b.path.length : 0;
  cmp = bPathLen - aPathLen;
  if (cmp !== 0) {
    return cmp;
  }

  // ascending for time: a CMP b
  var aTime = a.creation ? a.creation.getTime() : MAX_TIME;
  var bTime = b.creation ? b.creation.getTime() : MAX_TIME;
  cmp = aTime - bTime;
  if (cmp !== 0) {
    return cmp;
  }

  // break ties for the same millisecond (precision of JavaScript's clock)
  cmp = a.creationIndex - b.creationIndex;

  return cmp;
}

// Gives the permutation of all possible pathMatch()es of a given path. The
// array is in longest-to-shortest order.  Handy for indexing.
function permutePath(path) {
  if (path === '/') {
    return ['/'];
  }
  if (path.lastIndexOf('/') === path.length-1) {
    path = path.substr(0,path.length-1);
  }
  var permutations = [path];
  while (path.length > 1) {
    var lindex = path.lastIndexOf('/');
    if (lindex === 0) {
      break;
    }
    path = path.substr(0,lindex);
    permutations.push(path);
  }
  permutations.push('/');
  return permutations;
}

function getCookieContext(url) {
  if (url instanceof Object) {
    return url;
  }
  // NOTE: decodeURI will throw on malformed URIs (see GH-32).
  // Therefore, we will just skip decoding for such URIs.
  try {
    url = decodeURI(url);
  }
  catch(err) {
    // Silently swallow error
  }

  return urlParse(url);
}

function Cookie$1(options) {
  options = options || {};

  Object.keys(options).forEach(function(prop) {
    if (Cookie$1.prototype.hasOwnProperty(prop) &&
        Cookie$1.prototype[prop] !== options[prop] &&
        prop.substr(0,1) !== '_')
    {
      this[prop] = options[prop];
    }
  }, this);

  this.creation = this.creation || new Date();

  // used to break creation ties in cookieCompare():
  Object.defineProperty(this, 'creationIndex', {
    configurable: false,
    enumerable: false, // important for assert.deepEqual checks
    writable: true,
    value: ++Cookie$1.cookiesCreated
  });
}

Cookie$1.cookiesCreated = 0; // incremented each time a cookie is created

Cookie$1.parse = parse$4;
Cookie$1.fromJSON = fromJSON;

Cookie$1.prototype.key = "";
Cookie$1.prototype.value = "";

// the order in which the RFC has them:
Cookie$1.prototype.expires = "Infinity"; // coerces to literal Infinity
Cookie$1.prototype.maxAge = null; // takes precedence over expires for TTL
Cookie$1.prototype.domain = null;
Cookie$1.prototype.path = null;
Cookie$1.prototype.secure = false;
Cookie$1.prototype.httpOnly = false;
Cookie$1.prototype.extensions = null;

// set by the CookieJar:
Cookie$1.prototype.hostOnly = null; // boolean when set
Cookie$1.prototype.pathIsDefault = null; // boolean when set
Cookie$1.prototype.creation = null; // Date when set; defaulted by Cookie.parse
Cookie$1.prototype.lastAccessed = null; // Date when set
Object.defineProperty(Cookie$1.prototype, 'creationIndex', {
  configurable: true,
  enumerable: false,
  writable: true,
  value: 0
});

Cookie$1.serializableProperties = Object.keys(Cookie$1.prototype)
  .filter(function(prop) {
    return !(
      Cookie$1.prototype[prop] instanceof Function ||
      prop === 'creationIndex' ||
      prop.substr(0,1) === '_'
    );
  });

Cookie$1.prototype.inspect = function inspect() {
  var now = Date.now();
  return 'Cookie="'+this.toString() +
    '; hostOnly='+(this.hostOnly != null ? this.hostOnly : '?') +
    '; aAge='+(this.lastAccessed ? (now-this.lastAccessed.getTime())+'ms' : '?') +
    '; cAge='+(this.creation ? (now-this.creation.getTime())+'ms' : '?') +
    '"';
};

// Use the new custom inspection symbol to add the custom inspect function if
// available.
if (util$2.inspect.custom) {
  Cookie$1.prototype[util$2.inspect.custom] = Cookie$1.prototype.inspect;
}

Cookie$1.prototype.toJSON = function() {
  var obj = {};

  var props = Cookie$1.serializableProperties;
  for (var i=0; i<props.length; i++) {
    var prop = props[i];
    if (this[prop] === Cookie$1.prototype[prop]) {
      continue; // leave as prototype default
    }

    if (prop === 'expires' ||
        prop === 'creation' ||
        prop === 'lastAccessed')
    {
      if (this[prop] === null) {
        obj[prop] = null;
      } else {
        obj[prop] = this[prop] == "Infinity" ? // intentionally not ===
          "Infinity" : this[prop].toISOString();
      }
    } else if (prop === 'maxAge') {
      if (this[prop] !== null) {
        // again, intentionally not ===
        obj[prop] = (this[prop] == Infinity || this[prop] == -Infinity) ?
          this[prop].toString() : this[prop];
      }
    } else {
      if (this[prop] !== Cookie$1.prototype[prop]) {
        obj[prop] = this[prop];
      }
    }
  }

  return obj;
};

Cookie$1.prototype.clone = function() {
  return fromJSON(this.toJSON());
};

Cookie$1.prototype.validate = function validate() {
  if (!COOKIE_OCTETS.test(this.value)) {
    return false;
  }
  if (this.expires != Infinity && !(this.expires instanceof Date) && !parseDate(this.expires)) {
    return false;
  }
  if (this.maxAge != null && this.maxAge <= 0) {
    return false; // "Max-Age=" non-zero-digit *DIGIT
  }
  if (this.path != null && !PATH_VALUE.test(this.path)) {
    return false;
  }

  var cdomain = this.cdomain();
  if (cdomain) {
    if (cdomain.match(/\.$/)) {
      return false; // S4.1.2.3 suggests that this is bad. domainMatch() tests confirm this
    }
    var suffix = pubsuffixPsl.getPublicSuffix(cdomain);
    if (suffix == null) { // it's a public suffix
      return false;
    }
  }
  return true;
};

Cookie$1.prototype.setExpires = function setExpires(exp) {
  if (exp instanceof Date) {
    this.expires = exp;
  } else {
    this.expires = parseDate(exp) || "Infinity";
  }
};

Cookie$1.prototype.setMaxAge = function setMaxAge(age) {
  if (age === Infinity || age === -Infinity) {
    this.maxAge = age.toString(); // so JSON.stringify() works
  } else {
    this.maxAge = age;
  }
};

// gives Cookie header format
Cookie$1.prototype.cookieString = function cookieString() {
  var val = this.value;
  if (val == null) {
    val = '';
  }
  if (this.key === '') {
    return val;
  }
  return this.key+'='+val;
};

// gives Set-Cookie header format
Cookie$1.prototype.toString = function toString() {
  var str = this.cookieString();

  if (this.expires != Infinity) {
    if (this.expires instanceof Date) {
      str += '; Expires='+formatDate(this.expires);
    } else {
      str += '; Expires='+this.expires;
    }
  }

  if (this.maxAge != null && this.maxAge != Infinity) {
    str += '; Max-Age='+this.maxAge;
  }

  if (this.domain && !this.hostOnly) {
    str += '; Domain='+this.domain;
  }
  if (this.path) {
    str += '; Path='+this.path;
  }

  if (this.secure) {
    str += '; Secure';
  }
  if (this.httpOnly) {
    str += '; HttpOnly';
  }
  if (this.extensions) {
    this.extensions.forEach(function(ext) {
      str += '; '+ext;
    });
  }

  return str;
};

// TTL() partially replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere)
// S5.3 says to give the "latest representable date" for which we use Infinity
// For "expired" we use 0
Cookie$1.prototype.TTL = function TTL(now) {
  /* RFC6265 S4.1.2.2 If a cookie has both the Max-Age and the Expires
   * attribute, the Max-Age attribute has precedence and controls the
   * expiration date of the cookie.
   * (Concurs with S5.3 step 3)
   */
  if (this.maxAge != null) {
    return this.maxAge<=0 ? 0 : this.maxAge*1000;
  }

  var expires = this.expires;
  if (expires != Infinity) {
    if (!(expires instanceof Date)) {
      expires = parseDate(expires) || Infinity;
    }

    if (expires == Infinity) {
      return Infinity;
    }

    return expires.getTime() - (now || Date.now());
  }

  return Infinity;
};

// expiryTime() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere)
Cookie$1.prototype.expiryTime = function expiryTime(now) {
  if (this.maxAge != null) {
    var relativeTo = now || this.creation || new Date();
    var age = (this.maxAge <= 0) ? -Infinity : this.maxAge*1000;
    return relativeTo.getTime() + age;
  }

  if (this.expires == Infinity) {
    return Infinity;
  }
  return this.expires.getTime();
};

// expiryDate() replaces the "expiry-time" parts of S5.3 step 3 (setCookie()
// elsewhere), except it returns a Date
Cookie$1.prototype.expiryDate = function expiryDate(now) {
  var millisec = this.expiryTime(now);
  if (millisec == Infinity) {
    return new Date(MAX_TIME);
  } else if (millisec == -Infinity) {
    return new Date(MIN_TIME);
  } else {
    return new Date(millisec);
  }
};

// This replaces the "persistent-flag" parts of S5.3 step 3
Cookie$1.prototype.isPersistent = function isPersistent() {
  return (this.maxAge != null || this.expires != Infinity);
};

// Mostly S5.1.2 and S5.2.3:
Cookie$1.prototype.cdomain =
Cookie$1.prototype.canonicalizedDomain = function canonicalizedDomain() {
  if (this.domain == null) {
    return null;
  }
  return canonicalDomain(this.domain);
};

function CookieJar$1(store, options) {
  if (typeof options === "boolean") {
    options = {rejectPublicSuffixes: options};
  } else if (options == null) {
    options = {};
  }
  if (options.rejectPublicSuffixes != null) {
    this.rejectPublicSuffixes = options.rejectPublicSuffixes;
  }
  if (options.looseMode != null) {
    this.enableLooseMode = options.looseMode;
  }

  if (!store) {
    store = new MemoryCookieStore();
  }
  this.store = store;
}
CookieJar$1.prototype.store = null;
CookieJar$1.prototype.rejectPublicSuffixes = true;
CookieJar$1.prototype.enableLooseMode = false;
var CAN_BE_SYNC = [];

CAN_BE_SYNC.push('setCookie');
CookieJar$1.prototype.setCookie = function(cookie, url, options, cb) {
  var err;
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var loose = this.enableLooseMode;
  if (options.loose != null) {
    loose = options.loose;
  }

  // S5.3 step 1
  if (!(cookie instanceof Cookie$1)) {
    cookie = Cookie$1.parse(cookie, { loose: loose });
  }
  if (!cookie) {
    err = new Error("Cookie failed to parse");
    return cb(options.ignoreError ? null : err);
  }

  // S5.3 step 2
  var now = options.now || new Date(); // will assign later to save effort in the face of errors

  // S5.3 step 3: NOOP; persistent-flag and expiry-time is handled by getCookie()

  // S5.3 step 4: NOOP; domain is null by default

  // S5.3 step 5: public suffixes
  if (this.rejectPublicSuffixes && cookie.domain) {
    var suffix = pubsuffixPsl.getPublicSuffix(cookie.cdomain());
    if (suffix == null) { // e.g. "com"
      err = new Error("Cookie has domain set to a public suffix");
      return cb(options.ignoreError ? null : err);
    }
  }

  // S5.3 step 6:
  if (cookie.domain) {
    if (!domainMatch(host, cookie.cdomain(), false)) {
      err = new Error("Cookie not in this host's domain. Cookie:"+cookie.cdomain()+" Request:"+host);
      return cb(options.ignoreError ? null : err);
    }

    if (cookie.hostOnly == null) { // don't reset if already set
      cookie.hostOnly = false;
    }

  } else {
    cookie.hostOnly = true;
    cookie.domain = host;
  }

  //S5.2.4 If the attribute-value is empty or if the first character of the
  //attribute-value is not %x2F ("/"):
  //Let cookie-path be the default-path.
  if (!cookie.path || cookie.path[0] !== '/') {
    cookie.path = defaultPath(context.pathname);
    cookie.pathIsDefault = true;
  }

  // S5.3 step 8: NOOP; secure attribute
  // S5.3 step 9: NOOP; httpOnly attribute

  // S5.3 step 10
  if (options.http === false && cookie.httpOnly) {
    err = new Error("Cookie is HttpOnly and this isn't an HTTP API");
    return cb(options.ignoreError ? null : err);
  }

  var store = this.store;

  if (!store.updateCookie) {
    store.updateCookie = function(oldCookie, newCookie, cb) {
      this.putCookie(newCookie, cb);
    };
  }

  function withCookie(err, oldCookie) {
    if (err) {
      return cb(err);
    }

    var next = function(err) {
      if (err) {
        return cb(err);
      } else {
        cb(null, cookie);
      }
    };

    if (oldCookie) {
      // S5.3 step 11 - "If the cookie store contains a cookie with the same name,
      // domain, and path as the newly created cookie:"
      if (options.http === false && oldCookie.httpOnly) { // step 11.2
        err = new Error("old Cookie is HttpOnly and this isn't an HTTP API");
        return cb(options.ignoreError ? null : err);
      }
      cookie.creation = oldCookie.creation; // step 11.3
      cookie.creationIndex = oldCookie.creationIndex; // preserve tie-breaker
      cookie.lastAccessed = now;
      // Step 11.4 (delete cookie) is implied by just setting the new one:
      store.updateCookie(oldCookie, cookie, next); // step 12

    } else {
      cookie.creation = cookie.lastAccessed = now;
      store.putCookie(cookie, next); // step 12
    }
  }

  store.findCookie(cookie.domain, cookie.path, cookie.key, withCookie);
};

// RFC6365 S5.4
CAN_BE_SYNC.push('getCookies');
CookieJar$1.prototype.getCookies = function(url, options, cb) {
  var context = getCookieContext(url);
  if (options instanceof Function) {
    cb = options;
    options = {};
  }

  var host = canonicalDomain(context.hostname);
  var path = context.pathname || '/';

  var secure = options.secure;
  if (secure == null && context.protocol &&
      (context.protocol == 'https:' || context.protocol == 'wss:'))
  {
    secure = true;
  }

  var http = options.http;
  if (http == null) {
    http = true;
  }

  var now = options.now || Date.now();
  var expireCheck = options.expire !== false;
  var allPaths = !!options.allPaths;
  var store = this.store;

  function matchingCookie(c) {
    // "Either:
    //   The cookie's host-only-flag is true and the canonicalized
    //   request-host is identical to the cookie's domain.
    // Or:
    //   The cookie's host-only-flag is false and the canonicalized
    //   request-host domain-matches the cookie's domain."
    if (c.hostOnly) {
      if (c.domain != host) {
        return false;
      }
    } else {
      if (!domainMatch(host, c.domain, false)) {
        return false;
      }
    }

    // "The request-uri's path path-matches the cookie's path."
    if (!allPaths && !pathMatch(path, c.path)) {
      return false;
    }

    // "If the cookie's secure-only-flag is true, then the request-uri's
    // scheme must denote a "secure" protocol"
    if (c.secure && !secure) {
      return false;
    }

    // "If the cookie's http-only-flag is true, then exclude the cookie if the
    // cookie-string is being generated for a "non-HTTP" API"
    if (c.httpOnly && !http) {
      return false;
    }

    // deferred from S5.3
    // non-RFC: allow retention of expired cookies by choice
    if (expireCheck && c.expiryTime() <= now) {
      store.removeCookie(c.domain, c.path, c.key, function(){}); // result ignored
      return false;
    }

    return true;
  }

  store.findCookies(host, allPaths ? null : path, function(err,cookies) {
    if (err) {
      return cb(err);
    }

    cookies = cookies.filter(matchingCookie);

    // sorting of S5.4 part 2
    if (options.sort !== false) {
      cookies = cookies.sort(cookieCompare);
    }

    // S5.4 part 3
    var now = new Date();
    cookies.forEach(function(c) {
      c.lastAccessed = now;
    });
    // TODO persist lastAccessed

    cb(null,cookies);
  });
};

CAN_BE_SYNC.push('getCookieString');
CookieJar$1.prototype.getCookieString = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies
        .sort(cookieCompare)
        .map(function(c){
          return c.cookieString();
        })
        .join('; '));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push('getSetCookieStrings');
CookieJar$1.prototype.getSetCookieStrings = function(/*..., cb*/) {
  var args = Array.prototype.slice.call(arguments,0);
  var cb = args.pop();
  var next = function(err,cookies) {
    if (err) {
      cb(err);
    } else {
      cb(null, cookies.map(function(c){
        return c.toString();
      }));
    }
  };
  args.push(next);
  this.getCookies.apply(this,args);
};

CAN_BE_SYNC.push('serialize');
CookieJar$1.prototype.serialize = function(cb) {
  var type = this.store.constructor.name;
  if (type === 'Object') {
    type = null;
  }

  // update README.md "Serialization Format" if you change this, please!
  var serialized = {
    // The version of tough-cookie that serialized this jar. Generally a good
    // practice since future versions can make data import decisions based on
    // known past behavior. When/if this matters, use `semver`.
    version: 'tough-cookie@'+version$3,

    // add the store type, to make humans happy:
    storeType: type,

    // CookieJar configuration:
    rejectPublicSuffixes: !!this.rejectPublicSuffixes,

    // this gets filled from getAllCookies:
    cookies: []
  };

  if (!(this.store.getAllCookies &&
        typeof this.store.getAllCookies === 'function'))
  {
    return cb(new Error('store does not support getAllCookies and cannot be serialized'));
  }

  this.store.getAllCookies(function(err,cookies) {
    if (err) {
      return cb(err);
    }

    serialized.cookies = cookies.map(function(cookie) {
      // convert to serialized 'raw' cookies
      cookie = (cookie instanceof Cookie$1) ? cookie.toJSON() : cookie;

      // Remove the index so new ones get assigned during deserialization
      delete cookie.creationIndex;

      return cookie;
    });

    return cb(null, serialized);
  });
};

// well-known name that JSON.stringify calls
CookieJar$1.prototype.toJSON = function() {
  return this.serializeSync();
};

// use the class method CookieJar.deserialize instead of calling this directly
CAN_BE_SYNC.push('_importCookies');
CookieJar$1.prototype._importCookies = function(serialized, cb) {
  var jar = this;
  var cookies = serialized.cookies;
  if (!cookies || !Array.isArray(cookies)) {
    return cb(new Error('serialized jar has no cookies array'));
  }
  cookies = cookies.slice(); // do not modify the original

  function putNext(err) {
    if (err) {
      return cb(err);
    }

    if (!cookies.length) {
      return cb(err, jar);
    }

    var cookie;
    try {
      cookie = fromJSON(cookies.shift());
    } catch (e) {
      return cb(e);
    }

    if (cookie === null) {
      return putNext(null); // skip this cookie
    }

    jar.store.putCookie(cookie, putNext);
  }

  putNext();
};

CookieJar$1.deserialize = function(strOrObj, store, cb) {
  if (arguments.length !== 3) {
    // store is optional
    cb = store;
    store = null;
  }

  var serialized;
  if (typeof strOrObj === 'string') {
    serialized = jsonParse(strOrObj);
    if (serialized instanceof Error) {
      return cb(serialized);
    }
  } else {
    serialized = strOrObj;
  }

  var jar = new CookieJar$1(store, serialized.rejectPublicSuffixes);
  jar._importCookies(serialized, function(err) {
    if (err) {
      return cb(err);
    }
    cb(null, jar);
  });
};

CookieJar$1.deserializeSync = function(strOrObj, store) {
  var serialized = typeof strOrObj === 'string' ?
    JSON.parse(strOrObj) : strOrObj;
  var jar = new CookieJar$1(store, serialized.rejectPublicSuffixes);

  // catch this mistake early:
  if (!jar.store.synchronous) {
    throw new Error('CookieJar store is not synchronous; use async API instead.');
  }

  jar._importCookiesSync(serialized);
  return jar;
};
CookieJar$1.fromJSON = CookieJar$1.deserializeSync;

CookieJar$1.prototype.clone = function(newStore, cb) {
  if (arguments.length === 1) {
    cb = newStore;
    newStore = null;
  }

  this.serialize(function(err,serialized) {
    if (err) {
      return cb(err);
    }
    CookieJar$1.deserialize(serialized, newStore, cb);
  });
};

CAN_BE_SYNC.push('removeAllCookies');
CookieJar$1.prototype.removeAllCookies = function(cb) {
  var store = this.store;

  // Check that the store implements its own removeAllCookies(). The default
  // implementation in Store will immediately call the callback with a "not
  // implemented" Error.
  if (store.removeAllCookies instanceof Function &&
      store.removeAllCookies !== Store.prototype.removeAllCookies)
  {
    return store.removeAllCookies(cb);
  }

  store.getAllCookies(function(err, cookies) {
    if (err) {
      return cb(err);
    }

    if (cookies.length === 0) {
      return cb(null);
    }

    var completedCount = 0;
    var removeErrors = [];

    function removeCookieCb(removeErr) {
      if (removeErr) {
        removeErrors.push(removeErr);
      }

      completedCount++;

      if (completedCount === cookies.length) {
        return cb(removeErrors.length ? removeErrors[0] : null);
      }
    }

    cookies.forEach(function(cookie) {
      store.removeCookie(cookie.domain, cookie.path, cookie.key, removeCookieCb);
    });
  });
};

CookieJar$1.prototype._cloneSync = syncWrap('clone');
CookieJar$1.prototype.cloneSync = function(newStore) {
  if (!newStore.synchronous) {
    throw new Error('CookieJar clone destination store is not synchronous; use async API instead.');
  }
  return this._cloneSync(newStore);
};

// Use a closure to provide a true imperative API for synchronous stores.
function syncWrap(method) {
  return function() {
    if (!this.store.synchronous) {
      throw new Error('CookieJar store is not synchronous; use async API instead.');
    }

    var args = Array.prototype.slice.call(arguments);
    var syncErr, syncResult;
    args.push(function syncCb(err, result) {
      syncErr = err;
      syncResult = result;
    });
    this[method].apply(this, args);

    if (syncErr) {
      throw syncErr;
    }
    return syncResult;
  };
}

// wrap all declared CAN_BE_SYNC methods in the sync wrapper
CAN_BE_SYNC.forEach(function(method) {
  CookieJar$1.prototype[method+'Sync'] = syncWrap(method);
});

var version$2 = version$3;
var CookieJar_1 = CookieJar$1;
var Cookie_1 = Cookie$1;
var Store_1 = Store;
var MemoryCookieStore_1 = MemoryCookieStore;
var parseDate_1 = parseDate;
var formatDate_1 = formatDate;
var parse_1 = parse$4;
var fromJSON_1 = fromJSON;
var domainMatch_1 = domainMatch;
var defaultPath_1 = defaultPath;
var pathMatch_1 = pathMatch;
var getPublicSuffix = pubsuffixPsl.getPublicSuffix;
var cookieCompare_1 = cookieCompare;
var permuteDomain = permuteDomain_1.permuteDomain;
var permutePath_1 = permutePath;
var canonicalDomain_1 = canonicalDomain;

var cookie$1 = {
	version: version$2,
	CookieJar: CookieJar_1,
	Cookie: Cookie_1,
	Store: Store_1,
	MemoryCookieStore: MemoryCookieStore_1,
	parseDate: parseDate_1,
	formatDate: formatDate_1,
	parse: parse_1,
	fromJSON: fromJSON_1,
	domainMatch: domainMatch_1,
	defaultPath: defaultPath_1,
	pathMatch: pathMatch_1,
	getPublicSuffix: getPublicSuffix,
	cookieCompare: cookieCompare_1,
	permuteDomain: permuteDomain,
	permutePath: permutePath_1,
	canonicalDomain: canonicalDomain_1
};

var Cookie = cookie$1.Cookie;
var CookieJar = cookie$1.CookieJar;

var parse$3 = function (str) {
  if (str && str.uri) {
    str = str.uri;
  }
  if (typeof str !== 'string') {
    throw new Error('The cookie function only accepts STRING as param')
  }
  return Cookie.parse(str, {loose: true})
};

// Adapt the sometimes-Async api of tough.CookieJar to our requirements
function RequestJar (store) {
  var self = this;
  self._jar = new CookieJar(store, {looseMode: true});
}
RequestJar.prototype.setCookie = function (cookieOrStr, uri, options) {
  var self = this;
  return self._jar.setCookieSync(cookieOrStr, uri, options || {})
};
RequestJar.prototype.getCookieString = function (uri) {
  var self = this;
  return self._jar.getCookieStringSync(uri)
};
RequestJar.prototype.getCookies = function (uri) {
  var self = this;
  return self._jar.getCookiesSync(uri)
};

var jar = function (store) {
  return new RequestJar(store)
};

var cookies$1 = {
	parse: parse$3,
	jar: jar
};

var stringify_1$1 = createCommonjsModule(function (module, exports) {
exports = module.exports = stringify;
exports.getSerialize = serializer;

function stringify(obj, replacer, spaces, cycleReplacer) {
  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)
}

function serializer(replacer, cycleReplacer) {
  var stack = [], keys = [];

  if (cycleReplacer == null) cycleReplacer = function(key, value) {
    if (stack[0] === value) return "[Circular ~]"
    return "[Circular ~." + keys.slice(0, stack.indexOf(value)).join(".") + "]"
  };

  return function(key, value) {
    if (stack.length > 0) {
      var thisPos = stack.indexOf(this);
      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this);
      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key);
      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value);
    }
    else stack.push(value);

    return replacer == null ? value : replacer.call(this, key, value)
  }
}
});

/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */

var safeBuffer = createCommonjsModule(function (module, exports) {
/* eslint-disable node/no-deprecated-api */

var Buffer = buffer.Buffer;

// alternative to using Object.keys for old browsers
function copyProps (src, dst) {
  for (var key in src) {
    dst[key] = src[key];
  }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
  module.exports = buffer;
} else {
  // Copy properties from require('buffer')
  copyProps(buffer, exports);
  exports.Buffer = SafeBuffer;
}

function SafeBuffer (arg, encodingOrOffset, length) {
  return Buffer(arg, encodingOrOffset, length)
}

SafeBuffer.prototype = Object.create(Buffer.prototype);

// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);

SafeBuffer.from = function (arg, encodingOrOffset, length) {
  if (typeof arg === 'number') {
    throw new TypeError('Argument must not be a number')
  }
  return Buffer(arg, encodingOrOffset, length)
};

SafeBuffer.alloc = function (size, fill, encoding) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  var buf = Buffer(size);
  if (fill !== undefined) {
    if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
  } else {
    buf.fill(0);
  }
  return buf
};

SafeBuffer.allocUnsafe = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return Buffer(size)
};

SafeBuffer.allocUnsafeSlow = function (size) {
  if (typeof size !== 'number') {
    throw new TypeError('Argument must be a number')
  }
  return buffer.SlowBuffer(size)
};
});

var Buffer$u = safeBuffer.Buffer;

var defer$1 = typeof setImmediate === 'undefined'
  ? process.nextTick
  : setImmediate;

function paramsHaveRequestBody$1 (params) {
  return (
    params.body ||
    params.requestBodyStream ||
    (params.json && typeof params.json !== 'boolean') ||
    params.multipart
  )
}

function safeStringify$1 (obj, replacer) {
  var ret;
  try {
    ret = JSON.stringify(obj, replacer);
  } catch (e) {
    ret = stringify_1$1(obj, replacer);
  }
  return ret
}

function md5$1 (str) {
  return crypto$1.createHash('md5').update(str).digest('hex')
}

function isReadStream$1 (rs) {
  return rs.readable && rs.path && rs.mode
}

function toBase64$2 (str) {
  return Buffer$u.from(str || '', 'utf8').toString('base64')
}

function copy$2 (obj) {
  var o = {};
  Object.keys(obj).forEach(function (i) {
    o[i] = obj[i];
  });
  return o
}

function version$1 () {
  var numbers = process.version.replace('v', '').split('.');
  return {
    major: parseInt(numbers[0], 10),
    minor: parseInt(numbers[1], 10),
    patch: parseInt(numbers[2], 10)
  }
}

var paramsHaveRequestBody_1 = paramsHaveRequestBody$1;
var safeStringify_1 = safeStringify$1;
var md5_1 = md5$1;
var isReadStream_1 = isReadStream$1;
var toBase64_1 = toBase64$2;
var copy_1 = copy$2;
var version_1 = version$1;
var defer_1 = defer$1;

var helpers = {
	paramsHaveRequestBody: paramsHaveRequestBody_1,
	safeStringify: safeStringify_1,
	md5: md5_1,
	isReadStream: isReadStream_1,
	toBase64: toBase64_1,
	copy: copy_1,
	version: version_1,
	defer: defer_1
};

/*!
 *  Copyright 2010 LearnBoost <dev@learnboost.com>
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

/**
 * Module dependencies.
 */

var parse$2 = url.parse
  ;

/**
 * Valid keys.
 */

var keys = 
  [ 'acl'
  , 'location'
  , 'logging'
  , 'notification'
  , 'partNumber'
  , 'policy'
  , 'requestPayment'
  , 'torrent'
  , 'uploadId'
  , 'uploads'
  , 'versionId'
  , 'versioning'
  , 'versions'
  , 'website'
  ];

/**
 * Return an "Authorization" header value with the given `options`
 * in the form of "AWS <key>:<signature>"
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function authorization (options) {
  return 'AWS ' + options.key + ':' + sign$3(options)
}

var awsSign2 = authorization;
var authorization_1 = authorization;

/**
 * Simple HMAC-SHA1 Wrapper
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */ 

function hmacSha1 (options) {
  return crypto$1.createHmac('sha1', options.secret).update(options.message).digest('base64')
}

var hmacSha1_1 = hmacSha1;

/**
 * Create a base64 sha1 HMAC for `options`. 
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function sign$3 (options) {
  options.message = stringToSign(options);
  return hmacSha1(options)
}
var sign_1$1 = sign$3;

/**
 * Create a base64 sha1 HMAC for `options`. 
 *
 * Specifically to be used with S3 presigned URLs
 * 
 * @param {Object} options
 * @return {String}
 * @api private
 */

function signQuery (options) {
  options.message = queryStringToSign(options);
  return hmacSha1(options)
}
var signQuery_1= signQuery;

/**
 * Return a string for sign() with the given `options`.
 *
 * Spec:
 * 
 *    <verb>\n
 *    <md5>\n
 *    <content-type>\n
 *    <date>\n
 *    [headers\n]
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function stringToSign (options) {
  var headers = options.amazonHeaders || '';
  if (headers) headers += '\n';
  var r = 
    [ options.verb
    , options.md5
    , options.contentType
    , options.date ? options.date.toUTCString() : ''
    , headers + options.resource
    ];
  return r.join('\n')
}
var stringToSign_1 = stringToSign;

/**
 * Return a string for sign() with the given `options`, but is meant exclusively
 * for S3 presigned URLs
 *
 * Spec:
 * 
 *    <date>\n
 *    <resource>
 *
 * @param {Object} options
 * @return {String}
 * @api private
 */

function queryStringToSign (options){
  return 'GET\n\n\n' + options.date + '\n' + options.resource
}
var queryStringToSign_1 = queryStringToSign;

/**
 * Perform the following:
 *
 *  - ignore non-amazon headers
 *  - lowercase fields
 *  - sort lexicographically
 *  - trim whitespace between ":"
 *  - join with newline
 *
 * @param {Object} headers
 * @return {String}
 * @api private
 */

function canonicalizeHeaders (headers) {
  var buf = []
    , fields = Object.keys(headers)
    ;
  for (var i = 0, len = fields.length; i < len; ++i) {
    var field = fields[i]
      , val = headers[field]
      , field = field.toLowerCase()
      ;
    if (0 !== field.indexOf('x-amz')) continue
    buf.push(field + ':' + val);
  }
  return buf.sort().join('\n')
}
var canonicalizeHeaders_1 = canonicalizeHeaders;

/**
 * Perform the following:
 *
 *  - ignore non sub-resources
 *  - sort lexicographically
 *
 * @param {String} resource
 * @return {String}
 * @api private
 */

function canonicalizeResource (resource) {
  var url = parse$2(resource, true)
    , path = url.pathname
    , buf = []
    ;

  Object.keys(url.query).forEach(function(key){
    if (!~keys.indexOf(key)) return
    var val = '' == url.query[key] ? '' : '=' + encodeURIComponent(url.query[key]);
    buf.push(key + val);
  });

  return path + (buf.length ? '?' + buf.sort().join('&') : '')
}
var canonicalizeResource_1 = canonicalizeResource;
awsSign2.authorization = authorization_1;
awsSign2.hmacSha1 = hmacSha1_1;
awsSign2.sign = sign_1$1;
awsSign2.signQuery = signQuery_1;
awsSign2.stringToSign = stringToSign_1;
awsSign2.queryStringToSign = queryStringToSign_1;
awsSign2.canonicalizeHeaders = canonicalizeHeaders_1;
awsSign2.canonicalizeResource = canonicalizeResource_1;

var lru = function(size) {
  return new LruCache(size)
};

function LruCache(size) {
  this.capacity = size | 0;
  this.map = Object.create(null);
  this.list = new DoublyLinkedList();
}

LruCache.prototype.get = function(key) {
  var node = this.map[key];
  if (node == null) return undefined
  this.used(node);
  return node.val
};

LruCache.prototype.set = function(key, val) {
  var node = this.map[key];
  if (node != null) {
    node.val = val;
  } else {
    if (!this.capacity) this.prune();
    if (!this.capacity) return false
    node = new DoublyLinkedNode(key, val);
    this.map[key] = node;
    this.capacity--;
  }
  this.used(node);
  return true
};

LruCache.prototype.used = function(node) {
  this.list.moveToFront(node);
};

LruCache.prototype.prune = function() {
  var node = this.list.pop();
  if (node != null) {
    delete this.map[node.key];
    this.capacity++;
  }
};


function DoublyLinkedList() {
  this.firstNode = null;
  this.lastNode = null;
}

DoublyLinkedList.prototype.moveToFront = function(node) {
  if (this.firstNode == node) return

  this.remove(node);

  if (this.firstNode == null) {
    this.firstNode = node;
    this.lastNode = node;
    node.prev = null;
    node.next = null;
  } else {
    node.prev = null;
    node.next = this.firstNode;
    node.next.prev = node;
    this.firstNode = node;
  }
};

DoublyLinkedList.prototype.pop = function() {
  var lastNode = this.lastNode;
  if (lastNode != null) {
    this.remove(lastNode);
  }
  return lastNode
};

DoublyLinkedList.prototype.remove = function(node) {
  if (this.firstNode == node) {
    this.firstNode = node.next;
  } else if (node.prev != null) {
    node.prev.next = node.next;
  }
  if (this.lastNode == node) {
    this.lastNode = node.prev;
  } else if (node.next != null) {
    node.next.prev = node.prev;
  }
};


function DoublyLinkedNode(key, val) {
  this.key = key;
  this.val = val;
  this.prev = null;
  this.next = null;
}

var aws4_1 = createCommonjsModule(function (module, exports) {
var aws4 = exports,
    credentialsCache = lru(1000);

// http://docs.amazonwebservices.com/general/latest/gr/signature-version-4.html

function hmac(key, string, encoding) {
  return crypto$1.createHmac('sha256', key).update(string, 'utf8').digest(encoding)
}

function hash(string, encoding) {
  return crypto$1.createHash('sha256').update(string, 'utf8').digest(encoding)
}

// This function assumes the string has already been percent encoded
function encodeRfc3986(urlEncodedString) {
  return urlEncodedString.replace(/[!'()*]/g, function(c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
}

function encodeRfc3986Full(str) {
  return encodeRfc3986(encodeURIComponent(str))
}

// A bit of a combination of:
// https://github.com/aws/aws-sdk-java-v2/blob/dc695de6ab49ad03934e1b02e7263abbd2354be0/core/auth/src/main/java/software/amazon/awssdk/auth/signer/internal/AbstractAws4Signer.java#L59
// https://github.com/aws/aws-sdk-js/blob/18cb7e5b463b46239f9fdd4a65e2ff8c81831e8f/lib/signers/v4.js#L191-L199
// https://github.com/mhart/aws4fetch/blob/b3aed16b6f17384cf36ea33bcba3c1e9f3bdfefd/src/main.js#L25-L34
var HEADERS_TO_IGNORE = {
  'authorization': true,
  'connection': true,
  'x-amzn-trace-id': true,
  'user-agent': true,
  'expect': true,
  'presigned-expires': true,
  'range': true,
};

// request: { path | body, [host], [method], [headers], [service], [region] }
// credentials: { accessKeyId, secretAccessKey, [sessionToken] }
function RequestSigner(request, credentials) {

  if (typeof request === 'string') request = url.parse(request);

  var headers = request.headers = (request.headers || {}),
      hostParts = (!this.service || !this.region) && this.matchHost(request.hostname || request.host || headers.Host || headers.host);

  this.request = request;
  this.credentials = credentials || this.defaultCredentials();

  this.service = request.service || hostParts[0] || '';
  this.region = request.region || hostParts[1] || 'us-east-1';

  // SES uses a different domain from the service name
  if (this.service === 'email') this.service = 'ses';

  if (!request.method && request.body)
    request.method = 'POST';

  if (!headers.Host && !headers.host) {
    headers.Host = request.hostname || request.host || this.createHost();

    // If a port is specified explicitly, use it as is
    if (request.port)
      headers.Host += ':' + request.port;
  }
  if (!request.hostname && !request.host)
    request.hostname = headers.Host || headers.host;

  this.isCodeCommitGit = this.service === 'codecommit' && request.method === 'GIT';
}

RequestSigner.prototype.matchHost = function(host) {
  var match = (host || '').match(/([^\.]+)\.(?:([^\.]*)\.)?amazonaws\.com(\.cn)?$/);
  var hostParts = (match || []).slice(1, 3);

  // ES's hostParts are sometimes the other way round, if the value that is expected
  // to be region equals ‘es’ switch them back
  // e.g. search-cluster-name-aaaa00aaaa0aaa0aaaaaaa0aaa.us-east-1.es.amazonaws.com
  if (hostParts[1] === 'es')
    hostParts = hostParts.reverse();

  if (hostParts[1] == 's3') {
    hostParts[0] = 's3';
    hostParts[1] = 'us-east-1';
  } else {
    for (var i = 0; i < 2; i++) {
      if (/^s3-/.test(hostParts[i])) {
        hostParts[1] = hostParts[i].slice(3);
        hostParts[0] = 's3';
        break
      }
    }
  }

  return hostParts
};

// http://docs.aws.amazon.com/general/latest/gr/rande.html
RequestSigner.prototype.isSingleRegion = function() {
  // Special case for S3 and SimpleDB in us-east-1
  if (['s3', 'sdb'].indexOf(this.service) >= 0 && this.region === 'us-east-1') return true

  return ['cloudfront', 'ls', 'route53', 'iam', 'importexport', 'sts']
    .indexOf(this.service) >= 0
};

RequestSigner.prototype.createHost = function() {
  var region = this.isSingleRegion() ? '' : '.' + this.region,
      subdomain = this.service === 'ses' ? 'email' : this.service;
  return subdomain + region + '.amazonaws.com'
};

RequestSigner.prototype.prepareRequest = function() {
  this.parsePath();

  var request = this.request, headers = request.headers, query;

  if (request.signQuery) {

    this.parsedPath.query = query = this.parsedPath.query || {};

    if (this.credentials.sessionToken)
      query['X-Amz-Security-Token'] = this.credentials.sessionToken;

    if (this.service === 's3' && !query['X-Amz-Expires'])
      query['X-Amz-Expires'] = 86400;

    if (query['X-Amz-Date'])
      this.datetime = query['X-Amz-Date'];
    else
      query['X-Amz-Date'] = this.getDateTime();

    query['X-Amz-Algorithm'] = 'AWS4-HMAC-SHA256';
    query['X-Amz-Credential'] = this.credentials.accessKeyId + '/' + this.credentialString();
    query['X-Amz-SignedHeaders'] = this.signedHeaders();

  } else {

    if (!request.doNotModifyHeaders && !this.isCodeCommitGit) {
      if (request.body && !headers['Content-Type'] && !headers['content-type'])
        headers['Content-Type'] = 'application/x-www-form-urlencoded; charset=utf-8';

      if (request.body && !headers['Content-Length'] && !headers['content-length'])
        headers['Content-Length'] = Buffer.byteLength(request.body);

      if (this.credentials.sessionToken && !headers['X-Amz-Security-Token'] && !headers['x-amz-security-token'])
        headers['X-Amz-Security-Token'] = this.credentials.sessionToken;

      if (this.service === 's3' && !headers['X-Amz-Content-Sha256'] && !headers['x-amz-content-sha256'])
        headers['X-Amz-Content-Sha256'] = hash(this.request.body || '', 'hex');

      if (headers['X-Amz-Date'] || headers['x-amz-date'])
        this.datetime = headers['X-Amz-Date'] || headers['x-amz-date'];
      else
        headers['X-Amz-Date'] = this.getDateTime();
    }

    delete headers.Authorization;
    delete headers.authorization;
  }
};

RequestSigner.prototype.sign = function() {
  if (!this.parsedPath) this.prepareRequest();

  if (this.request.signQuery) {
    this.parsedPath.query['X-Amz-Signature'] = this.signature();
  } else {
    this.request.headers.Authorization = this.authHeader();
  }

  this.request.path = this.formatPath();

  return this.request
};

RequestSigner.prototype.getDateTime = function() {
  if (!this.datetime) {
    var headers = this.request.headers,
      date = new Date(headers.Date || headers.date || new Date);

    this.datetime = date.toISOString().replace(/[:\-]|\.\d{3}/g, '');

    // Remove the trailing 'Z' on the timestamp string for CodeCommit git access
    if (this.isCodeCommitGit) this.datetime = this.datetime.slice(0, -1);
  }
  return this.datetime
};

RequestSigner.prototype.getDate = function() {
  return this.getDateTime().substr(0, 8)
};

RequestSigner.prototype.authHeader = function() {
  return [
    'AWS4-HMAC-SHA256 Credential=' + this.credentials.accessKeyId + '/' + this.credentialString(),
    'SignedHeaders=' + this.signedHeaders(),
    'Signature=' + this.signature(),
  ].join(', ')
};

RequestSigner.prototype.signature = function() {
  var date = this.getDate(),
      cacheKey = [this.credentials.secretAccessKey, date, this.region, this.service].join(),
      kDate, kRegion, kService, kCredentials = credentialsCache.get(cacheKey);
  if (!kCredentials) {
    kDate = hmac('AWS4' + this.credentials.secretAccessKey, date);
    kRegion = hmac(kDate, this.region);
    kService = hmac(kRegion, this.service);
    kCredentials = hmac(kService, 'aws4_request');
    credentialsCache.set(cacheKey, kCredentials);
  }
  return hmac(kCredentials, this.stringToSign(), 'hex')
};

RequestSigner.prototype.stringToSign = function() {
  return [
    'AWS4-HMAC-SHA256',
    this.getDateTime(),
    this.credentialString(),
    hash(this.canonicalString(), 'hex'),
  ].join('\n')
};

RequestSigner.prototype.canonicalString = function() {
  if (!this.parsedPath) this.prepareRequest();

  var pathStr = this.parsedPath.path,
      query = this.parsedPath.query,
      headers = this.request.headers,
      queryStr = '',
      normalizePath = this.service !== 's3',
      decodePath = this.service === 's3' || this.request.doNotEncodePath,
      decodeSlashesInPath = this.service === 's3',
      firstValOnly = this.service === 's3',
      bodyHash;

  if (this.service === 's3' && this.request.signQuery) {
    bodyHash = 'UNSIGNED-PAYLOAD';
  } else if (this.isCodeCommitGit) {
    bodyHash = '';
  } else {
    bodyHash = headers['X-Amz-Content-Sha256'] || headers['x-amz-content-sha256'] ||
      hash(this.request.body || '', 'hex');
  }

  if (query) {
    var reducedQuery = Object.keys(query).reduce(function(obj, key) {
      if (!key) return obj
      obj[encodeRfc3986Full(key)] = !Array.isArray(query[key]) ? query[key] :
        (firstValOnly ? query[key][0] : query[key]);
      return obj
    }, {});
    var encodedQueryPieces = [];
    Object.keys(reducedQuery).sort().forEach(function(key) {
      if (!Array.isArray(reducedQuery[key])) {
        encodedQueryPieces.push(key + '=' + encodeRfc3986Full(reducedQuery[key]));
      } else {
        reducedQuery[key].map(encodeRfc3986Full).sort()
          .forEach(function(val) { encodedQueryPieces.push(key + '=' + val); });
      }
    });
    queryStr = encodedQueryPieces.join('&');
  }
  if (pathStr !== '/') {
    if (normalizePath) pathStr = pathStr.replace(/\/{2,}/g, '/');
    pathStr = pathStr.split('/').reduce(function(path, piece) {
      if (normalizePath && piece === '..') {
        path.pop();
      } else if (!normalizePath || piece !== '.') {
        if (decodePath) piece = decodeURIComponent(piece.replace(/\+/g, ' '));
        path.push(encodeRfc3986Full(piece));
      }
      return path
    }, []).join('/');
    if (pathStr[0] !== '/') pathStr = '/' + pathStr;
    if (decodeSlashesInPath) pathStr = pathStr.replace(/%2F/g, '/');
  }

  return [
    this.request.method || 'GET',
    pathStr,
    queryStr,
    this.canonicalHeaders() + '\n',
    this.signedHeaders(),
    bodyHash,
  ].join('\n')
};

RequestSigner.prototype.canonicalHeaders = function() {
  var headers = this.request.headers;
  function trimAll(header) {
    return header.toString().trim().replace(/\s+/g, ' ')
  }
  return Object.keys(headers)
    .filter(function(key) { return HEADERS_TO_IGNORE[key.toLowerCase()] == null })
    .sort(function(a, b) { return a.toLowerCase() < b.toLowerCase() ? -1 : 1 })
    .map(function(key) { return key.toLowerCase() + ':' + trimAll(headers[key]) })
    .join('\n')
};

RequestSigner.prototype.signedHeaders = function() {
  return Object.keys(this.request.headers)
    .map(function(key) { return key.toLowerCase() })
    .filter(function(key) { return HEADERS_TO_IGNORE[key] == null })
    .sort()
    .join(';')
};

RequestSigner.prototype.credentialString = function() {
  return [
    this.getDate(),
    this.region,
    this.service,
    'aws4_request',
  ].join('/')
};

RequestSigner.prototype.defaultCredentials = function() {
  var env = process.env;
  return {
    accessKeyId: env.AWS_ACCESS_KEY_ID || env.AWS_ACCESS_KEY,
    secretAccessKey: env.AWS_SECRET_ACCESS_KEY || env.AWS_SECRET_KEY,
    sessionToken: env.AWS_SESSION_TOKEN,
  }
};

RequestSigner.prototype.parsePath = function() {
  var path = this.request.path || '/';

  // S3 doesn't always encode characters > 127 correctly and
  // all services don't encode characters > 255 correctly
  // So if there are non-reserved chars (and it's not already all % encoded), just encode them all
  if (/[^0-9A-Za-z;,/?:@&=+$\-_.!~*'()#%]/.test(path)) {
    path = encodeURI(decodeURI(path));
  }

  var queryIx = path.indexOf('?'),
      query = null;

  if (queryIx >= 0) {
    query = querystring.parse(path.slice(queryIx + 1));
    path = path.slice(0, queryIx);
  }

  this.parsedPath = {
    path: path,
    query: query,
  };
};

RequestSigner.prototype.formatPath = function() {
  var path = this.parsedPath.path,
      query = this.parsedPath.query;

  if (!query) return path

  // Services don't support empty query string keys
  if (query[''] != null) delete query[''];

  return path + '?' + encodeRfc3986(querystring.stringify(query))
};

aws4.RequestSigner = RequestSigner;

aws4.sign = function(request, credentials) {
  return new RequestSigner(request, credentials).sign()
};
});

// Copyright (c) 2012, Mark Cavage. All rights reserved.
// Copyright 2015 Joyent, Inc.


var Stream$2 = stream.Stream;



///--- Globals

/* JSSTYLED */
var UUID_REGEXP = /^[a-fA-F0-9]{8}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{4}-[a-fA-F0-9]{12}$/;


///--- Internal

function _capitalize(str) {
    return (str.charAt(0).toUpperCase() + str.slice(1));
}

function _toss(name, expected, oper, arg, actual) {
    throw new assert.AssertionError({
        message: util$2.format('%s (%s) is required', name, expected),
        actual: (actual === undefined) ? typeof (arg) : actual(arg),
        expected: expected,
        operator: oper || '===',
        stackStartFunction: _toss.caller
    });
}

function _getClass(arg) {
    return (Object.prototype.toString.call(arg).slice(8, -1));
}

function noop$1() {
    // Why even bother with asserts?
}


///--- Exports

var types$1 = {
    bool: {
        check: function (arg) { return typeof (arg) === 'boolean'; }
    },
    func: {
        check: function (arg) { return typeof (arg) === 'function'; }
    },
    string: {
        check: function (arg) { return typeof (arg) === 'string'; }
    },
    object: {
        check: function (arg) {
            return typeof (arg) === 'object' && arg !== null;
        }
    },
    number: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg);
        }
    },
    finite: {
        check: function (arg) {
            return typeof (arg) === 'number' && !isNaN(arg) && isFinite(arg);
        }
    },
    buffer: {
        check: function (arg) { return Buffer.isBuffer(arg); },
        operator: 'Buffer.isBuffer'
    },
    array: {
        check: function (arg) { return Array.isArray(arg); },
        operator: 'Array.isArray'
    },
    stream: {
        check: function (arg) { return arg instanceof Stream$2; },
        operator: 'instanceof',
        actual: _getClass
    },
    date: {
        check: function (arg) { return arg instanceof Date; },
        operator: 'instanceof',
        actual: _getClass
    },
    regexp: {
        check: function (arg) { return arg instanceof RegExp; },
        operator: 'instanceof',
        actual: _getClass
    },
    uuid: {
        check: function (arg) {
            return typeof (arg) === 'string' && UUID_REGEXP.test(arg);
        },
        operator: 'isUUID'
    }
};

function _setExports(ndebug) {
    var keys = Object.keys(types$1);
    var out;

    /* re-export standard assert */
    if (process.env.NODE_NDEBUG) {
        out = noop$1;
    } else {
        out = function (arg, msg) {
            if (!arg) {
                _toss(msg, 'true', arg);
            }
        };
    }

    /* standard checks */
    keys.forEach(function (k) {
        if (ndebug) {
            out[k] = noop$1;
            return;
        }
        var type = types$1[k];
        out[k] = function (arg, msg) {
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* optional checks */
    keys.forEach(function (k) {
        var name = 'optional' + _capitalize(k);
        if (ndebug) {
            out[name] = noop$1;
            return;
        }
        var type = types$1[k];
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!type.check(arg)) {
                _toss(msg, k, type.operator, arg, type.actual);
            }
        };
    });

    /* arrayOf checks */
    keys.forEach(function (k) {
        var name = 'arrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop$1;
            return;
        }
        var type = types$1[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* optionalArrayOf checks */
    keys.forEach(function (k) {
        var name = 'optionalArrayOf' + _capitalize(k);
        if (ndebug) {
            out[name] = noop$1;
            return;
        }
        var type = types$1[k];
        var expected = '[' + k + ']';
        out[name] = function (arg, msg) {
            if (arg === undefined || arg === null) {
                return;
            }
            if (!Array.isArray(arg)) {
                _toss(msg, expected, type.operator, arg, type.actual);
            }
            var i;
            for (i = 0; i < arg.length; i++) {
                if (!type.check(arg[i])) {
                    _toss(msg, expected, type.operator, arg, type.actual);
                }
            }
        };
    });

    /* re-export built-in assertions */
    Object.keys(assert).forEach(function (k) {
        if (k === 'AssertionError') {
            out[k] = assert[k];
            return;
        }
        if (ndebug) {
            out[k] = noop$1;
            return;
        }
        out[k] = assert[k];
    });

    /* export ourselves (for unit tests _only_) */
    out._setExports = _setExports;

    return out;
}

var assert_1 = _setExports(process.env.NODE_NDEBUG);

/* eslint-disable node/no-deprecated-api */


var Buffer$t = buffer.Buffer;

var safer = {};

var key$1;

for (key$1 in buffer) {
  if (!buffer.hasOwnProperty(key$1)) continue
  if (key$1 === 'SlowBuffer' || key$1 === 'Buffer') continue
  safer[key$1] = buffer[key$1];
}

var Safer = safer.Buffer = {};
for (key$1 in Buffer$t) {
  if (!Buffer$t.hasOwnProperty(key$1)) continue
  if (key$1 === 'allocUnsafe' || key$1 === 'allocUnsafeSlow') continue
  Safer[key$1] = Buffer$t[key$1];
}

safer.Buffer.prototype = Buffer$t.prototype;

if (!Safer.from || Safer.from === Uint8Array.from) {
  Safer.from = function (value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value)
    }
    if (value && typeof value.length === 'undefined') {
      throw new TypeError('The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type ' + typeof value)
    }
    return Buffer$t(value, encodingOrOffset, length)
  };
}

if (!Safer.alloc) {
  Safer.alloc = function (size, fill, encoding) {
    if (typeof size !== 'number') {
      throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size)
    }
    if (size < 0 || size >= 2 * (1 << 30)) {
      throw new RangeError('The value "' + size + '" is invalid for option "size"')
    }
    var buf = Buffer$t(size);
    if (!fill || fill.length === 0) {
      buf.fill(0);
    } else if (typeof encoding === 'string') {
      buf.fill(fill, encoding);
    } else {
      buf.fill(fill);
    }
    return buf
  };
}

if (!safer.kStringMaxLength) {
  try {
    safer.kStringMaxLength = process.binding('buffer').kStringMaxLength;
  } catch (e) {
    // we can't determine kStringMaxLength in environments where process.binding
    // is unsupported, so let's not set it
  }
}

if (!safer.constants) {
  safer.constants = {
    MAX_LENGTH: safer.kMaxLength
  };
  if (safer.kStringMaxLength) {
    safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
  }
}

var safer_1 = safer;

// Copyright 2015 Joyent, Inc.

var Buffer$s = safer_1.Buffer;

var algInfo = {
	'dsa': {
		parts: ['p', 'q', 'g', 'y'],
		sizePart: 'p'
	},
	'rsa': {
		parts: ['e', 'n'],
		sizePart: 'n'
	},
	'ecdsa': {
		parts: ['curve', 'Q'],
		sizePart: 'Q'
	},
	'ed25519': {
		parts: ['A'],
		sizePart: 'A'
	}
};
algInfo['curve25519'] = algInfo['ed25519'];

var algPrivInfo = {
	'dsa': {
		parts: ['p', 'q', 'g', 'y', 'x']
	},
	'rsa': {
		parts: ['n', 'e', 'd', 'iqmp', 'p', 'q']
	},
	'ecdsa': {
		parts: ['curve', 'Q', 'd']
	},
	'ed25519': {
		parts: ['A', 'k']
	}
};
algPrivInfo['curve25519'] = algPrivInfo['ed25519'];

var hashAlgs = {
	'md5': true,
	'sha1': true,
	'sha256': true,
	'sha384': true,
	'sha512': true
};

/*
 * Taken from
 * http://csrc.nist.gov/groups/ST/toolkit/documents/dss/NISTReCur.pdf
 */
var curves = {
	'nistp256': {
		size: 256,
		pkcs8oid: '1.2.840.10045.3.1.7',
		p: Buffer$s.from(('00' +
		    'ffffffff 00000001 00000000 00000000' +
		    '00000000 ffffffff ffffffff ffffffff').
		    replace(/ /g, ''), 'hex'),
		a: Buffer$s.from(('00' +
		    'FFFFFFFF 00000001 00000000 00000000' +
		    '00000000 FFFFFFFF FFFFFFFF FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer$s.from((
		    '5ac635d8 aa3a93e7 b3ebbd55 769886bc' +
		    '651d06b0 cc53b0f6 3bce3c3e 27d2604b').
		    replace(/ /g, ''), 'hex'),
		s: Buffer$s.from(('00' +
		    'c49d3608 86e70493 6a6678e1 139d26b7' +
		    '819f7e90').
		    replace(/ /g, ''), 'hex'),
		n: Buffer$s.from(('00' +
		    'ffffffff 00000000 ffffffff ffffffff' +
		    'bce6faad a7179e84 f3b9cac2 fc632551').
		    replace(/ /g, ''), 'hex'),
		G: Buffer$s.from(('04' +
		    '6b17d1f2 e12c4247 f8bce6e5 63a440f2' +
		    '77037d81 2deb33a0 f4a13945 d898c296' +
		    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16' +
		    '2bce3357 6b315ece cbb64068 37bf51f5').
		    replace(/ /g, ''), 'hex')
	},
	'nistp384': {
		size: 384,
		pkcs8oid: '1.3.132.0.34',
		p: Buffer$s.from(('00' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff fffffffe' +
		    'ffffffff 00000000 00000000 ffffffff').
		    replace(/ /g, ''), 'hex'),
		a: Buffer$s.from(('00' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE' +
		    'FFFFFFFF 00000000 00000000 FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer$s.from((
		    'b3312fa7 e23ee7e4 988e056b e3f82d19' +
		    '181d9c6e fe814112 0314088f 5013875a' +
		    'c656398d 8a2ed19d 2a85c8ed d3ec2aef').
		    replace(/ /g, ''), 'hex'),
		s: Buffer$s.from(('00' +
		    'a335926a a319a27a 1d00896a 6773a482' +
		    '7acdac73').
		    replace(/ /g, ''), 'hex'),
		n: Buffer$s.from(('00' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff c7634d81 f4372ddf' +
		    '581a0db2 48b0a77a ecec196a ccc52973').
		    replace(/ /g, ''), 'hex'),
		G: Buffer$s.from(('04' +
		    'aa87ca22 be8b0537 8eb1c71e f320ad74' +
		    '6e1d3b62 8ba79b98 59f741e0 82542a38' +
		    '5502f25d bf55296c 3a545e38 72760ab7' +
		    '3617de4a 96262c6f 5d9e98bf 9292dc29' +
		    'f8f41dbd 289a147c e9da3113 b5f0b8c0' +
		    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f').
		    replace(/ /g, ''), 'hex')
	},
	'nistp521': {
		size: 521,
		pkcs8oid: '1.3.132.0.35',
		p: Buffer$s.from((
		    '01ffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffff').replace(/ /g, ''), 'hex'),
		a: Buffer$s.from(('01FF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFF' +
		    'FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFC').
		    replace(/ /g, ''), 'hex'),
		b: Buffer$s.from(('51' +
		    '953eb961 8e1c9a1f 929a21a0 b68540ee' +
		    'a2da725b 99b315f3 b8b48991 8ef109e1' +
		    '56193951 ec7e937b 1652c0bd 3bb1bf07' +
		    '3573df88 3d2c34f1 ef451fd4 6b503f00').
		    replace(/ /g, ''), 'hex'),
		s: Buffer$s.from(('00' +
		    'd09e8800 291cb853 96cc6717 393284aa' +
		    'a0da64ba').replace(/ /g, ''), 'hex'),
		n: Buffer$s.from(('01ff' +
		    'ffffffff ffffffff ffffffff ffffffff' +
		    'ffffffff ffffffff ffffffff fffffffa' +
		    '51868783 bf2f966b 7fcc0148 f709a5d0' +
		    '3bb5c9b8 899c47ae bb6fb71e 91386409').
		    replace(/ /g, ''), 'hex'),
		G: Buffer$s.from(('04' +
		    '00c6 858e06b7 0404e9cd 9e3ecb66 2395b442' +
		         '9c648139 053fb521 f828af60 6b4d3dba' +
		         'a14b5e77 efe75928 fe1dc127 a2ffa8de' +
		         '3348b3c1 856a429b f97e7e31 c2e5bd66' +
		    '0118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9' +
		         '98f54449 579b4468 17afbd17 273e662c' +
		         '97ee7299 5ef42640 c550b901 3fad0761' +
		         '353c7086 a272c240 88be9476 9fd16650').
		    replace(/ /g, ''), 'hex')
	}
};

var algs = {
	info: algInfo,
	privInfo: algPrivInfo,
	hashAlgs: hashAlgs,
	curves: curves
};

// Copyright 2015 Joyent, Inc.




function FingerprintFormatError$1(fp, format) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, FingerprintFormatError$1);
	this.name = 'FingerprintFormatError';
	this.fingerprint = fp;
	this.format = format;
	this.message = 'Fingerprint format is not supported, or is invalid: ';
	if (fp !== undefined)
		this.message += ' fingerprint = ' + fp;
	if (format !== undefined)
		this.message += ' format = ' + format;
}
util$2.inherits(FingerprintFormatError$1, Error);

function InvalidAlgorithmError$7(alg) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, InvalidAlgorithmError$7);
	this.name = 'InvalidAlgorithmError';
	this.algorithm = alg;
	this.message = 'Algorithm "' + alg + '" is not supported';
}
util$2.inherits(InvalidAlgorithmError$7, Error);

function KeyParseError$2(name, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, KeyParseError$2);
	this.name = 'KeyParseError';
	this.format = format;
	this.keyName = name;
	this.innerErr = innerErr;
	this.message = 'Failed to parse ' + name + ' as a valid ' + format +
	    ' format key: ' + innerErr.message;
}
util$2.inherits(KeyParseError$2, Error);

function SignatureParseError$1(type, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, SignatureParseError$1);
	this.name = 'SignatureParseError';
	this.type = type;
	this.format = format;
	this.innerErr = innerErr;
	this.message = 'Failed to parse the given data as a ' + type +
	    ' signature in ' + format + ' format: ' + innerErr.message;
}
util$2.inherits(SignatureParseError$1, Error);

function CertificateParseError$1(name, format, innerErr) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, CertificateParseError$1);
	this.name = 'CertificateParseError';
	this.format = format;
	this.certName = name;
	this.innerErr = innerErr;
	this.message = 'Failed to parse ' + name + ' as a valid ' + format +
	    ' format certificate: ' + innerErr.message;
}
util$2.inherits(CertificateParseError$1, Error);

function KeyEncryptedError(name, format) {
	if (Error.captureStackTrace)
		Error.captureStackTrace(this, KeyEncryptedError);
	this.name = 'KeyEncryptedError';
	this.format = format;
	this.keyName = name;
	this.message = 'The ' + format + ' format key ' + name + ' is ' +
	    'encrypted (password-protected), and no passphrase was ' +
	    'provided in `options`';
}
util$2.inherits(KeyEncryptedError, Error);

var errors$1 = {
	FingerprintFormatError: FingerprintFormatError$1,
	InvalidAlgorithmError: InvalidAlgorithmError$7,
	KeyParseError: KeyParseError$2,
	SignatureParseError: SignatureParseError$1,
	KeyEncryptedError: KeyEncryptedError,
	CertificateParseError: CertificateParseError$1
};

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


var errors = {

  newInvalidAsn1Error: function (msg) {
    var e = new Error();
    e.name = 'InvalidAsn1Error';
    e.message = msg || '';
    return e;
  }

};

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


var types = {
  EOC: 0,
  Boolean: 1,
  Integer: 2,
  BitString: 3,
  OctetString: 4,
  Null: 5,
  OID: 6,
  ObjectDescriptor: 7,
  External: 8,
  Real: 9, // float
  Enumeration: 10,
  PDV: 11,
  Utf8String: 12,
  RelativeOID: 13,
  Sequence: 16,
  Set: 17,
  NumericString: 18,
  PrintableString: 19,
  T61String: 20,
  VideotexString: 21,
  IA5String: 22,
  UTCTime: 23,
  GeneralizedTime: 24,
  GraphicString: 25,
  VisibleString: 26,
  GeneralString: 28,
  UniversalString: 29,
  CharacterString: 30,
  BMPString: 31,
  Constructor: 32,
  Context: 128
};

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


var Buffer$r = safer_1.Buffer;





// --- Globals

var newInvalidAsn1Error$1 = errors.newInvalidAsn1Error;



// --- API

function Reader(data) {
  if (!data || !Buffer$r.isBuffer(data))
    throw new TypeError('data must be a node Buffer');

  this._buf = data;
  this._size = data.length;

  // These hold the "current" state
  this._len = 0;
  this._offset = 0;
}

Object.defineProperty(Reader.prototype, 'length', {
  enumerable: true,
  get: function () { return (this._len); }
});

Object.defineProperty(Reader.prototype, 'offset', {
  enumerable: true,
  get: function () { return (this._offset); }
});

Object.defineProperty(Reader.prototype, 'remain', {
  get: function () { return (this._size - this._offset); }
});

Object.defineProperty(Reader.prototype, 'buffer', {
  get: function () { return (this._buf.slice(this._offset)); }
});


/**
 * Reads a single byte and advances offset; you can pass in `true` to make this
 * a "peek" operation (i.e., get the byte, but don't advance the offset).
 *
 * @param {Boolean} peek true means don't move offset.
 * @return {Number} the next byte, null if not enough data.
 */
Reader.prototype.readByte = function (peek) {
  if (this._size - this._offset < 1)
    return null;

  var b = this._buf[this._offset] & 0xff;

  if (!peek)
    this._offset += 1;

  return b;
};


Reader.prototype.peek = function () {
  return this.readByte(true);
};


/**
 * Reads a (potentially) variable length off the BER buffer.  This call is
 * not really meant to be called directly, as callers have to manipulate
 * the internal buffer afterwards.
 *
 * As a result of this call, you can call `Reader.length`, until the
 * next thing called that does a readLength.
 *
 * @return {Number} the amount of offset to advance the buffer.
 * @throws {InvalidAsn1Error} on bad ASN.1
 */
Reader.prototype.readLength = function (offset) {
  if (offset === undefined)
    offset = this._offset;

  if (offset >= this._size)
    return null;

  var lenB = this._buf[offset++] & 0xff;
  if (lenB === null)
    return null;

  if ((lenB & 0x80) === 0x80) {
    lenB &= 0x7f;

    if (lenB === 0)
      throw newInvalidAsn1Error$1('Indefinite length not supported');

    if (lenB > 4)
      throw newInvalidAsn1Error$1('encoding too long');

    if (this._size - offset < lenB)
      return null;

    this._len = 0;
    for (var i = 0; i < lenB; i++)
      this._len = (this._len << 8) + (this._buf[offset++] & 0xff);

  } else {
    // Wasn't a variable length
    this._len = lenB;
  }

  return offset;
};


/**
 * Parses the next sequence in this BER buffer.
 *
 * To get the length of the sequence, call `Reader.length`.
 *
 * @return {Number} the sequence's tag.
 */
Reader.prototype.readSequence = function (tag) {
  var seq = this.peek();
  if (seq === null)
    return null;
  if (tag !== undefined && tag !== seq)
    throw newInvalidAsn1Error$1('Expected 0x' + tag.toString(16) +
                              ': got 0x' + seq.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  this._offset = o;
  return seq;
};


Reader.prototype.readInt = function () {
  return this._readTag(types.Integer);
};


Reader.prototype.readBoolean = function () {
  return (this._readTag(types.Boolean) === 0 ? false : true);
};


Reader.prototype.readEnumeration = function () {
  return this._readTag(types.Enumeration);
};


Reader.prototype.readString = function (tag, retbuf) {
  if (!tag)
    tag = types.OctetString;

  var b = this.peek();
  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error$1('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`

  if (o === null)
    return null;

  if (this.length > this._size - o)
    return null;

  this._offset = o;

  if (this.length === 0)
    return retbuf ? Buffer$r.alloc(0) : '';

  var str = this._buf.slice(this._offset, this._offset + this.length);
  this._offset += this.length;

  return retbuf ? str : str.toString('utf8');
};

Reader.prototype.readOID = function (tag) {
  if (!tag)
    tag = types.OID;

  var b = this.readString(tag, true);
  if (b === null)
    return null;

  var values = [];
  var value = 0;

  for (var i = 0; i < b.length; i++) {
    var byte = b[i] & 0xff;

    value <<= 7;
    value += byte & 0x7f;
    if ((byte & 0x80) === 0) {
      values.push(value);
      value = 0;
    }
  }

  value = values.shift();
  values.unshift(value % 40);
  values.unshift((value / 40) >> 0);

  return values.join('.');
};


Reader.prototype._readTag = function (tag) {
  assert.ok(tag !== undefined);

  var b = this.peek();

  if (b === null)
    return null;

  if (b !== tag)
    throw newInvalidAsn1Error$1('Expected 0x' + tag.toString(16) +
                              ': got 0x' + b.toString(16));

  var o = this.readLength(this._offset + 1); // stored in `length`
  if (o === null)
    return null;

  if (this.length > 4)
    throw newInvalidAsn1Error$1('Integer too long: ' + this.length);

  if (this.length > this._size - o)
    return null;
  this._offset = o;

  var fb = this._buf[this._offset];
  var value = 0;

  for (var i = 0; i < this.length; i++) {
    value <<= 8;
    value |= (this._buf[this._offset++] & 0xff);
  }

  if ((fb & 0x80) === 0x80 && i !== 4)
    value -= (1 << (i * 8));

  return value >> 0;
};



// --- Exported API

var reader = Reader;

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.


var Buffer$q = safer_1.Buffer;




// --- Globals

var newInvalidAsn1Error = errors.newInvalidAsn1Error;

var DEFAULT_OPTS = {
  size: 1024,
  growthFactor: 8
};


// --- Helpers

function merge$1(from, to) {
  assert.ok(from);
  assert.equal(typeof (from), 'object');
  assert.ok(to);
  assert.equal(typeof (to), 'object');

  var keys = Object.getOwnPropertyNames(from);
  keys.forEach(function (key) {
    if (to[key])
      return;

    var value = Object.getOwnPropertyDescriptor(from, key);
    Object.defineProperty(to, key, value);
  });

  return to;
}



// --- API

function Writer(options) {
  options = merge$1(DEFAULT_OPTS, options || {});

  this._buf = Buffer$q.alloc(options.size || 1024);
  this._size = this._buf.length;
  this._offset = 0;
  this._options = options;

  // A list of offsets in the buffer where we need to insert
  // sequence tag/len pairs.
  this._seq = [];
}

Object.defineProperty(Writer.prototype, 'buffer', {
  get: function () {
    if (this._seq.length)
      throw newInvalidAsn1Error(this._seq.length + ' unended sequence(s)');

    return (this._buf.slice(0, this._offset));
  }
});

Writer.prototype.writeByte = function (b) {
  if (typeof (b) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(1);
  this._buf[this._offset++] = b;
};


Writer.prototype.writeInt = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = types.Integer;

  var sz = 4;

  while ((((i & 0xff800000) === 0) || ((i & 0xff800000) === 0xff800000 >> 0)) &&
        (sz > 1)) {
    sz--;
    i <<= 8;
  }

  if (sz > 4)
    throw newInvalidAsn1Error('BER ints cannot be > 0xffffffff');

  this._ensure(2 + sz);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = sz;

  while (sz-- > 0) {
    this._buf[this._offset++] = ((i & 0xff000000) >>> 24);
    i <<= 8;
  }

};


Writer.prototype.writeNull = function () {
  this.writeByte(types.Null);
  this.writeByte(0x00);
};


Writer.prototype.writeEnumeration = function (i, tag) {
  if (typeof (i) !== 'number')
    throw new TypeError('argument must be a Number');
  if (typeof (tag) !== 'number')
    tag = types.Enumeration;

  return this.writeInt(i, tag);
};


Writer.prototype.writeBoolean = function (b, tag) {
  if (typeof (b) !== 'boolean')
    throw new TypeError('argument must be a Boolean');
  if (typeof (tag) !== 'number')
    tag = types.Boolean;

  this._ensure(3);
  this._buf[this._offset++] = tag;
  this._buf[this._offset++] = 0x01;
  this._buf[this._offset++] = b ? 0xff : 0x00;
};


Writer.prototype.writeString = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string (was: ' + typeof (s) + ')');
  if (typeof (tag) !== 'number')
    tag = types.OctetString;

  var len = Buffer$q.byteLength(s);
  this.writeByte(tag);
  this.writeLength(len);
  if (len) {
    this._ensure(len);
    this._buf.write(s, this._offset);
    this._offset += len;
  }
};


Writer.prototype.writeBuffer = function (buf, tag) {
  if (typeof (tag) !== 'number')
    throw new TypeError('tag must be a number');
  if (!Buffer$q.isBuffer(buf))
    throw new TypeError('argument must be a buffer');

  this.writeByte(tag);
  this.writeLength(buf.length);
  this._ensure(buf.length);
  buf.copy(this._buf, this._offset, 0, buf.length);
  this._offset += buf.length;
};


Writer.prototype.writeStringArray = function (strings) {
  if ((!strings instanceof Array))
    throw new TypeError('argument must be an Array[String]');

  var self = this;
  strings.forEach(function (s) {
    self.writeString(s);
  });
};

// This is really to solve DER cases, but whatever for now
Writer.prototype.writeOID = function (s, tag) {
  if (typeof (s) !== 'string')
    throw new TypeError('argument must be a string');
  if (typeof (tag) !== 'number')
    tag = types.OID;

  if (!/^([0-9]+\.){3,}[0-9]+$/.test(s))
    throw new Error('argument is not a valid OID string');

  function encodeOctet(bytes, octet) {
    if (octet < 128) {
        bytes.push(octet);
    } else if (octet < 16384) {
        bytes.push((octet >>> 7) | 0x80);
        bytes.push(octet & 0x7F);
    } else if (octet < 2097152) {
      bytes.push((octet >>> 14) | 0x80);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else if (octet < 268435456) {
      bytes.push((octet >>> 21) | 0x80);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    } else {
      bytes.push(((octet >>> 28) | 0x80) & 0xFF);
      bytes.push(((octet >>> 21) | 0x80) & 0xFF);
      bytes.push(((octet >>> 14) | 0x80) & 0xFF);
      bytes.push(((octet >>> 7) | 0x80) & 0xFF);
      bytes.push(octet & 0x7F);
    }
  }

  var tmp = s.split('.');
  var bytes = [];
  bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
  tmp.slice(2).forEach(function (b) {
    encodeOctet(bytes, parseInt(b, 10));
  });

  var self = this;
  this._ensure(2 + bytes.length);
  this.writeByte(tag);
  this.writeLength(bytes.length);
  bytes.forEach(function (b) {
    self.writeByte(b);
  });
};


Writer.prototype.writeLength = function (len) {
  if (typeof (len) !== 'number')
    throw new TypeError('argument must be a Number');

  this._ensure(4);

  if (len <= 0x7f) {
    this._buf[this._offset++] = len;
  } else if (len <= 0xff) {
    this._buf[this._offset++] = 0x81;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffff) {
    this._buf[this._offset++] = 0x82;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else if (len <= 0xffffff) {
    this._buf[this._offset++] = 0x83;
    this._buf[this._offset++] = len >> 16;
    this._buf[this._offset++] = len >> 8;
    this._buf[this._offset++] = len;
  } else {
    throw newInvalidAsn1Error('Length too long (> 4 bytes)');
  }
};

Writer.prototype.startSequence = function (tag) {
  if (typeof (tag) !== 'number')
    tag = types.Sequence | types.Constructor;

  this.writeByte(tag);
  this._seq.push(this._offset);
  this._ensure(3);
  this._offset += 3;
};


Writer.prototype.endSequence = function () {
  var seq = this._seq.pop();
  var start = seq + 3;
  var len = this._offset - start;

  if (len <= 0x7f) {
    this._shift(start, len, -2);
    this._buf[seq] = len;
  } else if (len <= 0xff) {
    this._shift(start, len, -1);
    this._buf[seq] = 0x81;
    this._buf[seq + 1] = len;
  } else if (len <= 0xffff) {
    this._buf[seq] = 0x82;
    this._buf[seq + 1] = len >> 8;
    this._buf[seq + 2] = len;
  } else if (len <= 0xffffff) {
    this._shift(start, len, 1);
    this._buf[seq] = 0x83;
    this._buf[seq + 1] = len >> 16;
    this._buf[seq + 2] = len >> 8;
    this._buf[seq + 3] = len;
  } else {
    throw newInvalidAsn1Error('Sequence too long');
  }
};


Writer.prototype._shift = function (start, len, shift) {
  assert.ok(start !== undefined);
  assert.ok(len !== undefined);
  assert.ok(shift);

  this._buf.copy(this._buf, start + shift, start, start + len);
  this._offset += shift;
};

Writer.prototype._ensure = function (len) {
  assert.ok(len);

  if (this._size - this._offset < len) {
    var sz = this._size * this._options.growthFactor;
    if (sz - this._offset < len)
      sz += len;

    var buf = Buffer$q.alloc(sz);

    this._buf.copy(buf, 0, 0, this._offset);
    this._buf = buf;
    this._size = sz;
  }
};



// --- Exported API

var writer = Writer;

var ber = createCommonjsModule(function (module) {
// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.








// --- Exports

module.exports = {

  Reader: reader,

  Writer: writer

};

for (var t in types) {
  if (types.hasOwnProperty(t))
    module.exports[t] = types[t];
}
for (var e in errors) {
  if (errors.hasOwnProperty(e))
    module.exports[e] = errors[e];
}
});

// Copyright 2011 Mark Cavage <mcavage@gmail.com> All rights reserved.

// If you have no idea what ASN.1 or BER is, see this:
// ftp://ftp.rsa.com/pub/pkcs/ascii/layman.asc





// --- Exported API

var lib$f = {

  Ber: ber,

  BerReader: ber.Reader,

  BerWriter: ber.Writer

};

var jsbn$2 = createCommonjsModule(function (module, exports) {
(function(){

    // Copyright (c) 2005  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Basic JavaScript BN library - subset useful for RSA encryption.

    // Bits per digit
    var dbits;

    // JavaScript engine analysis
    var canary = 0xdeadbeefcafe;
    var j_lm = ((canary&0xffffff)==0xefcafe);

    // (public) Constructor
    function BigInteger(a,b,c) {
      if(a != null)
        if("number" == typeof a) this.fromNumber(a,b,c);
        else if(b == null && "string" != typeof a) this.fromString(a,256);
        else this.fromString(a,b);
    }

    // return new, unset BigInteger
    function nbi() { return new BigInteger(null); }

    // am: Compute w_j += (x*this_i), propagate carries,
    // c is initial carry, returns final carry.
    // c < 3*dvalue, x < 2*dvalue, this_i < dvalue
    // We need to select the fastest one that works in this environment.

    // am1: use a single mult and divide to get the high bits,
    // max digit bits should be 26 because
    // max internal value = 2*dvalue^2-2*dvalue (< 2^53)
    function am1(i,x,w,j,c,n) {
      while(--n >= 0) {
        var v = x*this[i++]+w[j]+c;
        c = Math.floor(v/0x4000000);
        w[j++] = v&0x3ffffff;
      }
      return c;
    }
    // am2 avoids a big mult-and-extract completely.
    // Max digit bits should be <= 30 because we do bitwise ops
    // on values up to 2*hdvalue^2-hdvalue-1 (< 2^31)
    function am2(i,x,w,j,c,n) {
      var xl = x&0x7fff, xh = x>>15;
      while(--n >= 0) {
        var l = this[i]&0x7fff;
        var h = this[i++]>>15;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x7fff)<<15)+w[j]+(c&0x3fffffff);
        c = (l>>>30)+(m>>>15)+xh*h+(c>>>30);
        w[j++] = l&0x3fffffff;
      }
      return c;
    }
    // Alternately, set max digit bits to 28 since some
    // browsers slow down when dealing with 32-bit numbers.
    function am3(i,x,w,j,c,n) {
      var xl = x&0x3fff, xh = x>>14;
      while(--n >= 0) {
        var l = this[i]&0x3fff;
        var h = this[i++]>>14;
        var m = xh*l+h*xl;
        l = xl*l+((m&0x3fff)<<14)+w[j]+c;
        c = (l>>28)+(m>>14)+xh*h;
        w[j++] = l&0xfffffff;
      }
      return c;
    }
    var inBrowser = typeof navigator !== "undefined";
    if(inBrowser && j_lm && (navigator.appName == "Microsoft Internet Explorer")) {
      BigInteger.prototype.am = am2;
      dbits = 30;
    }
    else if(inBrowser && j_lm && (navigator.appName != "Netscape")) {
      BigInteger.prototype.am = am1;
      dbits = 26;
    }
    else { // Mozilla/Netscape seems to prefer am3
      BigInteger.prototype.am = am3;
      dbits = 28;
    }

    BigInteger.prototype.DB = dbits;
    BigInteger.prototype.DM = ((1<<dbits)-1);
    BigInteger.prototype.DV = (1<<dbits);

    var BI_FP = 52;
    BigInteger.prototype.FV = Math.pow(2,BI_FP);
    BigInteger.prototype.F1 = BI_FP-dbits;
    BigInteger.prototype.F2 = 2*dbits-BI_FP;

    // Digit conversions
    var BI_RM = "0123456789abcdefghijklmnopqrstuvwxyz";
    var BI_RC = new Array();
    var rr,vv;
    rr = "0".charCodeAt(0);
    for(vv = 0; vv <= 9; ++vv) BI_RC[rr++] = vv;
    rr = "a".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;
    rr = "A".charCodeAt(0);
    for(vv = 10; vv < 36; ++vv) BI_RC[rr++] = vv;

    function int2char(n) { return BI_RM.charAt(n); }
    function intAt(s,i) {
      var c = BI_RC[s.charCodeAt(i)];
      return (c==null)?-1:c;
    }

    // (protected) copy this to r
    function bnpCopyTo(r) {
      for(var i = this.t-1; i >= 0; --i) r[i] = this[i];
      r.t = this.t;
      r.s = this.s;
    }

    // (protected) set from integer value x, -DV <= x < DV
    function bnpFromInt(x) {
      this.t = 1;
      this.s = (x<0)?-1:0;
      if(x > 0) this[0] = x;
      else if(x < -1) this[0] = x+this.DV;
      else this.t = 0;
    }

    // return bigint initialized to value
    function nbv(i) { var r = nbi(); r.fromInt(i); return r; }

    // (protected) set from string and radix
    function bnpFromString(s,b) {
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 256) k = 8; // byte array
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else { this.fromRadix(s,b); return; }
      this.t = 0;
      this.s = 0;
      var i = s.length, mi = false, sh = 0;
      while(--i >= 0) {
        var x = (k==8)?s[i]&0xff:intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-") mi = true;
          continue;
        }
        mi = false;
        if(sh == 0)
          this[this.t++] = x;
        else if(sh+k > this.DB) {
          this[this.t-1] |= (x&((1<<(this.DB-sh))-1))<<sh;
          this[this.t++] = (x>>(this.DB-sh));
        }
        else
          this[this.t-1] |= x<<sh;
        sh += k;
        if(sh >= this.DB) sh -= this.DB;
      }
      if(k == 8 && (s[0]&0x80) != 0) {
        this.s = -1;
        if(sh > 0) this[this.t-1] |= ((1<<(this.DB-sh))-1)<<sh;
      }
      this.clamp();
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) clamp off excess high words
    function bnpClamp() {
      var c = this.s&this.DM;
      while(this.t > 0 && this[this.t-1] == c) --this.t;
    }

    // (public) return string representation in given radix
    function bnToString(b) {
      if(this.s < 0) return "-"+this.negate().toString(b);
      var k;
      if(b == 16) k = 4;
      else if(b == 8) k = 3;
      else if(b == 2) k = 1;
      else if(b == 32) k = 5;
      else if(b == 4) k = 2;
      else return this.toRadix(b);
      var km = (1<<k)-1, d, m = false, r = "", i = this.t;
      var p = this.DB-(i*this.DB)%k;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) > 0) { m = true; r = int2char(d); }
        while(i >= 0) {
          if(p < k) {
            d = (this[i]&((1<<p)-1))<<(k-p);
            d |= this[--i]>>(p+=this.DB-k);
          }
          else {
            d = (this[i]>>(p-=k))&km;
            if(p <= 0) { p += this.DB; --i; }
          }
          if(d > 0) m = true;
          if(m) r += int2char(d);
        }
      }
      return m?r:"0";
    }

    // (public) -this
    function bnNegate() { var r = nbi(); BigInteger.ZERO.subTo(this,r); return r; }

    // (public) |this|
    function bnAbs() { return (this.s<0)?this.negate():this; }

    // (public) return + if this > a, - if this < a, 0 if equal
    function bnCompareTo(a) {
      var r = this.s-a.s;
      if(r != 0) return r;
      var i = this.t;
      r = i-a.t;
      if(r != 0) return (this.s<0)?-r:r;
      while(--i >= 0) if((r=this[i]-a[i]) != 0) return r;
      return 0;
    }

    // returns bit length of the integer x
    function nbits(x) {
      var r = 1, t;
      if((t=x>>>16) != 0) { x = t; r += 16; }
      if((t=x>>8) != 0) { x = t; r += 8; }
      if((t=x>>4) != 0) { x = t; r += 4; }
      if((t=x>>2) != 0) { x = t; r += 2; }
      if((t=x>>1) != 0) { x = t; r += 1; }
      return r;
    }

    // (public) return the number of bits in "this"
    function bnBitLength() {
      if(this.t <= 0) return 0;
      return this.DB*(this.t-1)+nbits(this[this.t-1]^(this.s&this.DM));
    }

    // (protected) r = this << n*DB
    function bnpDLShiftTo(n,r) {
      var i;
      for(i = this.t-1; i >= 0; --i) r[i+n] = this[i];
      for(i = n-1; i >= 0; --i) r[i] = 0;
      r.t = this.t+n;
      r.s = this.s;
    }

    // (protected) r = this >> n*DB
    function bnpDRShiftTo(n,r) {
      for(var i = n; i < this.t; ++i) r[i-n] = this[i];
      r.t = Math.max(this.t-n,0);
      r.s = this.s;
    }

    // (protected) r = this << n
    function bnpLShiftTo(n,r) {
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<cbs)-1;
      var ds = Math.floor(n/this.DB), c = (this.s<<bs)&this.DM, i;
      for(i = this.t-1; i >= 0; --i) {
        r[i+ds+1] = (this[i]>>cbs)|c;
        c = (this[i]&bm)<<bs;
      }
      for(i = ds-1; i >= 0; --i) r[i] = 0;
      r[ds] = c;
      r.t = this.t+ds+1;
      r.s = this.s;
      r.clamp();
    }

    // (protected) r = this >> n
    function bnpRShiftTo(n,r) {
      r.s = this.s;
      var ds = Math.floor(n/this.DB);
      if(ds >= this.t) { r.t = 0; return; }
      var bs = n%this.DB;
      var cbs = this.DB-bs;
      var bm = (1<<bs)-1;
      r[0] = this[ds]>>bs;
      for(var i = ds+1; i < this.t; ++i) {
        r[i-ds-1] |= (this[i]&bm)<<cbs;
        r[i-ds] = this[i]>>bs;
      }
      if(bs > 0) r[this.t-ds-1] |= (this.s&bm)<<cbs;
      r.t = this.t-ds;
      r.clamp();
    }

    // (protected) r = this - a
    function bnpSubTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]-a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c -= a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c -= a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c -= a.s;
      }
      r.s = (c<0)?-1:0;
      if(c < -1) r[i++] = this.DV+c;
      else if(c > 0) r[i++] = c;
      r.t = i;
      r.clamp();
    }

    // (protected) r = this * a, r != this,a (HAC 14.12)
    // "this" should be the larger one if appropriate.
    function bnpMultiplyTo(a,r) {
      var x = this.abs(), y = a.abs();
      var i = x.t;
      r.t = i+y.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < y.t; ++i) r[i+x.t] = x.am(0,y[i],r,i,0,x.t);
      r.s = 0;
      r.clamp();
      if(this.s != a.s) BigInteger.ZERO.subTo(r,r);
    }

    // (protected) r = this^2, r != this (HAC 14.16)
    function bnpSquareTo(r) {
      var x = this.abs();
      var i = r.t = 2*x.t;
      while(--i >= 0) r[i] = 0;
      for(i = 0; i < x.t-1; ++i) {
        var c = x.am(i,x[i],r,2*i,0,1);
        if((r[i+x.t]+=x.am(i+1,2*x[i],r,2*i+1,c,x.t-i-1)) >= x.DV) {
          r[i+x.t] -= x.DV;
          r[i+x.t+1] = 1;
        }
      }
      if(r.t > 0) r[r.t-1] += x.am(i,x[i],r,2*i,0,1);
      r.s = 0;
      r.clamp();
    }

    // (protected) divide this by m, quotient and remainder to q, r (HAC 14.20)
    // r != q, this != m.  q or r may be null.
    function bnpDivRemTo(m,q,r) {
      var pm = m.abs();
      if(pm.t <= 0) return;
      var pt = this.abs();
      if(pt.t < pm.t) {
        if(q != null) q.fromInt(0);
        if(r != null) this.copyTo(r);
        return;
      }
      if(r == null) r = nbi();
      var y = nbi(), ts = this.s, ms = m.s;
      var nsh = this.DB-nbits(pm[pm.t-1]);   // normalize modulus
      if(nsh > 0) { pm.lShiftTo(nsh,y); pt.lShiftTo(nsh,r); }
      else { pm.copyTo(y); pt.copyTo(r); }
      var ys = y.t;
      var y0 = y[ys-1];
      if(y0 == 0) return;
      var yt = y0*(1<<this.F1)+((ys>1)?y[ys-2]>>this.F2:0);
      var d1 = this.FV/yt, d2 = (1<<this.F1)/yt, e = 1<<this.F2;
      var i = r.t, j = i-ys, t = (q==null)?nbi():q;
      y.dlShiftTo(j,t);
      if(r.compareTo(t) >= 0) {
        r[r.t++] = 1;
        r.subTo(t,r);
      }
      BigInteger.ONE.dlShiftTo(ys,t);
      t.subTo(y,y);  // "negative" y so we can replace sub with am later
      while(y.t < ys) y[y.t++] = 0;
      while(--j >= 0) {
        // Estimate quotient digit
        var qd = (r[--i]==y0)?this.DM:Math.floor(r[i]*d1+(r[i-1]+e)*d2);
        if((r[i]+=y.am(0,qd,r,j,0,ys)) < qd) {   // Try it out
          y.dlShiftTo(j,t);
          r.subTo(t,r);
          while(r[i] < --qd) r.subTo(t,r);
        }
      }
      if(q != null) {
        r.drShiftTo(ys,q);
        if(ts != ms) BigInteger.ZERO.subTo(q,q);
      }
      r.t = ys;
      r.clamp();
      if(nsh > 0) r.rShiftTo(nsh,r); // Denormalize remainder
      if(ts < 0) BigInteger.ZERO.subTo(r,r);
    }

    // (public) this mod a
    function bnMod(a) {
      var r = nbi();
      this.abs().divRemTo(a,null,r);
      if(this.s < 0 && r.compareTo(BigInteger.ZERO) > 0) a.subTo(r,r);
      return r;
    }

    // Modular reduction using "classic" algorithm
    function Classic(m) { this.m = m; }
    function cConvert(x) {
      if(x.s < 0 || x.compareTo(this.m) >= 0) return x.mod(this.m);
      else return x;
    }
    function cRevert(x) { return x; }
    function cReduce(x) { x.divRemTo(this.m,null,x); }
    function cMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }
    function cSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    Classic.prototype.convert = cConvert;
    Classic.prototype.revert = cRevert;
    Classic.prototype.reduce = cReduce;
    Classic.prototype.mulTo = cMulTo;
    Classic.prototype.sqrTo = cSqrTo;

    // (protected) return "-1/this % 2^DB"; useful for Mont. reduction
    // justification:
    //         xy == 1 (mod m)
    //         xy =  1+km
    //   xy(2-xy) = (1+km)(1-km)
    // x[y(2-xy)] = 1-k^2m^2
    // x[y(2-xy)] == 1 (mod m^2)
    // if y is 1/x mod m, then y(2-xy) is 1/x mod m^2
    // should reduce x and y(2-xy) by m^2 at each step to keep size bounded.
    // JS multiply "overflows" differently from C/C++, so care is needed here.
    function bnpInvDigit() {
      if(this.t < 1) return 0;
      var x = this[0];
      if((x&1) == 0) return 0;
      var y = x&3;       // y == 1/x mod 2^2
      y = (y*(2-(x&0xf)*y))&0xf; // y == 1/x mod 2^4
      y = (y*(2-(x&0xff)*y))&0xff;   // y == 1/x mod 2^8
      y = (y*(2-(((x&0xffff)*y)&0xffff)))&0xffff;    // y == 1/x mod 2^16
      // last step - calculate inverse mod DV directly;
      // assumes 16 < DB <= 32 and assumes ability to handle 48-bit ints
      y = (y*(2-x*y%this.DV))%this.DV;       // y == 1/x mod 2^dbits
      // we really want the negative inverse, and -DV < y < DV
      return (y>0)?this.DV-y:-y;
    }

    // Montgomery reduction
    function Montgomery(m) {
      this.m = m;
      this.mp = m.invDigit();
      this.mpl = this.mp&0x7fff;
      this.mph = this.mp>>15;
      this.um = (1<<(m.DB-15))-1;
      this.mt2 = 2*m.t;
    }

    // xR mod m
    function montConvert(x) {
      var r = nbi();
      x.abs().dlShiftTo(this.m.t,r);
      r.divRemTo(this.m,null,r);
      if(x.s < 0 && r.compareTo(BigInteger.ZERO) > 0) this.m.subTo(r,r);
      return r;
    }

    // x/R mod m
    function montRevert(x) {
      var r = nbi();
      x.copyTo(r);
      this.reduce(r);
      return r;
    }

    // x = x/R mod m (HAC 14.32)
    function montReduce(x) {
      while(x.t <= this.mt2) // pad x so am has enough room later
        x[x.t++] = 0;
      for(var i = 0; i < this.m.t; ++i) {
        // faster way of calculating u0 = x[i]*mp mod DV
        var j = x[i]&0x7fff;
        var u0 = (j*this.mpl+(((j*this.mph+(x[i]>>15)*this.mpl)&this.um)<<15))&x.DM;
        // use am to combine the multiply-shift-add into one call
        j = i+this.m.t;
        x[j] += this.m.am(0,u0,x,i,0,this.m.t);
        // propagate carry
        while(x[j] >= x.DV) { x[j] -= x.DV; x[++j]++; }
      }
      x.clamp();
      x.drShiftTo(this.m.t,x);
      if(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = "x^2/R mod m"; x != r
    function montSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = "xy/R mod m"; x,y != r
    function montMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Montgomery.prototype.convert = montConvert;
    Montgomery.prototype.revert = montRevert;
    Montgomery.prototype.reduce = montReduce;
    Montgomery.prototype.mulTo = montMulTo;
    Montgomery.prototype.sqrTo = montSqrTo;

    // (protected) true iff this is even
    function bnpIsEven() { return ((this.t>0)?(this[0]&1):this.s) == 0; }

    // (protected) this^e, e < 2^32, doing sqr and mul with "r" (HAC 14.79)
    function bnpExp(e,z) {
      if(e > 0xffffffff || e < 1) return BigInteger.ONE;
      var r = nbi(), r2 = nbi(), g = z.convert(this), i = nbits(e)-1;
      g.copyTo(r);
      while(--i >= 0) {
        z.sqrTo(r,r2);
        if((e&(1<<i)) > 0) z.mulTo(r2,g,r);
        else { var t = r; r = r2; r2 = t; }
      }
      return z.revert(r);
    }

    // (public) this^e % m, 0 <= e < 2^32
    function bnModPowInt(e,m) {
      var z;
      if(e < 256 || m.isEven()) z = new Classic(m); else z = new Montgomery(m);
      return this.exp(e,z);
    }

    // protected
    BigInteger.prototype.copyTo = bnpCopyTo;
    BigInteger.prototype.fromInt = bnpFromInt;
    BigInteger.prototype.fromString = bnpFromString;
    BigInteger.prototype.clamp = bnpClamp;
    BigInteger.prototype.dlShiftTo = bnpDLShiftTo;
    BigInteger.prototype.drShiftTo = bnpDRShiftTo;
    BigInteger.prototype.lShiftTo = bnpLShiftTo;
    BigInteger.prototype.rShiftTo = bnpRShiftTo;
    BigInteger.prototype.subTo = bnpSubTo;
    BigInteger.prototype.multiplyTo = bnpMultiplyTo;
    BigInteger.prototype.squareTo = bnpSquareTo;
    BigInteger.prototype.divRemTo = bnpDivRemTo;
    BigInteger.prototype.invDigit = bnpInvDigit;
    BigInteger.prototype.isEven = bnpIsEven;
    BigInteger.prototype.exp = bnpExp;

    // public
    BigInteger.prototype.toString = bnToString;
    BigInteger.prototype.negate = bnNegate;
    BigInteger.prototype.abs = bnAbs;
    BigInteger.prototype.compareTo = bnCompareTo;
    BigInteger.prototype.bitLength = bnBitLength;
    BigInteger.prototype.mod = bnMod;
    BigInteger.prototype.modPowInt = bnModPowInt;

    // "constants"
    BigInteger.ZERO = nbv(0);
    BigInteger.ONE = nbv(1);

    // Copyright (c) 2005-2009  Tom Wu
    // All Rights Reserved.
    // See "LICENSE" for details.

    // Extended JavaScript BN functions, required for RSA private ops.

    // Version 1.1: new BigInteger("0", 10) returns "proper" zero
    // Version 1.2: square() API, isProbablePrime fix

    // (public)
    function bnClone() { var r = nbi(); this.copyTo(r); return r; }

    // (public) return value as integer
    function bnIntValue() {
      if(this.s < 0) {
        if(this.t == 1) return this[0]-this.DV;
        else if(this.t == 0) return -1;
      }
      else if(this.t == 1) return this[0];
      else if(this.t == 0) return 0;
      // assumes 16 < DB < 32
      return ((this[1]&((1<<(32-this.DB))-1))<<this.DB)|this[0];
    }

    // (public) return value as byte
    function bnByteValue() { return (this.t==0)?this.s:(this[0]<<24)>>24; }

    // (public) return value as short (assumes DB>=16)
    function bnShortValue() { return (this.t==0)?this.s:(this[0]<<16)>>16; }

    // (protected) return x s.t. r^x < DV
    function bnpChunkSize(r) { return Math.floor(Math.LN2*this.DB/Math.log(r)); }

    // (public) 0 if this == 0, 1 if this > 0
    function bnSigNum() {
      if(this.s < 0) return -1;
      else if(this.t <= 0 || (this.t == 1 && this[0] <= 0)) return 0;
      else return 1;
    }

    // (protected) convert to radix string
    function bnpToRadix(b) {
      if(b == null) b = 10;
      if(this.signum() == 0 || b < 2 || b > 36) return "0";
      var cs = this.chunkSize(b);
      var a = Math.pow(b,cs);
      var d = nbv(a), y = nbi(), z = nbi(), r = "";
      this.divRemTo(d,y,z);
      while(y.signum() > 0) {
        r = (a+z.intValue()).toString(b).substr(1) + r;
        y.divRemTo(d,y,z);
      }
      return z.intValue().toString(b) + r;
    }

    // (protected) convert from radix string
    function bnpFromRadix(s,b) {
      this.fromInt(0);
      if(b == null) b = 10;
      var cs = this.chunkSize(b);
      var d = Math.pow(b,cs), mi = false, j = 0, w = 0;
      for(var i = 0; i < s.length; ++i) {
        var x = intAt(s,i);
        if(x < 0) {
          if(s.charAt(i) == "-" && this.signum() == 0) mi = true;
          continue;
        }
        w = b*w+x;
        if(++j >= cs) {
          this.dMultiply(d);
          this.dAddOffset(w,0);
          j = 0;
          w = 0;
        }
      }
      if(j > 0) {
        this.dMultiply(Math.pow(b,j));
        this.dAddOffset(w,0);
      }
      if(mi) BigInteger.ZERO.subTo(this,this);
    }

    // (protected) alternate constructor
    function bnpFromNumber(a,b,c) {
      if("number" == typeof b) {
        // new BigInteger(int,int,RNG)
        if(a < 2) this.fromInt(1);
        else {
          this.fromNumber(a,c);
          if(!this.testBit(a-1))	// force MSB set
            this.bitwiseTo(BigInteger.ONE.shiftLeft(a-1),op_or,this);
          if(this.isEven()) this.dAddOffset(1,0); // force odd
          while(!this.isProbablePrime(b)) {
            this.dAddOffset(2,0);
            if(this.bitLength() > a) this.subTo(BigInteger.ONE.shiftLeft(a-1),this);
          }
        }
      }
      else {
        // new BigInteger(int,RNG)
        var x = new Array(), t = a&7;
        x.length = (a>>3)+1;
        b.nextBytes(x);
        if(t > 0) x[0] &= ((1<<t)-1); else x[0] = 0;
        this.fromString(x,256);
      }
    }

    // (public) convert to bigendian byte array
    function bnToByteArray() {
      var i = this.t, r = new Array();
      r[0] = this.s;
      var p = this.DB-(i*this.DB)%8, d, k = 0;
      if(i-- > 0) {
        if(p < this.DB && (d = this[i]>>p) != (this.s&this.DM)>>p)
          r[k++] = d|(this.s<<(this.DB-p));
        while(i >= 0) {
          if(p < 8) {
            d = (this[i]&((1<<p)-1))<<(8-p);
            d |= this[--i]>>(p+=this.DB-8);
          }
          else {
            d = (this[i]>>(p-=8))&0xff;
            if(p <= 0) { p += this.DB; --i; }
          }
          if((d&0x80) != 0) d |= -256;
          if(k == 0 && (this.s&0x80) != (d&0x80)) ++k;
          if(k > 0 || d != this.s) r[k++] = d;
        }
      }
      return r;
    }

    function bnEquals(a) { return(this.compareTo(a)==0); }
    function bnMin(a) { return (this.compareTo(a)<0)?this:a; }
    function bnMax(a) { return (this.compareTo(a)>0)?this:a; }

    // (protected) r = this op a (bitwise)
    function bnpBitwiseTo(a,op,r) {
      var i, f, m = Math.min(a.t,this.t);
      for(i = 0; i < m; ++i) r[i] = op(this[i],a[i]);
      if(a.t < this.t) {
        f = a.s&this.DM;
        for(i = m; i < this.t; ++i) r[i] = op(this[i],f);
        r.t = this.t;
      }
      else {
        f = this.s&this.DM;
        for(i = m; i < a.t; ++i) r[i] = op(f,a[i]);
        r.t = a.t;
      }
      r.s = op(this.s,a.s);
      r.clamp();
    }

    // (public) this & a
    function op_and(x,y) { return x&y; }
    function bnAnd(a) { var r = nbi(); this.bitwiseTo(a,op_and,r); return r; }

    // (public) this | a
    function op_or(x,y) { return x|y; }
    function bnOr(a) { var r = nbi(); this.bitwiseTo(a,op_or,r); return r; }

    // (public) this ^ a
    function op_xor(x,y) { return x^y; }
    function bnXor(a) { var r = nbi(); this.bitwiseTo(a,op_xor,r); return r; }

    // (public) this & ~a
    function op_andnot(x,y) { return x&~y; }
    function bnAndNot(a) { var r = nbi(); this.bitwiseTo(a,op_andnot,r); return r; }

    // (public) ~this
    function bnNot() {
      var r = nbi();
      for(var i = 0; i < this.t; ++i) r[i] = this.DM&~this[i];
      r.t = this.t;
      r.s = ~this.s;
      return r;
    }

    // (public) this << n
    function bnShiftLeft(n) {
      var r = nbi();
      if(n < 0) this.rShiftTo(-n,r); else this.lShiftTo(n,r);
      return r;
    }

    // (public) this >> n
    function bnShiftRight(n) {
      var r = nbi();
      if(n < 0) this.lShiftTo(-n,r); else this.rShiftTo(n,r);
      return r;
    }

    // return index of lowest 1-bit in x, x < 2^31
    function lbit(x) {
      if(x == 0) return -1;
      var r = 0;
      if((x&0xffff) == 0) { x >>= 16; r += 16; }
      if((x&0xff) == 0) { x >>= 8; r += 8; }
      if((x&0xf) == 0) { x >>= 4; r += 4; }
      if((x&3) == 0) { x >>= 2; r += 2; }
      if((x&1) == 0) ++r;
      return r;
    }

    // (public) returns index of lowest 1-bit (or -1 if none)
    function bnGetLowestSetBit() {
      for(var i = 0; i < this.t; ++i)
        if(this[i] != 0) return i*this.DB+lbit(this[i]);
      if(this.s < 0) return this.t*this.DB;
      return -1;
    }

    // return number of 1 bits in x
    function cbit(x) {
      var r = 0;
      while(x != 0) { x &= x-1; ++r; }
      return r;
    }

    // (public) return number of set bits
    function bnBitCount() {
      var r = 0, x = this.s&this.DM;
      for(var i = 0; i < this.t; ++i) r += cbit(this[i]^x);
      return r;
    }

    // (public) true iff nth bit is set
    function bnTestBit(n) {
      var j = Math.floor(n/this.DB);
      if(j >= this.t) return(this.s!=0);
      return((this[j]&(1<<(n%this.DB)))!=0);
    }

    // (protected) this op (1<<n)
    function bnpChangeBit(n,op) {
      var r = BigInteger.ONE.shiftLeft(n);
      this.bitwiseTo(r,op,r);
      return r;
    }

    // (public) this | (1<<n)
    function bnSetBit(n) { return this.changeBit(n,op_or); }

    // (public) this & ~(1<<n)
    function bnClearBit(n) { return this.changeBit(n,op_andnot); }

    // (public) this ^ (1<<n)
    function bnFlipBit(n) { return this.changeBit(n,op_xor); }

    // (protected) r = this + a
    function bnpAddTo(a,r) {
      var i = 0, c = 0, m = Math.min(a.t,this.t);
      while(i < m) {
        c += this[i]+a[i];
        r[i++] = c&this.DM;
        c >>= this.DB;
      }
      if(a.t < this.t) {
        c += a.s;
        while(i < this.t) {
          c += this[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += this.s;
      }
      else {
        c += this.s;
        while(i < a.t) {
          c += a[i];
          r[i++] = c&this.DM;
          c >>= this.DB;
        }
        c += a.s;
      }
      r.s = (c<0)?-1:0;
      if(c > 0) r[i++] = c;
      else if(c < -1) r[i++] = this.DV+c;
      r.t = i;
      r.clamp();
    }

    // (public) this + a
    function bnAdd(a) { var r = nbi(); this.addTo(a,r); return r; }

    // (public) this - a
    function bnSubtract(a) { var r = nbi(); this.subTo(a,r); return r; }

    // (public) this * a
    function bnMultiply(a) { var r = nbi(); this.multiplyTo(a,r); return r; }

    // (public) this^2
    function bnSquare() { var r = nbi(); this.squareTo(r); return r; }

    // (public) this / a
    function bnDivide(a) { var r = nbi(); this.divRemTo(a,r,null); return r; }

    // (public) this % a
    function bnRemainder(a) { var r = nbi(); this.divRemTo(a,null,r); return r; }

    // (public) [this/a,this%a]
    function bnDivideAndRemainder(a) {
      var q = nbi(), r = nbi();
      this.divRemTo(a,q,r);
      return new Array(q,r);
    }

    // (protected) this *= n, this >= 0, 1 < n < DV
    function bnpDMultiply(n) {
      this[this.t] = this.am(0,n-1,this,0,0,this.t);
      ++this.t;
      this.clamp();
    }

    // (protected) this += n << w words, this >= 0
    function bnpDAddOffset(n,w) {
      if(n == 0) return;
      while(this.t <= w) this[this.t++] = 0;
      this[w] += n;
      while(this[w] >= this.DV) {
        this[w] -= this.DV;
        if(++w >= this.t) this[this.t++] = 0;
        ++this[w];
      }
    }

    // A "null" reducer
    function NullExp() {}
    function nNop(x) { return x; }
    function nMulTo(x,y,r) { x.multiplyTo(y,r); }
    function nSqrTo(x,r) { x.squareTo(r); }

    NullExp.prototype.convert = nNop;
    NullExp.prototype.revert = nNop;
    NullExp.prototype.mulTo = nMulTo;
    NullExp.prototype.sqrTo = nSqrTo;

    // (public) this^e
    function bnPow(e) { return this.exp(e,new NullExp()); }

    // (protected) r = lower n words of "this * a", a.t <= n
    // "this" should be the larger one if appropriate.
    function bnpMultiplyLowerTo(a,n,r) {
      var i = Math.min(this.t+a.t,n);
      r.s = 0; // assumes a,this >= 0
      r.t = i;
      while(i > 0) r[--i] = 0;
      var j;
      for(j = r.t-this.t; i < j; ++i) r[i+this.t] = this.am(0,a[i],r,i,0,this.t);
      for(j = Math.min(a.t,n); i < j; ++i) this.am(0,a[i],r,i,0,n-i);
      r.clamp();
    }

    // (protected) r = "this * a" without lower n words, n > 0
    // "this" should be the larger one if appropriate.
    function bnpMultiplyUpperTo(a,n,r) {
      --n;
      var i = r.t = this.t+a.t-n;
      r.s = 0; // assumes a,this >= 0
      while(--i >= 0) r[i] = 0;
      for(i = Math.max(n-this.t,0); i < a.t; ++i)
        r[this.t+i-n] = this.am(n-i,a[i],r,0,0,this.t+i-n);
      r.clamp();
      r.drShiftTo(1,r);
    }

    // Barrett modular reduction
    function Barrett(m) {
      // setup Barrett
      this.r2 = nbi();
      this.q3 = nbi();
      BigInteger.ONE.dlShiftTo(2*m.t,this.r2);
      this.mu = this.r2.divide(m);
      this.m = m;
    }

    function barrettConvert(x) {
      if(x.s < 0 || x.t > 2*this.m.t) return x.mod(this.m);
      else if(x.compareTo(this.m) < 0) return x;
      else { var r = nbi(); x.copyTo(r); this.reduce(r); return r; }
    }

    function barrettRevert(x) { return x; }

    // x = x mod m (HAC 14.42)
    function barrettReduce(x) {
      x.drShiftTo(this.m.t-1,this.r2);
      if(x.t > this.m.t+1) { x.t = this.m.t+1; x.clamp(); }
      this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3);
      this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);
      while(x.compareTo(this.r2) < 0) x.dAddOffset(1,this.m.t+1);
      x.subTo(this.r2,x);
      while(x.compareTo(this.m) >= 0) x.subTo(this.m,x);
    }

    // r = x^2 mod m; x != r
    function barrettSqrTo(x,r) { x.squareTo(r); this.reduce(r); }

    // r = x*y mod m; x,y != r
    function barrettMulTo(x,y,r) { x.multiplyTo(y,r); this.reduce(r); }

    Barrett.prototype.convert = barrettConvert;
    Barrett.prototype.revert = barrettRevert;
    Barrett.prototype.reduce = barrettReduce;
    Barrett.prototype.mulTo = barrettMulTo;
    Barrett.prototype.sqrTo = barrettSqrTo;

    // (public) this^e % m (HAC 14.85)
    function bnModPow(e,m) {
      var i = e.bitLength(), k, r = nbv(1), z;
      if(i <= 0) return r;
      else if(i < 18) k = 1;
      else if(i < 48) k = 3;
      else if(i < 144) k = 4;
      else if(i < 768) k = 5;
      else k = 6;
      if(i < 8)
        z = new Classic(m);
      else if(m.isEven())
        z = new Barrett(m);
      else
        z = new Montgomery(m);

      // precomputation
      var g = new Array(), n = 3, k1 = k-1, km = (1<<k)-1;
      g[1] = z.convert(this);
      if(k > 1) {
        var g2 = nbi();
        z.sqrTo(g[1],g2);
        while(n <= km) {
          g[n] = nbi();
          z.mulTo(g2,g[n-2],g[n]);
          n += 2;
        }
      }

      var j = e.t-1, w, is1 = true, r2 = nbi(), t;
      i = nbits(e[j])-1;
      while(j >= 0) {
        if(i >= k1) w = (e[j]>>(i-k1))&km;
        else {
          w = (e[j]&((1<<(i+1))-1))<<(k1-i);
          if(j > 0) w |= e[j-1]>>(this.DB+i-k1);
        }

        n = k;
        while((w&1) == 0) { w >>= 1; --n; }
        if((i -= n) < 0) { i += this.DB; --j; }
        if(is1) {	// ret == 1, don't bother squaring or multiplying it
          g[w].copyTo(r);
          is1 = false;
        }
        else {
          while(n > 1) { z.sqrTo(r,r2); z.sqrTo(r2,r); n -= 2; }
          if(n > 0) z.sqrTo(r,r2); else { t = r; r = r2; r2 = t; }
          z.mulTo(r2,g[w],r);
        }

        while(j >= 0 && (e[j]&(1<<i)) == 0) {
          z.sqrTo(r,r2); t = r; r = r2; r2 = t;
          if(--i < 0) { i = this.DB-1; --j; }
        }
      }
      return z.revert(r);
    }

    // (public) gcd(this,a) (HAC 14.54)
    function bnGCD(a) {
      var x = (this.s<0)?this.negate():this.clone();
      var y = (a.s<0)?a.negate():a.clone();
      if(x.compareTo(y) < 0) { var t = x; x = y; y = t; }
      var i = x.getLowestSetBit(), g = y.getLowestSetBit();
      if(g < 0) return x;
      if(i < g) g = i;
      if(g > 0) {
        x.rShiftTo(g,x);
        y.rShiftTo(g,y);
      }
      while(x.signum() > 0) {
        if((i = x.getLowestSetBit()) > 0) x.rShiftTo(i,x);
        if((i = y.getLowestSetBit()) > 0) y.rShiftTo(i,y);
        if(x.compareTo(y) >= 0) {
          x.subTo(y,x);
          x.rShiftTo(1,x);
        }
        else {
          y.subTo(x,y);
          y.rShiftTo(1,y);
        }
      }
      if(g > 0) y.lShiftTo(g,y);
      return y;
    }

    // (protected) this % n, n < 2^26
    function bnpModInt(n) {
      if(n <= 0) return 0;
      var d = this.DV%n, r = (this.s<0)?n-1:0;
      if(this.t > 0)
        if(d == 0) r = this[0]%n;
        else for(var i = this.t-1; i >= 0; --i) r = (d*r+this[i])%n;
      return r;
    }

    // (public) 1/this % m (HAC 14.61)
    function bnModInverse(m) {
      var ac = m.isEven();
      if((this.isEven() && ac) || m.signum() == 0) return BigInteger.ZERO;
      var u = m.clone(), v = this.clone();
      var a = nbv(1), b = nbv(0), c = nbv(0), d = nbv(1);
      while(u.signum() != 0) {
        while(u.isEven()) {
          u.rShiftTo(1,u);
          if(ac) {
            if(!a.isEven() || !b.isEven()) { a.addTo(this,a); b.subTo(m,b); }
            a.rShiftTo(1,a);
          }
          else if(!b.isEven()) b.subTo(m,b);
          b.rShiftTo(1,b);
        }
        while(v.isEven()) {
          v.rShiftTo(1,v);
          if(ac) {
            if(!c.isEven() || !d.isEven()) { c.addTo(this,c); d.subTo(m,d); }
            c.rShiftTo(1,c);
          }
          else if(!d.isEven()) d.subTo(m,d);
          d.rShiftTo(1,d);
        }
        if(u.compareTo(v) >= 0) {
          u.subTo(v,u);
          if(ac) a.subTo(c,a);
          b.subTo(d,b);
        }
        else {
          v.subTo(u,v);
          if(ac) c.subTo(a,c);
          d.subTo(b,d);
        }
      }
      if(v.compareTo(BigInteger.ONE) != 0) return BigInteger.ZERO;
      if(d.compareTo(m) >= 0) return d.subtract(m);
      if(d.signum() < 0) d.addTo(m,d); else return d;
      if(d.signum() < 0) return d.add(m); else return d;
    }

    var lowprimes = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997];
    var lplim = (1<<26)/lowprimes[lowprimes.length-1];

    // (public) test primality with certainty >= 1-.5^t
    function bnIsProbablePrime(t) {
      var i, x = this.abs();
      if(x.t == 1 && x[0] <= lowprimes[lowprimes.length-1]) {
        for(i = 0; i < lowprimes.length; ++i)
          if(x[0] == lowprimes[i]) return true;
        return false;
      }
      if(x.isEven()) return false;
      i = 1;
      while(i < lowprimes.length) {
        var m = lowprimes[i], j = i+1;
        while(j < lowprimes.length && m < lplim) m *= lowprimes[j++];
        m = x.modInt(m);
        while(i < j) if(m%lowprimes[i++] == 0) return false;
      }
      return x.millerRabin(t);
    }

    // (protected) true if probably prime (HAC 4.24, Miller-Rabin)
    function bnpMillerRabin(t) {
      var n1 = this.subtract(BigInteger.ONE);
      var k = n1.getLowestSetBit();
      if(k <= 0) return false;
      var r = n1.shiftRight(k);
      t = (t+1)>>1;
      if(t > lowprimes.length) t = lowprimes.length;
      var a = nbi();
      for(var i = 0; i < t; ++i) {
        //Pick bases at random, instead of starting at 2
        a.fromInt(lowprimes[Math.floor(Math.random()*lowprimes.length)]);
        var y = a.modPow(r,this);
        if(y.compareTo(BigInteger.ONE) != 0 && y.compareTo(n1) != 0) {
          var j = 1;
          while(j++ < k && y.compareTo(n1) != 0) {
            y = y.modPowInt(2,this);
            if(y.compareTo(BigInteger.ONE) == 0) return false;
          }
          if(y.compareTo(n1) != 0) return false;
        }
      }
      return true;
    }

    // protected
    BigInteger.prototype.chunkSize = bnpChunkSize;
    BigInteger.prototype.toRadix = bnpToRadix;
    BigInteger.prototype.fromRadix = bnpFromRadix;
    BigInteger.prototype.fromNumber = bnpFromNumber;
    BigInteger.prototype.bitwiseTo = bnpBitwiseTo;
    BigInteger.prototype.changeBit = bnpChangeBit;
    BigInteger.prototype.addTo = bnpAddTo;
    BigInteger.prototype.dMultiply = bnpDMultiply;
    BigInteger.prototype.dAddOffset = bnpDAddOffset;
    BigInteger.prototype.multiplyLowerTo = bnpMultiplyLowerTo;
    BigInteger.prototype.multiplyUpperTo = bnpMultiplyUpperTo;
    BigInteger.prototype.modInt = bnpModInt;
    BigInteger.prototype.millerRabin = bnpMillerRabin;

    // public
    BigInteger.prototype.clone = bnClone;
    BigInteger.prototype.intValue = bnIntValue;
    BigInteger.prototype.byteValue = bnByteValue;
    BigInteger.prototype.shortValue = bnShortValue;
    BigInteger.prototype.signum = bnSigNum;
    BigInteger.prototype.toByteArray = bnToByteArray;
    BigInteger.prototype.equals = bnEquals;
    BigInteger.prototype.min = bnMin;
    BigInteger.prototype.max = bnMax;
    BigInteger.prototype.and = bnAnd;
    BigInteger.prototype.or = bnOr;
    BigInteger.prototype.xor = bnXor;
    BigInteger.prototype.andNot = bnAndNot;
    BigInteger.prototype.not = bnNot;
    BigInteger.prototype.shiftLeft = bnShiftLeft;
    BigInteger.prototype.shiftRight = bnShiftRight;
    BigInteger.prototype.getLowestSetBit = bnGetLowestSetBit;
    BigInteger.prototype.bitCount = bnBitCount;
    BigInteger.prototype.testBit = bnTestBit;
    BigInteger.prototype.setBit = bnSetBit;
    BigInteger.prototype.clearBit = bnClearBit;
    BigInteger.prototype.flipBit = bnFlipBit;
    BigInteger.prototype.add = bnAdd;
    BigInteger.prototype.subtract = bnSubtract;
    BigInteger.prototype.multiply = bnMultiply;
    BigInteger.prototype.divide = bnDivide;
    BigInteger.prototype.remainder = bnRemainder;
    BigInteger.prototype.divideAndRemainder = bnDivideAndRemainder;
    BigInteger.prototype.modPow = bnModPow;
    BigInteger.prototype.modInverse = bnModInverse;
    BigInteger.prototype.pow = bnPow;
    BigInteger.prototype.gcd = bnGCD;
    BigInteger.prototype.isProbablePrime = bnIsProbablePrime;

    // JSBN-specific extension
    BigInteger.prototype.square = bnSquare;

    // Expose the Barrett function
    BigInteger.prototype.Barrett = Barrett;

    // BigInteger interfaces not implemented in jsbn:

    // BigInteger(int signum, byte[] magnitude)
    // double doubleValue()
    // float floatValue()
    // int hashCode()
    // long longValue()
    // static BigInteger valueOf(long val)

	// Random number generator - requires a PRNG backend, e.g. prng4.js

	// For best results, put code like
	// <body onClick='rng_seed_time();' onKeyPress='rng_seed_time();'>
	// in your main HTML document.

	var rng_state;
	var rng_pool;
	var rng_pptr;

	// Mix in a 32-bit integer into the pool
	function rng_seed_int(x) {
	  rng_pool[rng_pptr++] ^= x & 255;
	  rng_pool[rng_pptr++] ^= (x >> 8) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 16) & 255;
	  rng_pool[rng_pptr++] ^= (x >> 24) & 255;
	  if(rng_pptr >= rng_psize) rng_pptr -= rng_psize;
	}

	// Mix in the current time (w/milliseconds) into the pool
	function rng_seed_time() {
	  rng_seed_int(new Date().getTime());
	}

	// Initialize the pool with junk if needed.
	if(rng_pool == null) {
	  rng_pool = new Array();
	  rng_pptr = 0;
	  var t;
	  if(typeof window !== "undefined" && window.crypto) {
		if (window.crypto.getRandomValues) {
		  // Use webcrypto if available
		  var ua = new Uint8Array(32);
		  window.crypto.getRandomValues(ua);
		  for(t = 0; t < 32; ++t)
			rng_pool[rng_pptr++] = ua[t];
		}
		else if(navigator.appName == "Netscape" && navigator.appVersion < "5") {
		  // Extract entropy (256 bits) from NS4 RNG if available
		  var z = window.crypto.random(32);
		  for(t = 0; t < z.length; ++t)
			rng_pool[rng_pptr++] = z.charCodeAt(t) & 255;
		}
	  }
	  while(rng_pptr < rng_psize) {  // extract some randomness from Math.random()
		t = Math.floor(65536 * Math.random());
		rng_pool[rng_pptr++] = t >>> 8;
		rng_pool[rng_pptr++] = t & 255;
	  }
	  rng_pptr = 0;
	  rng_seed_time();
	  //rng_seed_int(window.screenX);
	  //rng_seed_int(window.screenY);
	}

	function rng_get_byte() {
	  if(rng_state == null) {
		rng_seed_time();
		rng_state = prng_newstate();
		rng_state.init(rng_pool);
		for(rng_pptr = 0; rng_pptr < rng_pool.length; ++rng_pptr)
		  rng_pool[rng_pptr] = 0;
		rng_pptr = 0;
		//rng_pool = null;
	  }
	  // TODO: allow reseeding after first request
	  return rng_state.next();
	}

	function rng_get_bytes(ba) {
	  var i;
	  for(i = 0; i < ba.length; ++i) ba[i] = rng_get_byte();
	}

	function SecureRandom() {}

	SecureRandom.prototype.nextBytes = rng_get_bytes;

	// prng4.js - uses Arcfour as a PRNG

	function Arcfour() {
	  this.i = 0;
	  this.j = 0;
	  this.S = new Array();
	}

	// Initialize arcfour context from key, an array of ints, each from [0..255]
	function ARC4init(key) {
	  var i, j, t;
	  for(i = 0; i < 256; ++i)
		this.S[i] = i;
	  j = 0;
	  for(i = 0; i < 256; ++i) {
		j = (j + this.S[i] + key[i % key.length]) & 255;
		t = this.S[i];
		this.S[i] = this.S[j];
		this.S[j] = t;
	  }
	  this.i = 0;
	  this.j = 0;
	}

	function ARC4next() {
	  var t;
	  this.i = (this.i + 1) & 255;
	  this.j = (this.j + this.S[this.i]) & 255;
	  t = this.S[this.i];
	  this.S[this.i] = this.S[this.j];
	  this.S[this.j] = t;
	  return this.S[(t + this.S[this.i]) & 255];
	}

	Arcfour.prototype.init = ARC4init;
	Arcfour.prototype.next = ARC4next;

	// Plug in your RNG constructor here
	function prng_newstate() {
	  return new Arcfour();
	}

	// Pool size must be a multiple of 4 and greater than 32.
	// An array of bytes the size of the pool will be passed to init()
	var rng_psize = 256;

  BigInteger.SecureRandom = SecureRandom;
  BigInteger.BigInteger = BigInteger;
  {
    module.exports = BigInteger;
  }

}).call(commonjsGlobal);
});

// Basic Javascript Elliptic Curve implementation
// Ported loosely from BouncyCastle's Java EC code
// Only Fp curves implemented for now

// Requires jsbn.js and jsbn2.js
var BigInteger$1 = jsbn$2.BigInteger;
var Barrett = BigInteger$1.prototype.Barrett;

// ----------------
// ECFieldElementFp

// constructor
function ECFieldElementFp(q,x) {
    this.x = x;
    // TODO if(x.compareTo(q) >= 0) error
    this.q = q;
}

function feFpEquals(other) {
    if(other == this) return true;
    return (this.q.equals(other.q) && this.x.equals(other.x));
}

function feFpToBigInteger() {
    return this.x;
}

function feFpNegate() {
    return new ECFieldElementFp(this.q, this.x.negate().mod(this.q));
}

function feFpAdd(b) {
    return new ECFieldElementFp(this.q, this.x.add(b.toBigInteger()).mod(this.q));
}

function feFpSubtract(b) {
    return new ECFieldElementFp(this.q, this.x.subtract(b.toBigInteger()).mod(this.q));
}

function feFpMultiply(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger()).mod(this.q));
}

function feFpSquare() {
    return new ECFieldElementFp(this.q, this.x.square().mod(this.q));
}

function feFpDivide(b) {
    return new ECFieldElementFp(this.q, this.x.multiply(b.toBigInteger().modInverse(this.q)).mod(this.q));
}

ECFieldElementFp.prototype.equals = feFpEquals;
ECFieldElementFp.prototype.toBigInteger = feFpToBigInteger;
ECFieldElementFp.prototype.negate = feFpNegate;
ECFieldElementFp.prototype.add = feFpAdd;
ECFieldElementFp.prototype.subtract = feFpSubtract;
ECFieldElementFp.prototype.multiply = feFpMultiply;
ECFieldElementFp.prototype.square = feFpSquare;
ECFieldElementFp.prototype.divide = feFpDivide;

// ----------------
// ECPointFp

// constructor
function ECPointFp(curve,x,y,z) {
    this.curve = curve;
    this.x = x;
    this.y = y;
    // Projective coordinates: either zinv == null or z * zinv == 1
    // z and zinv are just BigIntegers, not fieldElements
    if(z == null) {
      this.z = BigInteger$1.ONE;
    }
    else {
      this.z = z;
    }
    this.zinv = null;
    //TODO: compression flag
}

function pointFpGetX() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.x.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpGetY() {
    if(this.zinv == null) {
      this.zinv = this.z.modInverse(this.curve.q);
    }
    var r = this.y.toBigInteger().multiply(this.zinv);
    this.curve.reduce(r);
    return this.curve.fromBigInteger(r);
}

function pointFpEquals(other) {
    if(other == this) return true;
    if(this.isInfinity()) return other.isInfinity();
    if(other.isInfinity()) return this.isInfinity();
    var u, v;
    // u = Y2 * Z1 - Y1 * Z2
    u = other.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(other.z)).mod(this.curve.q);
    if(!u.equals(BigInteger$1.ZERO)) return false;
    // v = X2 * Z1 - X1 * Z2
    v = other.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(other.z)).mod(this.curve.q);
    return v.equals(BigInteger$1.ZERO);
}

function pointFpIsInfinity() {
    if((this.x == null) && (this.y == null)) return true;
    return this.z.equals(BigInteger$1.ZERO) && !this.y.toBigInteger().equals(BigInteger$1.ZERO);
}

function pointFpNegate() {
    return new ECPointFp(this.curve, this.x, this.y.negate(), this.z);
}

function pointFpAdd(b) {
    if(this.isInfinity()) return b;
    if(b.isInfinity()) return this;

    // u = Y2 * Z1 - Y1 * Z2
    var u = b.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(b.z)).mod(this.curve.q);
    // v = X2 * Z1 - X1 * Z2
    var v = b.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(b.z)).mod(this.curve.q);

    if(BigInteger$1.ZERO.equals(v)) {
        if(BigInteger$1.ZERO.equals(u)) {
            return this.twice(); // this == b, so double
        }
	return this.curve.getInfinity(); // this = -b, so infinity
    }

    var THREE = new BigInteger$1("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();
    b.x.toBigInteger();
    b.y.toBigInteger();

    var v2 = v.square();
    var v3 = v2.multiply(v);
    var x1v2 = x1.multiply(v2);
    var zu2 = u.square().multiply(this.z);

    // x3 = v * (z2 * (z1 * u^2 - 2 * x1 * v^2) - v^3)
    var x3 = zu2.subtract(x1v2.shiftLeft(1)).multiply(b.z).subtract(v3).multiply(v).mod(this.curve.q);
    // y3 = z2 * (3 * x1 * u * v^2 - y1 * v^3 - z1 * u^3) + u * v^3
    var y3 = x1v2.multiply(THREE).multiply(u).subtract(y1.multiply(v3)).subtract(zu2.multiply(u)).multiply(b.z).add(u.multiply(v3)).mod(this.curve.q);
    // z3 = v^3 * z1 * z2
    var z3 = v3.multiply(this.z).multiply(b.z).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

function pointFpTwice() {
    if(this.isInfinity()) return this;
    if(this.y.toBigInteger().signum() == 0) return this.curve.getInfinity();

    // TODO: optimized handling of constants
    var THREE = new BigInteger$1("3");
    var x1 = this.x.toBigInteger();
    var y1 = this.y.toBigInteger();

    var y1z1 = y1.multiply(this.z);
    var y1sqz1 = y1z1.multiply(y1).mod(this.curve.q);
    var a = this.curve.a.toBigInteger();

    // w = 3 * x1^2 + a * z1^2
    var w = x1.square().multiply(THREE);
    if(!BigInteger$1.ZERO.equals(a)) {
      w = w.add(this.z.square().multiply(a));
    }
    w = w.mod(this.curve.q);
    //this.curve.reduce(w);
    // x3 = 2 * y1 * z1 * (w^2 - 8 * x1 * y1^2 * z1)
    var x3 = w.square().subtract(x1.shiftLeft(3).multiply(y1sqz1)).shiftLeft(1).multiply(y1z1).mod(this.curve.q);
    // y3 = 4 * y1^2 * z1 * (3 * w * x1 - 2 * y1^2 * z1) - w^3
    var y3 = w.multiply(THREE).multiply(x1).subtract(y1sqz1.shiftLeft(1)).shiftLeft(2).multiply(y1sqz1).subtract(w.square().multiply(w)).mod(this.curve.q);
    // z3 = 8 * (y1 * z1)^3
    var z3 = y1z1.square().multiply(y1z1).shiftLeft(3).mod(this.curve.q);

    return new ECPointFp(this.curve, this.curve.fromBigInteger(x3), this.curve.fromBigInteger(y3), z3);
}

// Simple NAF (Non-Adjacent Form) multiplication algorithm
// TODO: modularize the multiplication algorithm
function pointFpMultiply(k) {
    if(this.isInfinity()) return this;
    if(k.signum() == 0) return this.curve.getInfinity();

    var e = k;
    var h = e.multiply(new BigInteger$1("3"));

    var neg = this.negate();
    var R = this;

    var i;
    for(i = h.bitLength() - 2; i > 0; --i) {
	R = R.twice();

	var hBit = h.testBit(i);
	var eBit = e.testBit(i);

	if (hBit != eBit) {
	    R = R.add(hBit ? this : neg);
	}
    }

    return R;
}

// Compute this*j + x*k (simultaneous multiplication)
function pointFpMultiplyTwo(j,x,k) {
  var i;
  if(j.bitLength() > k.bitLength())
    i = j.bitLength() - 1;
  else
    i = k.bitLength() - 1;

  var R = this.curve.getInfinity();
  var both = this.add(x);
  while(i >= 0) {
    R = R.twice();
    if(j.testBit(i)) {
      if(k.testBit(i)) {
        R = R.add(both);
      }
      else {
        R = R.add(this);
      }
    }
    else {
      if(k.testBit(i)) {
        R = R.add(x);
      }
    }
    --i;
  }

  return R;
}

ECPointFp.prototype.getX = pointFpGetX;
ECPointFp.prototype.getY = pointFpGetY;
ECPointFp.prototype.equals = pointFpEquals;
ECPointFp.prototype.isInfinity = pointFpIsInfinity;
ECPointFp.prototype.negate = pointFpNegate;
ECPointFp.prototype.add = pointFpAdd;
ECPointFp.prototype.twice = pointFpTwice;
ECPointFp.prototype.multiply = pointFpMultiply;
ECPointFp.prototype.multiplyTwo = pointFpMultiplyTwo;

// ----------------
// ECCurveFp

// constructor
function ECCurveFp(q,a,b) {
    this.q = q;
    this.a = this.fromBigInteger(a);
    this.b = this.fromBigInteger(b);
    this.infinity = new ECPointFp(this, null, null);
    this.reducer = new Barrett(this.q);
}

function curveFpGetQ() {
    return this.q;
}

function curveFpGetA() {
    return this.a;
}

function curveFpGetB() {
    return this.b;
}

function curveFpEquals(other) {
    if(other == this) return true;
    return(this.q.equals(other.q) && this.a.equals(other.a) && this.b.equals(other.b));
}

function curveFpGetInfinity() {
    return this.infinity;
}

function curveFpFromBigInteger(x) {
    return new ECFieldElementFp(this.q, x);
}

function curveReduce(x) {
    this.reducer.reduce(x);
}

function curveFpEncodePointHex(p) {
	if (p.isInfinity()) return "00";
	var xHex = p.getX().toBigInteger().toString(16);
	var yHex = p.getY().toBigInteger().toString(16);
	var oLen = this.getQ().toString(16).length;
	if ((oLen % 2) != 0) oLen++;
	while (xHex.length < oLen) {
		xHex = "0" + xHex;
	}
	while (yHex.length < oLen) {
		yHex = "0" + yHex;
	}
	return "04" + xHex + yHex;
}

ECCurveFp.prototype.getQ = curveFpGetQ;
ECCurveFp.prototype.getA = curveFpGetA;
ECCurveFp.prototype.getB = curveFpGetB;
ECCurveFp.prototype.equals = curveFpEquals;
ECCurveFp.prototype.getInfinity = curveFpGetInfinity;
ECCurveFp.prototype.fromBigInteger = curveFpFromBigInteger;
ECCurveFp.prototype.reduce = curveReduce;
//ECCurveFp.prototype.decodePointHex = curveFpDecodePointHex;
ECCurveFp.prototype.encodePointHex = curveFpEncodePointHex;

// from: https://github.com/kaielvin/jsbn-ec-point-compression
ECCurveFp.prototype.decodePointHex = function(s)
{
	var yIsEven;
    switch(parseInt(s.substr(0,2), 16)) { // first byte
    case 0:
	return this.infinity;
    case 2:
	yIsEven = false;
    case 3:
	if(yIsEven == undefined) yIsEven = true;
	var len = s.length - 2;
	var xHex = s.substr(2, len);
	var x = this.fromBigInteger(new BigInteger$1(xHex,16));
	var alpha = x.multiply(x.square().add(this.getA())).add(this.getB());
	var beta = alpha.sqrt();

    if (beta == null) throw "Invalid point compression";

    var betaValue = beta.toBigInteger();
    if (betaValue.testBit(0) != yIsEven)
    {
        // Use the other root
        beta = this.fromBigInteger(this.getQ().subtract(betaValue));
    }
    return new ECPointFp(this,x,beta);
    case 4:
    case 6:
    case 7:
	var len = (s.length - 2) / 2;
	var xHex = s.substr(2, len);
	var yHex = s.substr(len+2, len);

	return new ECPointFp(this,
			     this.fromBigInteger(new BigInteger$1(xHex, 16)),
			     this.fromBigInteger(new BigInteger$1(yHex, 16)));

    default: // unsupported
	return null;
    }
};
ECCurveFp.prototype.encodeCompressedPointHex = function(p)
{
	if (p.isInfinity()) return "00";
	var xHex = p.getX().toBigInteger().toString(16);
	var oLen = this.getQ().toString(16).length;
	if ((oLen % 2) != 0) oLen++;
	while (xHex.length < oLen)
		xHex = "0" + xHex;
	var yPrefix;
	if(p.getY().toBigInteger().isEven()) yPrefix = "02";
	else                                 yPrefix = "03";

	return yPrefix + xHex;
};


ECFieldElementFp.prototype.getR = function()
{
	if(this.r != undefined) return this.r;

    this.r = null;
    var bitLength = this.q.bitLength();
    if (bitLength > 128)
    {
        var firstWord = this.q.shiftRight(bitLength - 64);
        if (firstWord.intValue() == -1)
        {
            this.r = BigInteger$1.ONE.shiftLeft(bitLength).subtract(this.q);
        }
    }
    return this.r;
};
ECFieldElementFp.prototype.modMult = function(x1,x2)
{
    return this.modReduce(x1.multiply(x2));
};
ECFieldElementFp.prototype.modReduce = function(x)
{
    if (this.getR() != null)
    {
        var qLen = q.bitLength();
        while (x.bitLength() > (qLen + 1))
        {
            var u = x.shiftRight(qLen);
            var v = x.subtract(u.shiftLeft(qLen));
            if (!this.getR().equals(BigInteger$1.ONE))
            {
                u = u.multiply(this.getR());
            }
            x = u.add(v); 
        }
        while (x.compareTo(q) >= 0)
        {
            x = x.subtract(q);
        }
    }
    else
    {
        x = x.mod(q);
    }
    return x;
};
ECFieldElementFp.prototype.sqrt = function()
{
    if (!this.q.testBit(0)) throw "unsupported";

    // p mod 4 == 3
    if (this.q.testBit(1))
    {
    	var z = new ECFieldElementFp(this.q,this.x.modPow(this.q.shiftRight(2).add(BigInteger$1.ONE),this.q));
    	return z.square().equals(this) ? z : null;
    }

    // p mod 4 == 1
    var qMinusOne = this.q.subtract(BigInteger$1.ONE);

    var legendreExponent = qMinusOne.shiftRight(1);
    if (!(this.x.modPow(legendreExponent, this.q).equals(BigInteger$1.ONE)))
    {
        return null;
    }

    var u = qMinusOne.shiftRight(2);
    var k = u.shiftLeft(1).add(BigInteger$1.ONE);

    var Q = this.x;
    var fourQ = modDouble(modDouble(Q));

    var U, V;
    do
    {
        var P;
        do
        {
            P = new BigInteger$1(this.q.bitLength(), new SecureRandom());
        }
        while (P.compareTo(this.q) >= 0
            || !(P.multiply(P).subtract(fourQ).modPow(legendreExponent, this.q).equals(qMinusOne)));

        var result = this.lucasSequence(P, Q, k);
        U = result[0];
        V = result[1];

        if (this.modMult(V, V).equals(fourQ))
        {
            // Integer division by 2, mod q
            if (V.testBit(0))
            {
                V = V.add(q);
            }

            V = V.shiftRight(1);

            return new ECFieldElementFp(q,V);
        }
    }
    while (U.equals(BigInteger$1.ONE) || U.equals(qMinusOne));

    return null;
};
ECFieldElementFp.prototype.lucasSequence = function(P,Q,k)
{
    var n = k.bitLength();
    var s = k.getLowestSetBit();

    var Uh = BigInteger$1.ONE;
    var Vl = BigInteger$1.TWO;
    var Vh = P;
    var Ql = BigInteger$1.ONE;
    var Qh = BigInteger$1.ONE;

    for (var j = n - 1; j >= s + 1; --j)
    {
        Ql = this.modMult(Ql, Qh);

        if (k.testBit(j))
        {
            Qh = this.modMult(Ql, Q);
            Uh = this.modMult(Uh, Vh);
            Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
            Vh = this.modReduce(Vh.multiply(Vh).subtract(Qh.shiftLeft(1)));
        }
        else
        {
            Qh = Ql;
            Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
            Vh = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
            Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        }
    }

    Ql = this.modMult(Ql, Qh);
    Qh = this.modMult(Ql, Q);
    Uh = this.modReduce(Uh.multiply(Vl).subtract(Ql));
    Vl = this.modReduce(Vh.multiply(Vl).subtract(P.multiply(Ql)));
    Ql = this.modMult(Ql, Qh);

    for (var j = 1; j <= s; ++j)
    {
        Uh = this.modMult(Uh, Vl);
        Vl = this.modReduce(Vl.multiply(Vl).subtract(Ql.shiftLeft(1)));
        Ql = this.modMult(Ql, Ql);
    }

    return [ Uh, Vl ];
};

var exports = {
  ECCurveFp: ECCurveFp,
  ECPointFp: ECPointFp,
  ECFieldElementFp: ECFieldElementFp
};

var ec = exports;

var _nodeResolve_empty = {};

var _nodeResolve_empty$1 = /*#__PURE__*/Object.freeze({
         __proto__: null,
         'default': _nodeResolve_empty
});

var require$$0$3 = /*@__PURE__*/getAugmentedNamespace(_nodeResolve_empty$1);

var naclFast = createCommonjsModule(function (module) {
(function(nacl) {

// Ported in 2014 by Dmitry Chestnykh and Devi Mandiri.
// Public domain.
//
// Implementation derived from TweetNaCl version 20140427.
// See for details: http://tweetnacl.cr.yp.to/

var gf = function(init) {
  var i, r = new Float64Array(16);
  if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
  return r;
};

//  Pluggable, initialized in high-level API below.
var randombytes = function(/* x, n */) { throw new Error('no PRNG'); };

var _0 = new Uint8Array(16);
var _9 = new Uint8Array(32); _9[0] = 9;

var gf0 = gf(),
    gf1 = gf([1]),
    _121665 = gf([0xdb41, 1]),
    D = gf([0x78a3, 0x1359, 0x4dca, 0x75eb, 0xd8ab, 0x4141, 0x0a4d, 0x0070, 0xe898, 0x7779, 0x4079, 0x8cc7, 0xfe73, 0x2b6f, 0x6cee, 0x5203]),
    D2 = gf([0xf159, 0x26b2, 0x9b94, 0xebd6, 0xb156, 0x8283, 0x149a, 0x00e0, 0xd130, 0xeef3, 0x80f2, 0x198e, 0xfce7, 0x56df, 0xd9dc, 0x2406]),
    X = gf([0xd51a, 0x8f25, 0x2d60, 0xc956, 0xa7b2, 0x9525, 0xc760, 0x692c, 0xdc5c, 0xfdd6, 0xe231, 0xc0a4, 0x53fe, 0xcd6e, 0x36d3, 0x2169]),
    Y = gf([0x6658, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666, 0x6666]),
    I = gf([0xa0b0, 0x4a0e, 0x1b27, 0xc4ee, 0xe478, 0xad2f, 0x1806, 0x2f43, 0xd7a7, 0x3dfb, 0x0099, 0x2b4d, 0xdf0b, 0x4fc1, 0x2480, 0x2b83]);

function ts64(x, i, h, l) {
  x[i]   = (h >> 24) & 0xff;
  x[i+1] = (h >> 16) & 0xff;
  x[i+2] = (h >>  8) & 0xff;
  x[i+3] = h & 0xff;
  x[i+4] = (l >> 24)  & 0xff;
  x[i+5] = (l >> 16)  & 0xff;
  x[i+6] = (l >>  8)  & 0xff;
  x[i+7] = l & 0xff;
}

function vn(x, xi, y, yi, n) {
  var i,d = 0;
  for (i = 0; i < n; i++) d |= x[xi+i]^y[yi+i];
  return (1 & ((d - 1) >>> 8)) - 1;
}

function crypto_verify_16(x, xi, y, yi) {
  return vn(x,xi,y,yi,16);
}

function crypto_verify_32(x, xi, y, yi) {
  return vn(x,xi,y,yi,32);
}

function core_salsa20(o, p, k, c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }
   x0 =  x0 +  j0 | 0;
   x1 =  x1 +  j1 | 0;
   x2 =  x2 +  j2 | 0;
   x3 =  x3 +  j3 | 0;
   x4 =  x4 +  j4 | 0;
   x5 =  x5 +  j5 | 0;
   x6 =  x6 +  j6 | 0;
   x7 =  x7 +  j7 | 0;
   x8 =  x8 +  j8 | 0;
   x9 =  x9 +  j9 | 0;
  x10 = x10 + j10 | 0;
  x11 = x11 + j11 | 0;
  x12 = x12 + j12 | 0;
  x13 = x13 + j13 | 0;
  x14 = x14 + j14 | 0;
  x15 = x15 + j15 | 0;

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x1 >>>  0 & 0xff;
  o[ 5] = x1 >>>  8 & 0xff;
  o[ 6] = x1 >>> 16 & 0xff;
  o[ 7] = x1 >>> 24 & 0xff;

  o[ 8] = x2 >>>  0 & 0xff;
  o[ 9] = x2 >>>  8 & 0xff;
  o[10] = x2 >>> 16 & 0xff;
  o[11] = x2 >>> 24 & 0xff;

  o[12] = x3 >>>  0 & 0xff;
  o[13] = x3 >>>  8 & 0xff;
  o[14] = x3 >>> 16 & 0xff;
  o[15] = x3 >>> 24 & 0xff;

  o[16] = x4 >>>  0 & 0xff;
  o[17] = x4 >>>  8 & 0xff;
  o[18] = x4 >>> 16 & 0xff;
  o[19] = x4 >>> 24 & 0xff;

  o[20] = x5 >>>  0 & 0xff;
  o[21] = x5 >>>  8 & 0xff;
  o[22] = x5 >>> 16 & 0xff;
  o[23] = x5 >>> 24 & 0xff;

  o[24] = x6 >>>  0 & 0xff;
  o[25] = x6 >>>  8 & 0xff;
  o[26] = x6 >>> 16 & 0xff;
  o[27] = x6 >>> 24 & 0xff;

  o[28] = x7 >>>  0 & 0xff;
  o[29] = x7 >>>  8 & 0xff;
  o[30] = x7 >>> 16 & 0xff;
  o[31] = x7 >>> 24 & 0xff;

  o[32] = x8 >>>  0 & 0xff;
  o[33] = x8 >>>  8 & 0xff;
  o[34] = x8 >>> 16 & 0xff;
  o[35] = x8 >>> 24 & 0xff;

  o[36] = x9 >>>  0 & 0xff;
  o[37] = x9 >>>  8 & 0xff;
  o[38] = x9 >>> 16 & 0xff;
  o[39] = x9 >>> 24 & 0xff;

  o[40] = x10 >>>  0 & 0xff;
  o[41] = x10 >>>  8 & 0xff;
  o[42] = x10 >>> 16 & 0xff;
  o[43] = x10 >>> 24 & 0xff;

  o[44] = x11 >>>  0 & 0xff;
  o[45] = x11 >>>  8 & 0xff;
  o[46] = x11 >>> 16 & 0xff;
  o[47] = x11 >>> 24 & 0xff;

  o[48] = x12 >>>  0 & 0xff;
  o[49] = x12 >>>  8 & 0xff;
  o[50] = x12 >>> 16 & 0xff;
  o[51] = x12 >>> 24 & 0xff;

  o[52] = x13 >>>  0 & 0xff;
  o[53] = x13 >>>  8 & 0xff;
  o[54] = x13 >>> 16 & 0xff;
  o[55] = x13 >>> 24 & 0xff;

  o[56] = x14 >>>  0 & 0xff;
  o[57] = x14 >>>  8 & 0xff;
  o[58] = x14 >>> 16 & 0xff;
  o[59] = x14 >>> 24 & 0xff;

  o[60] = x15 >>>  0 & 0xff;
  o[61] = x15 >>>  8 & 0xff;
  o[62] = x15 >>> 16 & 0xff;
  o[63] = x15 >>> 24 & 0xff;
}

function core_hsalsa20(o,p,k,c) {
  var j0  = c[ 0] & 0xff | (c[ 1] & 0xff)<<8 | (c[ 2] & 0xff)<<16 | (c[ 3] & 0xff)<<24,
      j1  = k[ 0] & 0xff | (k[ 1] & 0xff)<<8 | (k[ 2] & 0xff)<<16 | (k[ 3] & 0xff)<<24,
      j2  = k[ 4] & 0xff | (k[ 5] & 0xff)<<8 | (k[ 6] & 0xff)<<16 | (k[ 7] & 0xff)<<24,
      j3  = k[ 8] & 0xff | (k[ 9] & 0xff)<<8 | (k[10] & 0xff)<<16 | (k[11] & 0xff)<<24,
      j4  = k[12] & 0xff | (k[13] & 0xff)<<8 | (k[14] & 0xff)<<16 | (k[15] & 0xff)<<24,
      j5  = c[ 4] & 0xff | (c[ 5] & 0xff)<<8 | (c[ 6] & 0xff)<<16 | (c[ 7] & 0xff)<<24,
      j6  = p[ 0] & 0xff | (p[ 1] & 0xff)<<8 | (p[ 2] & 0xff)<<16 | (p[ 3] & 0xff)<<24,
      j7  = p[ 4] & 0xff | (p[ 5] & 0xff)<<8 | (p[ 6] & 0xff)<<16 | (p[ 7] & 0xff)<<24,
      j8  = p[ 8] & 0xff | (p[ 9] & 0xff)<<8 | (p[10] & 0xff)<<16 | (p[11] & 0xff)<<24,
      j9  = p[12] & 0xff | (p[13] & 0xff)<<8 | (p[14] & 0xff)<<16 | (p[15] & 0xff)<<24,
      j10 = c[ 8] & 0xff | (c[ 9] & 0xff)<<8 | (c[10] & 0xff)<<16 | (c[11] & 0xff)<<24,
      j11 = k[16] & 0xff | (k[17] & 0xff)<<8 | (k[18] & 0xff)<<16 | (k[19] & 0xff)<<24,
      j12 = k[20] & 0xff | (k[21] & 0xff)<<8 | (k[22] & 0xff)<<16 | (k[23] & 0xff)<<24,
      j13 = k[24] & 0xff | (k[25] & 0xff)<<8 | (k[26] & 0xff)<<16 | (k[27] & 0xff)<<24,
      j14 = k[28] & 0xff | (k[29] & 0xff)<<8 | (k[30] & 0xff)<<16 | (k[31] & 0xff)<<24,
      j15 = c[12] & 0xff | (c[13] & 0xff)<<8 | (c[14] & 0xff)<<16 | (c[15] & 0xff)<<24;

  var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7,
      x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14,
      x15 = j15, u;

  for (var i = 0; i < 20; i += 2) {
    u = x0 + x12 | 0;
    x4 ^= u<<7 | u>>>(32-7);
    u = x4 + x0 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x4 | 0;
    x12 ^= u<<13 | u>>>(32-13);
    u = x12 + x8 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x1 | 0;
    x9 ^= u<<7 | u>>>(32-7);
    u = x9 + x5 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x9 | 0;
    x1 ^= u<<13 | u>>>(32-13);
    u = x1 + x13 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x6 | 0;
    x14 ^= u<<7 | u>>>(32-7);
    u = x14 + x10 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x14 | 0;
    x6 ^= u<<13 | u>>>(32-13);
    u = x6 + x2 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x11 | 0;
    x3 ^= u<<7 | u>>>(32-7);
    u = x3 + x15 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x3 | 0;
    x11 ^= u<<13 | u>>>(32-13);
    u = x11 + x7 | 0;
    x15 ^= u<<18 | u>>>(32-18);

    u = x0 + x3 | 0;
    x1 ^= u<<7 | u>>>(32-7);
    u = x1 + x0 | 0;
    x2 ^= u<<9 | u>>>(32-9);
    u = x2 + x1 | 0;
    x3 ^= u<<13 | u>>>(32-13);
    u = x3 + x2 | 0;
    x0 ^= u<<18 | u>>>(32-18);

    u = x5 + x4 | 0;
    x6 ^= u<<7 | u>>>(32-7);
    u = x6 + x5 | 0;
    x7 ^= u<<9 | u>>>(32-9);
    u = x7 + x6 | 0;
    x4 ^= u<<13 | u>>>(32-13);
    u = x4 + x7 | 0;
    x5 ^= u<<18 | u>>>(32-18);

    u = x10 + x9 | 0;
    x11 ^= u<<7 | u>>>(32-7);
    u = x11 + x10 | 0;
    x8 ^= u<<9 | u>>>(32-9);
    u = x8 + x11 | 0;
    x9 ^= u<<13 | u>>>(32-13);
    u = x9 + x8 | 0;
    x10 ^= u<<18 | u>>>(32-18);

    u = x15 + x14 | 0;
    x12 ^= u<<7 | u>>>(32-7);
    u = x12 + x15 | 0;
    x13 ^= u<<9 | u>>>(32-9);
    u = x13 + x12 | 0;
    x14 ^= u<<13 | u>>>(32-13);
    u = x14 + x13 | 0;
    x15 ^= u<<18 | u>>>(32-18);
  }

  o[ 0] = x0 >>>  0 & 0xff;
  o[ 1] = x0 >>>  8 & 0xff;
  o[ 2] = x0 >>> 16 & 0xff;
  o[ 3] = x0 >>> 24 & 0xff;

  o[ 4] = x5 >>>  0 & 0xff;
  o[ 5] = x5 >>>  8 & 0xff;
  o[ 6] = x5 >>> 16 & 0xff;
  o[ 7] = x5 >>> 24 & 0xff;

  o[ 8] = x10 >>>  0 & 0xff;
  o[ 9] = x10 >>>  8 & 0xff;
  o[10] = x10 >>> 16 & 0xff;
  o[11] = x10 >>> 24 & 0xff;

  o[12] = x15 >>>  0 & 0xff;
  o[13] = x15 >>>  8 & 0xff;
  o[14] = x15 >>> 16 & 0xff;
  o[15] = x15 >>> 24 & 0xff;

  o[16] = x6 >>>  0 & 0xff;
  o[17] = x6 >>>  8 & 0xff;
  o[18] = x6 >>> 16 & 0xff;
  o[19] = x6 >>> 24 & 0xff;

  o[20] = x7 >>>  0 & 0xff;
  o[21] = x7 >>>  8 & 0xff;
  o[22] = x7 >>> 16 & 0xff;
  o[23] = x7 >>> 24 & 0xff;

  o[24] = x8 >>>  0 & 0xff;
  o[25] = x8 >>>  8 & 0xff;
  o[26] = x8 >>> 16 & 0xff;
  o[27] = x8 >>> 24 & 0xff;

  o[28] = x9 >>>  0 & 0xff;
  o[29] = x9 >>>  8 & 0xff;
  o[30] = x9 >>> 16 & 0xff;
  o[31] = x9 >>> 24 & 0xff;
}

function crypto_core_salsa20(out,inp,k,c) {
  core_salsa20(out,inp,k,c);
}

function crypto_core_hsalsa20(out,inp,k,c) {
  core_hsalsa20(out,inp,k,c);
}

var sigma = new Uint8Array([101, 120, 112, 97, 110, 100, 32, 51, 50, 45, 98, 121, 116, 101, 32, 107]);
            // "expand 32-byte k"

function crypto_stream_salsa20_xor(c,cpos,m,mpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = m[mpos+i] ^ x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
    mpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = m[mpos+i] ^ x[i];
  }
  return 0;
}

function crypto_stream_salsa20(c,cpos,b,n,k) {
  var z = new Uint8Array(16), x = new Uint8Array(64);
  var u, i;
  for (i = 0; i < 16; i++) z[i] = 0;
  for (i = 0; i < 8; i++) z[i] = n[i];
  while (b >= 64) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < 64; i++) c[cpos+i] = x[i];
    u = 1;
    for (i = 8; i < 16; i++) {
      u = u + (z[i] & 0xff) | 0;
      z[i] = u & 0xff;
      u >>>= 8;
    }
    b -= 64;
    cpos += 64;
  }
  if (b > 0) {
    crypto_core_salsa20(x,z,k,sigma);
    for (i = 0; i < b; i++) c[cpos+i] = x[i];
  }
  return 0;
}

function crypto_stream(c,cpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20(c,cpos,d,sn,s);
}

function crypto_stream_xor(c,cpos,m,mpos,d,n,k) {
  var s = new Uint8Array(32);
  crypto_core_hsalsa20(s,n,k,sigma);
  var sn = new Uint8Array(8);
  for (var i = 0; i < 8; i++) sn[i] = n[i+16];
  return crypto_stream_salsa20_xor(c,cpos,m,mpos,d,sn,s);
}

/*
* Port of Andrew Moon's Poly1305-donna-16. Public domain.
* https://github.com/floodyberry/poly1305-donna
*/

var poly1305 = function(key) {
  this.buffer = new Uint8Array(16);
  this.r = new Uint16Array(10);
  this.h = new Uint16Array(10);
  this.pad = new Uint16Array(8);
  this.leftover = 0;
  this.fin = 0;

  var t0, t1, t2, t3, t4, t5, t6, t7;

  t0 = key[ 0] & 0xff | (key[ 1] & 0xff) << 8; this.r[0] = ( t0                     ) & 0x1fff;
  t1 = key[ 2] & 0xff | (key[ 3] & 0xff) << 8; this.r[1] = ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
  t2 = key[ 4] & 0xff | (key[ 5] & 0xff) << 8; this.r[2] = ((t1 >>> 10) | (t2 <<  6)) & 0x1f03;
  t3 = key[ 6] & 0xff | (key[ 7] & 0xff) << 8; this.r[3] = ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
  t4 = key[ 8] & 0xff | (key[ 9] & 0xff) << 8; this.r[4] = ((t3 >>>  4) | (t4 << 12)) & 0x00ff;
  this.r[5] = ((t4 >>>  1)) & 0x1ffe;
  t5 = key[10] & 0xff | (key[11] & 0xff) << 8; this.r[6] = ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
  t6 = key[12] & 0xff | (key[13] & 0xff) << 8; this.r[7] = ((t5 >>> 11) | (t6 <<  5)) & 0x1f81;
  t7 = key[14] & 0xff | (key[15] & 0xff) << 8; this.r[8] = ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
  this.r[9] = ((t7 >>>  5)) & 0x007f;

  this.pad[0] = key[16] & 0xff | (key[17] & 0xff) << 8;
  this.pad[1] = key[18] & 0xff | (key[19] & 0xff) << 8;
  this.pad[2] = key[20] & 0xff | (key[21] & 0xff) << 8;
  this.pad[3] = key[22] & 0xff | (key[23] & 0xff) << 8;
  this.pad[4] = key[24] & 0xff | (key[25] & 0xff) << 8;
  this.pad[5] = key[26] & 0xff | (key[27] & 0xff) << 8;
  this.pad[6] = key[28] & 0xff | (key[29] & 0xff) << 8;
  this.pad[7] = key[30] & 0xff | (key[31] & 0xff) << 8;
};

poly1305.prototype.blocks = function(m, mpos, bytes) {
  var hibit = this.fin ? 0 : (1 << 11);
  var t0, t1, t2, t3, t4, t5, t6, t7, c;
  var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;

  var h0 = this.h[0],
      h1 = this.h[1],
      h2 = this.h[2],
      h3 = this.h[3],
      h4 = this.h[4],
      h5 = this.h[5],
      h6 = this.h[6],
      h7 = this.h[7],
      h8 = this.h[8],
      h9 = this.h[9];

  var r0 = this.r[0],
      r1 = this.r[1],
      r2 = this.r[2],
      r3 = this.r[3],
      r4 = this.r[4],
      r5 = this.r[5],
      r6 = this.r[6],
      r7 = this.r[7],
      r8 = this.r[8],
      r9 = this.r[9];

  while (bytes >= 16) {
    t0 = m[mpos+ 0] & 0xff | (m[mpos+ 1] & 0xff) << 8; h0 += ( t0                     ) & 0x1fff;
    t1 = m[mpos+ 2] & 0xff | (m[mpos+ 3] & 0xff) << 8; h1 += ((t0 >>> 13) | (t1 <<  3)) & 0x1fff;
    t2 = m[mpos+ 4] & 0xff | (m[mpos+ 5] & 0xff) << 8; h2 += ((t1 >>> 10) | (t2 <<  6)) & 0x1fff;
    t3 = m[mpos+ 6] & 0xff | (m[mpos+ 7] & 0xff) << 8; h3 += ((t2 >>>  7) | (t3 <<  9)) & 0x1fff;
    t4 = m[mpos+ 8] & 0xff | (m[mpos+ 9] & 0xff) << 8; h4 += ((t3 >>>  4) | (t4 << 12)) & 0x1fff;
    h5 += ((t4 >>>  1)) & 0x1fff;
    t5 = m[mpos+10] & 0xff | (m[mpos+11] & 0xff) << 8; h6 += ((t4 >>> 14) | (t5 <<  2)) & 0x1fff;
    t6 = m[mpos+12] & 0xff | (m[mpos+13] & 0xff) << 8; h7 += ((t5 >>> 11) | (t6 <<  5)) & 0x1fff;
    t7 = m[mpos+14] & 0xff | (m[mpos+15] & 0xff) << 8; h8 += ((t6 >>>  8) | (t7 <<  8)) & 0x1fff;
    h9 += ((t7 >>> 5)) | hibit;

    c = 0;

    d0 = c;
    d0 += h0 * r0;
    d0 += h1 * (5 * r9);
    d0 += h2 * (5 * r8);
    d0 += h3 * (5 * r7);
    d0 += h4 * (5 * r6);
    c = (d0 >>> 13); d0 &= 0x1fff;
    d0 += h5 * (5 * r5);
    d0 += h6 * (5 * r4);
    d0 += h7 * (5 * r3);
    d0 += h8 * (5 * r2);
    d0 += h9 * (5 * r1);
    c += (d0 >>> 13); d0 &= 0x1fff;

    d1 = c;
    d1 += h0 * r1;
    d1 += h1 * r0;
    d1 += h2 * (5 * r9);
    d1 += h3 * (5 * r8);
    d1 += h4 * (5 * r7);
    c = (d1 >>> 13); d1 &= 0x1fff;
    d1 += h5 * (5 * r6);
    d1 += h6 * (5 * r5);
    d1 += h7 * (5 * r4);
    d1 += h8 * (5 * r3);
    d1 += h9 * (5 * r2);
    c += (d1 >>> 13); d1 &= 0x1fff;

    d2 = c;
    d2 += h0 * r2;
    d2 += h1 * r1;
    d2 += h2 * r0;
    d2 += h3 * (5 * r9);
    d2 += h4 * (5 * r8);
    c = (d2 >>> 13); d2 &= 0x1fff;
    d2 += h5 * (5 * r7);
    d2 += h6 * (5 * r6);
    d2 += h7 * (5 * r5);
    d2 += h8 * (5 * r4);
    d2 += h9 * (5 * r3);
    c += (d2 >>> 13); d2 &= 0x1fff;

    d3 = c;
    d3 += h0 * r3;
    d3 += h1 * r2;
    d3 += h2 * r1;
    d3 += h3 * r0;
    d3 += h4 * (5 * r9);
    c = (d3 >>> 13); d3 &= 0x1fff;
    d3 += h5 * (5 * r8);
    d3 += h6 * (5 * r7);
    d3 += h7 * (5 * r6);
    d3 += h8 * (5 * r5);
    d3 += h9 * (5 * r4);
    c += (d3 >>> 13); d3 &= 0x1fff;

    d4 = c;
    d4 += h0 * r4;
    d4 += h1 * r3;
    d4 += h2 * r2;
    d4 += h3 * r1;
    d4 += h4 * r0;
    c = (d4 >>> 13); d4 &= 0x1fff;
    d4 += h5 * (5 * r9);
    d4 += h6 * (5 * r8);
    d4 += h7 * (5 * r7);
    d4 += h8 * (5 * r6);
    d4 += h9 * (5 * r5);
    c += (d4 >>> 13); d4 &= 0x1fff;

    d5 = c;
    d5 += h0 * r5;
    d5 += h1 * r4;
    d5 += h2 * r3;
    d5 += h3 * r2;
    d5 += h4 * r1;
    c = (d5 >>> 13); d5 &= 0x1fff;
    d5 += h5 * r0;
    d5 += h6 * (5 * r9);
    d5 += h7 * (5 * r8);
    d5 += h8 * (5 * r7);
    d5 += h9 * (5 * r6);
    c += (d5 >>> 13); d5 &= 0x1fff;

    d6 = c;
    d6 += h0 * r6;
    d6 += h1 * r5;
    d6 += h2 * r4;
    d6 += h3 * r3;
    d6 += h4 * r2;
    c = (d6 >>> 13); d6 &= 0x1fff;
    d6 += h5 * r1;
    d6 += h6 * r0;
    d6 += h7 * (5 * r9);
    d6 += h8 * (5 * r8);
    d6 += h9 * (5 * r7);
    c += (d6 >>> 13); d6 &= 0x1fff;

    d7 = c;
    d7 += h0 * r7;
    d7 += h1 * r6;
    d7 += h2 * r5;
    d7 += h3 * r4;
    d7 += h4 * r3;
    c = (d7 >>> 13); d7 &= 0x1fff;
    d7 += h5 * r2;
    d7 += h6 * r1;
    d7 += h7 * r0;
    d7 += h8 * (5 * r9);
    d7 += h9 * (5 * r8);
    c += (d7 >>> 13); d7 &= 0x1fff;

    d8 = c;
    d8 += h0 * r8;
    d8 += h1 * r7;
    d8 += h2 * r6;
    d8 += h3 * r5;
    d8 += h4 * r4;
    c = (d8 >>> 13); d8 &= 0x1fff;
    d8 += h5 * r3;
    d8 += h6 * r2;
    d8 += h7 * r1;
    d8 += h8 * r0;
    d8 += h9 * (5 * r9);
    c += (d8 >>> 13); d8 &= 0x1fff;

    d9 = c;
    d9 += h0 * r9;
    d9 += h1 * r8;
    d9 += h2 * r7;
    d9 += h3 * r6;
    d9 += h4 * r5;
    c = (d9 >>> 13); d9 &= 0x1fff;
    d9 += h5 * r4;
    d9 += h6 * r3;
    d9 += h7 * r2;
    d9 += h8 * r1;
    d9 += h9 * r0;
    c += (d9 >>> 13); d9 &= 0x1fff;

    c = (((c << 2) + c)) | 0;
    c = (c + d0) | 0;
    d0 = c & 0x1fff;
    c = (c >>> 13);
    d1 += c;

    h0 = d0;
    h1 = d1;
    h2 = d2;
    h3 = d3;
    h4 = d4;
    h5 = d5;
    h6 = d6;
    h7 = d7;
    h8 = d8;
    h9 = d9;

    mpos += 16;
    bytes -= 16;
  }
  this.h[0] = h0;
  this.h[1] = h1;
  this.h[2] = h2;
  this.h[3] = h3;
  this.h[4] = h4;
  this.h[5] = h5;
  this.h[6] = h6;
  this.h[7] = h7;
  this.h[8] = h8;
  this.h[9] = h9;
};

poly1305.prototype.finish = function(mac, macpos) {
  var g = new Uint16Array(10);
  var c, mask, f, i;

  if (this.leftover) {
    i = this.leftover;
    this.buffer[i++] = 1;
    for (; i < 16; i++) this.buffer[i] = 0;
    this.fin = 1;
    this.blocks(this.buffer, 0, 16);
  }

  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  for (i = 2; i < 10; i++) {
    this.h[i] += c;
    c = this.h[i] >>> 13;
    this.h[i] &= 0x1fff;
  }
  this.h[0] += (c * 5);
  c = this.h[0] >>> 13;
  this.h[0] &= 0x1fff;
  this.h[1] += c;
  c = this.h[1] >>> 13;
  this.h[1] &= 0x1fff;
  this.h[2] += c;

  g[0] = this.h[0] + 5;
  c = g[0] >>> 13;
  g[0] &= 0x1fff;
  for (i = 1; i < 10; i++) {
    g[i] = this.h[i] + c;
    c = g[i] >>> 13;
    g[i] &= 0x1fff;
  }
  g[9] -= (1 << 13);

  mask = (c ^ 1) - 1;
  for (i = 0; i < 10; i++) g[i] &= mask;
  mask = ~mask;
  for (i = 0; i < 10; i++) this.h[i] = (this.h[i] & mask) | g[i];

  this.h[0] = ((this.h[0]       ) | (this.h[1] << 13)                    ) & 0xffff;
  this.h[1] = ((this.h[1] >>>  3) | (this.h[2] << 10)                    ) & 0xffff;
  this.h[2] = ((this.h[2] >>>  6) | (this.h[3] <<  7)                    ) & 0xffff;
  this.h[3] = ((this.h[3] >>>  9) | (this.h[4] <<  4)                    ) & 0xffff;
  this.h[4] = ((this.h[4] >>> 12) | (this.h[5] <<  1) | (this.h[6] << 14)) & 0xffff;
  this.h[5] = ((this.h[6] >>>  2) | (this.h[7] << 11)                    ) & 0xffff;
  this.h[6] = ((this.h[7] >>>  5) | (this.h[8] <<  8)                    ) & 0xffff;
  this.h[7] = ((this.h[8] >>>  8) | (this.h[9] <<  5)                    ) & 0xffff;

  f = this.h[0] + this.pad[0];
  this.h[0] = f & 0xffff;
  for (i = 1; i < 8; i++) {
    f = (((this.h[i] + this.pad[i]) | 0) + (f >>> 16)) | 0;
    this.h[i] = f & 0xffff;
  }

  mac[macpos+ 0] = (this.h[0] >>> 0) & 0xff;
  mac[macpos+ 1] = (this.h[0] >>> 8) & 0xff;
  mac[macpos+ 2] = (this.h[1] >>> 0) & 0xff;
  mac[macpos+ 3] = (this.h[1] >>> 8) & 0xff;
  mac[macpos+ 4] = (this.h[2] >>> 0) & 0xff;
  mac[macpos+ 5] = (this.h[2] >>> 8) & 0xff;
  mac[macpos+ 6] = (this.h[3] >>> 0) & 0xff;
  mac[macpos+ 7] = (this.h[3] >>> 8) & 0xff;
  mac[macpos+ 8] = (this.h[4] >>> 0) & 0xff;
  mac[macpos+ 9] = (this.h[4] >>> 8) & 0xff;
  mac[macpos+10] = (this.h[5] >>> 0) & 0xff;
  mac[macpos+11] = (this.h[5] >>> 8) & 0xff;
  mac[macpos+12] = (this.h[6] >>> 0) & 0xff;
  mac[macpos+13] = (this.h[6] >>> 8) & 0xff;
  mac[macpos+14] = (this.h[7] >>> 0) & 0xff;
  mac[macpos+15] = (this.h[7] >>> 8) & 0xff;
};

poly1305.prototype.update = function(m, mpos, bytes) {
  var i, want;

  if (this.leftover) {
    want = (16 - this.leftover);
    if (want > bytes)
      want = bytes;
    for (i = 0; i < want; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    bytes -= want;
    mpos += want;
    this.leftover += want;
    if (this.leftover < 16)
      return;
    this.blocks(this.buffer, 0, 16);
    this.leftover = 0;
  }

  if (bytes >= 16) {
    want = bytes - (bytes % 16);
    this.blocks(m, mpos, want);
    mpos += want;
    bytes -= want;
  }

  if (bytes) {
    for (i = 0; i < bytes; i++)
      this.buffer[this.leftover + i] = m[mpos+i];
    this.leftover += bytes;
  }
};

function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
  var s = new poly1305(k);
  s.update(m, mpos, n);
  s.finish(out, outpos);
  return 0;
}

function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
  var x = new Uint8Array(16);
  crypto_onetimeauth(x,0,m,mpos,n,k);
  return crypto_verify_16(h,hpos,x,0);
}

function crypto_secretbox(c,m,d,n,k) {
  var i;
  if (d < 32) return -1;
  crypto_stream_xor(c,0,m,0,d,n,k);
  crypto_onetimeauth(c, 16, c, 32, d - 32, c);
  for (i = 0; i < 16; i++) c[i] = 0;
  return 0;
}

function crypto_secretbox_open(m,c,d,n,k) {
  var i;
  var x = new Uint8Array(32);
  if (d < 32) return -1;
  crypto_stream(x,0,32,n,k);
  if (crypto_onetimeauth_verify(c, 16,c, 32,d - 32,x) !== 0) return -1;
  crypto_stream_xor(m,0,c,0,d,n,k);
  for (i = 0; i < 32; i++) m[i] = 0;
  return 0;
}

function set25519(r, a) {
  var i;
  for (i = 0; i < 16; i++) r[i] = a[i]|0;
}

function car25519(o) {
  var i, v, c = 1;
  for (i = 0; i < 16; i++) {
    v = o[i] + c + 65535;
    c = Math.floor(v / 65536);
    o[i] = v - c * 65536;
  }
  o[0] += c-1 + 37 * (c-1);
}

function sel25519(p, q, b) {
  var t, c = ~(b-1);
  for (var i = 0; i < 16; i++) {
    t = c & (p[i] ^ q[i]);
    p[i] ^= t;
    q[i] ^= t;
  }
}

function pack25519(o, n) {
  var i, j, b;
  var m = gf(), t = gf();
  for (i = 0; i < 16; i++) t[i] = n[i];
  car25519(t);
  car25519(t);
  car25519(t);
  for (j = 0; j < 2; j++) {
    m[0] = t[0] - 0xffed;
    for (i = 1; i < 15; i++) {
      m[i] = t[i] - 0xffff - ((m[i-1]>>16) & 1);
      m[i-1] &= 0xffff;
    }
    m[15] = t[15] - 0x7fff - ((m[14]>>16) & 1);
    b = (m[15]>>16) & 1;
    m[14] &= 0xffff;
    sel25519(t, m, 1-b);
  }
  for (i = 0; i < 16; i++) {
    o[2*i] = t[i] & 0xff;
    o[2*i+1] = t[i]>>8;
  }
}

function neq25519(a, b) {
  var c = new Uint8Array(32), d = new Uint8Array(32);
  pack25519(c, a);
  pack25519(d, b);
  return crypto_verify_32(c, 0, d, 0);
}

function par25519(a) {
  var d = new Uint8Array(32);
  pack25519(d, a);
  return d[0] & 1;
}

function unpack25519(o, n) {
  var i;
  for (i = 0; i < 16; i++) o[i] = n[2*i] + (n[2*i+1] << 8);
  o[15] &= 0x7fff;
}

function A(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
}

function Z(o, a, b) {
  for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
}

function M(o, a, b) {
  var v, c,
     t0 = 0,  t1 = 0,  t2 = 0,  t3 = 0,  t4 = 0,  t5 = 0,  t6 = 0,  t7 = 0,
     t8 = 0,  t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0,
    t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0,
    t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0,
    b0 = b[0],
    b1 = b[1],
    b2 = b[2],
    b3 = b[3],
    b4 = b[4],
    b5 = b[5],
    b6 = b[6],
    b7 = b[7],
    b8 = b[8],
    b9 = b[9],
    b10 = b[10],
    b11 = b[11],
    b12 = b[12],
    b13 = b[13],
    b14 = b[14],
    b15 = b[15];

  v = a[0];
  t0 += v * b0;
  t1 += v * b1;
  t2 += v * b2;
  t3 += v * b3;
  t4 += v * b4;
  t5 += v * b5;
  t6 += v * b6;
  t7 += v * b7;
  t8 += v * b8;
  t9 += v * b9;
  t10 += v * b10;
  t11 += v * b11;
  t12 += v * b12;
  t13 += v * b13;
  t14 += v * b14;
  t15 += v * b15;
  v = a[1];
  t1 += v * b0;
  t2 += v * b1;
  t3 += v * b2;
  t4 += v * b3;
  t5 += v * b4;
  t6 += v * b5;
  t7 += v * b6;
  t8 += v * b7;
  t9 += v * b8;
  t10 += v * b9;
  t11 += v * b10;
  t12 += v * b11;
  t13 += v * b12;
  t14 += v * b13;
  t15 += v * b14;
  t16 += v * b15;
  v = a[2];
  t2 += v * b0;
  t3 += v * b1;
  t4 += v * b2;
  t5 += v * b3;
  t6 += v * b4;
  t7 += v * b5;
  t8 += v * b6;
  t9 += v * b7;
  t10 += v * b8;
  t11 += v * b9;
  t12 += v * b10;
  t13 += v * b11;
  t14 += v * b12;
  t15 += v * b13;
  t16 += v * b14;
  t17 += v * b15;
  v = a[3];
  t3 += v * b0;
  t4 += v * b1;
  t5 += v * b2;
  t6 += v * b3;
  t7 += v * b4;
  t8 += v * b5;
  t9 += v * b6;
  t10 += v * b7;
  t11 += v * b8;
  t12 += v * b9;
  t13 += v * b10;
  t14 += v * b11;
  t15 += v * b12;
  t16 += v * b13;
  t17 += v * b14;
  t18 += v * b15;
  v = a[4];
  t4 += v * b0;
  t5 += v * b1;
  t6 += v * b2;
  t7 += v * b3;
  t8 += v * b4;
  t9 += v * b5;
  t10 += v * b6;
  t11 += v * b7;
  t12 += v * b8;
  t13 += v * b9;
  t14 += v * b10;
  t15 += v * b11;
  t16 += v * b12;
  t17 += v * b13;
  t18 += v * b14;
  t19 += v * b15;
  v = a[5];
  t5 += v * b0;
  t6 += v * b1;
  t7 += v * b2;
  t8 += v * b3;
  t9 += v * b4;
  t10 += v * b5;
  t11 += v * b6;
  t12 += v * b7;
  t13 += v * b8;
  t14 += v * b9;
  t15 += v * b10;
  t16 += v * b11;
  t17 += v * b12;
  t18 += v * b13;
  t19 += v * b14;
  t20 += v * b15;
  v = a[6];
  t6 += v * b0;
  t7 += v * b1;
  t8 += v * b2;
  t9 += v * b3;
  t10 += v * b4;
  t11 += v * b5;
  t12 += v * b6;
  t13 += v * b7;
  t14 += v * b8;
  t15 += v * b9;
  t16 += v * b10;
  t17 += v * b11;
  t18 += v * b12;
  t19 += v * b13;
  t20 += v * b14;
  t21 += v * b15;
  v = a[7];
  t7 += v * b0;
  t8 += v * b1;
  t9 += v * b2;
  t10 += v * b3;
  t11 += v * b4;
  t12 += v * b5;
  t13 += v * b6;
  t14 += v * b7;
  t15 += v * b8;
  t16 += v * b9;
  t17 += v * b10;
  t18 += v * b11;
  t19 += v * b12;
  t20 += v * b13;
  t21 += v * b14;
  t22 += v * b15;
  v = a[8];
  t8 += v * b0;
  t9 += v * b1;
  t10 += v * b2;
  t11 += v * b3;
  t12 += v * b4;
  t13 += v * b5;
  t14 += v * b6;
  t15 += v * b7;
  t16 += v * b8;
  t17 += v * b9;
  t18 += v * b10;
  t19 += v * b11;
  t20 += v * b12;
  t21 += v * b13;
  t22 += v * b14;
  t23 += v * b15;
  v = a[9];
  t9 += v * b0;
  t10 += v * b1;
  t11 += v * b2;
  t12 += v * b3;
  t13 += v * b4;
  t14 += v * b5;
  t15 += v * b6;
  t16 += v * b7;
  t17 += v * b8;
  t18 += v * b9;
  t19 += v * b10;
  t20 += v * b11;
  t21 += v * b12;
  t22 += v * b13;
  t23 += v * b14;
  t24 += v * b15;
  v = a[10];
  t10 += v * b0;
  t11 += v * b1;
  t12 += v * b2;
  t13 += v * b3;
  t14 += v * b4;
  t15 += v * b5;
  t16 += v * b6;
  t17 += v * b7;
  t18 += v * b8;
  t19 += v * b9;
  t20 += v * b10;
  t21 += v * b11;
  t22 += v * b12;
  t23 += v * b13;
  t24 += v * b14;
  t25 += v * b15;
  v = a[11];
  t11 += v * b0;
  t12 += v * b1;
  t13 += v * b2;
  t14 += v * b3;
  t15 += v * b4;
  t16 += v * b5;
  t17 += v * b6;
  t18 += v * b7;
  t19 += v * b8;
  t20 += v * b9;
  t21 += v * b10;
  t22 += v * b11;
  t23 += v * b12;
  t24 += v * b13;
  t25 += v * b14;
  t26 += v * b15;
  v = a[12];
  t12 += v * b0;
  t13 += v * b1;
  t14 += v * b2;
  t15 += v * b3;
  t16 += v * b4;
  t17 += v * b5;
  t18 += v * b6;
  t19 += v * b7;
  t20 += v * b8;
  t21 += v * b9;
  t22 += v * b10;
  t23 += v * b11;
  t24 += v * b12;
  t25 += v * b13;
  t26 += v * b14;
  t27 += v * b15;
  v = a[13];
  t13 += v * b0;
  t14 += v * b1;
  t15 += v * b2;
  t16 += v * b3;
  t17 += v * b4;
  t18 += v * b5;
  t19 += v * b6;
  t20 += v * b7;
  t21 += v * b8;
  t22 += v * b9;
  t23 += v * b10;
  t24 += v * b11;
  t25 += v * b12;
  t26 += v * b13;
  t27 += v * b14;
  t28 += v * b15;
  v = a[14];
  t14 += v * b0;
  t15 += v * b1;
  t16 += v * b2;
  t17 += v * b3;
  t18 += v * b4;
  t19 += v * b5;
  t20 += v * b6;
  t21 += v * b7;
  t22 += v * b8;
  t23 += v * b9;
  t24 += v * b10;
  t25 += v * b11;
  t26 += v * b12;
  t27 += v * b13;
  t28 += v * b14;
  t29 += v * b15;
  v = a[15];
  t15 += v * b0;
  t16 += v * b1;
  t17 += v * b2;
  t18 += v * b3;
  t19 += v * b4;
  t20 += v * b5;
  t21 += v * b6;
  t22 += v * b7;
  t23 += v * b8;
  t24 += v * b9;
  t25 += v * b10;
  t26 += v * b11;
  t27 += v * b12;
  t28 += v * b13;
  t29 += v * b14;
  t30 += v * b15;

  t0  += 38 * t16;
  t1  += 38 * t17;
  t2  += 38 * t18;
  t3  += 38 * t19;
  t4  += 38 * t20;
  t5  += 38 * t21;
  t6  += 38 * t22;
  t7  += 38 * t23;
  t8  += 38 * t24;
  t9  += 38 * t25;
  t10 += 38 * t26;
  t11 += 38 * t27;
  t12 += 38 * t28;
  t13 += 38 * t29;
  t14 += 38 * t30;
  // t15 left as is

  // first car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  // second car
  c = 1;
  v =  t0 + c + 65535; c = Math.floor(v / 65536);  t0 = v - c * 65536;
  v =  t1 + c + 65535; c = Math.floor(v / 65536);  t1 = v - c * 65536;
  v =  t2 + c + 65535; c = Math.floor(v / 65536);  t2 = v - c * 65536;
  v =  t3 + c + 65535; c = Math.floor(v / 65536);  t3 = v - c * 65536;
  v =  t4 + c + 65535; c = Math.floor(v / 65536);  t4 = v - c * 65536;
  v =  t5 + c + 65535; c = Math.floor(v / 65536);  t5 = v - c * 65536;
  v =  t6 + c + 65535; c = Math.floor(v / 65536);  t6 = v - c * 65536;
  v =  t7 + c + 65535; c = Math.floor(v / 65536);  t7 = v - c * 65536;
  v =  t8 + c + 65535; c = Math.floor(v / 65536);  t8 = v - c * 65536;
  v =  t9 + c + 65535; c = Math.floor(v / 65536);  t9 = v - c * 65536;
  v = t10 + c + 65535; c = Math.floor(v / 65536); t10 = v - c * 65536;
  v = t11 + c + 65535; c = Math.floor(v / 65536); t11 = v - c * 65536;
  v = t12 + c + 65535; c = Math.floor(v / 65536); t12 = v - c * 65536;
  v = t13 + c + 65535; c = Math.floor(v / 65536); t13 = v - c * 65536;
  v = t14 + c + 65535; c = Math.floor(v / 65536); t14 = v - c * 65536;
  v = t15 + c + 65535; c = Math.floor(v / 65536); t15 = v - c * 65536;
  t0 += c-1 + 37 * (c-1);

  o[ 0] = t0;
  o[ 1] = t1;
  o[ 2] = t2;
  o[ 3] = t3;
  o[ 4] = t4;
  o[ 5] = t5;
  o[ 6] = t6;
  o[ 7] = t7;
  o[ 8] = t8;
  o[ 9] = t9;
  o[10] = t10;
  o[11] = t11;
  o[12] = t12;
  o[13] = t13;
  o[14] = t14;
  o[15] = t15;
}

function S(o, a) {
  M(o, a, a);
}

function inv25519(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 253; a >= 0; a--) {
    S(c, c);
    if(a !== 2 && a !== 4) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function pow2523(o, i) {
  var c = gf();
  var a;
  for (a = 0; a < 16; a++) c[a] = i[a];
  for (a = 250; a >= 0; a--) {
      S(c, c);
      if(a !== 1) M(c, c, i);
  }
  for (a = 0; a < 16; a++) o[a] = c[a];
}

function crypto_scalarmult(q, n, p) {
  var z = new Uint8Array(32);
  var x = new Float64Array(80), r, i;
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf();
  for (i = 0; i < 31; i++) z[i] = n[i];
  z[31]=(n[31]&127)|64;
  z[0]&=248;
  unpack25519(x,p);
  for (i = 0; i < 16; i++) {
    b[i]=x[i];
    d[i]=a[i]=c[i]=0;
  }
  a[0]=d[0]=1;
  for (i=254; i>=0; --i) {
    r=(z[i>>>3]>>>(i&7))&1;
    sel25519(a,b,r);
    sel25519(c,d,r);
    A(e,a,c);
    Z(a,a,c);
    A(c,b,d);
    Z(b,b,d);
    S(d,e);
    S(f,a);
    M(a,c,a);
    M(c,b,e);
    A(e,a,c);
    Z(a,a,c);
    S(b,a);
    Z(c,d,f);
    M(a,c,_121665);
    A(a,a,d);
    M(c,c,a);
    M(a,d,f);
    M(d,b,x);
    S(b,e);
    sel25519(a,b,r);
    sel25519(c,d,r);
  }
  for (i = 0; i < 16; i++) {
    x[i+16]=a[i];
    x[i+32]=c[i];
    x[i+48]=b[i];
    x[i+64]=d[i];
  }
  var x32 = x.subarray(32);
  var x16 = x.subarray(16);
  inv25519(x32,x32);
  M(x16,x16,x32);
  pack25519(q,x16);
  return 0;
}

function crypto_scalarmult_base(q, n) {
  return crypto_scalarmult(q, n, _9);
}

function crypto_box_keypair(y, x) {
  randombytes(x, 32);
  return crypto_scalarmult_base(y, x);
}

function crypto_box_beforenm(k, y, x) {
  var s = new Uint8Array(32);
  crypto_scalarmult(s, x, y);
  return crypto_core_hsalsa20(k, _0, s, sigma);
}

var crypto_box_afternm = crypto_secretbox;
var crypto_box_open_afternm = crypto_secretbox_open;

function crypto_box(c, m, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_afternm(c, m, d, n, k);
}

function crypto_box_open(m, c, d, n, y, x) {
  var k = new Uint8Array(32);
  crypto_box_beforenm(k, y, x);
  return crypto_box_open_afternm(m, c, d, n, k);
}

var K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function crypto_hashblocks_hl(hh, hl, m, n) {
  var wh = new Int32Array(16), wl = new Int32Array(16),
      bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7,
      bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7,
      th, tl, i, j, h, l, a, b, c, d;

  var ah0 = hh[0],
      ah1 = hh[1],
      ah2 = hh[2],
      ah3 = hh[3],
      ah4 = hh[4],
      ah5 = hh[5],
      ah6 = hh[6],
      ah7 = hh[7],

      al0 = hl[0],
      al1 = hl[1],
      al2 = hl[2],
      al3 = hl[3],
      al4 = hl[4],
      al5 = hl[5],
      al6 = hl[6],
      al7 = hl[7];

  var pos = 0;
  while (n >= 128) {
    for (i = 0; i < 16; i++) {
      j = 8 * i + pos;
      wh[i] = (m[j+0] << 24) | (m[j+1] << 16) | (m[j+2] << 8) | m[j+3];
      wl[i] = (m[j+4] << 24) | (m[j+5] << 16) | (m[j+6] << 8) | m[j+7];
    }
    for (i = 0; i < 80; i++) {
      bh0 = ah0;
      bh1 = ah1;
      bh2 = ah2;
      bh3 = ah3;
      bh4 = ah4;
      bh5 = ah5;
      bh6 = ah6;
      bh7 = ah7;

      bl0 = al0;
      bl1 = al1;
      bl2 = al2;
      bl3 = al3;
      bl4 = al4;
      bl5 = al5;
      bl6 = al6;
      bl7 = al7;

      // add
      h = ah7;
      l = al7;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma1
      h = ((ah4 >>> 14) | (al4 << (32-14))) ^ ((ah4 >>> 18) | (al4 << (32-18))) ^ ((al4 >>> (41-32)) | (ah4 << (32-(41-32))));
      l = ((al4 >>> 14) | (ah4 << (32-14))) ^ ((al4 >>> 18) | (ah4 << (32-18))) ^ ((ah4 >>> (41-32)) | (al4 << (32-(41-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Ch
      h = (ah4 & ah5) ^ (~ah4 & ah6);
      l = (al4 & al5) ^ (~al4 & al6);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // K
      h = K[i*2];
      l = K[i*2+1];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // w
      h = wh[i%16];
      l = wl[i%16];

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      th = c & 0xffff | d << 16;
      tl = a & 0xffff | b << 16;

      // add
      h = th;
      l = tl;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      // Sigma0
      h = ((ah0 >>> 28) | (al0 << (32-28))) ^ ((al0 >>> (34-32)) | (ah0 << (32-(34-32)))) ^ ((al0 >>> (39-32)) | (ah0 << (32-(39-32))));
      l = ((al0 >>> 28) | (ah0 << (32-28))) ^ ((ah0 >>> (34-32)) | (al0 << (32-(34-32)))) ^ ((ah0 >>> (39-32)) | (al0 << (32-(39-32))));

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      // Maj
      h = (ah0 & ah1) ^ (ah0 & ah2) ^ (ah1 & ah2);
      l = (al0 & al1) ^ (al0 & al2) ^ (al1 & al2);

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh7 = (c & 0xffff) | (d << 16);
      bl7 = (a & 0xffff) | (b << 16);

      // add
      h = bh3;
      l = bl3;

      a = l & 0xffff; b = l >>> 16;
      c = h & 0xffff; d = h >>> 16;

      h = th;
      l = tl;

      a += l & 0xffff; b += l >>> 16;
      c += h & 0xffff; d += h >>> 16;

      b += a >>> 16;
      c += b >>> 16;
      d += c >>> 16;

      bh3 = (c & 0xffff) | (d << 16);
      bl3 = (a & 0xffff) | (b << 16);

      ah1 = bh0;
      ah2 = bh1;
      ah3 = bh2;
      ah4 = bh3;
      ah5 = bh4;
      ah6 = bh5;
      ah7 = bh6;
      ah0 = bh7;

      al1 = bl0;
      al2 = bl1;
      al3 = bl2;
      al4 = bl3;
      al5 = bl4;
      al6 = bl5;
      al7 = bl6;
      al0 = bl7;

      if (i%16 === 15) {
        for (j = 0; j < 16; j++) {
          // add
          h = wh[j];
          l = wl[j];

          a = l & 0xffff; b = l >>> 16;
          c = h & 0xffff; d = h >>> 16;

          h = wh[(j+9)%16];
          l = wl[(j+9)%16];

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma0
          th = wh[(j+1)%16];
          tl = wl[(j+1)%16];
          h = ((th >>> 1) | (tl << (32-1))) ^ ((th >>> 8) | (tl << (32-8))) ^ (th >>> 7);
          l = ((tl >>> 1) | (th << (32-1))) ^ ((tl >>> 8) | (th << (32-8))) ^ ((tl >>> 7) | (th << (32-7)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          // sigma1
          th = wh[(j+14)%16];
          tl = wl[(j+14)%16];
          h = ((th >>> 19) | (tl << (32-19))) ^ ((tl >>> (61-32)) | (th << (32-(61-32)))) ^ (th >>> 6);
          l = ((tl >>> 19) | (th << (32-19))) ^ ((th >>> (61-32)) | (tl << (32-(61-32)))) ^ ((tl >>> 6) | (th << (32-6)));

          a += l & 0xffff; b += l >>> 16;
          c += h & 0xffff; d += h >>> 16;

          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;

          wh[j] = (c & 0xffff) | (d << 16);
          wl[j] = (a & 0xffff) | (b << 16);
        }
      }
    }

    // add
    h = ah0;
    l = al0;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[0];
    l = hl[0];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[0] = ah0 = (c & 0xffff) | (d << 16);
    hl[0] = al0 = (a & 0xffff) | (b << 16);

    h = ah1;
    l = al1;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[1];
    l = hl[1];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[1] = ah1 = (c & 0xffff) | (d << 16);
    hl[1] = al1 = (a & 0xffff) | (b << 16);

    h = ah2;
    l = al2;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[2];
    l = hl[2];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[2] = ah2 = (c & 0xffff) | (d << 16);
    hl[2] = al2 = (a & 0xffff) | (b << 16);

    h = ah3;
    l = al3;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[3];
    l = hl[3];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[3] = ah3 = (c & 0xffff) | (d << 16);
    hl[3] = al3 = (a & 0xffff) | (b << 16);

    h = ah4;
    l = al4;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[4];
    l = hl[4];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[4] = ah4 = (c & 0xffff) | (d << 16);
    hl[4] = al4 = (a & 0xffff) | (b << 16);

    h = ah5;
    l = al5;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[5];
    l = hl[5];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[5] = ah5 = (c & 0xffff) | (d << 16);
    hl[5] = al5 = (a & 0xffff) | (b << 16);

    h = ah6;
    l = al6;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[6];
    l = hl[6];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[6] = ah6 = (c & 0xffff) | (d << 16);
    hl[6] = al6 = (a & 0xffff) | (b << 16);

    h = ah7;
    l = al7;

    a = l & 0xffff; b = l >>> 16;
    c = h & 0xffff; d = h >>> 16;

    h = hh[7];
    l = hl[7];

    a += l & 0xffff; b += l >>> 16;
    c += h & 0xffff; d += h >>> 16;

    b += a >>> 16;
    c += b >>> 16;
    d += c >>> 16;

    hh[7] = ah7 = (c & 0xffff) | (d << 16);
    hl[7] = al7 = (a & 0xffff) | (b << 16);

    pos += 128;
    n -= 128;
  }

  return n;
}

function crypto_hash(out, m, n) {
  var hh = new Int32Array(8),
      hl = new Int32Array(8),
      x = new Uint8Array(256),
      i, b = n;

  hh[0] = 0x6a09e667;
  hh[1] = 0xbb67ae85;
  hh[2] = 0x3c6ef372;
  hh[3] = 0xa54ff53a;
  hh[4] = 0x510e527f;
  hh[5] = 0x9b05688c;
  hh[6] = 0x1f83d9ab;
  hh[7] = 0x5be0cd19;

  hl[0] = 0xf3bcc908;
  hl[1] = 0x84caa73b;
  hl[2] = 0xfe94f82b;
  hl[3] = 0x5f1d36f1;
  hl[4] = 0xade682d1;
  hl[5] = 0x2b3e6c1f;
  hl[6] = 0xfb41bd6b;
  hl[7] = 0x137e2179;

  crypto_hashblocks_hl(hh, hl, m, n);
  n %= 128;

  for (i = 0; i < n; i++) x[i] = m[b-n+i];
  x[n] = 128;

  n = 256-128*(n<112?1:0);
  x[n-9] = 0;
  ts64(x, n-8,  (b / 0x20000000) | 0, b << 3);
  crypto_hashblocks_hl(hh, hl, x, n);

  for (i = 0; i < 8; i++) ts64(out, 8*i, hh[i], hl[i]);

  return 0;
}

function add(p, q) {
  var a = gf(), b = gf(), c = gf(),
      d = gf(), e = gf(), f = gf(),
      g = gf(), h = gf(), t = gf();

  Z(a, p[1], p[0]);
  Z(t, q[1], q[0]);
  M(a, a, t);
  A(b, p[0], p[1]);
  A(t, q[0], q[1]);
  M(b, b, t);
  M(c, p[3], q[3]);
  M(c, c, D2);
  M(d, p[2], q[2]);
  A(d, d, d);
  Z(e, b, a);
  Z(f, d, c);
  A(g, d, c);
  A(h, b, a);

  M(p[0], e, f);
  M(p[1], h, g);
  M(p[2], g, f);
  M(p[3], e, h);
}

function cswap(p, q, b) {
  var i;
  for (i = 0; i < 4; i++) {
    sel25519(p[i], q[i], b);
  }
}

function pack(r, p) {
  var tx = gf(), ty = gf(), zi = gf();
  inv25519(zi, p[2]);
  M(tx, p[0], zi);
  M(ty, p[1], zi);
  pack25519(r, ty);
  r[31] ^= par25519(tx) << 7;
}

function scalarmult(p, q, s) {
  var b, i;
  set25519(p[0], gf0);
  set25519(p[1], gf1);
  set25519(p[2], gf1);
  set25519(p[3], gf0);
  for (i = 255; i >= 0; --i) {
    b = (s[(i/8)|0] >> (i&7)) & 1;
    cswap(p, q, b);
    add(q, p);
    add(p, p);
    cswap(p, q, b);
  }
}

function scalarbase(p, s) {
  var q = [gf(), gf(), gf(), gf()];
  set25519(q[0], X);
  set25519(q[1], Y);
  set25519(q[2], gf1);
  M(q[3], X, Y);
  scalarmult(p, q, s);
}

function crypto_sign_keypair(pk, sk, seeded) {
  var d = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()];
  var i;

  if (!seeded) randombytes(sk, 32);
  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  scalarbase(p, d);
  pack(pk, p);

  for (i = 0; i < 32; i++) sk[i+32] = pk[i];
  return 0;
}

var L = new Float64Array([0xed, 0xd3, 0xf5, 0x5c, 0x1a, 0x63, 0x12, 0x58, 0xd6, 0x9c, 0xf7, 0xa2, 0xde, 0xf9, 0xde, 0x14, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x10]);

function modL(r, x) {
  var carry, i, j, k;
  for (i = 63; i >= 32; --i) {
    carry = 0;
    for (j = i - 32, k = i - 12; j < k; ++j) {
      x[j] += carry - 16 * x[i] * L[j - (i - 32)];
      carry = (x[j] + 128) >> 8;
      x[j] -= carry * 256;
    }
    x[j] += carry;
    x[i] = 0;
  }
  carry = 0;
  for (j = 0; j < 32; j++) {
    x[j] += carry - (x[31] >> 4) * L[j];
    carry = x[j] >> 8;
    x[j] &= 255;
  }
  for (j = 0; j < 32; j++) x[j] -= carry * L[j];
  for (i = 0; i < 32; i++) {
    x[i+1] += x[i] >> 8;
    r[i] = x[i] & 255;
  }
}

function reduce(r) {
  var x = new Float64Array(64), i;
  for (i = 0; i < 64; i++) x[i] = r[i];
  for (i = 0; i < 64; i++) r[i] = 0;
  modL(r, x);
}

// Note: difference from C - smlen returned, not passed as argument.
function crypto_sign(sm, m, n, sk) {
  var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
  var i, j, x = new Float64Array(64);
  var p = [gf(), gf(), gf(), gf()];

  crypto_hash(d, sk, 32);
  d[0] &= 248;
  d[31] &= 127;
  d[31] |= 64;

  var smlen = n + 64;
  for (i = 0; i < n; i++) sm[64 + i] = m[i];
  for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];

  crypto_hash(r, sm.subarray(32), n+32);
  reduce(r);
  scalarbase(p, r);
  pack(sm, p);

  for (i = 32; i < 64; i++) sm[i] = sk[i];
  crypto_hash(h, sm, n + 64);
  reduce(h);

  for (i = 0; i < 64; i++) x[i] = 0;
  for (i = 0; i < 32; i++) x[i] = r[i];
  for (i = 0; i < 32; i++) {
    for (j = 0; j < 32; j++) {
      x[i+j] += h[i] * d[j];
    }
  }

  modL(sm.subarray(32), x);
  return smlen;
}

function unpackneg(r, p) {
  var t = gf(), chk = gf(), num = gf(),
      den = gf(), den2 = gf(), den4 = gf(),
      den6 = gf();

  set25519(r[2], gf1);
  unpack25519(r[1], p);
  S(num, r[1]);
  M(den, num, D);
  Z(num, num, r[2]);
  A(den, r[2], den);

  S(den2, den);
  S(den4, den2);
  M(den6, den4, den2);
  M(t, den6, num);
  M(t, t, den);

  pow2523(t, t);
  M(t, t, num);
  M(t, t, den);
  M(t, t, den);
  M(r[0], t, den);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) M(r[0], r[0], I);

  S(chk, r[0]);
  M(chk, chk, den);
  if (neq25519(chk, num)) return -1;

  if (par25519(r[0]) === (p[31]>>7)) Z(r[0], gf0, r[0]);

  M(r[3], r[0], r[1]);
  return 0;
}

function crypto_sign_open(m, sm, n, pk) {
  var i, mlen;
  var t = new Uint8Array(32), h = new Uint8Array(64);
  var p = [gf(), gf(), gf(), gf()],
      q = [gf(), gf(), gf(), gf()];

  mlen = -1;
  if (n < 64) return -1;

  if (unpackneg(q, pk)) return -1;

  for (i = 0; i < n; i++) m[i] = sm[i];
  for (i = 0; i < 32; i++) m[i+32] = pk[i];
  crypto_hash(h, m, n);
  reduce(h);
  scalarmult(p, q, h);

  scalarbase(q, sm.subarray(32));
  add(p, q);
  pack(t, p);

  n -= 64;
  if (crypto_verify_32(sm, 0, t, 0)) {
    for (i = 0; i < n; i++) m[i] = 0;
    return -1;
  }

  for (i = 0; i < n; i++) m[i] = sm[i + 64];
  mlen = n;
  return mlen;
}

var crypto_secretbox_KEYBYTES = 32,
    crypto_secretbox_NONCEBYTES = 24,
    crypto_secretbox_ZEROBYTES = 32,
    crypto_secretbox_BOXZEROBYTES = 16,
    crypto_scalarmult_BYTES = 32,
    crypto_scalarmult_SCALARBYTES = 32,
    crypto_box_PUBLICKEYBYTES = 32,
    crypto_box_SECRETKEYBYTES = 32,
    crypto_box_BEFORENMBYTES = 32,
    crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES,
    crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES,
    crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES,
    crypto_sign_BYTES = 64,
    crypto_sign_PUBLICKEYBYTES = 32,
    crypto_sign_SECRETKEYBYTES = 64,
    crypto_sign_SEEDBYTES = 32,
    crypto_hash_BYTES = 64;

nacl.lowlevel = {
  crypto_core_hsalsa20: crypto_core_hsalsa20,
  crypto_stream_xor: crypto_stream_xor,
  crypto_stream: crypto_stream,
  crypto_stream_salsa20_xor: crypto_stream_salsa20_xor,
  crypto_stream_salsa20: crypto_stream_salsa20,
  crypto_onetimeauth: crypto_onetimeauth,
  crypto_onetimeauth_verify: crypto_onetimeauth_verify,
  crypto_verify_16: crypto_verify_16,
  crypto_verify_32: crypto_verify_32,
  crypto_secretbox: crypto_secretbox,
  crypto_secretbox_open: crypto_secretbox_open,
  crypto_scalarmult: crypto_scalarmult,
  crypto_scalarmult_base: crypto_scalarmult_base,
  crypto_box_beforenm: crypto_box_beforenm,
  crypto_box_afternm: crypto_box_afternm,
  crypto_box: crypto_box,
  crypto_box_open: crypto_box_open,
  crypto_box_keypair: crypto_box_keypair,
  crypto_hash: crypto_hash,
  crypto_sign: crypto_sign,
  crypto_sign_keypair: crypto_sign_keypair,
  crypto_sign_open: crypto_sign_open,

  crypto_secretbox_KEYBYTES: crypto_secretbox_KEYBYTES,
  crypto_secretbox_NONCEBYTES: crypto_secretbox_NONCEBYTES,
  crypto_secretbox_ZEROBYTES: crypto_secretbox_ZEROBYTES,
  crypto_secretbox_BOXZEROBYTES: crypto_secretbox_BOXZEROBYTES,
  crypto_scalarmult_BYTES: crypto_scalarmult_BYTES,
  crypto_scalarmult_SCALARBYTES: crypto_scalarmult_SCALARBYTES,
  crypto_box_PUBLICKEYBYTES: crypto_box_PUBLICKEYBYTES,
  crypto_box_SECRETKEYBYTES: crypto_box_SECRETKEYBYTES,
  crypto_box_BEFORENMBYTES: crypto_box_BEFORENMBYTES,
  crypto_box_NONCEBYTES: crypto_box_NONCEBYTES,
  crypto_box_ZEROBYTES: crypto_box_ZEROBYTES,
  crypto_box_BOXZEROBYTES: crypto_box_BOXZEROBYTES,
  crypto_sign_BYTES: crypto_sign_BYTES,
  crypto_sign_PUBLICKEYBYTES: crypto_sign_PUBLICKEYBYTES,
  crypto_sign_SECRETKEYBYTES: crypto_sign_SECRETKEYBYTES,
  crypto_sign_SEEDBYTES: crypto_sign_SEEDBYTES,
  crypto_hash_BYTES: crypto_hash_BYTES
};

/* High-level API */

function checkLengths(k, n) {
  if (k.length !== crypto_secretbox_KEYBYTES) throw new Error('bad key size');
  if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error('bad nonce size');
}

function checkBoxLengths(pk, sk) {
  if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error('bad public key size');
  if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error('bad secret key size');
}

function checkArrayTypes() {
  var t, i;
  for (i = 0; i < arguments.length; i++) {
     if ((t = Object.prototype.toString.call(arguments[i])) !== '[object Uint8Array]')
       throw new TypeError('unexpected type ' + t + ', use Uint8Array');
  }
}

function cleanup(arr) {
  for (var i = 0; i < arr.length; i++) arr[i] = 0;
}

// TODO: Completely remove this in v0.15.
if (!nacl.util) {
  nacl.util = {};
  nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
    throw new Error('nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js');
  };
}

nacl.randomBytes = function(n) {
  var b = new Uint8Array(n);
  randombytes(b, n);
  return b;
};

nacl.secretbox = function(msg, nonce, key) {
  checkArrayTypes(msg, nonce, key);
  checkLengths(key, nonce);
  var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
  var c = new Uint8Array(m.length);
  for (var i = 0; i < msg.length; i++) m[i+crypto_secretbox_ZEROBYTES] = msg[i];
  crypto_secretbox(c, m, m.length, nonce, key);
  return c.subarray(crypto_secretbox_BOXZEROBYTES);
};

nacl.secretbox.open = function(box, nonce, key) {
  checkArrayTypes(box, nonce, key);
  checkLengths(key, nonce);
  var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
  var m = new Uint8Array(c.length);
  for (var i = 0; i < box.length; i++) c[i+crypto_secretbox_BOXZEROBYTES] = box[i];
  if (c.length < 32) return false;
  if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
  return m.subarray(crypto_secretbox_ZEROBYTES);
};

nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;

nacl.scalarMult = function(n, p) {
  checkArrayTypes(n, p);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  if (p.length !== crypto_scalarmult_BYTES) throw new Error('bad p size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult(q, n, p);
  return q;
};

nacl.scalarMult.base = function(n) {
  checkArrayTypes(n);
  if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error('bad n size');
  var q = new Uint8Array(crypto_scalarmult_BYTES);
  crypto_scalarmult_base(q, n);
  return q;
};

nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;

nacl.box = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox(msg, nonce, k);
};

nacl.box.before = function(publicKey, secretKey) {
  checkArrayTypes(publicKey, secretKey);
  checkBoxLengths(publicKey, secretKey);
  var k = new Uint8Array(crypto_box_BEFORENMBYTES);
  crypto_box_beforenm(k, publicKey, secretKey);
  return k;
};

nacl.box.after = nacl.secretbox;

nacl.box.open = function(msg, nonce, publicKey, secretKey) {
  var k = nacl.box.before(publicKey, secretKey);
  return nacl.secretbox.open(msg, nonce, k);
};

nacl.box.open.after = nacl.secretbox.open;

nacl.box.keyPair = function() {
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
  crypto_box_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.box.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_box_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
  crypto_scalarmult_base(pk, secretKey);
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
nacl.box.nonceLength = crypto_box_NONCEBYTES;
nacl.box.overheadLength = nacl.secretbox.overheadLength;

nacl.sign = function(msg, secretKey) {
  checkArrayTypes(msg, secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var signedMsg = new Uint8Array(crypto_sign_BYTES+msg.length);
  crypto_sign(signedMsg, msg, msg.length, secretKey);
  return signedMsg;
};

nacl.sign.open = function(signedMsg, publicKey) {
  if (arguments.length !== 2)
    throw new Error('nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?');
  checkArrayTypes(signedMsg, publicKey);
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var tmp = new Uint8Array(signedMsg.length);
  var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
  if (mlen < 0) return null;
  var m = new Uint8Array(mlen);
  for (var i = 0; i < m.length; i++) m[i] = tmp[i];
  return m;
};

nacl.sign.detached = function(msg, secretKey) {
  var signedMsg = nacl.sign(msg, secretKey);
  var sig = new Uint8Array(crypto_sign_BYTES);
  for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
  return sig;
};

nacl.sign.detached.verify = function(msg, sig, publicKey) {
  checkArrayTypes(msg, sig, publicKey);
  if (sig.length !== crypto_sign_BYTES)
    throw new Error('bad signature size');
  if (publicKey.length !== crypto_sign_PUBLICKEYBYTES)
    throw new Error('bad public key size');
  var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
  var m = new Uint8Array(crypto_sign_BYTES + msg.length);
  var i;
  for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
  for (i = 0; i < msg.length; i++) sm[i+crypto_sign_BYTES] = msg[i];
  return (crypto_sign_open(m, sm, sm.length, publicKey) >= 0);
};

nacl.sign.keyPair = function() {
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  crypto_sign_keypair(pk, sk);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.keyPair.fromSecretKey = function(secretKey) {
  checkArrayTypes(secretKey);
  if (secretKey.length !== crypto_sign_SECRETKEYBYTES)
    throw new Error('bad secret key size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32+i];
  return {publicKey: pk, secretKey: new Uint8Array(secretKey)};
};

nacl.sign.keyPair.fromSeed = function(seed) {
  checkArrayTypes(seed);
  if (seed.length !== crypto_sign_SEEDBYTES)
    throw new Error('bad seed size');
  var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
  var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
  for (var i = 0; i < 32; i++) sk[i] = seed[i];
  crypto_sign_keypair(pk, sk, true);
  return {publicKey: pk, secretKey: sk};
};

nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
nacl.sign.seedLength = crypto_sign_SEEDBYTES;
nacl.sign.signatureLength = crypto_sign_BYTES;

nacl.hash = function(msg) {
  checkArrayTypes(msg);
  var h = new Uint8Array(crypto_hash_BYTES);
  crypto_hash(h, msg, msg.length);
  return h;
};

nacl.hash.hashLength = crypto_hash_BYTES;

nacl.verify = function(x, y) {
  checkArrayTypes(x, y);
  // Zero length arguments are considered not equal.
  if (x.length === 0 || y.length === 0) return false;
  if (x.length !== y.length) return false;
  return (vn(x, 0, y, 0, x.length) === 0) ? true : false;
};

nacl.setPRNG = function(fn) {
  randombytes = fn;
};

(function() {
  // Initialize PRNG if environment provides CSPRNG.
  // If not, methods calling randombytes will throw.
  var crypto = typeof self !== 'undefined' ? (self.crypto || self.msCrypto) : null;
  if (crypto && crypto.getRandomValues) {
    // Browsers.
    var QUOTA = 65536;
    nacl.setPRNG(function(x, n) {
      var i, v = new Uint8Array(n);
      for (i = 0; i < n; i += QUOTA) {
        crypto.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
      }
      for (i = 0; i < n; i++) x[i] = v[i];
      cleanup(v);
    });
  } else if (typeof commonjsRequire !== 'undefined') {
    // Node.js.
    crypto = require$$0$3;
    if (crypto && crypto.randomBytes) {
      nacl.setPRNG(function(x, n) {
        var i, v = crypto.randomBytes(n);
        for (i = 0; i < n; i++) x[i] = v[i];
        cleanup(v);
      });
    }
  }
})();

})(module.exports ? module.exports : (self.nacl = self.nacl || {}));
});

var PrivateKey$1 = privateKey;

var Key$1 = key;

// Copyright 2015 Joyent, Inc.

var utils$2 = {
	bufferSplit: bufferSplit,
	addRSAMissing: addRSAMissing,
	calculateDSAPublic: calculateDSAPublic,
	calculateED25519Public: calculateED25519Public,
	calculateX25519Public: calculateX25519Public,
	mpNormalize: mpNormalize,
	mpDenormalize: mpDenormalize,
	ecNormalize: ecNormalize,
	countZeros: countZeros,
	assertCompatible: assertCompatible,
	isCompatible: isCompatible,
	opensslKeyDeriv: opensslKeyDeriv,
	opensshCipherInfo: opensshCipherInfo,
	publicFromPrivateECDSA: publicFromPrivateECDSA,
	zeroPadToLength: zeroPadToLength,
	writeBitString: writeBitString,
	readBitString: readBitString,
	pbkdf2: pbkdf2
};


var Buffer$p = safer_1.Buffer;







var jsbn$1 = jsbn$2.BigInteger;


var MAX_CLASS_DEPTH = 3;

function isCompatible(obj, klass, needVer) {
	if (obj === null || typeof (obj) !== 'object')
		return (false);
	if (needVer === undefined)
		needVer = klass.prototype._sshpkApiVersion;
	if (obj instanceof klass &&
	    klass.prototype._sshpkApiVersion[0] == needVer[0])
		return (true);
	var proto = Object.getPrototypeOf(obj);
	var depth = 0;
	while (proto.constructor.name !== klass.name) {
		proto = Object.getPrototypeOf(proto);
		if (!proto || ++depth > MAX_CLASS_DEPTH)
			return (false);
	}
	if (proto.constructor.name !== klass.name)
		return (false);
	var ver = proto._sshpkApiVersion;
	if (ver === undefined)
		ver = klass._oldVersionDetect(obj);
	if (ver[0] != needVer[0] || ver[1] < needVer[1])
		return (false);
	return (true);
}

function assertCompatible(obj, klass, needVer, name) {
	if (name === undefined)
		name = 'object';
	assert_1.ok(obj, name + ' must not be null');
	assert_1.object(obj, name + ' must be an object');
	if (needVer === undefined)
		needVer = klass.prototype._sshpkApiVersion;
	if (obj instanceof klass &&
	    klass.prototype._sshpkApiVersion[0] == needVer[0])
		return;
	var proto = Object.getPrototypeOf(obj);
	var depth = 0;
	while (proto.constructor.name !== klass.name) {
		proto = Object.getPrototypeOf(proto);
		assert_1.ok(proto && ++depth <= MAX_CLASS_DEPTH,
		    name + ' must be a ' + klass.name + ' instance');
	}
	assert_1.strictEqual(proto.constructor.name, klass.name,
	    name + ' must be a ' + klass.name + ' instance');
	var ver = proto._sshpkApiVersion;
	if (ver === undefined)
		ver = klass._oldVersionDetect(obj);
	assert_1.ok(ver[0] == needVer[0] && ver[1] >= needVer[1],
	    name + ' must be compatible with ' + klass.name + ' klass ' +
	    'version ' + needVer[0] + '.' + needVer[1]);
}

var CIPHER_LEN = {
	'des-ede3-cbc': { key: 24, iv: 8 },
	'aes-128-cbc': { key: 16, iv: 16 },
	'aes-256-cbc': { key: 32, iv: 16 }
};
var PKCS5_SALT_LEN = 8;

function opensslKeyDeriv(cipher, salt, passphrase, count) {
	assert_1.buffer(salt, 'salt');
	assert_1.buffer(passphrase, 'passphrase');
	assert_1.number(count, 'iteration count');

	var clen = CIPHER_LEN[cipher];
	assert_1.object(clen, 'supported cipher');

	salt = salt.slice(0, PKCS5_SALT_LEN);

	var D, D_prev, bufs;
	var material = Buffer$p.alloc(0);
	while (material.length < clen.key + clen.iv) {
		bufs = [];
		if (D_prev)
			bufs.push(D_prev);
		bufs.push(passphrase);
		bufs.push(salt);
		D = Buffer$p.concat(bufs);
		for (var j = 0; j < count; ++j)
			D = crypto$1.createHash('md5').update(D).digest();
		material = Buffer$p.concat([material, D]);
		D_prev = D;
	}

	return ({
	    key: material.slice(0, clen.key),
	    iv: material.slice(clen.key, clen.key + clen.iv)
	});
}

/* See: RFC2898 */
function pbkdf2(hashAlg, salt, iterations, size, passphrase) {
	var hkey = Buffer$p.alloc(salt.length + 4);
	salt.copy(hkey);

	var gen = 0, ts = [];
	var i = 1;
	while (gen < size) {
		var t = T(i++);
		gen += t.length;
		ts.push(t);
	}
	return (Buffer$p.concat(ts).slice(0, size));

	function T(I) {
		hkey.writeUInt32BE(I, hkey.length - 4);

		var hmac = crypto$1.createHmac(hashAlg, passphrase);
		hmac.update(hkey);

		var Ti = hmac.digest();
		var Uc = Ti;
		var c = 1;
		while (c++ < iterations) {
			hmac = crypto$1.createHmac(hashAlg, passphrase);
			hmac.update(Uc);
			Uc = hmac.digest();
			for (var x = 0; x < Ti.length; ++x)
				Ti[x] ^= Uc[x];
		}
		return (Ti);
	}
}

/* Count leading zero bits on a buffer */
function countZeros(buf) {
	var o = 0, obit = 8;
	while (o < buf.length) {
		var mask = (1 << obit);
		if ((buf[o] & mask) === mask)
			break;
		obit--;
		if (obit < 0) {
			o++;
			obit = 8;
		}
	}
	return (o*8 + (8 - obit) - 1);
}

function bufferSplit(buf, chr) {
	assert_1.buffer(buf);
	assert_1.string(chr);

	var parts = [];
	var lastPart = 0;
	var matches = 0;
	for (var i = 0; i < buf.length; ++i) {
		if (buf[i] === chr.charCodeAt(matches))
			++matches;
		else if (buf[i] === chr.charCodeAt(0))
			matches = 1;
		else
			matches = 0;

		if (matches >= chr.length) {
			var newPart = i + 1;
			parts.push(buf.slice(lastPart, newPart - matches));
			lastPart = newPart;
			matches = 0;
		}
	}
	if (lastPart <= buf.length)
		parts.push(buf.slice(lastPart, buf.length));

	return (parts);
}

function ecNormalize(buf, addZero) {
	assert_1.buffer(buf);
	if (buf[0] === 0x00 && buf[1] === 0x04) {
		if (addZero)
			return (buf);
		return (buf.slice(1));
	} else if (buf[0] === 0x04) {
		if (!addZero)
			return (buf);
	} else {
		while (buf[0] === 0x00)
			buf = buf.slice(1);
		if (buf[0] === 0x02 || buf[0] === 0x03)
			throw (new Error('Compressed elliptic curve points ' +
			    'are not supported'));
		if (buf[0] !== 0x04)
			throw (new Error('Not a valid elliptic curve point'));
		if (!addZero)
			return (buf);
	}
	var b = Buffer$p.alloc(buf.length + 1);
	b[0] = 0x0;
	buf.copy(b, 1);
	return (b);
}

function readBitString(der, tag) {
	if (tag === undefined)
		tag = lib$f.Ber.BitString;
	var buf = der.readString(tag, true);
	assert_1.strictEqual(buf[0], 0x00, 'bit strings with unused bits are ' +
	    'not supported (0x' + buf[0].toString(16) + ')');
	return (buf.slice(1));
}

function writeBitString(der, buf, tag) {
	if (tag === undefined)
		tag = lib$f.Ber.BitString;
	var b = Buffer$p.alloc(buf.length + 1);
	b[0] = 0x00;
	buf.copy(b, 1);
	der.writeBuffer(b, tag);
}

function mpNormalize(buf) {
	assert_1.buffer(buf);
	while (buf.length > 1 && buf[0] === 0x00 && (buf[1] & 0x80) === 0x00)
		buf = buf.slice(1);
	if ((buf[0] & 0x80) === 0x80) {
		var b = Buffer$p.alloc(buf.length + 1);
		b[0] = 0x00;
		buf.copy(b, 1);
		buf = b;
	}
	return (buf);
}

function mpDenormalize(buf) {
	assert_1.buffer(buf);
	while (buf.length > 1 && buf[0] === 0x00)
		buf = buf.slice(1);
	return (buf);
}

function zeroPadToLength(buf, len) {
	assert_1.buffer(buf);
	assert_1.number(len);
	while (buf.length > len) {
		assert_1.equal(buf[0], 0x00);
		buf = buf.slice(1);
	}
	while (buf.length < len) {
		var b = Buffer$p.alloc(buf.length + 1);
		b[0] = 0x00;
		buf.copy(b, 1);
		buf = b;
	}
	return (buf);
}

function bigintToMpBuf(bigint) {
	var buf = Buffer$p.from(bigint.toByteArray());
	buf = mpNormalize(buf);
	return (buf);
}

function calculateDSAPublic(g, p, x) {
	assert_1.buffer(g);
	assert_1.buffer(p);
	assert_1.buffer(x);
	g = new jsbn$1(g);
	p = new jsbn$1(p);
	x = new jsbn$1(x);
	var y = g.modPow(x, p);
	var ybuf = bigintToMpBuf(y);
	return (ybuf);
}

function calculateED25519Public(k) {
	assert_1.buffer(k);

	var kp = naclFast.sign.keyPair.fromSeed(new Uint8Array(k));
	return (Buffer$p.from(kp.publicKey));
}

function calculateX25519Public(k) {
	assert_1.buffer(k);

	var kp = naclFast.box.keyPair.fromSeed(new Uint8Array(k));
	return (Buffer$p.from(kp.publicKey));
}

function addRSAMissing(key) {
	assert_1.object(key);
	assertCompatible(key, PrivateKey$1, [1, 1]);

	var d = new jsbn$1(key.part.d.data);
	var buf;

	if (!key.part.dmodp) {
		var p = new jsbn$1(key.part.p.data);
		var dmodp = d.mod(p.subtract(1));

		buf = bigintToMpBuf(dmodp);
		key.part.dmodp = {name: 'dmodp', data: buf};
		key.parts.push(key.part.dmodp);
	}
	if (!key.part.dmodq) {
		var q = new jsbn$1(key.part.q.data);
		var dmodq = d.mod(q.subtract(1));

		buf = bigintToMpBuf(dmodq);
		key.part.dmodq = {name: 'dmodq', data: buf};
		key.parts.push(key.part.dmodq);
	}
}

function publicFromPrivateECDSA(curveName, priv) {
	assert_1.string(curveName, 'curveName');
	assert_1.buffer(priv);
	var params = algs.curves[curveName];
	var p = new jsbn$1(params.p);
	var a = new jsbn$1(params.a);
	var b = new jsbn$1(params.b);
	var curve = new ec.ECCurveFp(p, a, b);
	var G = curve.decodePointHex(params.G.toString('hex'));

	var d = new jsbn$1(mpNormalize(priv));
	var pub = G.multiply(d);
	pub = Buffer$p.from(curve.encodePointHex(pub), 'hex');

	var parts = [];
	parts.push({name: 'curve', data: Buffer$p.from(curveName)});
	parts.push({name: 'Q', data: pub});

	var key = new Key$1({type: 'ecdsa', curve: curve, parts: parts});
	return (key);
}

function opensshCipherInfo(cipher) {
	var inf = {};
	switch (cipher) {
	case '3des-cbc':
		inf.keySize = 24;
		inf.blockSize = 8;
		inf.opensslName = 'des-ede3-cbc';
		break;
	case 'blowfish-cbc':
		inf.keySize = 16;
		inf.blockSize = 8;
		inf.opensslName = 'bf-cbc';
		break;
	case 'aes128-cbc':
	case 'aes128-ctr':
	case 'aes128-gcm@openssh.com':
		inf.keySize = 16;
		inf.blockSize = 16;
		inf.opensslName = 'aes-128-' + cipher.slice(7, 10);
		break;
	case 'aes192-cbc':
	case 'aes192-ctr':
	case 'aes192-gcm@openssh.com':
		inf.keySize = 24;
		inf.blockSize = 16;
		inf.opensslName = 'aes-192-' + cipher.slice(7, 10);
		break;
	case 'aes256-cbc':
	case 'aes256-ctr':
	case 'aes256-gcm@openssh.com':
		inf.keySize = 32;
		inf.blockSize = 16;
		inf.opensslName = 'aes-256-' + cipher.slice(7, 10);
		break;
	default:
		throw (new Error(
		    'Unsupported openssl cipher "' + cipher + '"'));
	}
	return (inf);
}

// Copyright 2015 Joyent, Inc.

var sshBuffer = SSHBuffer;


var Buffer$o = safer_1.Buffer;

function SSHBuffer(opts) {
	assert_1.object(opts, 'options');
	if (opts.buffer !== undefined)
		assert_1.buffer(opts.buffer, 'options.buffer');

	this._size = opts.buffer ? opts.buffer.length : 1024;
	this._buffer = opts.buffer || Buffer$o.alloc(this._size);
	this._offset = 0;
}

SSHBuffer.prototype.toBuffer = function () {
	return (this._buffer.slice(0, this._offset));
};

SSHBuffer.prototype.atEnd = function () {
	return (this._offset >= this._buffer.length);
};

SSHBuffer.prototype.remainder = function () {
	return (this._buffer.slice(this._offset));
};

SSHBuffer.prototype.skip = function (n) {
	this._offset += n;
};

SSHBuffer.prototype.expand = function () {
	this._size *= 2;
	var buf = Buffer$o.alloc(this._size);
	this._buffer.copy(buf, 0);
	this._buffer = buf;
};

SSHBuffer.prototype.readPart = function () {
	return ({data: this.readBuffer()});
};

SSHBuffer.prototype.readBuffer = function () {
	var len = this._buffer.readUInt32BE(this._offset);
	this._offset += 4;
	assert_1.ok(this._offset + len <= this._buffer.length,
	    'length out of bounds at +0x' + this._offset.toString(16) +
	    ' (data truncated?)');
	var buf = this._buffer.slice(this._offset, this._offset + len);
	this._offset += len;
	return (buf);
};

SSHBuffer.prototype.readString = function () {
	return (this.readBuffer().toString());
};

SSHBuffer.prototype.readCString = function () {
	var offset = this._offset;
	while (offset < this._buffer.length &&
	    this._buffer[offset] !== 0x00)
		offset++;
	assert_1.ok(offset < this._buffer.length, 'c string does not terminate');
	var str = this._buffer.slice(this._offset, offset).toString();
	this._offset = offset + 1;
	return (str);
};

SSHBuffer.prototype.readInt = function () {
	var v = this._buffer.readUInt32BE(this._offset);
	this._offset += 4;
	return (v);
};

SSHBuffer.prototype.readInt64 = function () {
	assert_1.ok(this._offset + 8 < this._buffer.length,
	    'buffer not long enough to read Int64');
	var v = this._buffer.slice(this._offset, this._offset + 8);
	this._offset += 8;
	return (v);
};

SSHBuffer.prototype.readChar = function () {
	var v = this._buffer[this._offset++];
	return (v);
};

SSHBuffer.prototype.writeBuffer = function (buf) {
	while (this._offset + 4 + buf.length > this._size)
		this.expand();
	this._buffer.writeUInt32BE(buf.length, this._offset);
	this._offset += 4;
	buf.copy(this._buffer, this._offset);
	this._offset += buf.length;
};

SSHBuffer.prototype.writeString = function (str) {
	this.writeBuffer(Buffer$o.from(str, 'utf8'));
};

SSHBuffer.prototype.writeCString = function (str) {
	while (this._offset + 1 + str.length > this._size)
		this.expand();
	this._buffer.write(str, this._offset);
	this._offset += str.length;
	this._buffer[this._offset++] = 0;
};

SSHBuffer.prototype.writeInt = function (v) {
	while (this._offset + 4 > this._size)
		this.expand();
	this._buffer.writeUInt32BE(v, this._offset);
	this._offset += 4;
};

SSHBuffer.prototype.writeInt64 = function (v) {
	assert_1.buffer(v, 'value');
	if (v.length > 8) {
		var lead = v.slice(0, v.length - 8);
		for (var i = 0; i < lead.length; ++i) {
			assert_1.strictEqual(lead[i], 0,
			    'must fit in 64 bits of precision');
		}
		v = v.slice(v.length - 8, v.length);
	}
	while (this._offset + 8 > this._size)
		this.expand();
	v.copy(this._buffer, this._offset);
	this._offset += 8;
};

SSHBuffer.prototype.writeChar = function (v) {
	while (this._offset + 1 > this._size)
		this.expand();
	this._buffer[this._offset++] = v;
};

SSHBuffer.prototype.writePart = function (p) {
	this.writeBuffer(p.data);
};

SSHBuffer.prototype.write = function (buf) {
	while (this._offset + buf.length > this._size)
		this.expand();
	buf.copy(this._buffer, this._offset);
	this._offset += buf.length;
};

// Copyright 2015 Joyent, Inc.

var signature = Signature;


var Buffer$n = safer_1.Buffer;







var InvalidAlgorithmError$6 = errors$1.InvalidAlgorithmError;
var SignatureParseError = errors$1.SignatureParseError;

function Signature(opts) {
	assert_1.object(opts, 'options');
	assert_1.arrayOfObject(opts.parts, 'options.parts');
	assert_1.string(opts.type, 'options.type');

	var partLookup = {};
	for (var i = 0; i < opts.parts.length; ++i) {
		var part = opts.parts[i];
		partLookup[part.name] = part;
	}

	this.type = opts.type;
	this.hashAlgorithm = opts.hashAlgo;
	this.curve = opts.curve;
	this.parts = opts.parts;
	this.part = partLookup;
}

Signature.prototype.toBuffer = function (format) {
	if (format === undefined)
		format = 'asn1';
	assert_1.string(format, 'format');

	var buf;
	var stype = 'ssh-' + this.type;

	switch (this.type) {
	case 'rsa':
		switch (this.hashAlgorithm) {
		case 'sha256':
			stype = 'rsa-sha2-256';
			break;
		case 'sha512':
			stype = 'rsa-sha2-512';
			break;
		case 'sha1':
		case undefined:
			break;
		default:
			throw (new Error('SSH signature ' +
			    'format does not support hash ' +
			    'algorithm ' + this.hashAlgorithm));
		}
		if (format === 'ssh') {
			buf = new sshBuffer({});
			buf.writeString(stype);
			buf.writePart(this.part.sig);
			return (buf.toBuffer());
		} else {
			return (this.part.sig.data);
		}

	case 'ed25519':
		if (format === 'ssh') {
			buf = new sshBuffer({});
			buf.writeString(stype);
			buf.writePart(this.part.sig);
			return (buf.toBuffer());
		} else {
			return (this.part.sig.data);
		}

	case 'dsa':
	case 'ecdsa':
		var r, s;
		if (format === 'asn1') {
			var der = new lib$f.BerWriter();
			der.startSequence();
			r = utils$2.mpNormalize(this.part.r.data);
			s = utils$2.mpNormalize(this.part.s.data);
			der.writeBuffer(r, lib$f.Ber.Integer);
			der.writeBuffer(s, lib$f.Ber.Integer);
			der.endSequence();
			return (der.buffer);
		} else if (format === 'ssh' && this.type === 'dsa') {
			buf = new sshBuffer({});
			buf.writeString('ssh-dss');
			r = this.part.r.data;
			if (r.length > 20 && r[0] === 0x00)
				r = r.slice(1);
			s = this.part.s.data;
			if (s.length > 20 && s[0] === 0x00)
				s = s.slice(1);
			if ((this.hashAlgorithm &&
			    this.hashAlgorithm !== 'sha1') ||
			    r.length + s.length !== 40) {
				throw (new Error('OpenSSH only supports ' +
				    'DSA signatures with SHA1 hash'));
			}
			buf.writeBuffer(Buffer$n.concat([r, s]));
			return (buf.toBuffer());
		} else if (format === 'ssh' && this.type === 'ecdsa') {
			var inner = new sshBuffer({});
			r = this.part.r.data;
			inner.writeBuffer(r);
			inner.writePart(this.part.s);

			buf = new sshBuffer({});
			/* XXX: find a more proper way to do this? */
			var curve;
			if (r[0] === 0x00)
				r = r.slice(1);
			var sz = r.length * 8;
			if (sz === 256)
				curve = 'nistp256';
			else if (sz === 384)
				curve = 'nistp384';
			else if (sz === 528)
				curve = 'nistp521';
			buf.writeString('ecdsa-sha2-' + curve);
			buf.writeBuffer(inner.toBuffer());
			return (buf.toBuffer());
		}
		throw (new Error('Invalid signature format'));
	default:
		throw (new Error('Invalid signature data'));
	}
};

Signature.prototype.toString = function (format) {
	assert_1.optionalString(format, 'format');
	return (this.toBuffer(format).toString('base64'));
};

Signature.parse = function (data, type, format) {
	if (typeof (data) === 'string')
		data = Buffer$n.from(data, 'base64');
	assert_1.buffer(data, 'data');
	assert_1.string(format, 'format');
	assert_1.string(type, 'type');

	var opts = {};
	opts.type = type.toLowerCase();
	opts.parts = [];

	try {
		assert_1.ok(data.length > 0, 'signature must not be empty');
		switch (opts.type) {
		case 'rsa':
			return (parseOneNum(data, type, format, opts));
		case 'ed25519':
			return (parseOneNum(data, type, format, opts));

		case 'dsa':
		case 'ecdsa':
			if (format === 'asn1')
				return (parseDSAasn1(data, type, format, opts));
			else if (opts.type === 'dsa')
				return (parseDSA(data, type, format, opts));
			else
				return (parseECDSA(data, type, format, opts));

		default:
			throw (new InvalidAlgorithmError$6(type));
		}

	} catch (e) {
		if (e instanceof InvalidAlgorithmError$6)
			throw (e);
		throw (new SignatureParseError(type, format, e));
	}
};

function parseOneNum(data, type, format, opts) {
	if (format === 'ssh') {
		try {
			var buf = new sshBuffer({buffer: data});
			var head = buf.readString();
		} catch (e) {
			/* fall through */
		}
		if (buf !== undefined) {
			var msg = 'SSH signature does not match expected ' +
			    'type (expected ' + type + ', got ' + head + ')';
			switch (head) {
			case 'ssh-rsa':
				assert_1.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha1';
				break;
			case 'rsa-sha2-256':
				assert_1.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha256';
				break;
			case 'rsa-sha2-512':
				assert_1.strictEqual(type, 'rsa', msg);
				opts.hashAlgo = 'sha512';
				break;
			case 'ssh-ed25519':
				assert_1.strictEqual(type, 'ed25519', msg);
				opts.hashAlgo = 'sha512';
				break;
			default:
				throw (new Error('Unknown SSH signature ' +
				    'type: ' + head));
			}
			var sig = buf.readPart();
			assert_1.ok(buf.atEnd(), 'extra trailing bytes');
			sig.name = 'sig';
			opts.parts.push(sig);
			return (new Signature(opts));
		}
	}
	opts.parts.push({name: 'sig', data: data});
	return (new Signature(opts));
}

function parseDSAasn1(data, type, format, opts) {
	var der = new lib$f.BerReader(data);
	der.readSequence();
	var r = der.readString(lib$f.Ber.Integer, true);
	var s = der.readString(lib$f.Ber.Integer, true);

	opts.parts.push({name: 'r', data: utils$2.mpNormalize(r)});
	opts.parts.push({name: 's', data: utils$2.mpNormalize(s)});

	return (new Signature(opts));
}

function parseDSA(data, type, format, opts) {
	if (data.length != 40) {
		var buf = new sshBuffer({buffer: data});
		var d = buf.readBuffer();
		if (d.toString('ascii') === 'ssh-dss')
			d = buf.readBuffer();
		assert_1.ok(buf.atEnd(), 'extra trailing bytes');
		assert_1.strictEqual(d.length, 40, 'invalid inner length');
		data = d;
	}
	opts.parts.push({name: 'r', data: data.slice(0, 20)});
	opts.parts.push({name: 's', data: data.slice(20, 40)});
	return (new Signature(opts));
}

function parseECDSA(data, type, format, opts) {
	var buf = new sshBuffer({buffer: data});

	var r, s;
	var inner = buf.readBuffer();
	var stype = inner.toString('ascii');
	if (stype.slice(0, 6) === 'ecdsa-') {
		var parts = stype.split('-');
		assert_1.strictEqual(parts[0], 'ecdsa');
		assert_1.strictEqual(parts[1], 'sha2');
		opts.curve = parts[2];
		switch (opts.curve) {
		case 'nistp256':
			opts.hashAlgo = 'sha256';
			break;
		case 'nistp384':
			opts.hashAlgo = 'sha384';
			break;
		case 'nistp521':
			opts.hashAlgo = 'sha512';
			break;
		default:
			throw (new Error('Unsupported ECDSA curve: ' +
			    opts.curve));
		}
		inner = buf.readBuffer();
		assert_1.ok(buf.atEnd(), 'extra trailing bytes on outer');
		buf = new sshBuffer({buffer: inner});
		r = buf.readPart();
	} else {
		r = {data: inner};
	}

	s = buf.readPart();
	assert_1.ok(buf.atEnd(), 'extra trailing bytes');

	r.name = 'r';
	s.name = 's';

	opts.parts.push(r);
	opts.parts.push(s);
	return (new Signature(opts));
}

Signature.isSignature = function (obj, ver) {
	return (utils$2.isCompatible(obj, Signature, ver));
};

/*
 * API versions for Signature:
 * [1,0] -- initial ver
 * [2,0] -- support for rsa in full ssh format, compat with sshpk-agent
 *          hashAlgorithm property
 * [2,1] -- first tagged version
 */
Signature.prototype._sshpkApiVersion = [2, 1];

Signature._oldVersionDetect = function (obj) {
	assert_1.func(obj.toBuffer);
	if (obj.hasOwnProperty('hashAlgorithm'))
		return ([2, 0]);
	return ([1, 0]);
};

// Named EC curves

// Requires ec.js, jsbn.js, and jsbn2.js
jsbn$2.BigInteger;

jsbn$2.BigInteger;
safer_1.Buffer;

// Copyright 2017 Joyent, Inc.

var dhe = {
	DiffieHellman: DiffieHellman$1,
	generateECDSA: generateECDSA$1,
	generateED25519: generateED25519$1
};



var Buffer$m = safer_1.Buffer;







var CRYPTO_HAVE_ECDH = (crypto$1.createECDH !== undefined);



var jsbn = jsbn$2.BigInteger;

function DiffieHellman$1(key) {
	utils$2.assertCompatible(key, Key$1, [1, 4], 'key');
	this._isPriv = PrivateKey$1.isPrivateKey(key, [1, 3]);
	this._algo = key.type;
	this._curve = key.curve;
	this._key = key;
	if (key.type === 'dsa') {
		if (!CRYPTO_HAVE_ECDH) {
			throw (new Error('Due to bugs in the node 0.10 ' +
			    'crypto API, node 0.12.x or later is required ' +
			    'to use DH'));
		}
		this._dh = crypto$1.createDiffieHellman(
		    key.part.p.data, undefined,
		    key.part.g.data, undefined);
		this._p = key.part.p;
		this._g = key.part.g;
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.x.data);
		this._dh.setPublicKey(key.part.y.data);

	} else if (key.type === 'ecdsa') {
		if (!CRYPTO_HAVE_ECDH) {
			this._ecParams = new X9ECParameters(this._curve);

			if (this._isPriv) {
				this._priv = new ECPrivate(
				    this._ecParams, key.part.d.data);
			}
			return;
		}

		var curve = {
			'nistp256': 'prime256v1',
			'nistp384': 'secp384r1',
			'nistp521': 'secp521r1'
		}[key.curve];
		this._dh = crypto$1.createECDH(curve);
		if (typeof (this._dh) !== 'object' ||
		    typeof (this._dh.setPrivateKey) !== 'function') {
			CRYPTO_HAVE_ECDH = false;
			DiffieHellman$1.call(this, key);
			return;
		}
		if (this._isPriv)
			this._dh.setPrivateKey(key.part.d.data);
		this._dh.setPublicKey(key.part.Q.data);

	} else if (key.type === 'curve25519') {
		if (this._isPriv) {
			utils$2.assertCompatible(key, PrivateKey$1, [1, 5], 'key');
			this._priv = key.part.k.data;
		}

	} else {
		throw (new Error('DH not supported for ' + key.type + ' keys'));
	}
}

DiffieHellman$1.prototype.getPublicKey = function () {
	if (this._isPriv)
		return (this._key.toPublic());
	return (this._key);
};

DiffieHellman$1.prototype.getPrivateKey = function () {
	if (this._isPriv)
		return (this._key);
	else
		return (undefined);
};
DiffieHellman$1.prototype.getKey = DiffieHellman$1.prototype.getPrivateKey;

DiffieHellman$1.prototype._keyCheck = function (pk, isPub) {
	assert_1.object(pk, 'key');
	if (!isPub)
		utils$2.assertCompatible(pk, PrivateKey$1, [1, 3], 'key');
	utils$2.assertCompatible(pk, Key$1, [1, 4], 'key');

	if (pk.type !== this._algo) {
		throw (new Error('A ' + pk.type + ' key cannot be used in ' +
		    this._algo + ' Diffie-Hellman'));
	}

	if (pk.curve !== this._curve) {
		throw (new Error('A key from the ' + pk.curve + ' curve ' +
		    'cannot be used with a ' + this._curve +
		    ' Diffie-Hellman'));
	}

	if (pk.type === 'dsa') {
		assert_1.deepEqual(pk.part.p, this._p,
		    'DSA key prime does not match');
		assert_1.deepEqual(pk.part.g, this._g,
		    'DSA key generator does not match');
	}
};

DiffieHellman$1.prototype.setKey = function (pk) {
	this._keyCheck(pk);

	if (pk.type === 'dsa') {
		this._dh.setPrivateKey(pk.part.x.data);
		this._dh.setPublicKey(pk.part.y.data);

	} else if (pk.type === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.setPrivateKey(pk.part.d.data);
			this._dh.setPublicKey(pk.part.Q.data);
		} else {
			this._priv = new ECPrivate(
			    this._ecParams, pk.part.d.data);
		}

	} else if (pk.type === 'curve25519') {
		var k = pk.part.k;
		if (!pk.part.k)
			k = pk.part.r;
		this._priv = k.data;
		if (this._priv[0] === 0x00)
			this._priv = this._priv.slice(1);
		this._priv = this._priv.slice(0, 32);
	}
	this._key = pk;
	this._isPriv = true;
};
DiffieHellman$1.prototype.setPrivateKey = DiffieHellman$1.prototype.setKey;

DiffieHellman$1.prototype.computeSecret = function (otherpk) {
	this._keyCheck(otherpk, true);
	if (!this._isPriv)
		throw (new Error('DH exchange has not been initialized with ' +
		    'a private key yet'));

	var pub;
	if (this._algo === 'dsa') {
		return (this._dh.computeSecret(
		    otherpk.part.y.data));

	} else if (this._algo === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			return (this._dh.computeSecret(
			    otherpk.part.Q.data));
		} else {
			pub = new ECPublic(
			    this._ecParams, otherpk.part.Q.data);
			return (this._priv.deriveSharedSecret(pub));
		}

	} else if (this._algo === 'curve25519') {
		pub = otherpk.part.A.data;
		while (pub[0] === 0x00 && pub.length > 32)
			pub = pub.slice(1);
		var priv = this._priv;
		assert_1.strictEqual(pub.length, 32);
		assert_1.strictEqual(priv.length, 32);

		var secret = naclFast.box.before(new Uint8Array(pub),
		    new Uint8Array(priv));

		return (Buffer$m.from(secret));
	}

	throw (new Error('Invalid algorithm: ' + this._algo));
};

DiffieHellman$1.prototype.generateKey = function () {
	var parts = [];
	var priv, pub;
	if (this._algo === 'dsa') {
		this._dh.generateKeys();

		parts.push({name: 'p', data: this._p.data});
		parts.push({name: 'q', data: this._key.part.q.data});
		parts.push({name: 'g', data: this._g.data});
		parts.push({name: 'y', data: this._dh.getPublicKey()});
		parts.push({name: 'x', data: this._dh.getPrivateKey()});
		this._key = new PrivateKey$1({
			type: 'dsa',
			parts: parts
		});
		this._isPriv = true;
		return (this._key);

	} else if (this._algo === 'ecdsa') {
		if (CRYPTO_HAVE_ECDH) {
			this._dh.generateKeys();

			parts.push({name: 'curve',
			    data: Buffer$m.from(this._curve)});
			parts.push({name: 'Q', data: this._dh.getPublicKey()});
			parts.push({name: 'd', data: this._dh.getPrivateKey()});
			this._key = new PrivateKey$1({
				type: 'ecdsa',
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);

		} else {
			var n = this._ecParams.getN();
			var r = new jsbn(crypto$1.randomBytes(n.bitLength()));
			var n1 = n.subtract(jsbn.ONE);
			priv = r.mod(n1).add(jsbn.ONE);
			pub = this._ecParams.getG().multiply(priv);

			priv = Buffer$m.from(priv.toByteArray());
			pub = Buffer$m.from(this._ecParams.getCurve().
			    encodePointHex(pub), 'hex');

			this._priv = new ECPrivate(this._ecParams, priv);

			parts.push({name: 'curve',
			    data: Buffer$m.from(this._curve)});
			parts.push({name: 'Q', data: pub});
			parts.push({name: 'd', data: priv});

			this._key = new PrivateKey$1({
				type: 'ecdsa',
				curve: this._curve,
				parts: parts
			});
			this._isPriv = true;
			return (this._key);
		}

	} else if (this._algo === 'curve25519') {
		var pair = naclFast.box.keyPair();
		priv = Buffer$m.from(pair.secretKey);
		pub = Buffer$m.from(pair.publicKey);
		priv = Buffer$m.concat([priv, pub]);
		assert_1.strictEqual(priv.length, 64);
		assert_1.strictEqual(pub.length, 32);

		parts.push({name: 'A', data: pub});
		parts.push({name: 'k', data: priv});
		this._key = new PrivateKey$1({
			type: 'curve25519',
			parts: parts
		});
		this._isPriv = true;
		return (this._key);
	}

	throw (new Error('Invalid algorithm: ' + this._algo));
};
DiffieHellman$1.prototype.generateKeys = DiffieHellman$1.prototype.generateKey;

/* These are helpers for using ecc-jsbn (for node 0.10 compatibility). */

function X9ECParameters(name) {
	var params = algs.curves[name];
	assert_1.object(params);

	var p = new jsbn(params.p);
	var a = new jsbn(params.a);
	var b = new jsbn(params.b);
	var n = new jsbn(params.n);
	var h = jsbn.ONE;
	var curve = new ec.ECCurveFp(p, a, b);
	var G = curve.decodePointHex(params.G.toString('hex'));

	this.curve = curve;
	this.g = G;
	this.n = n;
	this.h = h;
}
X9ECParameters.prototype.getCurve = function () { return (this.curve); };
X9ECParameters.prototype.getG = function () { return (this.g); };
X9ECParameters.prototype.getN = function () { return (this.n); };
X9ECParameters.prototype.getH = function () { return (this.h); };

function ECPublic(params, buffer) {
	this._params = params;
	if (buffer[0] === 0x00)
		buffer = buffer.slice(1);
	this._pub = params.getCurve().decodePointHex(buffer.toString('hex'));
}

function ECPrivate(params, buffer) {
	this._params = params;
	this._priv = new jsbn(utils$2.mpNormalize(buffer));
}
ECPrivate.prototype.deriveSharedSecret = function (pubKey) {
	assert_1.ok(pubKey instanceof ECPublic);
	var S = pubKey._pub.multiply(this._priv);
	return (Buffer$m.from(S.getX().toBigInteger().toByteArray()));
};

function generateED25519$1() {
	var pair = naclFast.sign.keyPair();
	var priv = Buffer$m.from(pair.secretKey);
	var pub = Buffer$m.from(pair.publicKey);
	assert_1.strictEqual(priv.length, 64);
	assert_1.strictEqual(pub.length, 32);

	var parts = [];
	parts.push({name: 'A', data: pub});
	parts.push({name: 'k', data: priv.slice(0, 32)});
	var key = new PrivateKey$1({
		type: 'ed25519',
		parts: parts
	});
	return (key);
}

/* Generates a new ECDSA private key on a given curve. */
function generateECDSA$1(curve) {
	var parts = [];
	var key;

	if (CRYPTO_HAVE_ECDH) {
		/*
		 * Node crypto doesn't expose key generation directly, but the
		 * ECDH instances can generate keys. It turns out this just
		 * calls into the OpenSSL generic key generator, and we can
		 * read its output happily without doing an actual DH. So we
		 * use that here.
		 */
		var osCurve = {
			'nistp256': 'prime256v1',
			'nistp384': 'secp384r1',
			'nistp521': 'secp521r1'
		}[curve];

		var dh = crypto$1.createECDH(osCurve);
		dh.generateKeys();

		parts.push({name: 'curve',
		    data: Buffer$m.from(curve)});
		parts.push({name: 'Q', data: dh.getPublicKey()});
		parts.push({name: 'd', data: dh.getPrivateKey()});

		key = new PrivateKey$1({
			type: 'ecdsa',
			curve: curve,
			parts: parts
		});
		return (key);
	} else {

		var ecParams = new X9ECParameters(curve);

		/* This algorithm taken from FIPS PUB 186-4 (section B.4.1) */
		var n = ecParams.getN();
		/*
		 * The crypto.randomBytes() function can only give us whole
		 * bytes, so taking a nod from X9.62, we round up.
		 */
		var cByteLen = Math.ceil((n.bitLength() + 64) / 8);
		var c = new jsbn(crypto$1.randomBytes(cByteLen));

		var n1 = n.subtract(jsbn.ONE);
		var priv = c.mod(n1).add(jsbn.ONE);
		var pub = ecParams.getG().multiply(priv);

		priv = Buffer$m.from(priv.toByteArray());
		pub = Buffer$m.from(ecParams.getCurve().
		    encodePointHex(pub), 'hex');

		parts.push({name: 'curve', data: Buffer$m.from(curve)});
		parts.push({name: 'Q', data: pub});
		parts.push({name: 'd', data: priv});

		key = new PrivateKey$1({
			type: 'ecdsa',
			curve: curve,
			parts: parts
		});
		return (key);
	}
}

// Copyright 2015 Joyent, Inc.

var edCompat$1 = {
	Verifier: Verifier,
	Signer: Signer
};





var Buffer$l = safer_1.Buffer;


function Verifier(key, hashAlgo) {
	if (hashAlgo.toLowerCase() !== 'sha512')
		throw (new Error('ED25519 only supports the use of ' +
		    'SHA-512 hashes'));

	this.key = key;
	this.chunks = [];

	stream.Writable.call(this, {});
}
util$2.inherits(Verifier, stream.Writable);

Verifier.prototype._write = function (chunk, enc, cb) {
	this.chunks.push(chunk);
	cb();
};

Verifier.prototype.update = function (chunk) {
	if (typeof (chunk) === 'string')
		chunk = Buffer$l.from(chunk, 'binary');
	this.chunks.push(chunk);
};

Verifier.prototype.verify = function (signature$1, fmt) {
	var sig;
	if (signature.isSignature(signature$1, [2, 0])) {
		if (signature$1.type !== 'ed25519')
			return (false);
		sig = signature$1.toBuffer('raw');

	} else if (typeof (signature$1) === 'string') {
		sig = Buffer$l.from(signature$1, 'base64');

	} else if (signature.isSignature(signature$1, [1, 0])) {
		throw (new Error('signature was created by too old ' +
		    'a version of sshpk and cannot be verified'));
	}

	assert_1.buffer(sig);
	return (naclFast.sign.detached.verify(
	    new Uint8Array(Buffer$l.concat(this.chunks)),
	    new Uint8Array(sig),
	    new Uint8Array(this.key.part.A.data)));
};

function Signer(key, hashAlgo) {
	if (hashAlgo.toLowerCase() !== 'sha512')
		throw (new Error('ED25519 only supports the use of ' +
		    'SHA-512 hashes'));

	this.key = key;
	this.chunks = [];

	stream.Writable.call(this, {});
}
util$2.inherits(Signer, stream.Writable);

Signer.prototype._write = function (chunk, enc, cb) {
	this.chunks.push(chunk);
	cb();
};

Signer.prototype.update = function (chunk) {
	if (typeof (chunk) === 'string')
		chunk = Buffer$l.from(chunk, 'binary');
	this.chunks.push(chunk);
};

Signer.prototype.sign = function () {
	var sig = naclFast.sign.detached(
	    new Uint8Array(Buffer$l.concat(this.chunks)),
	    new Uint8Array(Buffer$l.concat([
		this.key.part.k.data, this.key.part.A.data])));
	var sigBuf = Buffer$l.from(sig);
	var sigObj = signature.parse(sigBuf, 'ed25519', 'raw');
	sigObj.hashAlgorithm = 'sha512';
	return (sigObj);
};

var require$$3$1 = pem;

// Copyright 2018 Joyent, Inc.

var pkcs8 = {
	read: read$b,
	readPkcs8: readPkcs8,
	write: write$b,
	writePkcs8: writePkcs8,
	pkcs8ToBuffer: pkcs8ToBuffer,

	readECDSACurve: readECDSACurve$1,
	writeECDSACurve: writeECDSACurve
};



var Buffer$k = safer_1.Buffer;






function read$b(buf, options) {
	return (require$$3$1.read(buf, options, 'pkcs8'));
}

function write$b(key, options) {
	return (require$$3$1.write(key, options, 'pkcs8'));
}

/* Helper to read in a single mpint */
function readMPInt$2(der, nm) {
	assert_1.strictEqual(der.peek(), lib$f.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils$2.mpNormalize(der.readString(lib$f.Ber.Integer, true)));
}

function readPkcs8(alg, type, der) {
	/* Private keys in pkcs#8 format have a weird extra int */
	if (der.peek() === lib$f.Ber.Integer) {
		assert_1.strictEqual(type, 'private',
		    'unexpected Integer at start of public key');
		der.readString(lib$f.Ber.Integer, true);
	}

	der.readSequence();
	var next = der.offset + der.length;

	var oid = der.readOID();
	switch (oid) {
	case '1.2.840.113549.1.1.1':
		der._offset = next;
		if (type === 'public')
			return (readPkcs8RSAPublic(der));
		else
			return (readPkcs8RSAPrivate(der));
	case '1.2.840.10040.4.1':
		if (type === 'public')
			return (readPkcs8DSAPublic(der));
		else
			return (readPkcs8DSAPrivate(der));
	case '1.2.840.10045.2.1':
		if (type === 'public')
			return (readPkcs8ECDSAPublic(der));
		else
			return (readPkcs8ECDSAPrivate(der));
	case '1.3.101.112':
		if (type === 'public') {
			return (readPkcs8EdDSAPublic(der));
		} else {
			return (readPkcs8EdDSAPrivate(der));
		}
	case '1.3.101.110':
		if (type === 'public') {
			return (readPkcs8X25519Public(der));
		} else {
			return (readPkcs8X25519Private(der));
		}
	default:
		throw (new Error('Unknown key type OID ' + oid));
	}
}

function readPkcs8RSAPublic(der) {
	// bit string sequence
	der.readSequence(lib$f.Ber.BitString);
	der.readByte();
	der.readSequence();

	// modulus
	var n = readMPInt$2(der, 'modulus');
	var e = readMPInt$2(der, 'exponent');

	// now, make the key
	var key = {
		type: 'rsa',
		source: der.originalInput,
		parts: [
			{ name: 'e', data: e },
			{ name: 'n', data: n }
		]
	};

	return (new Key$1(key));
}

function readPkcs8RSAPrivate(der) {
	der.readSequence(lib$f.Ber.OctetString);
	der.readSequence();

	var ver = readMPInt$2(der, 'version');
	assert_1.equal(ver[0], 0x0, 'unknown RSA private key version');

	// modulus then public exponent
	var n = readMPInt$2(der, 'modulus');
	var e = readMPInt$2(der, 'public exponent');
	var d = readMPInt$2(der, 'private exponent');
	var p = readMPInt$2(der, 'prime1');
	var q = readMPInt$2(der, 'prime2');
	var dmodp = readMPInt$2(der, 'exponent1');
	var dmodq = readMPInt$2(der, 'exponent2');
	var iqmp = readMPInt$2(der, 'iqmp');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'n', data: n },
			{ name: 'e', data: e },
			{ name: 'd', data: d },
			{ name: 'iqmp', data: iqmp },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'dmodp', data: dmodp },
			{ name: 'dmodq', data: dmodq }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs8DSAPublic(der) {
	der.readSequence();

	var p = readMPInt$2(der, 'p');
	var q = readMPInt$2(der, 'q');
	var g = readMPInt$2(der, 'g');

	// bit string sequence
	der.readSequence(lib$f.Ber.BitString);
	der.readByte();

	var y = readMPInt$2(der, 'y');

	// now, make the key
	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y }
		]
	};

	return (new Key$1(key));
}

function readPkcs8DSAPrivate(der) {
	der.readSequence();

	var p = readMPInt$2(der, 'p');
	var q = readMPInt$2(der, 'q');
	var g = readMPInt$2(der, 'g');

	der.readSequence(lib$f.Ber.OctetString);
	var x = readMPInt$2(der, 'x');

	/* The pkcs#8 format does not include the public key */
	var y = utils$2.calculateDSAPublic(g, p, x);

	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y },
			{ name: 'x', data: x }
		]
	};

	return (new PrivateKey$1(key));
}

function readECDSACurve$1(der) {
	var curveName, curveNames;
	var j, c, cd;

	if (der.peek() === lib$f.Ber.OID) {
		var oid = der.readOID();

		curveNames = Object.keys(algs.curves);
		for (j = 0; j < curveNames.length; ++j) {
			c = curveNames[j];
			cd = algs.curves[c];
			if (cd.pkcs8oid === oid) {
				curveName = c;
				break;
			}
		}

	} else {
		// ECParameters sequence
		der.readSequence();
		var version = der.readString(lib$f.Ber.Integer, true);
		assert_1.strictEqual(version[0], 1, 'ECDSA key not version 1');

		var curve = {};

		// FieldID sequence
		der.readSequence();
		var fieldTypeOid = der.readOID();
		assert_1.strictEqual(fieldTypeOid, '1.2.840.10045.1.1',
		    'ECDSA key is not from a prime-field');
		var p = curve.p = utils$2.mpNormalize(
		    der.readString(lib$f.Ber.Integer, true));
		/*
		 * p always starts with a 1 bit, so count the zeros to get its
		 * real size.
		 */
		curve.size = p.length * 8 - utils$2.countZeros(p);

		// Curve sequence
		der.readSequence();
		curve.a = utils$2.mpNormalize(
		    der.readString(lib$f.Ber.OctetString, true));
		curve.b = utils$2.mpNormalize(
		    der.readString(lib$f.Ber.OctetString, true));
		if (der.peek() === lib$f.Ber.BitString)
			curve.s = der.readString(lib$f.Ber.BitString, true);

		// Combined Gx and Gy
		curve.G = der.readString(lib$f.Ber.OctetString, true);
		assert_1.strictEqual(curve.G[0], 0x4,
		    'uncompressed G is required');

		curve.n = utils$2.mpNormalize(
		    der.readString(lib$f.Ber.Integer, true));
		curve.h = utils$2.mpNormalize(
		    der.readString(lib$f.Ber.Integer, true));
		assert_1.strictEqual(curve.h[0], 0x1, 'a cofactor=1 curve is ' +
		    'required');

		curveNames = Object.keys(algs.curves);
		var ks = Object.keys(curve);
		for (j = 0; j < curveNames.length; ++j) {
			c = curveNames[j];
			cd = algs.curves[c];
			var equal = true;
			for (var i = 0; i < ks.length; ++i) {
				var k = ks[i];
				if (cd[k] === undefined)
					continue;
				if (typeof (cd[k]) === 'object' &&
				    cd[k].equals !== undefined) {
					if (!cd[k].equals(curve[k])) {
						equal = false;
						break;
					}
				} else if (Buffer$k.isBuffer(cd[k])) {
					if (cd[k].toString('binary')
					    !== curve[k].toString('binary')) {
						equal = false;
						break;
					}
				} else {
					if (cd[k] !== curve[k]) {
						equal = false;
						break;
					}
				}
			}
			if (equal) {
				curveName = c;
				break;
			}
		}
	}
	return (curveName);
}

function readPkcs8ECDSAPrivate(der) {
	var curveName = readECDSACurve$1(der);
	assert_1.string(curveName, 'a known elliptic curve');

	der.readSequence(lib$f.Ber.OctetString);
	der.readSequence();

	var version = readMPInt$2(der, 'version');
	assert_1.equal(version[0], 1, 'unknown version of ECDSA key');

	var d = der.readString(lib$f.Ber.OctetString, true);
	var Q;

	if (der.peek() == 0xa0) {
		der.readSequence(0xa0);
		der._offset += der.length;
	}
	if (der.peek() == 0xa1) {
		der.readSequence(0xa1);
		Q = der.readString(lib$f.Ber.BitString, true);
		Q = utils$2.ecNormalize(Q);
	}

	if (Q === undefined) {
		var pub = utils$2.publicFromPrivateECDSA(curveName, d);
		Q = pub.part.Q.data;
	}

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer$k.from(curveName) },
			{ name: 'Q', data: Q },
			{ name: 'd', data: d }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs8ECDSAPublic(der) {
	var curveName = readECDSACurve$1(der);
	assert_1.string(curveName, 'a known elliptic curve');

	var Q = der.readString(lib$f.Ber.BitString, true);
	Q = utils$2.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer$k.from(curveName) },
			{ name: 'Q', data: Q }
		]
	};

	return (new Key$1(key));
}

function readPkcs8EdDSAPublic(der) {
	if (der.peek() === 0x00)
		der.readByte();

	var A = utils$2.readBitString(der);

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils$2.zeroPadToLength(A, 32) }
		]
	};

	return (new Key$1(key));
}

function readPkcs8X25519Public(der) {
	var A = utils$2.readBitString(der);

	var key = {
		type: 'curve25519',
		parts: [
			{ name: 'A', data: utils$2.zeroPadToLength(A, 32) }
		]
	};

	return (new Key$1(key));
}

function readPkcs8EdDSAPrivate(der) {
	if (der.peek() === 0x00)
		der.readByte();

	der.readSequence(lib$f.Ber.OctetString);
	var k = der.readString(lib$f.Ber.OctetString, true);
	k = utils$2.zeroPadToLength(k, 32);

	var A;
	if (der.peek() === lib$f.Ber.BitString) {
		A = utils$2.readBitString(der);
		A = utils$2.zeroPadToLength(A, 32);
	} else {
		A = utils$2.calculateED25519Public(k);
	}

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils$2.zeroPadToLength(A, 32) },
			{ name: 'k', data: utils$2.zeroPadToLength(k, 32) }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs8X25519Private(der) {
	if (der.peek() === 0x00)
		der.readByte();

	der.readSequence(lib$f.Ber.OctetString);
	var k = der.readString(lib$f.Ber.OctetString, true);
	k = utils$2.zeroPadToLength(k, 32);

	var A = utils$2.calculateX25519Public(k);

	var key = {
		type: 'curve25519',
		parts: [
			{ name: 'A', data: utils$2.zeroPadToLength(A, 32) },
			{ name: 'k', data: utils$2.zeroPadToLength(k, 32) }
		]
	};

	return (new PrivateKey$1(key));
}

function pkcs8ToBuffer(key) {
	var der = new lib$f.BerWriter();
	writePkcs8(der, key);
	return (der.buffer);
}

function writePkcs8(der, key) {
	der.startSequence();

	if (PrivateKey$1.isPrivateKey(key)) {
		var sillyInt = Buffer$k.from([0]);
		der.writeBuffer(sillyInt, lib$f.Ber.Integer);
	}

	der.startSequence();
	switch (key.type) {
	case 'rsa':
		der.writeOID('1.2.840.113549.1.1.1');
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs8RSAPrivate(key, der);
		else
			writePkcs8RSAPublic(key, der);
		break;
	case 'dsa':
		der.writeOID('1.2.840.10040.4.1');
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs8DSAPrivate(key, der);
		else
			writePkcs8DSAPublic(key, der);
		break;
	case 'ecdsa':
		der.writeOID('1.2.840.10045.2.1');
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs8ECDSAPrivate(key, der);
		else
			writePkcs8ECDSAPublic(key, der);
		break;
	case 'ed25519':
		der.writeOID('1.3.101.112');
		if (PrivateKey$1.isPrivateKey(key))
			throw (new Error('Ed25519 private keys in pkcs8 ' +
			    'format are not supported'));
		writePkcs8EdDSAPublic(key, der);
		break;
	default:
		throw (new Error('Unsupported key type: ' + key.type));
	}

	der.endSequence();
}

function writePkcs8RSAPrivate(key, der) {
	der.writeNull();
	der.endSequence();

	der.startSequence(lib$f.Ber.OctetString);
	der.startSequence();

	var version = Buffer$k.from([0]);
	der.writeBuffer(version, lib$f.Ber.Integer);

	der.writeBuffer(key.part.n.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.e.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.d.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	if (!key.part.dmodp || !key.part.dmodq)
		utils$2.addRSAMissing(key);
	der.writeBuffer(key.part.dmodp.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.dmodq.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.iqmp.data, lib$f.Ber.Integer);

	der.endSequence();
	der.endSequence();
}

function writePkcs8RSAPublic(key, der) {
	der.writeNull();
	der.endSequence();

	der.startSequence(lib$f.Ber.BitString);
	der.writeByte(0x00);

	der.startSequence();
	der.writeBuffer(key.part.n.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.e.data, lib$f.Ber.Integer);
	der.endSequence();

	der.endSequence();
}

function writePkcs8DSAPrivate(key, der) {
	der.startSequence();
	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.g.data, lib$f.Ber.Integer);
	der.endSequence();

	der.endSequence();

	der.startSequence(lib$f.Ber.OctetString);
	der.writeBuffer(key.part.x.data, lib$f.Ber.Integer);
	der.endSequence();
}

function writePkcs8DSAPublic(key, der) {
	der.startSequence();
	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.g.data, lib$f.Ber.Integer);
	der.endSequence();
	der.endSequence();

	der.startSequence(lib$f.Ber.BitString);
	der.writeByte(0x00);
	der.writeBuffer(key.part.y.data, lib$f.Ber.Integer);
	der.endSequence();
}

function writeECDSACurve(key, der) {
	var curve = algs.curves[key.curve];
	if (curve.pkcs8oid) {
		/* This one has a name in pkcs#8, so just write the oid */
		der.writeOID(curve.pkcs8oid);

	} else {
		// ECParameters sequence
		der.startSequence();

		var version = Buffer$k.from([1]);
		der.writeBuffer(version, lib$f.Ber.Integer);

		// FieldID sequence
		der.startSequence();
		der.writeOID('1.2.840.10045.1.1'); // prime-field
		der.writeBuffer(curve.p, lib$f.Ber.Integer);
		der.endSequence();

		// Curve sequence
		der.startSequence();
		var a = curve.p;
		if (a[0] === 0x0)
			a = a.slice(1);
		der.writeBuffer(a, lib$f.Ber.OctetString);
		der.writeBuffer(curve.b, lib$f.Ber.OctetString);
		der.writeBuffer(curve.s, lib$f.Ber.BitString);
		der.endSequence();

		der.writeBuffer(curve.G, lib$f.Ber.OctetString);
		der.writeBuffer(curve.n, lib$f.Ber.Integer);
		var h = curve.h;
		if (!h) {
			h = Buffer$k.from([1]);
		}
		der.writeBuffer(h, lib$f.Ber.Integer);

		// ECParameters
		der.endSequence();
	}
}

function writePkcs8ECDSAPublic(key, der) {
	writeECDSACurve(key, der);
	der.endSequence();

	var Q = utils$2.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, lib$f.Ber.BitString);
}

function writePkcs8ECDSAPrivate(key, der) {
	writeECDSACurve(key, der);
	der.endSequence();

	der.startSequence(lib$f.Ber.OctetString);
	der.startSequence();

	var version = Buffer$k.from([1]);
	der.writeBuffer(version, lib$f.Ber.Integer);

	der.writeBuffer(key.part.d.data, lib$f.Ber.OctetString);

	der.startSequence(0xa1);
	var Q = utils$2.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, lib$f.Ber.BitString);
	der.endSequence();

	der.endSequence();
	der.endSequence();
}

function writePkcs8EdDSAPublic(key, der) {
	der.endSequence();

	utils$2.writeBitString(der, key.part.A.data);
}

// Copyright 2015 Joyent, Inc.

var pkcs1 = {
	read: read$a,
	readPkcs1: readPkcs1,
	write: write$a,
	writePkcs1: writePkcs1
};



var Buffer$j = safer_1.Buffer;








var readECDSACurve = pkcs8.readECDSACurve;

function read$a(buf, options) {
	return (require$$3$1.read(buf, options, 'pkcs1'));
}

function write$a(key, options) {
	return (require$$3$1.write(key, options, 'pkcs1'));
}

/* Helper to read in a single mpint */
function readMPInt$1(der, nm) {
	assert_1.strictEqual(der.peek(), lib$f.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils$2.mpNormalize(der.readString(lib$f.Ber.Integer, true)));
}

function readPkcs1(alg, type, der) {
	switch (alg) {
	case 'RSA':
		if (type === 'public')
			return (readPkcs1RSAPublic(der));
		else if (type === 'private')
			return (readPkcs1RSAPrivate(der));
		throw (new Error('Unknown key type: ' + type));
	case 'DSA':
		if (type === 'public')
			return (readPkcs1DSAPublic(der));
		else if (type === 'private')
			return (readPkcs1DSAPrivate(der));
		throw (new Error('Unknown key type: ' + type));
	case 'EC':
	case 'ECDSA':
		if (type === 'private')
			return (readPkcs1ECDSAPrivate(der));
		else if (type === 'public')
			return (readPkcs1ECDSAPublic(der));
		throw (new Error('Unknown key type: ' + type));
	case 'EDDSA':
	case 'EdDSA':
		if (type === 'private')
			return (readPkcs1EdDSAPrivate(der));
		throw (new Error(type + ' keys not supported with EdDSA'));
	default:
		throw (new Error('Unknown key algo: ' + alg));
	}
}

function readPkcs1RSAPublic(der) {
	// modulus and exponent
	var n = readMPInt$1(der, 'modulus');
	var e = readMPInt$1(der, 'exponent');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'e', data: e },
			{ name: 'n', data: n }
		]
	};

	return (new Key$1(key));
}

function readPkcs1RSAPrivate(der) {
	var version = readMPInt$1(der, 'version');
	assert_1.strictEqual(version[0], 0);

	// modulus then public exponent
	var n = readMPInt$1(der, 'modulus');
	var e = readMPInt$1(der, 'public exponent');
	var d = readMPInt$1(der, 'private exponent');
	var p = readMPInt$1(der, 'prime1');
	var q = readMPInt$1(der, 'prime2');
	var dmodp = readMPInt$1(der, 'exponent1');
	var dmodq = readMPInt$1(der, 'exponent2');
	var iqmp = readMPInt$1(der, 'iqmp');

	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'n', data: n },
			{ name: 'e', data: e },
			{ name: 'd', data: d },
			{ name: 'iqmp', data: iqmp },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'dmodp', data: dmodp },
			{ name: 'dmodq', data: dmodq }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs1DSAPrivate(der) {
	var version = readMPInt$1(der, 'version');
	assert_1.strictEqual(version.readUInt8(0), 0);

	var p = readMPInt$1(der, 'p');
	var q = readMPInt$1(der, 'q');
	var g = readMPInt$1(der, 'g');
	var y = readMPInt$1(der, 'y');
	var x = readMPInt$1(der, 'x');

	// now, make the key
	var key = {
		type: 'dsa',
		parts: [
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g },
			{ name: 'y', data: y },
			{ name: 'x', data: x }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs1EdDSAPrivate(der) {
	var version = readMPInt$1(der, 'version');
	assert_1.strictEqual(version.readUInt8(0), 1);

	// private key
	var k = der.readString(lib$f.Ber.OctetString, true);

	der.readSequence(0xa0);
	var oid = der.readOID();
	assert_1.strictEqual(oid, '1.3.101.112', 'the ed25519 curve identifier');

	der.readSequence(0xa1);
	var A = utils$2.readBitString(der);

	var key = {
		type: 'ed25519',
		parts: [
			{ name: 'A', data: utils$2.zeroPadToLength(A, 32) },
			{ name: 'k', data: k }
		]
	};

	return (new PrivateKey$1(key));
}

function readPkcs1DSAPublic(der) {
	var y = readMPInt$1(der, 'y');
	var p = readMPInt$1(der, 'p');
	var q = readMPInt$1(der, 'q');
	var g = readMPInt$1(der, 'g');

	var key = {
		type: 'dsa',
		parts: [
			{ name: 'y', data: y },
			{ name: 'p', data: p },
			{ name: 'q', data: q },
			{ name: 'g', data: g }
		]
	};

	return (new Key$1(key));
}

function readPkcs1ECDSAPublic(der) {
	der.readSequence();

	var oid = der.readOID();
	assert_1.strictEqual(oid, '1.2.840.10045.2.1', 'must be ecPublicKey');

	var curveOid = der.readOID();

	var curve;
	var curves = Object.keys(algs.curves);
	for (var j = 0; j < curves.length; ++j) {
		var c = curves[j];
		var cd = algs.curves[c];
		if (cd.pkcs8oid === curveOid) {
			curve = c;
			break;
		}
	}
	assert_1.string(curve, 'a known ECDSA named curve');

	var Q = der.readString(lib$f.Ber.BitString, true);
	Q = utils$2.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer$j.from(curve) },
			{ name: 'Q', data: Q }
		]
	};

	return (new Key$1(key));
}

function readPkcs1ECDSAPrivate(der) {
	var version = readMPInt$1(der, 'version');
	assert_1.strictEqual(version.readUInt8(0), 1);

	// private key
	var d = der.readString(lib$f.Ber.OctetString, true);

	der.readSequence(0xa0);
	var curve = readECDSACurve(der);
	assert_1.string(curve, 'a known elliptic curve');

	der.readSequence(0xa1);
	var Q = der.readString(lib$f.Ber.BitString, true);
	Q = utils$2.ecNormalize(Q);

	var key = {
		type: 'ecdsa',
		parts: [
			{ name: 'curve', data: Buffer$j.from(curve) },
			{ name: 'Q', data: Q },
			{ name: 'd', data: d }
		]
	};

	return (new PrivateKey$1(key));
}

function writePkcs1(der, key) {
	der.startSequence();

	switch (key.type) {
	case 'rsa':
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs1RSAPrivate(der, key);
		else
			writePkcs1RSAPublic(der, key);
		break;
	case 'dsa':
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs1DSAPrivate(der, key);
		else
			writePkcs1DSAPublic(der, key);
		break;
	case 'ecdsa':
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs1ECDSAPrivate(der, key);
		else
			writePkcs1ECDSAPublic(der, key);
		break;
	case 'ed25519':
		if (PrivateKey$1.isPrivateKey(key))
			writePkcs1EdDSAPrivate(der, key);
		else
			writePkcs1EdDSAPublic();
		break;
	default:
		throw (new Error('Unknown key algo: ' + key.type));
	}

	der.endSequence();
}

function writePkcs1RSAPublic(der, key) {
	der.writeBuffer(key.part.n.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.e.data, lib$f.Ber.Integer);
}

function writePkcs1RSAPrivate(der, key) {
	var ver = Buffer$j.from([0]);
	der.writeBuffer(ver, lib$f.Ber.Integer);

	der.writeBuffer(key.part.n.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.e.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.d.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	if (!key.part.dmodp || !key.part.dmodq)
		utils$2.addRSAMissing(key);
	der.writeBuffer(key.part.dmodp.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.dmodq.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.iqmp.data, lib$f.Ber.Integer);
}

function writePkcs1DSAPrivate(der, key) {
	var ver = Buffer$j.from([0]);
	der.writeBuffer(ver, lib$f.Ber.Integer);

	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.g.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.y.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.x.data, lib$f.Ber.Integer);
}

function writePkcs1DSAPublic(der, key) {
	der.writeBuffer(key.part.y.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.p.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.q.data, lib$f.Ber.Integer);
	der.writeBuffer(key.part.g.data, lib$f.Ber.Integer);
}

function writePkcs1ECDSAPublic(der, key) {
	der.startSequence();

	der.writeOID('1.2.840.10045.2.1'); /* ecPublicKey */
	var curve = key.part.curve.data.toString();
	var curveOid = algs.curves[curve].pkcs8oid;
	assert_1.string(curveOid, 'a known ECDSA named curve');
	der.writeOID(curveOid);

	der.endSequence();

	var Q = utils$2.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, lib$f.Ber.BitString);
}

function writePkcs1ECDSAPrivate(der, key) {
	var ver = Buffer$j.from([1]);
	der.writeBuffer(ver, lib$f.Ber.Integer);

	der.writeBuffer(key.part.d.data, lib$f.Ber.OctetString);

	der.startSequence(0xa0);
	var curve = key.part.curve.data.toString();
	var curveOid = algs.curves[curve].pkcs8oid;
	assert_1.string(curveOid, 'a known ECDSA named curve');
	der.writeOID(curveOid);
	der.endSequence();

	der.startSequence(0xa1);
	var Q = utils$2.ecNormalize(key.part.Q.data, true);
	der.writeBuffer(Q, lib$f.Ber.BitString);
	der.endSequence();
}

function writePkcs1EdDSAPrivate(der, key) {
	var ver = Buffer$j.from([1]);
	der.writeBuffer(ver, lib$f.Ber.Integer);

	der.writeBuffer(key.part.k.data, lib$f.Ber.OctetString);

	der.startSequence(0xa0);
	der.writeOID('1.3.101.112');
	der.endSequence();

	der.startSequence(0xa1);
	utils$2.writeBitString(der, key.part.A.data);
	der.endSequence();
}

function writePkcs1EdDSAPublic(der, key) {
	throw (new Error('Public keys are not supported for EdDSA PKCS#1'));
}

// Copyright 2015 Joyent, Inc.

var rfc4253 = {
	read: read$9.bind(undefined, false, undefined),
	readType: read$9.bind(undefined, false),
	write: write$9,
	/* semi-private api, used by sshpk-agent */
	readPartial: read$9.bind(undefined, true),

	/* shared with ssh format */
	readInternal: read$9,
	keyTypeToAlg: keyTypeToAlg,
	algToKeyType: algToKeyType
};


var Buffer$i = safer_1.Buffer;






function algToKeyType(alg) {
	assert_1.string(alg);
	if (alg === 'ssh-dss')
		return ('dsa');
	else if (alg === 'ssh-rsa')
		return ('rsa');
	else if (alg === 'ssh-ed25519')
		return ('ed25519');
	else if (alg === 'ssh-curve25519')
		return ('curve25519');
	else if (alg.match(/^ecdsa-sha2-/))
		return ('ecdsa');
	else
		throw (new Error('Unknown algorithm ' + alg));
}

function keyTypeToAlg(key) {
	assert_1.object(key);
	if (key.type === 'dsa')
		return ('ssh-dss');
	else if (key.type === 'rsa')
		return ('ssh-rsa');
	else if (key.type === 'ed25519')
		return ('ssh-ed25519');
	else if (key.type === 'curve25519')
		return ('ssh-curve25519');
	else if (key.type === 'ecdsa')
		return ('ecdsa-sha2-' + key.part.curve.data.toString());
	else
		throw (new Error('Unknown key type ' + key.type));
}

function read$9(partial, type, buf, options) {
	if (typeof (buf) === 'string')
		buf = Buffer$i.from(buf);
	assert_1.buffer(buf, 'buf');

	var key = {};

	var parts = key.parts = [];
	var sshbuf = new sshBuffer({buffer: buf});

	var alg = sshbuf.readString();
	assert_1.ok(!sshbuf.atEnd(), 'key must have at least one part');

	key.type = algToKeyType(alg);

	var partCount = algs.info[key.type].parts.length;
	if (type && type === 'private')
		partCount = algs.privInfo[key.type].parts.length;

	while (!sshbuf.atEnd() && parts.length < partCount)
		parts.push(sshbuf.readPart());
	while (!partial && !sshbuf.atEnd())
		parts.push(sshbuf.readPart());

	assert_1.ok(parts.length >= 1,
	    'key must have at least one part');
	assert_1.ok(partial || sshbuf.atEnd(),
	    'leftover bytes at end of key');

	var Constructor = Key$1;
	var algInfo = algs.info[key.type];
	if (type === 'private' || algInfo.parts.length !== parts.length) {
		algInfo = algs.privInfo[key.type];
		Constructor = PrivateKey$1;
	}
	assert_1.strictEqual(algInfo.parts.length, parts.length);

	if (key.type === 'ecdsa') {
		var res = /^ecdsa-sha2-(.+)$/.exec(alg);
		assert_1.ok(res !== null);
		assert_1.strictEqual(res[1], parts[0].data.toString());
	}

	var normalized = true;
	for (var i = 0; i < algInfo.parts.length; ++i) {
		var p = parts[i];
		p.name = algInfo.parts[i];
		/*
		 * OpenSSH stores ed25519 "private" keys as seed + public key
		 * concat'd together (k followed by A). We want to keep them
		 * separate for other formats that don't do this.
		 */
		if (key.type === 'ed25519' && p.name === 'k')
			p.data = p.data.slice(0, 32);

		if (p.name !== 'curve' && algInfo.normalize !== false) {
			var nd;
			if (key.type === 'ed25519') {
				nd = utils$2.zeroPadToLength(p.data, 32);
			} else {
				nd = utils$2.mpNormalize(p.data);
			}
			if (nd.toString('binary') !==
			    p.data.toString('binary')) {
				p.data = nd;
				normalized = false;
			}
		}
	}

	if (normalized)
		key._rfc4253Cache = sshbuf.toBuffer();

	if (partial && typeof (partial) === 'object') {
		partial.remainder = sshbuf.remainder();
		partial.consumed = sshbuf._offset;
	}

	return (new Constructor(key));
}

function write$9(key, options) {
	assert_1.object(key);

	var alg = keyTypeToAlg(key);
	var i;

	var algInfo = algs.info[key.type];
	if (PrivateKey$1.isPrivateKey(key))
		algInfo = algs.privInfo[key.type];
	var parts = algInfo.parts;

	var buf = new sshBuffer({});

	buf.writeString(alg);

	for (i = 0; i < parts.length; ++i) {
		var data = key.part[parts[i]].data;
		if (algInfo.normalize !== false) {
			if (key.type === 'ed25519')
				data = utils$2.zeroPadToLength(data, 32);
			else
				data = utils$2.mpNormalize(data);
		}
		if (key.type === 'ed25519' && parts[i] === 'k')
			data = Buffer$i.concat([data, key.part.A.data]);
		buf.writeBuffer(data);
	}

	return (buf.toBuffer());
}

var crypto_hash_sha512 = naclFast.lowlevel.crypto_hash;

/*
 * This file is a 1:1 port from the OpenBSD blowfish.c and bcrypt_pbkdf.c. As a
 * result, it retains the original copyright and license. The two files are
 * under slightly different (but compatible) licenses, and are here combined in
 * one file.
 *
 * Credit for the actual porting work goes to:
 *  Devi Mandiri <me@devi.web.id>
 */

/*
 * The Blowfish portions are under the following license:
 *
 * Blowfish block cipher for OpenBSD
 * Copyright 1997 Niels Provos <provos@physnet.uni-hamburg.de>
 * All rights reserved.
 *
 * Implementation advice by David Mazieres <dm@lcs.mit.edu>.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions
 * are met:
 * 1. Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 * 2. Redistributions in binary form must reproduce the above copyright
 *    notice, this list of conditions and the following disclaimer in the
 *    documentation and/or other materials provided with the distribution.
 * 3. The name of the author may not be used to endorse or promote products
 *    derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
 * IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
 * OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
 * IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
 * INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
 * NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * The bcrypt_pbkdf portions are under the following license:
 *
 * Copyright (c) 2013 Ted Unangst <tedu@openbsd.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

/*
 * Performance improvements (Javascript-specific):
 *
 * Copyright 2016, Joyent Inc
 * Author: Alex Wilson <alex.wilson@joyent.com>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 */

// Ported from OpenBSD bcrypt_pbkdf.c v1.9

var BLF_J = 0;

var Blowfish = function() {
  this.S = [
    new Uint32Array([
      0xd1310ba6, 0x98dfb5ac, 0x2ffd72db, 0xd01adfb7,
      0xb8e1afed, 0x6a267e96, 0xba7c9045, 0xf12c7f99,
      0x24a19947, 0xb3916cf7, 0x0801f2e2, 0x858efc16,
      0x636920d8, 0x71574e69, 0xa458fea3, 0xf4933d7e,
      0x0d95748f, 0x728eb658, 0x718bcd58, 0x82154aee,
      0x7b54a41d, 0xc25a59b5, 0x9c30d539, 0x2af26013,
      0xc5d1b023, 0x286085f0, 0xca417918, 0xb8db38ef,
      0x8e79dcb0, 0x603a180e, 0x6c9e0e8b, 0xb01e8a3e,
      0xd71577c1, 0xbd314b27, 0x78af2fda, 0x55605c60,
      0xe65525f3, 0xaa55ab94, 0x57489862, 0x63e81440,
      0x55ca396a, 0x2aab10b6, 0xb4cc5c34, 0x1141e8ce,
      0xa15486af, 0x7c72e993, 0xb3ee1411, 0x636fbc2a,
      0x2ba9c55d, 0x741831f6, 0xce5c3e16, 0x9b87931e,
      0xafd6ba33, 0x6c24cf5c, 0x7a325381, 0x28958677,
      0x3b8f4898, 0x6b4bb9af, 0xc4bfe81b, 0x66282193,
      0x61d809cc, 0xfb21a991, 0x487cac60, 0x5dec8032,
      0xef845d5d, 0xe98575b1, 0xdc262302, 0xeb651b88,
      0x23893e81, 0xd396acc5, 0x0f6d6ff3, 0x83f44239,
      0x2e0b4482, 0xa4842004, 0x69c8f04a, 0x9e1f9b5e,
      0x21c66842, 0xf6e96c9a, 0x670c9c61, 0xabd388f0,
      0x6a51a0d2, 0xd8542f68, 0x960fa728, 0xab5133a3,
      0x6eef0b6c, 0x137a3be4, 0xba3bf050, 0x7efb2a98,
      0xa1f1651d, 0x39af0176, 0x66ca593e, 0x82430e88,
      0x8cee8619, 0x456f9fb4, 0x7d84a5c3, 0x3b8b5ebe,
      0xe06f75d8, 0x85c12073, 0x401a449f, 0x56c16aa6,
      0x4ed3aa62, 0x363f7706, 0x1bfedf72, 0x429b023d,
      0x37d0d724, 0xd00a1248, 0xdb0fead3, 0x49f1c09b,
      0x075372c9, 0x80991b7b, 0x25d479d8, 0xf6e8def7,
      0xe3fe501a, 0xb6794c3b, 0x976ce0bd, 0x04c006ba,
      0xc1a94fb6, 0x409f60c4, 0x5e5c9ec2, 0x196a2463,
      0x68fb6faf, 0x3e6c53b5, 0x1339b2eb, 0x3b52ec6f,
      0x6dfc511f, 0x9b30952c, 0xcc814544, 0xaf5ebd09,
      0xbee3d004, 0xde334afd, 0x660f2807, 0x192e4bb3,
      0xc0cba857, 0x45c8740f, 0xd20b5f39, 0xb9d3fbdb,
      0x5579c0bd, 0x1a60320a, 0xd6a100c6, 0x402c7279,
      0x679f25fe, 0xfb1fa3cc, 0x8ea5e9f8, 0xdb3222f8,
      0x3c7516df, 0xfd616b15, 0x2f501ec8, 0xad0552ab,
      0x323db5fa, 0xfd238760, 0x53317b48, 0x3e00df82,
      0x9e5c57bb, 0xca6f8ca0, 0x1a87562e, 0xdf1769db,
      0xd542a8f6, 0x287effc3, 0xac6732c6, 0x8c4f5573,
      0x695b27b0, 0xbbca58c8, 0xe1ffa35d, 0xb8f011a0,
      0x10fa3d98, 0xfd2183b8, 0x4afcb56c, 0x2dd1d35b,
      0x9a53e479, 0xb6f84565, 0xd28e49bc, 0x4bfb9790,
      0xe1ddf2da, 0xa4cb7e33, 0x62fb1341, 0xcee4c6e8,
      0xef20cada, 0x36774c01, 0xd07e9efe, 0x2bf11fb4,
      0x95dbda4d, 0xae909198, 0xeaad8e71, 0x6b93d5a0,
      0xd08ed1d0, 0xafc725e0, 0x8e3c5b2f, 0x8e7594b7,
      0x8ff6e2fb, 0xf2122b64, 0x8888b812, 0x900df01c,
      0x4fad5ea0, 0x688fc31c, 0xd1cff191, 0xb3a8c1ad,
      0x2f2f2218, 0xbe0e1777, 0xea752dfe, 0x8b021fa1,
      0xe5a0cc0f, 0xb56f74e8, 0x18acf3d6, 0xce89e299,
      0xb4a84fe0, 0xfd13e0b7, 0x7cc43b81, 0xd2ada8d9,
      0x165fa266, 0x80957705, 0x93cc7314, 0x211a1477,
      0xe6ad2065, 0x77b5fa86, 0xc75442f5, 0xfb9d35cf,
      0xebcdaf0c, 0x7b3e89a0, 0xd6411bd3, 0xae1e7e49,
      0x00250e2d, 0x2071b35e, 0x226800bb, 0x57b8e0af,
      0x2464369b, 0xf009b91e, 0x5563911d, 0x59dfa6aa,
      0x78c14389, 0xd95a537f, 0x207d5ba2, 0x02e5b9c5,
      0x83260376, 0x6295cfa9, 0x11c81968, 0x4e734a41,
      0xb3472dca, 0x7b14a94a, 0x1b510052, 0x9a532915,
      0xd60f573f, 0xbc9bc6e4, 0x2b60a476, 0x81e67400,
      0x08ba6fb5, 0x571be91f, 0xf296ec6b, 0x2a0dd915,
      0xb6636521, 0xe7b9f9b6, 0xff34052e, 0xc5855664,
      0x53b02d5d, 0xa99f8fa1, 0x08ba4799, 0x6e85076a]),
    new Uint32Array([
      0x4b7a70e9, 0xb5b32944, 0xdb75092e, 0xc4192623,
      0xad6ea6b0, 0x49a7df7d, 0x9cee60b8, 0x8fedb266,
      0xecaa8c71, 0x699a17ff, 0x5664526c, 0xc2b19ee1,
      0x193602a5, 0x75094c29, 0xa0591340, 0xe4183a3e,
      0x3f54989a, 0x5b429d65, 0x6b8fe4d6, 0x99f73fd6,
      0xa1d29c07, 0xefe830f5, 0x4d2d38e6, 0xf0255dc1,
      0x4cdd2086, 0x8470eb26, 0x6382e9c6, 0x021ecc5e,
      0x09686b3f, 0x3ebaefc9, 0x3c971814, 0x6b6a70a1,
      0x687f3584, 0x52a0e286, 0xb79c5305, 0xaa500737,
      0x3e07841c, 0x7fdeae5c, 0x8e7d44ec, 0x5716f2b8,
      0xb03ada37, 0xf0500c0d, 0xf01c1f04, 0x0200b3ff,
      0xae0cf51a, 0x3cb574b2, 0x25837a58, 0xdc0921bd,
      0xd19113f9, 0x7ca92ff6, 0x94324773, 0x22f54701,
      0x3ae5e581, 0x37c2dadc, 0xc8b57634, 0x9af3dda7,
      0xa9446146, 0x0fd0030e, 0xecc8c73e, 0xa4751e41,
      0xe238cd99, 0x3bea0e2f, 0x3280bba1, 0x183eb331,
      0x4e548b38, 0x4f6db908, 0x6f420d03, 0xf60a04bf,
      0x2cb81290, 0x24977c79, 0x5679b072, 0xbcaf89af,
      0xde9a771f, 0xd9930810, 0xb38bae12, 0xdccf3f2e,
      0x5512721f, 0x2e6b7124, 0x501adde6, 0x9f84cd87,
      0x7a584718, 0x7408da17, 0xbc9f9abc, 0xe94b7d8c,
      0xec7aec3a, 0xdb851dfa, 0x63094366, 0xc464c3d2,
      0xef1c1847, 0x3215d908, 0xdd433b37, 0x24c2ba16,
      0x12a14d43, 0x2a65c451, 0x50940002, 0x133ae4dd,
      0x71dff89e, 0x10314e55, 0x81ac77d6, 0x5f11199b,
      0x043556f1, 0xd7a3c76b, 0x3c11183b, 0x5924a509,
      0xf28fe6ed, 0x97f1fbfa, 0x9ebabf2c, 0x1e153c6e,
      0x86e34570, 0xeae96fb1, 0x860e5e0a, 0x5a3e2ab3,
      0x771fe71c, 0x4e3d06fa, 0x2965dcb9, 0x99e71d0f,
      0x803e89d6, 0x5266c825, 0x2e4cc978, 0x9c10b36a,
      0xc6150eba, 0x94e2ea78, 0xa5fc3c53, 0x1e0a2df4,
      0xf2f74ea7, 0x361d2b3d, 0x1939260f, 0x19c27960,
      0x5223a708, 0xf71312b6, 0xebadfe6e, 0xeac31f66,
      0xe3bc4595, 0xa67bc883, 0xb17f37d1, 0x018cff28,
      0xc332ddef, 0xbe6c5aa5, 0x65582185, 0x68ab9802,
      0xeecea50f, 0xdb2f953b, 0x2aef7dad, 0x5b6e2f84,
      0x1521b628, 0x29076170, 0xecdd4775, 0x619f1510,
      0x13cca830, 0xeb61bd96, 0x0334fe1e, 0xaa0363cf,
      0xb5735c90, 0x4c70a239, 0xd59e9e0b, 0xcbaade14,
      0xeecc86bc, 0x60622ca7, 0x9cab5cab, 0xb2f3846e,
      0x648b1eaf, 0x19bdf0ca, 0xa02369b9, 0x655abb50,
      0x40685a32, 0x3c2ab4b3, 0x319ee9d5, 0xc021b8f7,
      0x9b540b19, 0x875fa099, 0x95f7997e, 0x623d7da8,
      0xf837889a, 0x97e32d77, 0x11ed935f, 0x16681281,
      0x0e358829, 0xc7e61fd6, 0x96dedfa1, 0x7858ba99,
      0x57f584a5, 0x1b227263, 0x9b83c3ff, 0x1ac24696,
      0xcdb30aeb, 0x532e3054, 0x8fd948e4, 0x6dbc3128,
      0x58ebf2ef, 0x34c6ffea, 0xfe28ed61, 0xee7c3c73,
      0x5d4a14d9, 0xe864b7e3, 0x42105d14, 0x203e13e0,
      0x45eee2b6, 0xa3aaabea, 0xdb6c4f15, 0xfacb4fd0,
      0xc742f442, 0xef6abbb5, 0x654f3b1d, 0x41cd2105,
      0xd81e799e, 0x86854dc7, 0xe44b476a, 0x3d816250,
      0xcf62a1f2, 0x5b8d2646, 0xfc8883a0, 0xc1c7b6a3,
      0x7f1524c3, 0x69cb7492, 0x47848a0b, 0x5692b285,
      0x095bbf00, 0xad19489d, 0x1462b174, 0x23820e00,
      0x58428d2a, 0x0c55f5ea, 0x1dadf43e, 0x233f7061,
      0x3372f092, 0x8d937e41, 0xd65fecf1, 0x6c223bdb,
      0x7cde3759, 0xcbee7460, 0x4085f2a7, 0xce77326e,
      0xa6078084, 0x19f8509e, 0xe8efd855, 0x61d99735,
      0xa969a7aa, 0xc50c06c2, 0x5a04abfc, 0x800bcadc,
      0x9e447a2e, 0xc3453484, 0xfdd56705, 0x0e1e9ec9,
      0xdb73dbd3, 0x105588cd, 0x675fda79, 0xe3674340,
      0xc5c43465, 0x713e38d8, 0x3d28f89e, 0xf16dff20,
      0x153e21e7, 0x8fb03d4a, 0xe6e39f2b, 0xdb83adf7]),
    new Uint32Array([
      0xe93d5a68, 0x948140f7, 0xf64c261c, 0x94692934,
      0x411520f7, 0x7602d4f7, 0xbcf46b2e, 0xd4a20068,
      0xd4082471, 0x3320f46a, 0x43b7d4b7, 0x500061af,
      0x1e39f62e, 0x97244546, 0x14214f74, 0xbf8b8840,
      0x4d95fc1d, 0x96b591af, 0x70f4ddd3, 0x66a02f45,
      0xbfbc09ec, 0x03bd9785, 0x7fac6dd0, 0x31cb8504,
      0x96eb27b3, 0x55fd3941, 0xda2547e6, 0xabca0a9a,
      0x28507825, 0x530429f4, 0x0a2c86da, 0xe9b66dfb,
      0x68dc1462, 0xd7486900, 0x680ec0a4, 0x27a18dee,
      0x4f3ffea2, 0xe887ad8c, 0xb58ce006, 0x7af4d6b6,
      0xaace1e7c, 0xd3375fec, 0xce78a399, 0x406b2a42,
      0x20fe9e35, 0xd9f385b9, 0xee39d7ab, 0x3b124e8b,
      0x1dc9faf7, 0x4b6d1856, 0x26a36631, 0xeae397b2,
      0x3a6efa74, 0xdd5b4332, 0x6841e7f7, 0xca7820fb,
      0xfb0af54e, 0xd8feb397, 0x454056ac, 0xba489527,
      0x55533a3a, 0x20838d87, 0xfe6ba9b7, 0xd096954b,
      0x55a867bc, 0xa1159a58, 0xcca92963, 0x99e1db33,
      0xa62a4a56, 0x3f3125f9, 0x5ef47e1c, 0x9029317c,
      0xfdf8e802, 0x04272f70, 0x80bb155c, 0x05282ce3,
      0x95c11548, 0xe4c66d22, 0x48c1133f, 0xc70f86dc,
      0x07f9c9ee, 0x41041f0f, 0x404779a4, 0x5d886e17,
      0x325f51eb, 0xd59bc0d1, 0xf2bcc18f, 0x41113564,
      0x257b7834, 0x602a9c60, 0xdff8e8a3, 0x1f636c1b,
      0x0e12b4c2, 0x02e1329e, 0xaf664fd1, 0xcad18115,
      0x6b2395e0, 0x333e92e1, 0x3b240b62, 0xeebeb922,
      0x85b2a20e, 0xe6ba0d99, 0xde720c8c, 0x2da2f728,
      0xd0127845, 0x95b794fd, 0x647d0862, 0xe7ccf5f0,
      0x5449a36f, 0x877d48fa, 0xc39dfd27, 0xf33e8d1e,
      0x0a476341, 0x992eff74, 0x3a6f6eab, 0xf4f8fd37,
      0xa812dc60, 0xa1ebddf8, 0x991be14c, 0xdb6e6b0d,
      0xc67b5510, 0x6d672c37, 0x2765d43b, 0xdcd0e804,
      0xf1290dc7, 0xcc00ffa3, 0xb5390f92, 0x690fed0b,
      0x667b9ffb, 0xcedb7d9c, 0xa091cf0b, 0xd9155ea3,
      0xbb132f88, 0x515bad24, 0x7b9479bf, 0x763bd6eb,
      0x37392eb3, 0xcc115979, 0x8026e297, 0xf42e312d,
      0x6842ada7, 0xc66a2b3b, 0x12754ccc, 0x782ef11c,
      0x6a124237, 0xb79251e7, 0x06a1bbe6, 0x4bfb6350,
      0x1a6b1018, 0x11caedfa, 0x3d25bdd8, 0xe2e1c3c9,
      0x44421659, 0x0a121386, 0xd90cec6e, 0xd5abea2a,
      0x64af674e, 0xda86a85f, 0xbebfe988, 0x64e4c3fe,
      0x9dbc8057, 0xf0f7c086, 0x60787bf8, 0x6003604d,
      0xd1fd8346, 0xf6381fb0, 0x7745ae04, 0xd736fccc,
      0x83426b33, 0xf01eab71, 0xb0804187, 0x3c005e5f,
      0x77a057be, 0xbde8ae24, 0x55464299, 0xbf582e61,
      0x4e58f48f, 0xf2ddfda2, 0xf474ef38, 0x8789bdc2,
      0x5366f9c3, 0xc8b38e74, 0xb475f255, 0x46fcd9b9,
      0x7aeb2661, 0x8b1ddf84, 0x846a0e79, 0x915f95e2,
      0x466e598e, 0x20b45770, 0x8cd55591, 0xc902de4c,
      0xb90bace1, 0xbb8205d0, 0x11a86248, 0x7574a99e,
      0xb77f19b6, 0xe0a9dc09, 0x662d09a1, 0xc4324633,
      0xe85a1f02, 0x09f0be8c, 0x4a99a025, 0x1d6efe10,
      0x1ab93d1d, 0x0ba5a4df, 0xa186f20f, 0x2868f169,
      0xdcb7da83, 0x573906fe, 0xa1e2ce9b, 0x4fcd7f52,
      0x50115e01, 0xa70683fa, 0xa002b5c4, 0x0de6d027,
      0x9af88c27, 0x773f8641, 0xc3604c06, 0x61a806b5,
      0xf0177a28, 0xc0f586e0, 0x006058aa, 0x30dc7d62,
      0x11e69ed7, 0x2338ea63, 0x53c2dd94, 0xc2c21634,
      0xbbcbee56, 0x90bcb6de, 0xebfc7da1, 0xce591d76,
      0x6f05e409, 0x4b7c0188, 0x39720a3d, 0x7c927c24,
      0x86e3725f, 0x724d9db9, 0x1ac15bb4, 0xd39eb8fc,
      0xed545578, 0x08fca5b5, 0xd83d7cd3, 0x4dad0fc4,
      0x1e50ef5e, 0xb161e6f8, 0xa28514d9, 0x6c51133c,
      0x6fd5c7e7, 0x56e14ec4, 0x362abfce, 0xddc6c837,
      0xd79a3234, 0x92638212, 0x670efa8e, 0x406000e0]),
    new Uint32Array([
      0x3a39ce37, 0xd3faf5cf, 0xabc27737, 0x5ac52d1b,
      0x5cb0679e, 0x4fa33742, 0xd3822740, 0x99bc9bbe,
      0xd5118e9d, 0xbf0f7315, 0xd62d1c7e, 0xc700c47b,
      0xb78c1b6b, 0x21a19045, 0xb26eb1be, 0x6a366eb4,
      0x5748ab2f, 0xbc946e79, 0xc6a376d2, 0x6549c2c8,
      0x530ff8ee, 0x468dde7d, 0xd5730a1d, 0x4cd04dc6,
      0x2939bbdb, 0xa9ba4650, 0xac9526e8, 0xbe5ee304,
      0xa1fad5f0, 0x6a2d519a, 0x63ef8ce2, 0x9a86ee22,
      0xc089c2b8, 0x43242ef6, 0xa51e03aa, 0x9cf2d0a4,
      0x83c061ba, 0x9be96a4d, 0x8fe51550, 0xba645bd6,
      0x2826a2f9, 0xa73a3ae1, 0x4ba99586, 0xef5562e9,
      0xc72fefd3, 0xf752f7da, 0x3f046f69, 0x77fa0a59,
      0x80e4a915, 0x87b08601, 0x9b09e6ad, 0x3b3ee593,
      0xe990fd5a, 0x9e34d797, 0x2cf0b7d9, 0x022b8b51,
      0x96d5ac3a, 0x017da67d, 0xd1cf3ed6, 0x7c7d2d28,
      0x1f9f25cf, 0xadf2b89b, 0x5ad6b472, 0x5a88f54c,
      0xe029ac71, 0xe019a5e6, 0x47b0acfd, 0xed93fa9b,
      0xe8d3c48d, 0x283b57cc, 0xf8d56629, 0x79132e28,
      0x785f0191, 0xed756055, 0xf7960e44, 0xe3d35e8c,
      0x15056dd4, 0x88f46dba, 0x03a16125, 0x0564f0bd,
      0xc3eb9e15, 0x3c9057a2, 0x97271aec, 0xa93a072a,
      0x1b3f6d9b, 0x1e6321f5, 0xf59c66fb, 0x26dcf319,
      0x7533d928, 0xb155fdf5, 0x03563482, 0x8aba3cbb,
      0x28517711, 0xc20ad9f8, 0xabcc5167, 0xccad925f,
      0x4de81751, 0x3830dc8e, 0x379d5862, 0x9320f991,
      0xea7a90c2, 0xfb3e7bce, 0x5121ce64, 0x774fbe32,
      0xa8b6e37e, 0xc3293d46, 0x48de5369, 0x6413e680,
      0xa2ae0810, 0xdd6db224, 0x69852dfd, 0x09072166,
      0xb39a460a, 0x6445c0dd, 0x586cdecf, 0x1c20c8ae,
      0x5bbef7dd, 0x1b588d40, 0xccd2017f, 0x6bb4e3bb,
      0xdda26a7e, 0x3a59ff45, 0x3e350a44, 0xbcb4cdd5,
      0x72eacea8, 0xfa6484bb, 0x8d6612ae, 0xbf3c6f47,
      0xd29be463, 0x542f5d9e, 0xaec2771b, 0xf64e6370,
      0x740e0d8d, 0xe75b1357, 0xf8721671, 0xaf537d5d,
      0x4040cb08, 0x4eb4e2cc, 0x34d2466a, 0x0115af84,
      0xe1b00428, 0x95983a1d, 0x06b89fb4, 0xce6ea048,
      0x6f3f3b82, 0x3520ab82, 0x011a1d4b, 0x277227f8,
      0x611560b1, 0xe7933fdc, 0xbb3a792b, 0x344525bd,
      0xa08839e1, 0x51ce794b, 0x2f32c9b7, 0xa01fbac9,
      0xe01cc87e, 0xbcc7d1f6, 0xcf0111c3, 0xa1e8aac7,
      0x1a908749, 0xd44fbd9a, 0xd0dadecb, 0xd50ada38,
      0x0339c32a, 0xc6913667, 0x8df9317c, 0xe0b12b4f,
      0xf79e59b7, 0x43f5bb3a, 0xf2d519ff, 0x27d9459c,
      0xbf97222c, 0x15e6fc2a, 0x0f91fc71, 0x9b941525,
      0xfae59361, 0xceb69ceb, 0xc2a86459, 0x12baa8d1,
      0xb6c1075e, 0xe3056a0c, 0x10d25065, 0xcb03a442,
      0xe0ec6e0e, 0x1698db3b, 0x4c98a0be, 0x3278e964,
      0x9f1f9532, 0xe0d392df, 0xd3a0342b, 0x8971f21e,
      0x1b0a7441, 0x4ba3348c, 0xc5be7120, 0xc37632d8,
      0xdf359f8d, 0x9b992f2e, 0xe60b6f47, 0x0fe3f11d,
      0xe54cda54, 0x1edad891, 0xce6279cf, 0xcd3e7e6f,
      0x1618b166, 0xfd2c1d05, 0x848fd2c5, 0xf6fb2299,
      0xf523f357, 0xa6327623, 0x93a83531, 0x56cccd02,
      0xacf08162, 0x5a75ebb5, 0x6e163697, 0x88d273cc,
      0xde966292, 0x81b949d0, 0x4c50901b, 0x71c65614,
      0xe6c6c7bd, 0x327a140a, 0x45e1d006, 0xc3f27b9a,
      0xc9aa53fd, 0x62a80f00, 0xbb25bfe2, 0x35bdd2f6,
      0x71126905, 0xb2040222, 0xb6cbcf7c, 0xcd769c2b,
      0x53113ec0, 0x1640e3d3, 0x38abbd60, 0x2547adf0,
      0xba38209c, 0xf746ce76, 0x77afa1c5, 0x20756060,
      0x85cbfe4e, 0x8ae88dd8, 0x7aaaf9b0, 0x4cf9aa7e,
      0x1948c25c, 0x02fb8a8c, 0x01c36ae4, 0xd6ebe1f9,
      0x90d4f869, 0xa65cdea0, 0x3f09252d, 0xc208e69f,
      0xb74e6132, 0xce77e25b, 0x578fdfe3, 0x3ac372e6])
    ];
  this.P = new Uint32Array([
    0x243f6a88, 0x85a308d3, 0x13198a2e, 0x03707344,
    0xa4093822, 0x299f31d0, 0x082efa98, 0xec4e6c89,
    0x452821e6, 0x38d01377, 0xbe5466cf, 0x34e90c6c,
    0xc0ac29b7, 0xc97c50dd, 0x3f84d5b5, 0xb5470917,
    0x9216d5d9, 0x8979fb1b]);
};

function F(S, x8, i) {
  return (((S[0][x8[i+3]] +
            S[1][x8[i+2]]) ^
            S[2][x8[i+1]]) +
            S[3][x8[i]]);
}
Blowfish.prototype.encipher = function(x, x8) {
  if (x8 === undefined) {
    x8 = new Uint8Array(x.buffer);
    if (x.byteOffset !== 0)
      x8 = x8.subarray(x.byteOffset);
  }
  x[0] ^= this.P[0];
  for (var i = 1; i < 16; i += 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i+1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[17];
  x[1] = t;
};

Blowfish.prototype.decipher = function(x) {
  var x8 = new Uint8Array(x.buffer);
  if (x.byteOffset !== 0)
    x8 = x8.subarray(x.byteOffset);
  x[0] ^= this.P[17];
  for (var i = 16; i > 0; i -= 2) {
    x[1] ^= F(this.S, x8, 0) ^ this.P[i];
    x[0] ^= F(this.S, x8, 4) ^ this.P[i-1];
  }
  var t = x[0];
  x[0] = x[1] ^ this.P[0];
  x[1] = t;
};

function stream2word(data, databytes){
  var i, temp = 0;
  for (i = 0; i < 4; i++, BLF_J++) {
    if (BLF_J >= databytes) BLF_J = 0;
    temp = (temp << 8) | data[BLF_J];
  }
  return temp;
}
Blowfish.prototype.expand0state = function(key, keybytes) {
  var d = new Uint32Array(2), i, k;
  var d8 = new Uint8Array(d.buffer);

  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key, keybytes);
  }
  BLF_J = 0;

  for (i = 0; i < 18; i += 2) {
    this.encipher(d, d8);
    this.P[i]   = d[0];
    this.P[i+1] = d[1];
  }

  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      this.encipher(d, d8);
      this.S[i][k]   = d[0];
      this.S[i][k+1] = d[1];
    }
  }
};

Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
  var d = new Uint32Array(2), i, k;

  for (i = 0, BLF_J = 0; i < 18; i++) {
    this.P[i] ^= stream2word(key, keybytes);
  }

  for (i = 0, BLF_J = 0; i < 18; i += 2) {
    d[0] ^= stream2word(data, databytes);
    d[1] ^= stream2word(data, databytes);
    this.encipher(d);
    this.P[i]   = d[0];
    this.P[i+1] = d[1];
  }

  for (i = 0; i < 4; i++) {
    for (k = 0; k < 256; k += 2) {
      d[0] ^= stream2word(data, databytes);
      d[1] ^= stream2word(data, databytes);
      this.encipher(d);
      this.S[i][k]   = d[0];
      this.S[i][k+1] = d[1];
    }
  }
  BLF_J = 0;
};

Blowfish.prototype.enc = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.encipher(data.subarray(i*2));
  }
};

Blowfish.prototype.dec = function(data, blocks) {
  for (var i = 0; i < blocks; i++) {
    this.decipher(data.subarray(i*2));
  }
};

var BCRYPT_BLOCKS = 8,
    BCRYPT_HASHSIZE = 32;

function bcrypt_hash(sha2pass, sha2salt, out) {
  var state = new Blowfish(),
      cdata = new Uint32Array(BCRYPT_BLOCKS), i,
      ciphertext = new Uint8Array([79,120,121,99,104,114,111,109,97,116,105,
            99,66,108,111,119,102,105,115,104,83,119,97,116,68,121,110,97,109,
            105,116,101]); //"OxychromaticBlowfishSwatDynamite"

  state.expandstate(sha2salt, 64, sha2pass, 64);
  for (i = 0; i < 64; i++) {
    state.expand0state(sha2salt, 64);
    state.expand0state(sha2pass, 64);
  }

  for (i = 0; i < BCRYPT_BLOCKS; i++)
    cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
  for (i = 0; i < 64; i++)
    state.enc(cdata, cdata.byteLength / 8);

  for (i = 0; i < BCRYPT_BLOCKS; i++) {
    out[4*i+3] = cdata[i] >>> 24;
    out[4*i+2] = cdata[i] >>> 16;
    out[4*i+1] = cdata[i] >>> 8;
    out[4*i+0] = cdata[i];
  }
}
function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
  var sha2pass = new Uint8Array(64),
      sha2salt = new Uint8Array(64),
      out = new Uint8Array(BCRYPT_HASHSIZE),
      tmpout = new Uint8Array(BCRYPT_HASHSIZE),
      countsalt = new Uint8Array(saltlen+4),
      i, j, amt, stride, dest, count,
      origkeylen = keylen;

  if (rounds < 1)
    return -1;
  if (passlen === 0 || saltlen === 0 || keylen === 0 ||
      keylen > (out.byteLength * out.byteLength) || saltlen > (1<<20))
    return -1;

  stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
  amt = Math.floor((keylen + stride - 1) / stride);

  for (i = 0; i < saltlen; i++)
    countsalt[i] = salt[i];

  crypto_hash_sha512(sha2pass, pass, passlen);

  for (count = 1; keylen > 0; count++) {
    countsalt[saltlen+0] = count >>> 24;
    countsalt[saltlen+1] = count >>> 16;
    countsalt[saltlen+2] = count >>>  8;
    countsalt[saltlen+3] = count;

    crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
    bcrypt_hash(sha2pass, sha2salt, tmpout);
    for (i = out.byteLength; i--;)
      out[i] = tmpout[i];

    for (i = 1; i < rounds; i++) {
      crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
      bcrypt_hash(sha2pass, sha2salt, tmpout);
      for (j = 0; j < out.byteLength; j++)
        out[j] ^= tmpout[j];
    }

    amt = Math.min(amt, keylen);
    for (i = 0; i < amt; i++) {
      dest = i * stride + (count - 1);
      if (dest >= origkeylen)
        break;
      key[dest] = out[i];
    }
    keylen -= i;
  }

  return 0;
}
var bcryptPbkdf = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
};

// Copyright 2015 Joyent, Inc.

var sshPrivate = {
	read: read$8,
	readSSHPrivate: readSSHPrivate,
	write: write$8
};



var Buffer$h = safer_1.Buffer;











var bcrypt;

function read$8(buf, options) {
	return (require$$3$1.read(buf, options));
}

var MAGIC = 'openssh-key-v1';

function readSSHPrivate(type, buf, options) {
	buf = new sshBuffer({buffer: buf});

	var magic = buf.readCString();
	assert_1.strictEqual(magic, MAGIC, 'bad magic string');

	var cipher = buf.readString();
	var kdf = buf.readString();
	var kdfOpts = buf.readBuffer();

	var nkeys = buf.readInt();
	if (nkeys !== 1) {
		throw (new Error('OpenSSH-format key file contains ' +
		    'multiple keys: this is unsupported.'));
	}

	var pubKey = buf.readBuffer();

	if (type === 'public') {
		assert_1.ok(buf.atEnd(), 'excess bytes left after key');
		return (rfc4253.read(pubKey));
	}

	var privKeyBlob = buf.readBuffer();
	assert_1.ok(buf.atEnd(), 'excess bytes left after key');

	var kdfOptsBuf = new sshBuffer({ buffer: kdfOpts });
	switch (kdf) {
	case 'none':
		if (cipher !== 'none') {
			throw (new Error('OpenSSH-format key uses KDF "none" ' +
			     'but specifies a cipher other than "none"'));
		}
		break;
	case 'bcrypt':
		var salt = kdfOptsBuf.readBuffer();
		var rounds = kdfOptsBuf.readInt();
		var cinf = utils$2.opensshCipherInfo(cipher);
		if (bcrypt === undefined) {
			bcrypt = bcryptPbkdf;
		}

		if (typeof (options.passphrase) === 'string') {
			options.passphrase = Buffer$h.from(options.passphrase,
			    'utf-8');
		}
		if (!Buffer$h.isBuffer(options.passphrase)) {
			throw (new errors$1.KeyEncryptedError(
			    options.filename, 'OpenSSH'));
		}

		var pass = new Uint8Array(options.passphrase);
		var salti = new Uint8Array(salt);
		/* Use the pbkdf to derive both the key and the IV. */
		var out = new Uint8Array(cinf.keySize + cinf.blockSize);
		var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
		    out, out.length, rounds);
		if (res !== 0) {
			throw (new Error('bcrypt_pbkdf function returned ' +
			    'failure, parameters invalid'));
		}
		out = Buffer$h.from(out);
		var ckey = out.slice(0, cinf.keySize);
		var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);
		var cipherStream = crypto$1.createDecipheriv(cinf.opensslName,
		    ckey, iv);
		cipherStream.setAutoPadding(false);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			if (e.toString().indexOf('bad decrypt') !== -1) {
				throw (new Error('Incorrect passphrase ' +
				    'supplied, could not decrypt key'));
			}
			throw (e);
		});
		cipherStream.write(privKeyBlob);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		privKeyBlob = Buffer$h.concat(chunks);
		break;
	default:
		throw (new Error(
		    'OpenSSH-format key uses unknown KDF "' + kdf + '"'));
	}

	buf = new sshBuffer({buffer: privKeyBlob});

	var checkInt1 = buf.readInt();
	var checkInt2 = buf.readInt();
	if (checkInt1 !== checkInt2) {
		throw (new Error('Incorrect passphrase supplied, could not ' +
		    'decrypt key'));
	}

	var ret = {};
	var key = rfc4253.readInternal(ret, 'private', buf.remainder());

	buf.skip(ret.consumed);

	var comment = buf.readString();
	key.comment = comment;

	return (key);
}

function write$8(key, options) {
	var pubKey;
	if (PrivateKey$1.isPrivateKey(key))
		pubKey = key.toPublic();
	else
		pubKey = key;

	var cipher = 'none';
	var kdf = 'none';
	var kdfopts = Buffer$h.alloc(0);
	var cinf = { blockSize: 8 };
	var passphrase;
	if (options !== undefined) {
		passphrase = options.passphrase;
		if (typeof (passphrase) === 'string')
			passphrase = Buffer$h.from(passphrase, 'utf-8');
		if (passphrase !== undefined) {
			assert_1.buffer(passphrase, 'options.passphrase');
			assert_1.optionalString(options.cipher, 'options.cipher');
			cipher = options.cipher;
			if (cipher === undefined)
				cipher = 'aes128-ctr';
			cinf = utils$2.opensshCipherInfo(cipher);
			kdf = 'bcrypt';
		}
	}

	var privBuf;
	if (PrivateKey$1.isPrivateKey(key)) {
		privBuf = new sshBuffer({});
		var checkInt = crypto$1.randomBytes(4).readUInt32BE(0);
		privBuf.writeInt(checkInt);
		privBuf.writeInt(checkInt);
		privBuf.write(key.toBuffer('rfc4253'));
		privBuf.writeString(key.comment || '');

		var n = 1;
		while (privBuf._offset % cinf.blockSize !== 0)
			privBuf.writeChar(n++);
		privBuf = privBuf.toBuffer();
	}

	switch (kdf) {
	case 'none':
		break;
	case 'bcrypt':
		var salt = crypto$1.randomBytes(16);
		var rounds = 16;
		var kdfssh = new sshBuffer({});
		kdfssh.writeBuffer(salt);
		kdfssh.writeInt(rounds);
		kdfopts = kdfssh.toBuffer();

		if (bcrypt === undefined) {
			bcrypt = bcryptPbkdf;
		}
		var pass = new Uint8Array(passphrase);
		var salti = new Uint8Array(salt);
		/* Use the pbkdf to derive both the key and the IV. */
		var out = new Uint8Array(cinf.keySize + cinf.blockSize);
		var res = bcrypt.pbkdf(pass, pass.length, salti, salti.length,
		    out, out.length, rounds);
		if (res !== 0) {
			throw (new Error('bcrypt_pbkdf function returned ' +
			    'failure, parameters invalid'));
		}
		out = Buffer$h.from(out);
		var ckey = out.slice(0, cinf.keySize);
		var iv = out.slice(cinf.keySize, cinf.keySize + cinf.blockSize);

		var cipherStream = crypto$1.createCipheriv(cinf.opensslName,
		    ckey, iv);
		cipherStream.setAutoPadding(false);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			throw (e);
		});
		cipherStream.write(privBuf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		privBuf = Buffer$h.concat(chunks);
		break;
	default:
		throw (new Error('Unsupported kdf ' + kdf));
	}

	var buf = new sshBuffer({});

	buf.writeCString(MAGIC);
	buf.writeString(cipher);	/* cipher */
	buf.writeString(kdf);		/* kdf */
	buf.writeBuffer(kdfopts);	/* kdfoptions */

	buf.writeInt(1);		/* nkeys */
	buf.writeBuffer(pubKey.toBuffer('rfc4253'));

	if (privBuf)
		buf.writeBuffer(privBuf);

	buf = buf.toBuffer();

	var header;
	if (PrivateKey$1.isPrivateKey(key))
		header = 'OPENSSH PRIVATE KEY';
	else
		header = 'OPENSSH PUBLIC KEY';

	var tmp = buf.toString('base64');
	var len = tmp.length + (tmp.length / 70) +
	    18 + 16 + header.length*2 + 10;
	buf = Buffer$h.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 70;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}

// Copyright 2018 Joyent, Inc.

var pem = {
	read: read$7,
	write: write$7
};




var Buffer$g = safer_1.Buffer;












var OID_PBES2 = '1.2.840.113549.1.5.13';
var OID_PBKDF2 = '1.2.840.113549.1.5.12';

var OID_TO_CIPHER = {
	'1.2.840.113549.3.7': '3des-cbc',
	'2.16.840.1.101.3.4.1.2': 'aes128-cbc',
	'2.16.840.1.101.3.4.1.42': 'aes256-cbc'
};
var CIPHER_TO_OID = {};
Object.keys(OID_TO_CIPHER).forEach(function (k) {
	CIPHER_TO_OID[OID_TO_CIPHER[k]] = k;
});

var OID_TO_HASH = {
	'1.2.840.113549.2.7': 'sha1',
	'1.2.840.113549.2.9': 'sha256',
	'1.2.840.113549.2.11': 'sha512'
};
var HASH_TO_OID = {};
Object.keys(OID_TO_HASH).forEach(function (k) {
	HASH_TO_OID[OID_TO_HASH[k]] = k;
});

/*
 * For reading we support both PKCS#1 and PKCS#8. If we find a private key,
 * we just take the public component of it and use that.
 */
function read$7(buf, options, forceType) {
	var input = buf;
	if (typeof (buf) !== 'string') {
		assert_1.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var lines = buf.trim().split(/[\r\n]+/g);

	var m;
	var si = -1;
	while (!m && si < lines.length) {
		m = lines[++si].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert_1.ok(m, 'invalid PEM header');

	var m2;
	var ei = lines.length;
	while (!m2 && ei > 0) {
		m2 = lines[--ei].match(/*JSSTYLED*/
		    /[-]+[ ]*END ([A-Z0-9][A-Za-z0-9]+ )?(PUBLIC|PRIVATE) KEY[ ]*[-]+/);
	}
	assert_1.ok(m2, 'invalid PEM footer');

	/* Begin and end banners must match key type */
	assert_1.equal(m[2], m2[2]);
	var type = m[2].toLowerCase();

	var alg;
	if (m[1]) {
		/* They also must match algorithms, if given */
		assert_1.equal(m[1], m2[1], 'PEM header and footer mismatch');
		alg = m[1].trim();
	}

	lines = lines.slice(si, ei + 1);

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join('');
	buf = Buffer$g.from(lines, 'base64');

	var cipher, key, iv;
	if (headers['proc-type']) {
		var parts = headers['proc-type'].split(',');
		if (parts[0] === '4' && parts[1] === 'ENCRYPTED') {
			if (typeof (options.passphrase) === 'string') {
				options.passphrase = Buffer$g.from(
				    options.passphrase, 'utf-8');
			}
			if (!Buffer$g.isBuffer(options.passphrase)) {
				throw (new errors$1.KeyEncryptedError(
				    options.filename, 'PEM'));
			} else {
				parts = headers['dek-info'].split(',');
				assert_1.ok(parts.length === 2);
				cipher = parts[0].toLowerCase();
				iv = Buffer$g.from(parts[1], 'hex');
				key = utils$2.opensslKeyDeriv(cipher, iv,
				    options.passphrase, 1).key;
			}
		}
	}

	if (alg && alg.toLowerCase() === 'encrypted') {
		var eder = new lib$f.BerReader(buf);
		var pbesEnd;
		eder.readSequence();

		eder.readSequence();
		pbesEnd = eder.offset + eder.length;

		var method = eder.readOID();
		if (method !== OID_PBES2) {
			throw (new Error('Unsupported PEM/PKCS8 encryption ' +
			    'scheme: ' + method));
		}

		eder.readSequence();	/* PBES2-params */

		eder.readSequence();	/* keyDerivationFunc */
		var kdfEnd = eder.offset + eder.length;
		var kdfOid = eder.readOID();
		if (kdfOid !== OID_PBKDF2)
			throw (new Error('Unsupported PBES2 KDF: ' + kdfOid));
		eder.readSequence();
		var salt = eder.readString(lib$f.Ber.OctetString, true);
		var iterations = eder.readInt();
		var hashAlg = 'sha1';
		if (eder.offset < kdfEnd) {
			eder.readSequence();
			var hashAlgOid = eder.readOID();
			hashAlg = OID_TO_HASH[hashAlgOid];
			if (hashAlg === undefined) {
				throw (new Error('Unsupported PBKDF2 hash: ' +
				    hashAlgOid));
			}
		}
		eder._offset = kdfEnd;

		eder.readSequence();	/* encryptionScheme */
		var cipherOid = eder.readOID();
		cipher = OID_TO_CIPHER[cipherOid];
		if (cipher === undefined) {
			throw (new Error('Unsupported PBES2 cipher: ' +
			    cipherOid));
		}
		iv = eder.readString(lib$f.Ber.OctetString, true);

		eder._offset = pbesEnd;
		buf = eder.readString(lib$f.Ber.OctetString, true);

		if (typeof (options.passphrase) === 'string') {
			options.passphrase = Buffer$g.from(
			    options.passphrase, 'utf-8');
		}
		if (!Buffer$g.isBuffer(options.passphrase)) {
			throw (new errors$1.KeyEncryptedError(
			    options.filename, 'PEM'));
		}

		var cinfo = utils$2.opensshCipherInfo(cipher);

		cipher = cinfo.opensslName;
		key = utils$2.pbkdf2(hashAlg, salt, iterations, cinfo.keySize,
		    options.passphrase);
		alg = undefined;
	}

	if (cipher && key && iv) {
		var cipherStream = crypto$1.createDecipheriv(cipher, key, iv);
		var chunk, chunks = [];
		cipherStream.once('error', function (e) {
			if (e.toString().indexOf('bad decrypt') !== -1) {
				throw (new Error('Incorrect passphrase ' +
				    'supplied, could not decrypt key'));
			}
			throw (e);
		});
		cipherStream.write(buf);
		cipherStream.end();
		while ((chunk = cipherStream.read()) !== null)
			chunks.push(chunk);
		buf = Buffer$g.concat(chunks);
	}

	/* The new OpenSSH internal format abuses PEM headers */
	if (alg && alg.toLowerCase() === 'openssh')
		return (sshPrivate.readSSHPrivate(type, buf, options));
	if (alg && alg.toLowerCase() === 'ssh2')
		return (rfc4253.readType(type, buf, options));

	var der = new lib$f.BerReader(buf);
	der.originalInput = input;

	/*
	 * All of the PEM file types start with a sequence tag, so chop it
	 * off here
	 */
	der.readSequence();

	/* PKCS#1 type keys name an algorithm in the banner explicitly */
	if (alg) {
		if (forceType)
			assert_1.strictEqual(forceType, 'pkcs1');
		return (pkcs1.readPkcs1(alg, type, der));
	} else {
		if (forceType)
			assert_1.strictEqual(forceType, 'pkcs8');
		return (pkcs8.readPkcs8(alg, type, der));
	}
}

function write$7(key, options, type) {
	assert_1.object(key);

	var alg = {
	    'ecdsa': 'EC',
	    'rsa': 'RSA',
	    'dsa': 'DSA',
	    'ed25519': 'EdDSA'
	}[key.type];
	var header;

	var der = new lib$f.BerWriter();

	if (PrivateKey$1.isPrivateKey(key)) {
		if (type && type === 'pkcs8') {
			header = 'PRIVATE KEY';
			pkcs8.writePkcs8(der, key);
		} else {
			if (type)
				assert_1.strictEqual(type, 'pkcs1');
			header = alg + ' PRIVATE KEY';
			pkcs1.writePkcs1(der, key);
		}

	} else if (Key$1.isKey(key)) {
		if (type && type === 'pkcs1') {
			header = alg + ' PUBLIC KEY';
			pkcs1.writePkcs1(der, key);
		} else {
			if (type)
				assert_1.strictEqual(type, 'pkcs8');
			header = 'PUBLIC KEY';
			pkcs8.writePkcs8(der, key);
		}

	} else {
		throw (new Error('key is not a Key or PrivateKey'));
	}

	var tmp = der.buffer.toString('base64');
	var len = tmp.length + (tmp.length / 64) +
	    18 + 16 + header.length*2 + 10;
	var buf = Buffer$g.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 64;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}

// Copyright 2015 Joyent, Inc.

var ssh = {
	read: read$6,
	write: write$6
};


var Buffer$f = safer_1.Buffer;







/*JSSTYLED*/
var SSHKEY_RE = /^([a-z0-9-]+)[ \t]+([a-zA-Z0-9+\/]+[=]*)([ \t]+([^ \t][^\n]*[\n]*)?)?$/;
/*JSSTYLED*/
var SSHKEY_RE2 = /^([a-z0-9-]+)[ \t\n]+([a-zA-Z0-9+\/][a-zA-Z0-9+\/ \t\n=]*)([^a-zA-Z0-9+\/ \t\n=].*)?$/;

function read$6(buf, options) {
	if (typeof (buf) !== 'string') {
		assert_1.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var trimmed = buf.trim().replace(/[\\\r]/g, '');
	var m = trimmed.match(SSHKEY_RE);
	if (!m)
		m = trimmed.match(SSHKEY_RE2);
	assert_1.ok(m, 'key must match regex');

	var type = rfc4253.algToKeyType(m[1]);
	var kbuf = Buffer$f.from(m[2], 'base64');

	/*
	 * This is a bit tricky. If we managed to parse the key and locate the
	 * key comment with the regex, then do a non-partial read and assert
	 * that we have consumed all bytes. If we couldn't locate the key
	 * comment, though, there may be whitespace shenanigans going on that
	 * have conjoined the comment to the rest of the key. We do a partial
	 * read in this case to try to make the best out of a sorry situation.
	 */
	var key;
	var ret = {};
	if (m[4]) {
		try {
			key = rfc4253.read(kbuf);

		} catch (e) {
			m = trimmed.match(SSHKEY_RE2);
			assert_1.ok(m, 'key must match regex');
			kbuf = Buffer$f.from(m[2], 'base64');
			key = rfc4253.readInternal(ret, 'public', kbuf);
		}
	} else {
		key = rfc4253.readInternal(ret, 'public', kbuf);
	}

	assert_1.strictEqual(type, key.type);

	if (m[4] && m[4].length > 0) {
		key.comment = m[4];

	} else if (ret.consumed) {
		/*
		 * Now the magic: trying to recover the key comment when it's
		 * gotten conjoined to the key or otherwise shenanigan'd.
		 *
		 * Work out how much base64 we used, then drop all non-base64
		 * chars from the beginning up to this point in the the string.
		 * Then offset in this and try to make up for missing = chars.
		 */
		var data = m[2] + (m[3] ? m[3] : '');
		var realOffset = Math.ceil(ret.consumed / 3) * 4;
		data = data.slice(0, realOffset - 2). /*JSSTYLED*/
		    replace(/[^a-zA-Z0-9+\/=]/g, '') +
		    data.slice(realOffset - 2);

		var padding = ret.consumed % 3;
		if (padding > 0 &&
		    data.slice(realOffset - 1, realOffset) !== '=')
			realOffset--;
		while (data.slice(realOffset, realOffset + 1) === '=')
			realOffset++;

		/* Finally, grab what we think is the comment & clean it up. */
		var trailer = data.slice(realOffset);
		trailer = trailer.replace(/[\r\n]/g, ' ').
		    replace(/^\s+/, '');
		if (trailer.match(/^[a-zA-Z0-9]/))
			key.comment = trailer;
	}

	return (key);
}

function write$6(key, options) {
	assert_1.object(key);
	if (!Key$1.isKey(key))
		throw (new Error('Must be a public key'));

	var parts = [];
	var alg = rfc4253.keyTypeToAlg(key);
	parts.push(alg);

	var buf = rfc4253.write(key);
	parts.push(buf.toString('base64'));

	if (key.comment)
		parts.push(key.comment);

	return (Buffer$f.from(parts.join(' ')));
}

// Copyright 2017 Joyent, Inc.

var dnssec = {
	read: read$5,
	write: write$5
};


var Buffer$e = safer_1.Buffer;






var supportedAlgos = {
	'rsa-sha1' : 5,
	'rsa-sha256' : 8,
	'rsa-sha512' : 10,
	'ecdsa-p256-sha256' : 13,
	'ecdsa-p384-sha384' : 14
	/*
	 * ed25519 is hypothetically supported with id 15
	 * but the common tools available don't appear to be
	 * capable of generating/using ed25519 keys
	 */
};

var supportedAlgosById = {};
Object.keys(supportedAlgos).forEach(function (k) {
	supportedAlgosById[supportedAlgos[k]] = k.toUpperCase();
});

function read$5(buf, options) {
	if (typeof (buf) !== 'string') {
		assert_1.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}
	var lines = buf.split('\n');
	if (lines[0].match(/^Private-key-format\: v1/)) {
		var algElems = lines[1].split(' ');
		var algoNum = parseInt(algElems[1], 10);
		var algoName = algElems[2];
		if (!supportedAlgosById[algoNum])
			throw (new Error('Unsupported algorithm: ' + algoName));
		return (readDNSSECPrivateKey(algoNum, lines.slice(2)));
	}

	// skip any comment-lines
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	// we should now have *one single* line left with our KEY on it.
	if ((lines[line].match(/\. IN KEY /) ||
	    lines[line].match(/\. IN DNSKEY /)) && lines[line+1].length === 0) {
		return (readRFC3110(lines[line]));
	}
	throw (new Error('Cannot parse dnssec key'));
}

function readRFC3110(keyString) {
	var elems = keyString.split(' ');
	//unused var flags = parseInt(elems[3], 10);
	//unused var protocol = parseInt(elems[4], 10);
	var algorithm = parseInt(elems[5], 10);
	if (!supportedAlgosById[algorithm])
		throw (new Error('Unsupported algorithm: ' + algorithm));
	var base64key = elems.slice(6, elems.length).join();
	var keyBuffer = Buffer$e.from(base64key, 'base64');
	if (supportedAlgosById[algorithm].match(/^RSA-/)) {
		// join the rest of the body into a single base64-blob
		var publicExponentLen = keyBuffer.readUInt8(0);
		if (publicExponentLen != 3 && publicExponentLen != 1)
			throw (new Error('Cannot parse dnssec key: ' +
			    'unsupported exponent length'));

		var publicExponent = keyBuffer.slice(1, publicExponentLen+1);
		publicExponent = utils$2.mpNormalize(publicExponent);
		var modulus = keyBuffer.slice(1+publicExponentLen);
		modulus = utils$2.mpNormalize(modulus);
		// now, make the key
		var rsaKey = {
			type: 'rsa',
			parts: []
		};
		rsaKey.parts.push({ name: 'e', data: publicExponent});
		rsaKey.parts.push({ name: 'n', data: modulus});
		return (new Key$1(rsaKey));
	}
	if (supportedAlgosById[algorithm] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[algorithm] === 'ECDSA-P256-SHA256') {
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[algorithm].match(/^ECDSA-P256-SHA256/)) {
			curve = 'nistp256';
			size = 256;
		}

		var ecdsaKey = {
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				{name: 'curve', data: Buffer$e.from(curve) },
				{name: 'Q', data: utils$2.ecNormalize(keyBuffer) }
			]
		};
		return (new Key$1(ecdsaKey));
	}
	throw (new Error('Unsupported algorithm: ' +
	    supportedAlgosById[algorithm]));
}

function elementToBuf(e) {
	return (Buffer$e.from(e.split(' ')[1], 'base64'));
}

function readDNSSECRSAPrivateKey(elements) {
	var rsaParams = {};
	elements.forEach(function (element) {
		if (element.split(' ')[0] === 'Modulus:')
			rsaParams['n'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PublicExponent:')
			rsaParams['e'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'PrivateExponent:')
			rsaParams['d'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime1:')
			rsaParams['p'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Prime2:')
			rsaParams['q'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent1:')
			rsaParams['dmodp'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Exponent2:')
			rsaParams['dmodq'] = elementToBuf(element);
		else if (element.split(' ')[0] === 'Coefficient:')
			rsaParams['iqmp'] = elementToBuf(element);
	});
	// now, make the key
	var key = {
		type: 'rsa',
		parts: [
			{ name: 'e', data: utils$2.mpNormalize(rsaParams['e'])},
			{ name: 'n', data: utils$2.mpNormalize(rsaParams['n'])},
			{ name: 'd', data: utils$2.mpNormalize(rsaParams['d'])},
			{ name: 'p', data: utils$2.mpNormalize(rsaParams['p'])},
			{ name: 'q', data: utils$2.mpNormalize(rsaParams['q'])},
			{ name: 'dmodp',
			    data: utils$2.mpNormalize(rsaParams['dmodp'])},
			{ name: 'dmodq',
			    data: utils$2.mpNormalize(rsaParams['dmodq'])},
			{ name: 'iqmp',
			    data: utils$2.mpNormalize(rsaParams['iqmp'])}
		]
	};
	return (new PrivateKey$1(key));
}

function readDNSSECPrivateKey(alg, elements) {
	if (supportedAlgosById[alg].match(/^RSA-/)) {
		return (readDNSSECRSAPrivateKey(elements));
	}
	if (supportedAlgosById[alg] === 'ECDSA-P384-SHA384' ||
	    supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
		var d = Buffer$e.from(elements[0].split(' ')[1], 'base64');
		var curve = 'nistp384';
		var size = 384;
		if (supportedAlgosById[alg] === 'ECDSA-P256-SHA256') {
			curve = 'nistp256';
			size = 256;
		}
		// DNSSEC generates the public-key on the fly (go calculate it)
		var publicKey = utils$2.publicFromPrivateECDSA(curve, d);
		var Q = publicKey.part['Q'].data;
		var ecdsaKey = {
			type: 'ecdsa',
			curve: curve,
			size: size,
			parts: [
				{name: 'curve', data: Buffer$e.from(curve) },
				{name: 'd', data: d },
				{name: 'Q', data: Q }
			]
		};
		return (new PrivateKey$1(ecdsaKey));
	}
	throw (new Error('Unsupported algorithm: ' + supportedAlgosById[alg]));
}

function dnssecTimestamp(date) {
	var year = date.getFullYear() + ''; //stringify
	var month = (date.getMonth() + 1);
	var timestampStr = year + month + date.getUTCDate();
	timestampStr += '' + date.getUTCHours() + date.getUTCMinutes();
	timestampStr += date.getUTCSeconds();
	return (timestampStr);
}

function rsaAlgFromOptions(opts) {
	if (!opts || !opts.hashAlgo || opts.hashAlgo === 'sha1')
		return ('5 (RSASHA1)');
	else if (opts.hashAlgo === 'sha256')
		return ('8 (RSASHA256)');
	else if (opts.hashAlgo === 'sha512')
		return ('10 (RSASHA512)');
	else
		throw (new Error('Unknown or unsupported hash: ' +
		    opts.hashAlgo));
}

function writeRSA(key, options) {
	// if we're missing parts, add them.
	if (!key.part.dmodp || !key.part.dmodq) {
		utils$2.addRSAMissing(key);
	}

	var out = '';
	out += 'Private-key-format: v1.3\n';
	out += 'Algorithm: ' + rsaAlgFromOptions(options) + '\n';
	var n = utils$2.mpDenormalize(key.part['n'].data);
	out += 'Modulus: ' + n.toString('base64') + '\n';
	var e = utils$2.mpDenormalize(key.part['e'].data);
	out += 'PublicExponent: ' + e.toString('base64') + '\n';
	var d = utils$2.mpDenormalize(key.part['d'].data);
	out += 'PrivateExponent: ' + d.toString('base64') + '\n';
	var p = utils$2.mpDenormalize(key.part['p'].data);
	out += 'Prime1: ' + p.toString('base64') + '\n';
	var q = utils$2.mpDenormalize(key.part['q'].data);
	out += 'Prime2: ' + q.toString('base64') + '\n';
	var dmodp = utils$2.mpDenormalize(key.part['dmodp'].data);
	out += 'Exponent1: ' + dmodp.toString('base64') + '\n';
	var dmodq = utils$2.mpDenormalize(key.part['dmodq'].data);
	out += 'Exponent2: ' + dmodq.toString('base64') + '\n';
	var iqmp = utils$2.mpDenormalize(key.part['iqmp'].data);
	out += 'Coefficient: ' + iqmp.toString('base64') + '\n';
	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';
	return (Buffer$e.from(out, 'ascii'));
}

function writeECDSA(key, options) {
	var out = '';
	out += 'Private-key-format: v1.3\n';

	if (key.curve === 'nistp256') {
		out += 'Algorithm: 13 (ECDSAP256SHA256)\n';
	} else if (key.curve === 'nistp384') {
		out += 'Algorithm: 14 (ECDSAP384SHA384)\n';
	} else {
		throw (new Error('Unsupported curve'));
	}
	var base64Key = key.part['d'].data.toString('base64');
	out += 'PrivateKey: ' + base64Key + '\n';

	// Assume that we're valid as-of now
	var timestamp = new Date();
	out += 'Created: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Publish: ' + dnssecTimestamp(timestamp) + '\n';
	out += 'Activate: ' + dnssecTimestamp(timestamp) + '\n';

	return (Buffer$e.from(out, 'ascii'));
}

function write$5(key, options) {
	if (PrivateKey$1.isPrivateKey(key)) {
		if (key.type === 'rsa') {
			return (writeRSA(key, options));
		} else if (key.type === 'ecdsa') {
			return (writeECDSA(key));
		} else {
			throw (new Error('Unsupported algorithm: ' + key.type));
		}
	} else if (Key$1.isKey(key)) {
		/*
		 * RFC3110 requires a keyname, and a keytype, which we
		 * don't really have a mechanism for specifying such
		 * additional metadata.
		 */
		throw (new Error('Format "dnssec" only supports ' +
		    'writing private keys'));
	} else {
		throw (new Error('key is not a Key or PrivateKey'));
	}
}

// Copyright 2018 Joyent, Inc.

var putty = {
	read: read$4,
	write: write$4
};


var Buffer$d = safer_1.Buffer;





function read$4(buf, options) {
	var lines = buf.toString('ascii').split(/[\r\n]+/);
	var found = false;
	var parts;
	var si = 0;
	while (si < lines.length) {
		parts = splitHeader(lines[si++]);
		if (parts &&
		    parts[0].toLowerCase() === 'putty-user-key-file-2') {
			found = true;
			break;
		}
	}
	if (!found) {
		throw (new Error('No PuTTY format first line found'));
	}
	var alg = parts[1];

	parts = splitHeader(lines[si++]);
	assert_1.equal(parts[0].toLowerCase(), 'encryption');

	parts = splitHeader(lines[si++]);
	assert_1.equal(parts[0].toLowerCase(), 'comment');
	var comment = parts[1];

	parts = splitHeader(lines[si++]);
	assert_1.equal(parts[0].toLowerCase(), 'public-lines');
	var publicLines = parseInt(parts[1], 10);
	if (!isFinite(publicLines) || publicLines < 0 ||
	    publicLines > lines.length) {
		throw (new Error('Invalid public-lines count'));
	}

	var publicBuf = Buffer$d.from(
	    lines.slice(si, si + publicLines).join(''), 'base64');
	var keyType = rfc4253.algToKeyType(alg);
	var key = rfc4253.read(publicBuf);
	if (key.type !== keyType) {
		throw (new Error('Outer key algorithm mismatch'));
	}
	key.comment = comment;
	return (key);
}

function splitHeader(line) {
	var idx = line.indexOf(':');
	if (idx === -1)
		return (null);
	var header = line.slice(0, idx);
	++idx;
	while (line[idx] === ' ')
		++idx;
	var rest = line.slice(idx);
	return ([header, rest]);
}

function write$4(key, options) {
	assert_1.object(key);
	if (!Key$1.isKey(key))
		throw (new Error('Must be a public key'));

	var alg = rfc4253.keyTypeToAlg(key);
	var buf = rfc4253.write(key);
	var comment = key.comment || '';

	var b64 = buf.toString('base64');
	var lines = wrap(b64);

	lines.unshift('Public-Lines: ' + lines.length);
	lines.unshift('Comment: ' + comment);
	lines.unshift('Encryption: none');
	lines.unshift('PuTTY-User-Key-File-2: ' + alg);

	return (Buffer$d.from(lines.join('\n') + '\n'));
}

function wrap(txt, len) {
	var lines = [];
	var pos = 0;
	while (pos < txt.length) {
		lines.push(txt.slice(pos, pos + 64));
		pos += 64;
	}
	return (lines);
}

// Copyright 2018 Joyent, Inc.

var auto = {
	read: read$3,
	write: write$3
};


var Buffer$c = safer_1.Buffer;










var DNSSEC_PRIVKEY_HEADER_PREFIX = 'Private-key-format: v1';

function read$3(buf, options) {
	if (typeof (buf) === 'string') {
		if (buf.trim().match(/^[-]+[ ]*BEGIN/))
			return (require$$3$1.read(buf, options));
		if (buf.match(/^\s*ssh-[a-z]/))
			return (ssh.read(buf, options));
		if (buf.match(/^\s*ecdsa-/))
			return (ssh.read(buf, options));
		if (buf.match(/^putty-user-key-file-2:/i))
			return (putty.read(buf, options));
		if (findDNSSECHeader(buf))
			return (dnssec.read(buf, options));
		buf = Buffer$c.from(buf, 'binary');
	} else {
		assert_1.buffer(buf);
		if (findPEMHeader(buf))
			return (require$$3$1.read(buf, options));
		if (findSSHHeader(buf))
			return (ssh.read(buf, options));
		if (findPuTTYHeader(buf))
			return (putty.read(buf, options));
		if (findDNSSECHeader(buf))
			return (dnssec.read(buf, options));
	}
	if (buf.readUInt32BE(0) < buf.length)
		return (rfc4253.read(buf, options));
	throw (new Error('Failed to auto-detect format of key'));
}

function findPuTTYHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
		++offset;
	if (offset + 22 <= buf.length &&
	    buf.slice(offset, offset + 22).toString('ascii').toLowerCase() ===
	    'putty-user-key-file-2:')
		return (true);
	return (false);
}

function findSSHHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10 || buf[offset] === 9))
		++offset;
	if (offset + 4 <= buf.length &&
	    buf.slice(offset, offset + 4).toString('ascii') === 'ssh-')
		return (true);
	if (offset + 6 <= buf.length &&
	    buf.slice(offset, offset + 6).toString('ascii') === 'ecdsa-')
		return (true);
	return (false);
}

function findPEMHeader(buf) {
	var offset = 0;
	while (offset < buf.length &&
	    (buf[offset] === 32 || buf[offset] === 10))
		++offset;
	if (buf[offset] !== 45)
		return (false);
	while (offset < buf.length &&
	    (buf[offset] === 45))
		++offset;
	while (offset < buf.length &&
	    (buf[offset] === 32))
		++offset;
	if (offset + 5 > buf.length ||
	    buf.slice(offset, offset + 5).toString('ascii') !== 'BEGIN')
		return (false);
	return (true);
}

function findDNSSECHeader(buf) {
	// private case first
	if (buf.length <= DNSSEC_PRIVKEY_HEADER_PREFIX.length)
		return (false);
	var headerCheck = buf.slice(0, DNSSEC_PRIVKEY_HEADER_PREFIX.length);
	if (headerCheck.toString('ascii') === DNSSEC_PRIVKEY_HEADER_PREFIX)
		return (true);

	// public-key RFC3110 ?
	// 'domain.com. IN KEY ...' or 'domain.com. IN DNSKEY ...'
	// skip any comment-lines
	if (typeof (buf) !== 'string') {
		buf = buf.toString('ascii');
	}
	var lines = buf.split('\n');
	var line = 0;
	/* JSSTYLED */
	while (lines[line].match(/^\;/))
		line++;
	if (lines[line].toString('ascii').match(/\. IN KEY /))
		return (true);
	if (lines[line].toString('ascii').match(/\. IN DNSKEY /))
		return (true);
	return (false);
}

function write$3(key, options) {
	throw (new Error('"auto" format cannot be used for writing'));
}

var Fingerprint$1 = fingerprint;

// Copyright 2017 Joyent, Inc.

var privateKey = PrivateKey;


var Buffer$b = safer_1.Buffer;








var generateECDSA = dhe.generateECDSA;
var generateED25519 = dhe.generateED25519;
var KeyParseError$1 = errors$1.KeyParseError;

var formats$4 = {};
formats$4['auto'] = auto;
formats$4['pem'] = require$$3$1;
formats$4['pkcs1'] = pkcs1;
formats$4['pkcs8'] = pkcs8;
formats$4['rfc4253'] = rfc4253;
formats$4['ssh-private'] = sshPrivate;
formats$4['openssh'] = formats$4['ssh-private'];
formats$4['ssh'] = formats$4['ssh-private'];
formats$4['dnssec'] = dnssec;

function PrivateKey(opts) {
	assert_1.object(opts, 'options');
	Key$1.call(this, opts);

	this._pubCache = undefined;
}
util$2.inherits(PrivateKey, Key$1);

PrivateKey.formats = formats$4;

PrivateKey.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'pkcs1';
	assert_1.string(format, 'format');
	assert_1.object(formats$4[format], 'formats[format]');
	assert_1.optionalObject(options, 'options');

	return (formats$4[format].write(this, options));
};

PrivateKey.prototype.hash = function (algo, type) {
	return (this.toPublic().hash(algo, type));
};

PrivateKey.prototype.fingerprint = function (algo, type) {
	return (this.toPublic().fingerprint(algo, type));
};

PrivateKey.prototype.toPublic = function () {
	if (this._pubCache)
		return (this._pubCache);

	var algInfo = algs.info[this.type];
	var pubParts = [];
	for (var i = 0; i < algInfo.parts.length; ++i) {
		var p = algInfo.parts[i];
		pubParts.push(this.part[p]);
	}

	this._pubCache = new Key$1({
		type: this.type,
		source: this,
		parts: pubParts
	});
	if (this.comment)
		this._pubCache.comment = this.comment;
	return (this._pubCache);
};

PrivateKey.prototype.derive = function (newType) {
	assert_1.string(newType, 'type');
	var priv, pub, pair;

	if (this.type === 'ed25519' && newType === 'curve25519') {
		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = naclFast.box.keyPair.fromSecretKey(new Uint8Array(priv));
		pub = Buffer$b.from(pair.publicKey);

		return (new PrivateKey({
			type: 'curve25519',
			parts: [
				{ name: 'A', data: utils$2.mpNormalize(pub) },
				{ name: 'k', data: utils$2.mpNormalize(priv) }
			]
		}));
	} else if (this.type === 'curve25519' && newType === 'ed25519') {
		priv = this.part.k.data;
		if (priv[0] === 0x00)
			priv = priv.slice(1);

		pair = naclFast.sign.keyPair.fromSeed(new Uint8Array(priv));
		pub = Buffer$b.from(pair.publicKey);

		return (new PrivateKey({
			type: 'ed25519',
			parts: [
				{ name: 'A', data: utils$2.mpNormalize(pub) },
				{ name: 'k', data: utils$2.mpNormalize(priv) }
			]
		}));
	}
	throw (new Error('Key derivation not supported from ' + this.type +
	    ' to ' + newType));
};

PrivateKey.prototype.createVerify = function (hashAlgo) {
	return (this.toPublic().createVerify(hashAlgo));
};

PrivateKey.prototype.createSign = function (hashAlgo) {
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert_1.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat$1 !== undefined)
		return (new edCompat$1.Signer(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try {
		nm = hashAlgo.toUpperCase();
		v = crypto$1.createSign(nm);
	} catch (e) {
		err = e;
	}
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) {
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto$1.createSign(nm);
	}
	assert_1.ok(v, 'failed to create verifier');
	var oldSign = v.sign.bind(v);
	var key = this.toBuffer('pkcs1');
	var type = this.type;
	var curve = this.curve;
	v.sign = function () {
		var sig = oldSign(key);
		if (typeof (sig) === 'string')
			sig = Buffer$b.from(sig, 'binary');
		sig = signature.parse(sig, type, 'asn1');
		sig.hashAlgorithm = hashAlgo;
		sig.curve = curve;
		return (sig);
	};
	return (v);
};

PrivateKey.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert_1.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert_1.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert_1.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert_1.object(formats$4[format], 'formats[format]');

	try {
		var k = formats$4[format].read(data, options);
		assert_1.ok(k instanceof PrivateKey, 'key is not a private key');
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	} catch (e) {
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError$1(options.filename, format, e));
	}
};

PrivateKey.isPrivateKey = function (obj, ver) {
	return (utils$2.isCompatible(obj, PrivateKey, ver));
};

PrivateKey.generate = function (type, options) {
	if (options === undefined)
		options = {};
	assert_1.object(options, 'options');

	switch (type) {
	case 'ecdsa':
		if (options.curve === undefined)
			options.curve = 'nistp256';
		assert_1.string(options.curve, 'options.curve');
		return (generateECDSA(options.curve));
	case 'ed25519':
		return (generateED25519());
	default:
		throw (new Error('Key generation not supported with key ' +
		    'type "' + type + '"'));
	}
};

/*
 * API versions for PrivateKey:
 * [1,0] -- initial ver
 * [1,1] -- added auto, pkcs[18], openssh/ssh-private formats
 * [1,2] -- added defaultHashAlgorithm
 * [1,3] -- added derive, ed, createDH
 * [1,4] -- first tagged version
 * [1,5] -- changed ed25519 part names and format
 * [1,6] -- type arguments for hash() and fingerprint()
 */
PrivateKey.prototype._sshpkApiVersion = [1, 6];

PrivateKey._oldVersionDetect = function (obj) {
	assert_1.func(obj.toPublic);
	assert_1.func(obj.createSign);
	if (obj.derive)
		return ([1, 3]);
	if (obj.defaultHashAlgorithm)
		return ([1, 2]);
	if (obj.formats['auto'])
		return ([1, 1]);
	return ([1, 0]);
};

// Copyright 2017 Joyent, Inc.

var identity = Identity;










var Buffer$a = safer_1.Buffer;

/*JSSTYLED*/
var DNS_NAME_RE = /^([*]|[a-z0-9][a-z0-9\-]{0,62})(?:\.([*]|[a-z0-9][a-z0-9\-]{0,62}))*$/i;

var oids = {};
oids.cn = '2.5.4.3';
oids.o = '2.5.4.10';
oids.ou = '2.5.4.11';
oids.l = '2.5.4.7';
oids.s = '2.5.4.8';
oids.c = '2.5.4.6';
oids.sn = '2.5.4.4';
oids.postalCode = '2.5.4.17';
oids.serialNumber = '2.5.4.5';
oids.street = '2.5.4.9';
oids.x500UniqueIdentifier = '2.5.4.45';
oids.role = '2.5.4.72';
oids.telephoneNumber = '2.5.4.20';
oids.description = '2.5.4.13';
oids.dc = '0.9.2342.19200300.100.1.25';
oids.uid = '0.9.2342.19200300.100.1.1';
oids.mail = '0.9.2342.19200300.100.1.3';
oids.title = '2.5.4.12';
oids.gn = '2.5.4.42';
oids.initials = '2.5.4.43';
oids.pseudonym = '2.5.4.65';
oids.emailAddress = '1.2.840.113549.1.9.1';

var unoids = {};
Object.keys(oids).forEach(function (k) {
	unoids[oids[k]] = k;
});

function Identity(opts) {
	var self = this;
	assert_1.object(opts, 'options');
	assert_1.arrayOfObject(opts.components, 'options.components');
	this.components = opts.components;
	this.componentLookup = {};
	this.components.forEach(function (c) {
		if (c.name && !c.oid)
			c.oid = oids[c.name];
		if (c.oid && !c.name)
			c.name = unoids[c.oid];
		if (self.componentLookup[c.name] === undefined)
			self.componentLookup[c.name] = [];
		self.componentLookup[c.name].push(c);
	});
	if (this.componentLookup.cn && this.componentLookup.cn.length > 0) {
		this.cn = this.componentLookup.cn[0].value;
	}
	assert_1.optionalString(opts.type, 'options.type');
	if (opts.type === undefined) {
		if (this.components.length === 1 &&
		    this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1 &&
		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
			this.type = 'host';
			this.hostname = this.componentLookup.cn[0].value;

		} else if (this.componentLookup.dc &&
		    this.components.length === this.componentLookup.dc.length) {
			this.type = 'host';
			this.hostname = this.componentLookup.dc.map(
			    function (c) {
				return (c.value);
			}).join('.');

		} else if (this.componentLookup.uid &&
		    this.components.length ===
		    this.componentLookup.uid.length) {
			this.type = 'user';
			this.uid = this.componentLookup.uid[0].value;

		} else if (this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1 &&
		    this.componentLookup.cn[0].value.match(DNS_NAME_RE)) {
			this.type = 'host';
			this.hostname = this.componentLookup.cn[0].value;

		} else if (this.componentLookup.uid &&
		    this.componentLookup.uid.length === 1) {
			this.type = 'user';
			this.uid = this.componentLookup.uid[0].value;

		} else if (this.componentLookup.mail &&
		    this.componentLookup.mail.length === 1) {
			this.type = 'email';
			this.email = this.componentLookup.mail[0].value;

		} else if (this.componentLookup.cn &&
		    this.componentLookup.cn.length === 1) {
			this.type = 'user';
			this.uid = this.componentLookup.cn[0].value;

		} else {
			this.type = 'unknown';
		}
	} else {
		this.type = opts.type;
		if (this.type === 'host')
			this.hostname = opts.hostname;
		else if (this.type === 'user')
			this.uid = opts.uid;
		else if (this.type === 'email')
			this.email = opts.email;
		else
			throw (new Error('Unknown type ' + this.type));
	}
}

Identity.prototype.toString = function () {
	return (this.components.map(function (c) {
		var n = c.name.toUpperCase();
		/*JSSTYLED*/
		n = n.replace(/=/g, '\\=');
		var v = c.value;
		/*JSSTYLED*/
		v = v.replace(/,/g, '\\,');
		return (n + '=' + v);
	}).join(', '));
};

Identity.prototype.get = function (name, asArray) {
	assert_1.string(name, 'name');
	var arr = this.componentLookup[name];
	if (arr === undefined || arr.length === 0)
		return (undefined);
	if (!asArray && arr.length > 1)
		throw (new Error('Multiple values for attribute ' + name));
	if (!asArray)
		return (arr[0].value);
	return (arr.map(function (c) {
		return (c.value);
	}));
};

Identity.prototype.toArray = function (idx) {
	return (this.components.map(function (c) {
		return ({
			name: c.name,
			value: c.value
		});
	}));
};

/*
 * These are from X.680 -- PrintableString allowed chars are in section 37.4
 * table 8. Spec for IA5Strings is "1,6 + SPACE + DEL" where 1 refers to
 * ISO IR #001 (standard ASCII control characters) and 6 refers to ISO IR #006
 * (the basic ASCII character set).
 */
/* JSSTYLED */
var NOT_PRINTABLE = /[^a-zA-Z0-9 '(),+.\/:=?-]/;
/* JSSTYLED */
var NOT_IA5 = /[^\x00-\x7f]/;

Identity.prototype.toAsn1 = function (der, tag) {
	der.startSequence(tag);
	this.components.forEach(function (c) {
		der.startSequence(lib$f.Ber.Constructor | lib$f.Ber.Set);
		der.startSequence();
		der.writeOID(c.oid);
		/*
		 * If we fit in a PrintableString, use that. Otherwise use an
		 * IA5String or UTF8String.
		 *
		 * If this identity was parsed from a DN, use the ASN.1 types
		 * from the original representation (otherwise this might not
		 * be a full match for the original in some validators).
		 */
		if (c.asn1type === lib$f.Ber.Utf8String ||
		    c.value.match(NOT_IA5)) {
			var v = Buffer$a.from(c.value, 'utf8');
			der.writeBuffer(v, lib$f.Ber.Utf8String);

		} else if (c.asn1type === lib$f.Ber.IA5String ||
		    c.value.match(NOT_PRINTABLE)) {
			der.writeString(c.value, lib$f.Ber.IA5String);

		} else {
			var type = lib$f.Ber.PrintableString;
			if (c.asn1type !== undefined)
				type = c.asn1type;
			der.writeString(c.value, type);
		}
		der.endSequence();
		der.endSequence();
	});
	der.endSequence();
};

function globMatch(a, b) {
	if (a === '**' || b === '**')
		return (true);
	var aParts = a.split('.');
	var bParts = b.split('.');
	if (aParts.length !== bParts.length)
		return (false);
	for (var i = 0; i < aParts.length; ++i) {
		if (aParts[i] === '*' || bParts[i] === '*')
			continue;
		if (aParts[i] !== bParts[i])
			return (false);
	}
	return (true);
}

Identity.prototype.equals = function (other) {
	if (!Identity.isIdentity(other, [1, 0]))
		return (false);
	if (other.components.length !== this.components.length)
		return (false);
	for (var i = 0; i < this.components.length; ++i) {
		if (this.components[i].oid !== other.components[i].oid)
			return (false);
		if (!globMatch(this.components[i].value,
		    other.components[i].value)) {
			return (false);
		}
	}
	return (true);
};

Identity.forHost = function (hostname) {
	assert_1.string(hostname, 'hostname');
	return (new Identity({
		type: 'host',
		hostname: hostname,
		components: [ { name: 'cn', value: hostname } ]
	}));
};

Identity.forUser = function (uid) {
	assert_1.string(uid, 'uid');
	return (new Identity({
		type: 'user',
		uid: uid,
		components: [ { name: 'uid', value: uid } ]
	}));
};

Identity.forEmail = function (email) {
	assert_1.string(email, 'email');
	return (new Identity({
		type: 'email',
		email: email,
		components: [ { name: 'mail', value: email } ]
	}));
};

Identity.parseDN = function (dn) {
	assert_1.string(dn, 'dn');
	var parts = [''];
	var idx = 0;
	var rem = dn;
	while (rem.length > 0) {
		var m;
		/*JSSTYLED*/
		if ((m = /^,/.exec(rem)) !== null) {
			parts[++idx] = '';
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^\\,/.exec(rem)) !== null) {
			parts[idx] += ',';
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^\\./.exec(rem)) !== null) {
			parts[idx] += m[0];
			rem = rem.slice(m[0].length);
		/*JSSTYLED*/
		} else if ((m = /^[^\\,]+/.exec(rem)) !== null) {
			parts[idx] += m[0];
			rem = rem.slice(m[0].length);
		} else {
			throw (new Error('Failed to parse DN'));
		}
	}
	var cmps = parts.map(function (c) {
		c = c.trim();
		var eqPos = c.indexOf('=');
		while (eqPos > 0 && c.charAt(eqPos - 1) === '\\')
			eqPos = c.indexOf('=', eqPos + 1);
		if (eqPos === -1) {
			throw (new Error('Failed to parse DN'));
		}
		/*JSSTYLED*/
		var name = c.slice(0, eqPos).toLowerCase().replace(/\\=/g, '=');
		var value = c.slice(eqPos + 1);
		return ({ name: name, value: value });
	});
	return (new Identity({ components: cmps }));
};

Identity.fromArray = function (components) {
	assert_1.arrayOfObject(components, 'components');
	components.forEach(function (cmp) {
		assert_1.object(cmp, 'component');
		assert_1.string(cmp.name, 'component.name');
		if (!Buffer$a.isBuffer(cmp.value) &&
		    !(typeof (cmp.value) === 'string')) {
			throw (new Error('Invalid component value'));
		}
	});
	return (new Identity({ components: components }));
};

Identity.parseAsn1 = function (der, top) {
	var components = [];
	der.readSequence(top);
	var end = der.offset + der.length;
	while (der.offset < end) {
		der.readSequence(lib$f.Ber.Constructor | lib$f.Ber.Set);
		var after = der.offset + der.length;
		der.readSequence();
		var oid = der.readOID();
		var type = der.peek();
		var value;
		switch (type) {
		case lib$f.Ber.PrintableString:
		case lib$f.Ber.IA5String:
		case lib$f.Ber.OctetString:
		case lib$f.Ber.T61String:
			value = der.readString(type);
			break;
		case lib$f.Ber.Utf8String:
			value = der.readString(type, true);
			value = value.toString('utf8');
			break;
		case lib$f.Ber.CharacterString:
		case lib$f.Ber.BMPString:
			value = der.readString(type, true);
			value = value.toString('utf16le');
			break;
		default:
			throw (new Error('Unknown asn1 type ' + type));
		}
		components.push({ oid: oid, asn1type: type, value: value });
		der._offset = after;
	}
	der._offset = end;
	return (new Identity({
		components: components
	}));
};

Identity.isIdentity = function (obj, ver) {
	return (utils$2.isCompatible(obj, Identity, ver));
};

/*
 * API versions for Identity:
 * [1,0] -- initial ver
 */
Identity.prototype._sshpkApiVersion = [1, 0];

Identity._oldVersionDetect = function (obj) {
	return ([1, 0]);
};

var Certificate$1 = certificate;

// Copyright 2017 Joyent, Inc.

var opensshCert = {
	read: read$2,
	verify: verify$2,
	sign: sign$2,
	signAsync: signAsync$1,
	write: write$2,

	/* Internal private API */
	fromBuffer: fromBuffer,
	toBuffer: toBuffer
};




var Buffer$9 = safer_1.Buffer;









function verify$2(cert, key) {
	/*
	 * We always give an issuerKey, so if our verify() is being called then
	 * there was no signature. Return false.
	 */
	return (false);
}

var TYPES = {
	'user': 1,
	'host': 2
};
Object.keys(TYPES).forEach(function (k) { TYPES[TYPES[k]] = k; });

var ECDSA_ALGO = /^ecdsa-sha2-([^@-]+)-cert-v01@openssh.com$/;

function read$2(buf, options) {
	if (Buffer$9.isBuffer(buf))
		buf = buf.toString('ascii');
	var parts = buf.trim().split(/[ \t\n]+/g);
	if (parts.length < 2 || parts.length > 3)
		throw (new Error('Not a valid SSH certificate line'));

	var algo = parts[0];
	var data = parts[1];

	data = Buffer$9.from(data, 'base64');
	return (fromBuffer(data, algo));
}

function fromBuffer(data, algo, partial) {
	var sshbuf = new sshBuffer({ buffer: data });
	var innerAlgo = sshbuf.readString();
	if (algo !== undefined && innerAlgo !== algo)
		throw (new Error('SSH certificate algorithm mismatch'));
	if (algo === undefined)
		algo = innerAlgo;

	var cert = {};
	cert.signatures = {};
	cert.signatures.openssh = {};

	cert.signatures.openssh.nonce = sshbuf.readBuffer();

	var key = {};
	var parts = (key.parts = []);
	key.type = getAlg(algo);

	var partCount = algs.info[key.type].parts.length;
	while (parts.length < partCount)
		parts.push(sshbuf.readPart());
	assert_1.ok(parts.length >= 1, 'key must have at least one part');

	var algInfo = algs.info[key.type];
	if (key.type === 'ecdsa') {
		var res = ECDSA_ALGO.exec(algo);
		assert_1.ok(res !== null);
		assert_1.strictEqual(res[1], parts[0].data.toString());
	}

	for (var i = 0; i < algInfo.parts.length; ++i) {
		parts[i].name = algInfo.parts[i];
		if (parts[i].name !== 'curve' &&
		    algInfo.normalize !== false) {
			var p = parts[i];
			p.data = utils$2.mpNormalize(p.data);
		}
	}

	cert.subjectKey = new Key$1(key);

	cert.serial = sshbuf.readInt64();

	var type = TYPES[sshbuf.readInt()];
	assert_1.string(type, 'valid cert type');

	cert.signatures.openssh.keyId = sshbuf.readString();

	var principals = [];
	var pbuf = sshbuf.readBuffer();
	var psshbuf = new sshBuffer({ buffer: pbuf });
	while (!psshbuf.atEnd())
		principals.push(psshbuf.readString());
	if (principals.length === 0)
		principals = ['*'];

	cert.subjects = principals.map(function (pr) {
		if (type === 'user')
			return (identity.forUser(pr));
		else if (type === 'host')
			return (identity.forHost(pr));
		throw (new Error('Unknown identity type ' + type));
	});

	cert.validFrom = int64ToDate(sshbuf.readInt64());
	cert.validUntil = int64ToDate(sshbuf.readInt64());

	var exts = [];
	var extbuf = new sshBuffer({ buffer: sshbuf.readBuffer() });
	var ext;
	while (!extbuf.atEnd()) {
		ext = { critical: true };
		ext.name = extbuf.readString();
		ext.data = extbuf.readBuffer();
		exts.push(ext);
	}
	extbuf = new sshBuffer({ buffer: sshbuf.readBuffer() });
	while (!extbuf.atEnd()) {
		ext = { critical: false };
		ext.name = extbuf.readString();
		ext.data = extbuf.readBuffer();
		exts.push(ext);
	}
	cert.signatures.openssh.exts = exts;

	/* reserved */
	sshbuf.readBuffer();

	var signingKeyBuf = sshbuf.readBuffer();
	cert.issuerKey = rfc4253.read(signingKeyBuf);

	/*
	 * OpenSSH certs don't give the identity of the issuer, just their
	 * public key. So, we use an Identity that matches anything. The
	 * isSignedBy() function will later tell you if the key matches.
	 */
	cert.issuer = identity.forHost('**');

	var sigBuf = sshbuf.readBuffer();
	cert.signatures.openssh.signature =
	    signature.parse(sigBuf, cert.issuerKey.type, 'ssh');

	if (partial !== undefined) {
		partial.remainder = sshbuf.remainder();
		partial.consumed = sshbuf._offset;
	}

	return (new Certificate$1(cert));
}

function int64ToDate(buf) {
	var i = buf.readUInt32BE(0) * 4294967296;
	i += buf.readUInt32BE(4);
	var d = new Date();
	d.setTime(i * 1000);
	d.sourceInt64 = buf;
	return (d);
}

function dateToInt64(date) {
	if (date.sourceInt64 !== undefined)
		return (date.sourceInt64);
	var i = Math.round(date.getTime() / 1000);
	var upper = Math.floor(i / 4294967296);
	var lower = Math.floor(i % 4294967296);
	var buf = Buffer$9.alloc(8);
	buf.writeUInt32BE(upper, 0);
	buf.writeUInt32BE(lower, 4);
	return (buf);
}

function sign$2(cert, key) {
	if (cert.signatures.openssh === undefined)
		cert.signatures.openssh = {};
	try {
		var blob = toBuffer(cert, true);
	} catch (e) {
		delete (cert.signatures.openssh);
		return (false);
	}
	var sig = cert.signatures.openssh;
	var hashAlgo = undefined;
	if (key.type === 'rsa' || key.type === 'dsa')
		hashAlgo = 'sha1';
	var signer = key.createSign(hashAlgo);
	signer.write(blob);
	sig.signature = signer.sign();
	return (true);
}

function signAsync$1(cert, signer, done) {
	if (cert.signatures.openssh === undefined)
		cert.signatures.openssh = {};
	try {
		var blob = toBuffer(cert, true);
	} catch (e) {
		delete (cert.signatures.openssh);
		done(e);
		return;
	}
	var sig = cert.signatures.openssh;

	signer(blob, function (err, signature) {
		if (err) {
			done(err);
			return;
		}
		try {
			/*
			 * This will throw if the signature isn't of a
			 * type/algo that can be used for SSH.
			 */
			signature.toBuffer('ssh');
		} catch (e) {
			done(e);
			return;
		}
		sig.signature = signature;
		done();
	});
}

function write$2(cert, options) {
	if (options === undefined)
		options = {};

	var blob = toBuffer(cert);
	var out = getCertType(cert.subjectKey) + ' ' + blob.toString('base64');
	if (options.comment)
		out = out + ' ' + options.comment;
	return (out);
}


function toBuffer(cert, noSig) {
	assert_1.object(cert.signatures.openssh, 'signature for openssh format');
	var sig = cert.signatures.openssh;

	if (sig.nonce === undefined)
		sig.nonce = crypto$1.randomBytes(16);
	var buf = new sshBuffer({});
	buf.writeString(getCertType(cert.subjectKey));
	buf.writeBuffer(sig.nonce);

	var key = cert.subjectKey;
	var algInfo = algs.info[key.type];
	algInfo.parts.forEach(function (part) {
		buf.writePart(key.part[part]);
	});

	buf.writeInt64(cert.serial);

	var type = cert.subjects[0].type;
	assert_1.notStrictEqual(type, 'unknown');
	cert.subjects.forEach(function (id) {
		assert_1.strictEqual(id.type, type);
	});
	type = TYPES[type];
	buf.writeInt(type);

	if (sig.keyId === undefined) {
		sig.keyId = cert.subjects[0].type + '_' +
		    (cert.subjects[0].uid || cert.subjects[0].hostname);
	}
	buf.writeString(sig.keyId);

	var sub = new sshBuffer({});
	cert.subjects.forEach(function (id) {
		if (type === TYPES.host)
			sub.writeString(id.hostname);
		else if (type === TYPES.user)
			sub.writeString(id.uid);
	});
	buf.writeBuffer(sub.toBuffer());

	buf.writeInt64(dateToInt64(cert.validFrom));
	buf.writeInt64(dateToInt64(cert.validUntil));

	var exts = sig.exts;
	if (exts === undefined)
		exts = [];

	var extbuf = new sshBuffer({});
	exts.forEach(function (ext) {
		if (ext.critical !== true)
			return;
		extbuf.writeString(ext.name);
		extbuf.writeBuffer(ext.data);
	});
	buf.writeBuffer(extbuf.toBuffer());

	extbuf = new sshBuffer({});
	exts.forEach(function (ext) {
		if (ext.critical === true)
			return;
		extbuf.writeString(ext.name);
		extbuf.writeBuffer(ext.data);
	});
	buf.writeBuffer(extbuf.toBuffer());

	/* reserved */
	buf.writeBuffer(Buffer$9.alloc(0));

	sub = rfc4253.write(cert.issuerKey);
	buf.writeBuffer(sub);

	if (!noSig)
		buf.writeBuffer(sig.signature.toBuffer('ssh'));

	return (buf.toBuffer());
}

function getAlg(certType) {
	if (certType === 'ssh-rsa-cert-v01@openssh.com')
		return ('rsa');
	if (certType === 'ssh-dss-cert-v01@openssh.com')
		return ('dsa');
	if (certType.match(ECDSA_ALGO))
		return ('ecdsa');
	if (certType === 'ssh-ed25519-cert-v01@openssh.com')
		return ('ed25519');
	throw (new Error('Unsupported cert type ' + certType));
}

function getCertType(key) {
	if (key.type === 'rsa')
		return ('ssh-rsa-cert-v01@openssh.com');
	if (key.type === 'dsa')
		return ('ssh-dss-cert-v01@openssh.com');
	if (key.type === 'ecdsa')
		return ('ecdsa-sha2-' + key.curve + '-cert-v01@openssh.com');
	if (key.type === 'ed25519')
		return ('ssh-ed25519-cert-v01@openssh.com');
	throw (new Error('Unsupported key type ' + key.type));
}

// Copyright 2017 Joyent, Inc.

var x509 = {
	read: read$1,
	verify: verify$1,
	sign: sign$1,
	signAsync: signAsync,
	write: write$1
};



var Buffer$8 = safer_1.Buffer;










/*
 * This file is based on RFC5280 (X.509).
 */

/* Helper to read in a single mpint */
function readMPInt(der, nm) {
	assert_1.strictEqual(der.peek(), lib$f.Ber.Integer,
	    nm + ' is not an Integer');
	return (utils$2.mpNormalize(der.readString(lib$f.Ber.Integer, true)));
}

function verify$1(cert, key) {
	var sig = cert.signatures.x509;
	assert_1.object(sig, 'x509 signature');

	var algParts = sig.algo.split('-');
	if (algParts[0] !== key.type)
		return (false);

	var blob = sig.cache;
	if (blob === undefined) {
		var der = new lib$f.BerWriter();
		writeTBSCert(cert, der);
		blob = der.buffer;
	}

	var verifier = key.createVerify(algParts[1]);
	verifier.write(blob);
	return (verifier.verify(sig.signature));
}

function Local(i) {
	return (lib$f.Ber.Context | lib$f.Ber.Constructor | i);
}

function Context(i) {
	return (lib$f.Ber.Context | i);
}

var SIGN_ALGS = {
	'rsa-md5': '1.2.840.113549.1.1.4',
	'rsa-sha1': '1.2.840.113549.1.1.5',
	'rsa-sha256': '1.2.840.113549.1.1.11',
	'rsa-sha384': '1.2.840.113549.1.1.12',
	'rsa-sha512': '1.2.840.113549.1.1.13',
	'dsa-sha1': '1.2.840.10040.4.3',
	'dsa-sha256': '2.16.840.1.101.3.4.3.2',
	'ecdsa-sha1': '1.2.840.10045.4.1',
	'ecdsa-sha256': '1.2.840.10045.4.3.2',
	'ecdsa-sha384': '1.2.840.10045.4.3.3',
	'ecdsa-sha512': '1.2.840.10045.4.3.4',
	'ed25519-sha512': '1.3.101.112'
};
Object.keys(SIGN_ALGS).forEach(function (k) {
	SIGN_ALGS[SIGN_ALGS[k]] = k;
});
SIGN_ALGS['1.3.14.3.2.3'] = 'rsa-md5';
SIGN_ALGS['1.3.14.3.2.29'] = 'rsa-sha1';

var EXTS = {
	'issuerKeyId': '2.5.29.35',
	'altName': '2.5.29.17',
	'basicConstraints': '2.5.29.19',
	'keyUsage': '2.5.29.15',
	'extKeyUsage': '2.5.29.37'
};

function read$1(buf, options) {
	if (typeof (buf) === 'string') {
		buf = Buffer$8.from(buf, 'binary');
	}
	assert_1.buffer(buf, 'buf');

	var der = new lib$f.BerReader(buf);

	der.readSequence();
	if (Math.abs(der.length - der.remain) > 1) {
		throw (new Error('DER sequence does not contain whole byte ' +
		    'stream'));
	}

	var tbsStart = der.offset;
	der.readSequence();
	var sigOffset = der.offset + der.length;
	var tbsEnd = sigOffset;

	if (der.peek() === Local(0)) {
		der.readSequence(Local(0));
		var version = der.readInt();
		assert_1.ok(version <= 3,
		    'only x.509 versions up to v3 supported');
	}

	var cert = {};
	cert.signatures = {};
	var sig = (cert.signatures.x509 = {});
	sig.extras = {};

	cert.serial = readMPInt(der, 'serial');

	der.readSequence();
	var after = der.offset + der.length;
	var certAlgOid = der.readOID();
	var certAlg = SIGN_ALGS[certAlgOid];
	if (certAlg === undefined)
		throw (new Error('unknown signature algorithm ' + certAlgOid));

	der._offset = after;
	cert.issuer = identity.parseAsn1(der);

	der.readSequence();
	cert.validFrom = readDate(der);
	cert.validUntil = readDate(der);

	cert.subjects = [identity.parseAsn1(der)];

	der.readSequence();
	after = der.offset + der.length;
	cert.subjectKey = pkcs8.readPkcs8(undefined, 'public', der);
	der._offset = after;

	/* issuerUniqueID */
	if (der.peek() === Local(1)) {
		der.readSequence(Local(1));
		sig.extras.issuerUniqueID =
		    buf.slice(der.offset, der.offset + der.length);
		der._offset += der.length;
	}

	/* subjectUniqueID */
	if (der.peek() === Local(2)) {
		der.readSequence(Local(2));
		sig.extras.subjectUniqueID =
		    buf.slice(der.offset, der.offset + der.length);
		der._offset += der.length;
	}

	/* extensions */
	if (der.peek() === Local(3)) {
		der.readSequence(Local(3));
		var extEnd = der.offset + der.length;
		der.readSequence();

		while (der.offset < extEnd)
			readExtension(cert, buf, der);

		assert_1.strictEqual(der.offset, extEnd);
	}

	assert_1.strictEqual(der.offset, sigOffset);

	der.readSequence();
	after = der.offset + der.length;
	var sigAlgOid = der.readOID();
	var sigAlg = SIGN_ALGS[sigAlgOid];
	if (sigAlg === undefined)
		throw (new Error('unknown signature algorithm ' + sigAlgOid));
	der._offset = after;

	var sigData = der.readString(lib$f.Ber.BitString, true);
	if (sigData[0] === 0)
		sigData = sigData.slice(1);
	var algParts = sigAlg.split('-');

	sig.signature = signature.parse(sigData, algParts[0], 'asn1');
	sig.signature.hashAlgorithm = algParts[1];
	sig.algo = sigAlg;
	sig.cache = buf.slice(tbsStart, tbsEnd);

	return (new Certificate$1(cert));
}

function readDate(der) {
	if (der.peek() === lib$f.Ber.UTCTime) {
		return (utcTimeToDate(der.readString(lib$f.Ber.UTCTime)));
	} else if (der.peek() === lib$f.Ber.GeneralizedTime) {
		return (gTimeToDate(der.readString(lib$f.Ber.GeneralizedTime)));
	} else {
		throw (new Error('Unsupported date format'));
	}
}

function writeDate(der, date) {
	if (date.getUTCFullYear() >= 2050 || date.getUTCFullYear() < 1950) {
		der.writeString(dateToGTime(date), lib$f.Ber.GeneralizedTime);
	} else {
		der.writeString(dateToUTCTime(date), lib$f.Ber.UTCTime);
	}
}

/* RFC5280, section 4.2.1.6 (GeneralName type) */
var ALTNAME = {
	OtherName: Local(0),
	RFC822Name: Context(1),
	DNSName: Context(2),
	X400Address: Local(3),
	DirectoryName: Local(4),
	EDIPartyName: Local(5),
	URI: Context(6),
	IPAddress: Context(7),
	OID: Context(8)
};

/* RFC5280, section 4.2.1.12 (KeyPurposeId) */
var EXTPURPOSE = {
	'serverAuth': '1.3.6.1.5.5.7.3.1',
	'clientAuth': '1.3.6.1.5.5.7.3.2',
	'codeSigning': '1.3.6.1.5.5.7.3.3',

	/* See https://github.com/joyent/oid-docs/blob/master/root.md */
	'joyentDocker': '1.3.6.1.4.1.38678.1.4.1',
	'joyentCmon': '1.3.6.1.4.1.38678.1.4.2'
};
var EXTPURPOSE_REV = {};
Object.keys(EXTPURPOSE).forEach(function (k) {
	EXTPURPOSE_REV[EXTPURPOSE[k]] = k;
});

var KEYUSEBITS = [
	'signature', 'identity', 'keyEncryption',
	'encryption', 'keyAgreement', 'ca', 'crl'
];

function readExtension(cert, buf, der) {
	der.readSequence();
	var after = der.offset + der.length;
	var extId = der.readOID();
	var id;
	var sig = cert.signatures.x509;
	if (!sig.extras.exts)
		sig.extras.exts = [];

	var critical;
	if (der.peek() === lib$f.Ber.Boolean)
		critical = der.readBoolean();

	switch (extId) {
	case (EXTS.basicConstraints):
		der.readSequence(lib$f.Ber.OctetString);
		der.readSequence();
		var bcEnd = der.offset + der.length;
		var ca = false;
		if (der.peek() === lib$f.Ber.Boolean)
			ca = der.readBoolean();
		if (cert.purposes === undefined)
			cert.purposes = [];
		if (ca === true)
			cert.purposes.push('ca');
		var bc = { oid: extId, critical: critical };
		if (der.offset < bcEnd && der.peek() === lib$f.Ber.Integer)
			bc.pathLen = der.readInt();
		sig.extras.exts.push(bc);
		break;
	case (EXTS.extKeyUsage):
		der.readSequence(lib$f.Ber.OctetString);
		der.readSequence();
		if (cert.purposes === undefined)
			cert.purposes = [];
		var ekEnd = der.offset + der.length;
		while (der.offset < ekEnd) {
			var oid = der.readOID();
			cert.purposes.push(EXTPURPOSE_REV[oid] || oid);
		}
		/*
		 * This is a bit of a hack: in the case where we have a cert
		 * that's only allowed to do serverAuth or clientAuth (and not
		 * the other), we want to make sure all our Subjects are of
		 * the right type. But we already parsed our Subjects and
		 * decided if they were hosts or users earlier (since it appears
		 * first in the cert).
		 *
		 * So we go through and mutate them into the right kind here if
		 * it doesn't match. This might not be hugely beneficial, as it
		 * seems that single-purpose certs are not often seen in the
		 * wild.
		 */
		if (cert.purposes.indexOf('serverAuth') !== -1 &&
		    cert.purposes.indexOf('clientAuth') === -1) {
			cert.subjects.forEach(function (ide) {
				if (ide.type !== 'host') {
					ide.type = 'host';
					ide.hostname = ide.uid ||
					    ide.email ||
					    ide.components[0].value;
				}
			});
		} else if (cert.purposes.indexOf('clientAuth') !== -1 &&
		    cert.purposes.indexOf('serverAuth') === -1) {
			cert.subjects.forEach(function (ide) {
				if (ide.type !== 'user') {
					ide.type = 'user';
					ide.uid = ide.hostname ||
					    ide.email ||
					    ide.components[0].value;
				}
			});
		}
		sig.extras.exts.push({ oid: extId, critical: critical });
		break;
	case (EXTS.keyUsage):
		der.readSequence(lib$f.Ber.OctetString);
		var bits = der.readString(lib$f.Ber.BitString, true);
		var setBits = readBitField(bits, KEYUSEBITS);
		setBits.forEach(function (bit) {
			if (cert.purposes === undefined)
				cert.purposes = [];
			if (cert.purposes.indexOf(bit) === -1)
				cert.purposes.push(bit);
		});
		sig.extras.exts.push({ oid: extId, critical: critical,
		    bits: bits });
		break;
	case (EXTS.altName):
		der.readSequence(lib$f.Ber.OctetString);
		der.readSequence();
		var aeEnd = der.offset + der.length;
		while (der.offset < aeEnd) {
			switch (der.peek()) {
			case ALTNAME.OtherName:
			case ALTNAME.EDIPartyName:
				der.readSequence();
				der._offset += der.length;
				break;
			case ALTNAME.OID:
				der.readOID(ALTNAME.OID);
				break;
			case ALTNAME.RFC822Name:
				/* RFC822 specifies email addresses */
				var email = der.readString(ALTNAME.RFC822Name);
				id = identity.forEmail(email);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			case ALTNAME.DirectoryName:
				der.readSequence(ALTNAME.DirectoryName);
				id = identity.parseAsn1(der);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			case ALTNAME.DNSName:
				var host = der.readString(
				    ALTNAME.DNSName);
				id = identity.forHost(host);
				if (!cert.subjects[0].equals(id))
					cert.subjects.push(id);
				break;
			default:
				der.readString(der.peek());
				break;
			}
		}
		sig.extras.exts.push({ oid: extId, critical: critical });
		break;
	default:
		sig.extras.exts.push({
			oid: extId,
			critical: critical,
			data: der.readString(lib$f.Ber.OctetString, true)
		});
		break;
	}

	der._offset = after;
}

var UTCTIME_RE =
    /^([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function utcTimeToDate(t) {
	var m = t.match(UTCTIME_RE);
	assert_1.ok(m, 'timestamps must be in UTC');
	var d = new Date();

	var thisYear = d.getUTCFullYear();
	var century = Math.floor(thisYear / 100) * 100;

	var year = parseInt(m[1], 10);
	if (thisYear % 100 < 50 && year >= 60)
		year += (century - 1);
	else
		year += century;
	d.setUTCFullYear(year, parseInt(m[2], 10) - 1, parseInt(m[3], 10));
	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
	if (m[6] && m[6].length > 0)
		d.setUTCSeconds(parseInt(m[6], 10));
	return (d);
}

var GTIME_RE =
    /^([0-9]{4})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})([0-9]{2})?Z$/;
function gTimeToDate(t) {
	var m = t.match(GTIME_RE);
	assert_1.ok(m);
	var d = new Date();

	d.setUTCFullYear(parseInt(m[1], 10), parseInt(m[2], 10) - 1,
	    parseInt(m[3], 10));
	d.setUTCHours(parseInt(m[4], 10), parseInt(m[5], 10));
	if (m[6] && m[6].length > 0)
		d.setUTCSeconds(parseInt(m[6], 10));
	return (d);
}

function zeroPad(n, m) {
	if (m === undefined)
		m = 2;
	var s = '' + n;
	while (s.length < m)
		s = '0' + s;
	return (s);
}

function dateToUTCTime(d) {
	var s = '';
	s += zeroPad(d.getUTCFullYear() % 100);
	s += zeroPad(d.getUTCMonth() + 1);
	s += zeroPad(d.getUTCDate());
	s += zeroPad(d.getUTCHours());
	s += zeroPad(d.getUTCMinutes());
	s += zeroPad(d.getUTCSeconds());
	s += 'Z';
	return (s);
}

function dateToGTime(d) {
	var s = '';
	s += zeroPad(d.getUTCFullYear(), 4);
	s += zeroPad(d.getUTCMonth() + 1);
	s += zeroPad(d.getUTCDate());
	s += zeroPad(d.getUTCHours());
	s += zeroPad(d.getUTCMinutes());
	s += zeroPad(d.getUTCSeconds());
	s += 'Z';
	return (s);
}

function sign$1(cert, key) {
	if (cert.signatures.x509 === undefined)
		cert.signatures.x509 = {};
	var sig = cert.signatures.x509;

	sig.algo = key.type + '-' + key.defaultHashAlgorithm();
	if (SIGN_ALGS[sig.algo] === undefined)
		return (false);

	var der = new lib$f.BerWriter();
	writeTBSCert(cert, der);
	var blob = der.buffer;
	sig.cache = blob;

	var signer = key.createSign();
	signer.write(blob);
	cert.signatures.x509.signature = signer.sign();

	return (true);
}

function signAsync(cert, signer, done) {
	if (cert.signatures.x509 === undefined)
		cert.signatures.x509 = {};
	var sig = cert.signatures.x509;

	var der = new lib$f.BerWriter();
	writeTBSCert(cert, der);
	var blob = der.buffer;
	sig.cache = blob;

	signer(blob, function (err, signature) {
		if (err) {
			done(err);
			return;
		}
		sig.algo = signature.type + '-' + signature.hashAlgorithm;
		if (SIGN_ALGS[sig.algo] === undefined) {
			done(new Error('Invalid signing algorithm "' +
			    sig.algo + '"'));
			return;
		}
		sig.signature = signature;
		done();
	});
}

function write$1(cert, options) {
	var sig = cert.signatures.x509;
	assert_1.object(sig, 'x509 signature');

	var der = new lib$f.BerWriter();
	der.startSequence();
	if (sig.cache) {
		der._ensure(sig.cache.length);
		sig.cache.copy(der._buf, der._offset);
		der._offset += sig.cache.length;
	} else {
		writeTBSCert(cert, der);
	}

	der.startSequence();
	der.writeOID(SIGN_ALGS[sig.algo]);
	if (sig.algo.match(/^rsa-/))
		der.writeNull();
	der.endSequence();

	var sigData = sig.signature.toBuffer('asn1');
	var data = Buffer$8.alloc(sigData.length + 1);
	data[0] = 0;
	sigData.copy(data, 1);
	der.writeBuffer(data, lib$f.Ber.BitString);
	der.endSequence();

	return (der.buffer);
}

function writeTBSCert(cert, der) {
	var sig = cert.signatures.x509;
	assert_1.object(sig, 'x509 signature');

	der.startSequence();

	der.startSequence(Local(0));
	der.writeInt(2);
	der.endSequence();

	der.writeBuffer(utils$2.mpNormalize(cert.serial), lib$f.Ber.Integer);

	der.startSequence();
	der.writeOID(SIGN_ALGS[sig.algo]);
	if (sig.algo.match(/^rsa-/))
		der.writeNull();
	der.endSequence();

	cert.issuer.toAsn1(der);

	der.startSequence();
	writeDate(der, cert.validFrom);
	writeDate(der, cert.validUntil);
	der.endSequence();

	var subject = cert.subjects[0];
	var altNames = cert.subjects.slice(1);
	subject.toAsn1(der);

	pkcs8.writePkcs8(der, cert.subjectKey);

	if (sig.extras && sig.extras.issuerUniqueID) {
		der.writeBuffer(sig.extras.issuerUniqueID, Local(1));
	}

	if (sig.extras && sig.extras.subjectUniqueID) {
		der.writeBuffer(sig.extras.subjectUniqueID, Local(2));
	}

	if (altNames.length > 0 || subject.type === 'host' ||
	    (cert.purposes !== undefined && cert.purposes.length > 0) ||
	    (sig.extras && sig.extras.exts)) {
		der.startSequence(Local(3));
		der.startSequence();

		var exts = [];
		if (cert.purposes !== undefined && cert.purposes.length > 0) {
			exts.push({
				oid: EXTS.basicConstraints,
				critical: true
			});
			exts.push({
				oid: EXTS.keyUsage,
				critical: true
			});
			exts.push({
				oid: EXTS.extKeyUsage,
				critical: true
			});
		}
		exts.push({ oid: EXTS.altName });
		if (sig.extras && sig.extras.exts)
			exts = sig.extras.exts;

		for (var i = 0; i < exts.length; ++i) {
			der.startSequence();
			der.writeOID(exts[i].oid);

			if (exts[i].critical !== undefined)
				der.writeBoolean(exts[i].critical);

			if (exts[i].oid === EXTS.altName) {
				der.startSequence(lib$f.Ber.OctetString);
				der.startSequence();
				if (subject.type === 'host') {
					der.writeString(subject.hostname,
					    Context(2));
				}
				for (var j = 0; j < altNames.length; ++j) {
					if (altNames[j].type === 'host') {
						der.writeString(
						    altNames[j].hostname,
						    ALTNAME.DNSName);
					} else if (altNames[j].type ===
					    'email') {
						der.writeString(
						    altNames[j].email,
						    ALTNAME.RFC822Name);
					} else {
						/*
						 * Encode anything else as a
						 * DN style name for now.
						 */
						der.startSequence(
						    ALTNAME.DirectoryName);
						altNames[j].toAsn1(der);
						der.endSequence();
					}
				}
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.basicConstraints) {
				der.startSequence(lib$f.Ber.OctetString);
				der.startSequence();
				var ca = (cert.purposes.indexOf('ca') !== -1);
				var pathLen = exts[i].pathLen;
				der.writeBoolean(ca);
				if (pathLen !== undefined)
					der.writeInt(pathLen);
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.extKeyUsage) {
				der.startSequence(lib$f.Ber.OctetString);
				der.startSequence();
				cert.purposes.forEach(function (purpose) {
					if (purpose === 'ca')
						return;
					if (KEYUSEBITS.indexOf(purpose) !== -1)
						return;
					var oid = purpose;
					if (EXTPURPOSE[purpose] !== undefined)
						oid = EXTPURPOSE[purpose];
					der.writeOID(oid);
				});
				der.endSequence();
				der.endSequence();
			} else if (exts[i].oid === EXTS.keyUsage) {
				der.startSequence(lib$f.Ber.OctetString);
				/*
				 * If we parsed this certificate from a byte
				 * stream (i.e. we didn't generate it in sshpk)
				 * then we'll have a ".bits" property on the
				 * ext with the original raw byte contents.
				 *
				 * If we have this, use it here instead of
				 * regenerating it. This guarantees we output
				 * the same data we parsed, so signatures still
				 * validate.
				 */
				if (exts[i].bits !== undefined) {
					der.writeBuffer(exts[i].bits,
					    lib$f.Ber.BitString);
				} else {
					var bits = writeBitField(cert.purposes,
					    KEYUSEBITS);
					der.writeBuffer(bits,
					    lib$f.Ber.BitString);
				}
				der.endSequence();
			} else {
				der.writeBuffer(exts[i].data,
				    lib$f.Ber.OctetString);
			}

			der.endSequence();
		}

		der.endSequence();
		der.endSequence();
	}

	der.endSequence();
}

/*
 * Reads an ASN.1 BER bitfield out of the Buffer produced by doing
 * `BerReader#readString(asn1.Ber.BitString)`. That function gives us the raw
 * contents of the BitString tag, which is a count of unused bits followed by
 * the bits as a right-padded byte string.
 *
 * `bits` is the Buffer, `bitIndex` should contain an array of string names
 * for the bits in the string, ordered starting with bit #0 in the ASN.1 spec.
 *
 * Returns an array of Strings, the names of the bits that were set to 1.
 */
function readBitField(bits, bitIndex) {
	var bitLen = 8 * (bits.length - 1) - bits[0];
	var setBits = {};
	for (var i = 0; i < bitLen; ++i) {
		var byteN = 1 + Math.floor(i / 8);
		var bit = 7 - (i % 8);
		var mask = 1 << bit;
		var bitVal = ((bits[byteN] & mask) !== 0);
		var name = bitIndex[i];
		if (bitVal && typeof (name) === 'string') {
			setBits[name] = true;
		}
	}
	return (Object.keys(setBits));
}

/*
 * `setBits` is an array of strings, containing the names for each bit that
 * sould be set to 1. `bitIndex` is same as in `readBitField()`.
 *
 * Returns a Buffer, ready to be written out with `BerWriter#writeString()`.
 */
function writeBitField(setBits, bitIndex) {
	var bitLen = bitIndex.length;
	var blen = Math.ceil(bitLen / 8);
	var unused = blen * 8 - bitLen;
	var bits = Buffer$8.alloc(1 + blen); // zero-filled
	bits[0] = unused;
	for (var i = 0; i < bitLen; ++i) {
		var byteN = 1 + Math.floor(i / 8);
		var bit = 7 - (i % 8);
		var mask = 1 << bit;
		var name = bitIndex[i];
		if (name === undefined)
			continue;
		var bitVal = (setBits.indexOf(name) !== -1);
		if (bitVal) {
			bits[byteN] |= mask;
		}
	}
	return (bits);
}

// Copyright 2016 Joyent, Inc.



var x509Pem = {
	read: read,
	verify: x509.verify,
	sign: x509.sign,
	write: write
};



var Buffer$7 = safer_1.Buffer;









function read(buf, options) {
	if (typeof (buf) !== 'string') {
		assert_1.buffer(buf, 'buf');
		buf = buf.toString('ascii');
	}

	var lines = buf.trim().split(/[\r\n]+/g);

	var m;
	var si = -1;
	while (!m && si < lines.length) {
		m = lines[++si].match(/*JSSTYLED*/
		    /[-]+[ ]*BEGIN CERTIFICATE[ ]*[-]+/);
	}
	assert_1.ok(m, 'invalid PEM header');

	var m2;
	var ei = lines.length;
	while (!m2 && ei > 0) {
		m2 = lines[--ei].match(/*JSSTYLED*/
		    /[-]+[ ]*END CERTIFICATE[ ]*[-]+/);
	}
	assert_1.ok(m2, 'invalid PEM footer');

	lines = lines.slice(si, ei + 1);

	var headers = {};
	while (true) {
		lines = lines.slice(1);
		m = lines[0].match(/*JSSTYLED*/
		    /^([A-Za-z0-9-]+): (.+)$/);
		if (!m)
			break;
		headers[m[1].toLowerCase()] = m[2];
	}

	/* Chop off the first and last lines */
	lines = lines.slice(0, -1).join('');
	buf = Buffer$7.from(lines, 'base64');

	return (x509.read(buf, options));
}

function write(cert, options) {
	var dbuf = x509.write(cert, options);

	var header = 'CERTIFICATE';
	var tmp = dbuf.toString('base64');
	var len = tmp.length + (tmp.length / 64) +
	    18 + 16 + header.length*2 + 10;
	var buf = Buffer$7.alloc(len);
	var o = 0;
	o += buf.write('-----BEGIN ' + header + '-----\n', o);
	for (var i = 0; i < tmp.length; ) {
		var limit = i + 64;
		if (limit > tmp.length)
			limit = tmp.length;
		o += buf.write(tmp.slice(i, limit), o);
		buf[o++] = 10;
		i = limit;
	}
	o += buf.write('-----END ' + header + '-----\n', o);

	return (buf.slice(0, o));
}

// Copyright 2016 Joyent, Inc.

var certificate = Certificate;


var Buffer$6 = safer_1.Buffer;











var formats$3 = {};
formats$3['openssh'] = opensshCert;
formats$3['x509'] = x509;
formats$3['pem'] = x509Pem;

var CertificateParseError = errors$1.CertificateParseError;
var InvalidAlgorithmError$5 = errors$1.InvalidAlgorithmError;

function Certificate(opts) {
	assert_1.object(opts, 'options');
	assert_1.arrayOfObject(opts.subjects, 'options.subjects');
	utils$2.assertCompatible(opts.subjects[0], identity, [1, 0],
	    'options.subjects');
	utils$2.assertCompatible(opts.subjectKey, Key$1, [1, 0],
	    'options.subjectKey');
	utils$2.assertCompatible(opts.issuer, identity, [1, 0], 'options.issuer');
	if (opts.issuerKey !== undefined) {
		utils$2.assertCompatible(opts.issuerKey, Key$1, [1, 0],
		    'options.issuerKey');
	}
	assert_1.object(opts.signatures, 'options.signatures');
	assert_1.buffer(opts.serial, 'options.serial');
	assert_1.date(opts.validFrom, 'options.validFrom');
	assert_1.date(opts.validUntil, 'optons.validUntil');

	assert_1.optionalArrayOfString(opts.purposes, 'options.purposes');

	this._hashCache = {};

	this.subjects = opts.subjects;
	this.issuer = opts.issuer;
	this.subjectKey = opts.subjectKey;
	this.issuerKey = opts.issuerKey;
	this.signatures = opts.signatures;
	this.serial = opts.serial;
	this.validFrom = opts.validFrom;
	this.validUntil = opts.validUntil;
	this.purposes = opts.purposes;
}

Certificate.formats = formats$3;

Certificate.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'x509';
	assert_1.string(format, 'format');
	assert_1.object(formats$3[format], 'formats[format]');
	assert_1.optionalObject(options, 'options');

	return (formats$3[format].write(this, options));
};

Certificate.prototype.toString = function (format, options) {
	if (format === undefined)
		format = 'pem';
	return (this.toBuffer(format, options).toString());
};

Certificate.prototype.fingerprint = function (algo) {
	if (algo === undefined)
		algo = 'sha256';
	assert_1.string(algo, 'algorithm');
	var opts = {
		type: 'certificate',
		hash: this.hash(algo),
		algorithm: algo
	};
	return (new Fingerprint$1(opts));
};

Certificate.prototype.hash = function (algo) {
	assert_1.string(algo, 'algorithm');
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError$5(algo));

	if (this._hashCache[algo])
		return (this._hashCache[algo]);

	var hash = crypto$1.createHash(algo).
	    update(this.toBuffer('x509')).digest();
	this._hashCache[algo] = hash;
	return (hash);
};

Certificate.prototype.isExpired = function (when) {
	if (when === undefined)
		when = new Date();
	return (!((when.getTime() >= this.validFrom.getTime()) &&
		(when.getTime() < this.validUntil.getTime())));
};

Certificate.prototype.isSignedBy = function (issuerCert) {
	utils$2.assertCompatible(issuerCert, Certificate, [1, 0], 'issuer');

	if (!this.issuer.equals(issuerCert.subjects[0]))
		return (false);
	if (this.issuer.purposes && this.issuer.purposes.length > 0 &&
	    this.issuer.purposes.indexOf('ca') === -1) {
		return (false);
	}

	return (this.isSignedByKey(issuerCert.subjectKey));
};

Certificate.prototype.getExtension = function (keyOrOid) {
	assert_1.string(keyOrOid, 'keyOrOid');
	var ext = this.getExtensions().filter(function (maybeExt) {
		if (maybeExt.format === 'x509')
			return (maybeExt.oid === keyOrOid);
		if (maybeExt.format === 'openssh')
			return (maybeExt.name === keyOrOid);
		return (false);
	})[0];
	return (ext);
};

Certificate.prototype.getExtensions = function () {
	var exts = [];
	var x509 = this.signatures.x509;
	if (x509 && x509.extras && x509.extras.exts) {
		x509.extras.exts.forEach(function (ext) {
			ext.format = 'x509';
			exts.push(ext);
		});
	}
	var openssh = this.signatures.openssh;
	if (openssh && openssh.exts) {
		openssh.exts.forEach(function (ext) {
			ext.format = 'openssh';
			exts.push(ext);
		});
	}
	return (exts);
};

Certificate.prototype.isSignedByKey = function (issuerKey) {
	utils$2.assertCompatible(issuerKey, Key$1, [1, 2], 'issuerKey');

	if (this.issuerKey !== undefined) {
		return (this.issuerKey.
		    fingerprint('sha512').matches(issuerKey));
	}

	var fmt = Object.keys(this.signatures)[0];
	var valid = formats$3[fmt].verify(this, issuerKey);
	if (valid)
		this.issuerKey = issuerKey;
	return (valid);
};

Certificate.prototype.signWith = function (key) {
	utils$2.assertCompatible(key, PrivateKey$1, [1, 2], 'key');
	var fmts = Object.keys(formats$3);
	var didOne = false;
	for (var i = 0; i < fmts.length; ++i) {
		if (fmts[i] !== 'pem') {
			var ret = formats$3[fmts[i]].sign(this, key);
			if (ret === true)
				didOne = true;
		}
	}
	if (!didOne) {
		throw (new Error('Failed to sign the certificate for any ' +
		    'available certificate formats'));
	}
};

Certificate.createSelfSigned = function (subjectOrSubjects, key, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert_1.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils$2.assertCompatible(subject, identity, [1, 0], 'subject');
	});

	utils$2.assertCompatible(key, PrivateKey$1, [1, 2], 'private key');

	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert_1.optionalObject(options.validFrom, 'options.validFrom');
	assert_1.optionalObject(options.validUntil, 'options.validUntil');
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert_1.optionalNumber(options.lifetime, 'options.lifetime');
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert_1.optionalBuffer(options.serial, 'options.serial');
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer$6.from('0000000000000001', 'hex');

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf('signature') === -1)
		purposes.push('signature');

	/* Self-signed certs are always CAs. */
	if (purposes.indexOf('ca') === -1)
		purposes.push('ca');
	if (purposes.indexOf('crl') === -1)
		purposes.push('crl');

	/*
	 * If we weren't explicitly given any other purposes, do the sensible
	 * thing and add some basic ones depending on the subject type.
	 */
	if (purposes.length <= 3) {
		var hostSubjects = subjects.filter(function (subject) {
			return (subject.type === 'host');
		});
		var userSubjects = subjects.filter(function (subject) {
			return (subject.type === 'user');
		});
		if (hostSubjects.length > 0) {
			if (purposes.indexOf('serverAuth') === -1)
				purposes.push('serverAuth');
		}
		if (userSubjects.length > 0) {
			if (purposes.indexOf('clientAuth') === -1)
				purposes.push('clientAuth');
		}
		if (userSubjects.length > 0 || hostSubjects.length > 0) {
			if (purposes.indexOf('keyAgreement') === -1)
				purposes.push('keyAgreement');
			if (key.type === 'rsa' &&
			    purposes.indexOf('encryption') === -1)
				purposes.push('encryption');
		}
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: subjects[0],
		subjectKey: key.toPublic(),
		issuerKey: key.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(key);

	return (cert);
};

Certificate.create =
    function (subjectOrSubjects, key, issuer, issuerKey, options) {
	var subjects;
	if (Array.isArray(subjectOrSubjects))
		subjects = subjectOrSubjects;
	else
		subjects = [subjectOrSubjects];

	assert_1.arrayOfObject(subjects);
	subjects.forEach(function (subject) {
		utils$2.assertCompatible(subject, identity, [1, 0], 'subject');
	});

	utils$2.assertCompatible(key, Key$1, [1, 0], 'key');
	if (PrivateKey$1.isPrivateKey(key))
		key = key.toPublic();
	utils$2.assertCompatible(issuer, identity, [1, 0], 'issuer');
	utils$2.assertCompatible(issuerKey, PrivateKey$1, [1, 2], 'issuer key');

	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert_1.optionalObject(options.validFrom, 'options.validFrom');
	assert_1.optionalObject(options.validUntil, 'options.validUntil');
	var validFrom = options.validFrom;
	var validUntil = options.validUntil;
	if (validFrom === undefined)
		validFrom = new Date();
	if (validUntil === undefined) {
		assert_1.optionalNumber(options.lifetime, 'options.lifetime');
		var lifetime = options.lifetime;
		if (lifetime === undefined)
			lifetime = 10*365*24*3600;
		validUntil = new Date();
		validUntil.setTime(validUntil.getTime() + lifetime*1000);
	}
	assert_1.optionalBuffer(options.serial, 'options.serial');
	var serial = options.serial;
	if (serial === undefined)
		serial = Buffer$6.from('0000000000000001', 'hex');

	var purposes = options.purposes;
	if (purposes === undefined)
		purposes = [];

	if (purposes.indexOf('signature') === -1)
		purposes.push('signature');

	if (options.ca === true) {
		if (purposes.indexOf('ca') === -1)
			purposes.push('ca');
		if (purposes.indexOf('crl') === -1)
			purposes.push('crl');
	}

	var hostSubjects = subjects.filter(function (subject) {
		return (subject.type === 'host');
	});
	var userSubjects = subjects.filter(function (subject) {
		return (subject.type === 'user');
	});
	if (hostSubjects.length > 0) {
		if (purposes.indexOf('serverAuth') === -1)
			purposes.push('serverAuth');
	}
	if (userSubjects.length > 0) {
		if (purposes.indexOf('clientAuth') === -1)
			purposes.push('clientAuth');
	}
	if (userSubjects.length > 0 || hostSubjects.length > 0) {
		if (purposes.indexOf('keyAgreement') === -1)
			purposes.push('keyAgreement');
		if (key.type === 'rsa' &&
		    purposes.indexOf('encryption') === -1)
			purposes.push('encryption');
	}

	var cert = new Certificate({
		subjects: subjects,
		issuer: issuer,
		subjectKey: key,
		issuerKey: issuerKey.toPublic(),
		signatures: {},
		serial: serial,
		validFrom: validFrom,
		validUntil: validUntil,
		purposes: purposes
	});
	cert.signWith(issuerKey);

	return (cert);
};

Certificate.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert_1.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert_1.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert_1.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert_1.object(formats$3[format], 'formats[format]');

	try {
		var k = formats$3[format].read(data, options);
		return (k);
	} catch (e) {
		throw (new CertificateParseError(options.filename, format, e));
	}
};

Certificate.isCertificate = function (obj, ver) {
	return (utils$2.isCompatible(obj, Certificate, ver));
};

/*
 * API versions for Certificate:
 * [1,0] -- initial ver
 * [1,1] -- openssh format now unpacks extensions
 */
Certificate.prototype._sshpkApiVersion = [1, 1];

Certificate._oldVersionDetect = function (obj) {
	return ([1, 0]);
};

// Copyright 2018 Joyent, Inc.

var fingerprint = Fingerprint;


var Buffer$5 = safer_1.Buffer;








var FingerprintFormatError = errors$1.FingerprintFormatError;
var InvalidAlgorithmError$4 = errors$1.InvalidAlgorithmError;

function Fingerprint(opts) {
	assert_1.object(opts, 'options');
	assert_1.string(opts.type, 'options.type');
	assert_1.buffer(opts.hash, 'options.hash');
	assert_1.string(opts.algorithm, 'options.algorithm');

	this.algorithm = opts.algorithm.toLowerCase();
	if (algs.hashAlgs[this.algorithm] !== true)
		throw (new InvalidAlgorithmError$4(this.algorithm));

	this.hash = opts.hash;
	this.type = opts.type;
	this.hashType = opts.hashType;
}

Fingerprint.prototype.toString = function (format) {
	if (format === undefined) {
		if (this.algorithm === 'md5' || this.hashType === 'spki')
			format = 'hex';
		else
			format = 'base64';
	}
	assert_1.string(format);

	switch (format) {
	case 'hex':
		if (this.hashType === 'spki')
			return (this.hash.toString('hex'));
		return (addColons(this.hash.toString('hex')));
	case 'base64':
		if (this.hashType === 'spki')
			return (this.hash.toString('base64'));
		return (sshBase64Format(this.algorithm,
		    this.hash.toString('base64')));
	default:
		throw (new FingerprintFormatError(undefined, format));
	}
};

Fingerprint.prototype.matches = function (other) {
	assert_1.object(other, 'key or certificate');
	if (this.type === 'key' && this.hashType !== 'ssh') {
		utils$2.assertCompatible(other, Key$1, [1, 7], 'key with spki');
		if (PrivateKey$1.isPrivateKey(other)) {
			utils$2.assertCompatible(other, PrivateKey$1, [1, 6],
			    'privatekey with spki support');
		}
	} else if (this.type === 'key') {
		utils$2.assertCompatible(other, Key$1, [1, 0], 'key');
	} else {
		utils$2.assertCompatible(other, Certificate$1, [1, 0],
		    'certificate');
	}

	var theirHash = other.hash(this.algorithm, this.hashType);
	var theirHash2 = crypto$1.createHash(this.algorithm).
	    update(theirHash).digest('base64');

	if (this.hash2 === undefined)
		this.hash2 = crypto$1.createHash(this.algorithm).
		    update(this.hash).digest('base64');

	return (this.hash2 === theirHash2);
};

/*JSSTYLED*/
var base64RE = /^[A-Za-z0-9+\/=]+$/;
/*JSSTYLED*/
var hexRE = /^[a-fA-F0-9]+$/;

Fingerprint.parse = function (fp, options) {
	assert_1.string(fp, 'fingerprint');

	var alg, hash, enAlgs;
	if (Array.isArray(options)) {
		enAlgs = options;
		options = {};
	}
	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	if (options.enAlgs !== undefined)
		enAlgs = options.enAlgs;
	if (options.algorithms !== undefined)
		enAlgs = options.algorithms;
	assert_1.optionalArrayOfString(enAlgs, 'algorithms');

	var hashType = 'ssh';
	if (options.hashType !== undefined)
		hashType = options.hashType;
	assert_1.string(hashType, 'options.hashType');

	var parts = fp.split(':');
	if (parts.length == 2) {
		alg = parts[0].toLowerCase();
		if (!base64RE.test(parts[1]))
			throw (new FingerprintFormatError(fp));
		try {
			hash = Buffer$5.from(parts[1], 'base64');
		} catch (e) {
			throw (new FingerprintFormatError(fp));
		}
	} else if (parts.length > 2) {
		alg = 'md5';
		if (parts[0].toLowerCase() === 'md5')
			parts = parts.slice(1);
		parts = parts.map(function (p) {
			while (p.length < 2)
				p = '0' + p;
			if (p.length > 2)
				throw (new FingerprintFormatError(fp));
			return (p);
		});
		parts = parts.join('');
		if (!hexRE.test(parts) || parts.length % 2 !== 0)
			throw (new FingerprintFormatError(fp));
		try {
			hash = Buffer$5.from(parts, 'hex');
		} catch (e) {
			throw (new FingerprintFormatError(fp));
		}
	} else {
		if (hexRE.test(fp)) {
			hash = Buffer$5.from(fp, 'hex');
		} else if (base64RE.test(fp)) {
			hash = Buffer$5.from(fp, 'base64');
		} else {
			throw (new FingerprintFormatError(fp));
		}

		switch (hash.length) {
		case 32:
			alg = 'sha256';
			break;
		case 16:
			alg = 'md5';
			break;
		case 20:
			alg = 'sha1';
			break;
		case 64:
			alg = 'sha512';
			break;
		default:
			throw (new FingerprintFormatError(fp));
		}

		/* Plain hex/base64: guess it's probably SPKI unless told. */
		if (options.hashType === undefined)
			hashType = 'spki';
	}

	if (alg === undefined)
		throw (new FingerprintFormatError(fp));

	if (algs.hashAlgs[alg] === undefined)
		throw (new InvalidAlgorithmError$4(alg));

	if (enAlgs !== undefined) {
		enAlgs = enAlgs.map(function (a) { return a.toLowerCase(); });
		if (enAlgs.indexOf(alg) === -1)
			throw (new InvalidAlgorithmError$4(alg));
	}

	return (new Fingerprint({
		algorithm: alg,
		hash: hash,
		type: options.type || 'key',
		hashType: hashType
	}));
};

function addColons(s) {
	/*JSSTYLED*/
	return (s.replace(/(.{2})(?=.)/g, '$1:'));
}

function base64Strip(s) {
	/*JSSTYLED*/
	return (s.replace(/=*$/, ''));
}

function sshBase64Format(alg, h) {
	return (alg.toUpperCase() + ':' + base64Strip(h));
}

Fingerprint.isFingerprint = function (obj, ver) {
	return (utils$2.isCompatible(obj, Fingerprint, ver));
};

/*
 * API versions for Fingerprint:
 * [1,0] -- initial ver
 * [1,1] -- first tagged ver
 * [1,2] -- hashType and spki support
 */
Fingerprint.prototype._sshpkApiVersion = [1, 2];

Fingerprint._oldVersionDetect = function (obj) {
	assert_1.func(obj.toString);
	assert_1.func(obj.matches);
	return ([1, 0]);
};

// Copyright 2018 Joyent, Inc.

var key = Key;






var DiffieHellman = dhe.DiffieHellman;



var edCompat;

try {
	edCompat = edCompat$1;
} catch (e) {
	/* Just continue through, and bail out if we try to use it. */
}

var InvalidAlgorithmError$3 = errors$1.InvalidAlgorithmError;
var KeyParseError = errors$1.KeyParseError;

var formats$2 = {};
formats$2['auto'] = auto;
formats$2['pem'] = require$$3$1;
formats$2['pkcs1'] = pkcs1;
formats$2['pkcs8'] = pkcs8;
formats$2['rfc4253'] = rfc4253;
formats$2['ssh'] = ssh;
formats$2['ssh-private'] = sshPrivate;
formats$2['openssh'] = formats$2['ssh-private'];
formats$2['dnssec'] = dnssec;
formats$2['putty'] = putty;
formats$2['ppk'] = formats$2['putty'];

function Key(opts) {
	assert_1.object(opts, 'options');
	assert_1.arrayOfObject(opts.parts, 'options.parts');
	assert_1.string(opts.type, 'options.type');
	assert_1.optionalString(opts.comment, 'options.comment');

	var algInfo = algs.info[opts.type];
	if (typeof (algInfo) !== 'object')
		throw (new InvalidAlgorithmError$3(opts.type));

	var partLookup = {};
	for (var i = 0; i < opts.parts.length; ++i) {
		var part = opts.parts[i];
		partLookup[part.name] = part;
	}

	this.type = opts.type;
	this.parts = opts.parts;
	this.part = partLookup;
	this.comment = undefined;
	this.source = opts.source;

	/* for speeding up hashing/fingerprint operations */
	this._rfc4253Cache = opts._rfc4253Cache;
	this._hashCache = {};

	var sz;
	this.curve = undefined;
	if (this.type === 'ecdsa') {
		var curve = this.part.curve.data.toString();
		this.curve = curve;
		sz = algs.curves[curve].size;
	} else if (this.type === 'ed25519' || this.type === 'curve25519') {
		sz = 256;
		this.curve = 'curve25519';
	} else {
		var szPart = this.part[algInfo.sizePart];
		sz = szPart.data.length;
		sz = sz * 8 - utils$2.countZeros(szPart.data);
	}
	this.size = sz;
}

Key.formats = formats$2;

Key.prototype.toBuffer = function (format, options) {
	if (format === undefined)
		format = 'ssh';
	assert_1.string(format, 'format');
	assert_1.object(formats$2[format], 'formats[format]');
	assert_1.optionalObject(options, 'options');

	if (format === 'rfc4253') {
		if (this._rfc4253Cache === undefined)
			this._rfc4253Cache = formats$2['rfc4253'].write(this);
		return (this._rfc4253Cache);
	}

	return (formats$2[format].write(this, options));
};

Key.prototype.toString = function (format, options) {
	return (this.toBuffer(format, options).toString());
};

Key.prototype.hash = function (algo, type) {
	assert_1.string(algo, 'algorithm');
	assert_1.optionalString(type, 'type');
	if (type === undefined)
		type = 'ssh';
	algo = algo.toLowerCase();
	if (algs.hashAlgs[algo] === undefined)
		throw (new InvalidAlgorithmError$3(algo));

	var cacheKey = algo + '||' + type;
	if (this._hashCache[cacheKey])
		return (this._hashCache[cacheKey]);

	var buf;
	if (type === 'ssh') {
		buf = this.toBuffer('rfc4253');
	} else if (type === 'spki') {
		buf = formats$2.pkcs8.pkcs8ToBuffer(this);
	} else {
		throw (new Error('Hash type ' + type + ' not supported'));
	}
	var hash = crypto$1.createHash(algo).update(buf).digest();
	this._hashCache[cacheKey] = hash;
	return (hash);
};

Key.prototype.fingerprint = function (algo, type) {
	if (algo === undefined)
		algo = 'sha256';
	if (type === undefined)
		type = 'ssh';
	assert_1.string(algo, 'algorithm');
	assert_1.string(type, 'type');
	var opts = {
		type: 'key',
		hash: this.hash(algo, type),
		algorithm: algo,
		hashType: type
	};
	return (new Fingerprint$1(opts));
};

Key.prototype.defaultHashAlgorithm = function () {
	var hashAlgo = 'sha1';
	if (this.type === 'rsa')
		hashAlgo = 'sha256';
	if (this.type === 'dsa' && this.size > 1024)
		hashAlgo = 'sha256';
	if (this.type === 'ed25519')
		hashAlgo = 'sha512';
	if (this.type === 'ecdsa') {
		if (this.size <= 256)
			hashAlgo = 'sha256';
		else if (this.size <= 384)
			hashAlgo = 'sha384';
		else
			hashAlgo = 'sha512';
	}
	return (hashAlgo);
};

Key.prototype.createVerify = function (hashAlgo) {
	if (hashAlgo === undefined)
		hashAlgo = this.defaultHashAlgorithm();
	assert_1.string(hashAlgo, 'hash algorithm');

	/* ED25519 is not supported by OpenSSL, use a javascript impl. */
	if (this.type === 'ed25519' && edCompat !== undefined)
		return (new edCompat.Verifier(this, hashAlgo));
	if (this.type === 'curve25519')
		throw (new Error('Curve25519 keys are not suitable for ' +
		    'signing or verification'));

	var v, nm, err;
	try {
		nm = hashAlgo.toUpperCase();
		v = crypto$1.createVerify(nm);
	} catch (e) {
		err = e;
	}
	if (v === undefined || (err instanceof Error &&
	    err.message.match(/Unknown message digest/))) {
		nm = 'RSA-';
		nm += hashAlgo.toUpperCase();
		v = crypto$1.createVerify(nm);
	}
	assert_1.ok(v, 'failed to create verifier');
	var oldVerify = v.verify.bind(v);
	var key = this.toBuffer('pkcs8');
	var curve = this.curve;
	var self = this;
	v.verify = function (signature$1, fmt) {
		if (signature.isSignature(signature$1, [2, 0])) {
			if (signature$1.type !== self.type)
				return (false);
			if (signature$1.hashAlgorithm &&
			    signature$1.hashAlgorithm !== hashAlgo)
				return (false);
			if (signature$1.curve && self.type === 'ecdsa' &&
			    signature$1.curve !== curve)
				return (false);
			return (oldVerify(key, signature$1.toBuffer('asn1')));

		} else if (typeof (signature$1) === 'string' ||
		    Buffer.isBuffer(signature$1)) {
			return (oldVerify(key, signature$1, fmt));

		/*
		 * Avoid doing this on valid arguments, walking the prototype
		 * chain can be quite slow.
		 */
		} else if (signature.isSignature(signature$1, [1, 0])) {
			throw (new Error('signature was created by too old ' +
			    'a version of sshpk and cannot be verified'));

		} else {
			throw (new TypeError('signature must be a string, ' +
			    'Buffer, or Signature object'));
		}
	};
	return (v);
};

Key.prototype.createDiffieHellman = function () {
	if (this.type === 'rsa')
		throw (new Error('RSA keys do not support Diffie-Hellman'));

	return (new DiffieHellman(this));
};
Key.prototype.createDH = Key.prototype.createDiffieHellman;

Key.parse = function (data, format, options) {
	if (typeof (data) !== 'string')
		assert_1.buffer(data, 'data');
	if (format === undefined)
		format = 'auto';
	assert_1.string(format, 'format');
	if (typeof (options) === 'string')
		options = { filename: options };
	assert_1.optionalObject(options, 'options');
	if (options === undefined)
		options = {};
	assert_1.optionalString(options.filename, 'options.filename');
	if (options.filename === undefined)
		options.filename = '(unnamed)';

	assert_1.object(formats$2[format], 'formats[format]');

	try {
		var k = formats$2[format].read(data, options);
		if (k instanceof PrivateKey$1)
			k = k.toPublic();
		if (!k.comment)
			k.comment = options.filename;
		return (k);
	} catch (e) {
		if (e.name === 'KeyEncryptedError')
			throw (e);
		throw (new KeyParseError(options.filename, format, e));
	}
};

Key.isKey = function (obj, ver) {
	return (utils$2.isCompatible(obj, Key, ver));
};

/*
 * API versions for Key:
 * [1,0] -- initial ver, may take Signature for createVerify or may not
 * [1,1] -- added pkcs1, pkcs8 formats
 * [1,2] -- added auto, ssh-private, openssh formats
 * [1,3] -- added defaultHashAlgorithm
 * [1,4] -- added ed support, createDH
 * [1,5] -- first explicitly tagged version
 * [1,6] -- changed ed25519 part names
 * [1,7] -- spki hash types
 */
Key.prototype._sshpkApiVersion = [1, 7];

Key._oldVersionDetect = function (obj) {
	assert_1.func(obj.toBuffer);
	assert_1.func(obj.fingerprint);
	if (obj.createDH)
		return ([1, 4]);
	if (obj.defaultHashAlgorithm)
		return ([1, 3]);
	if (obj.formats['auto'])
		return ([1, 2]);
	if (obj.formats['pkcs1'])
		return ([1, 1]);
	return ([1, 0]);
};

// Copyright 2015 Joyent, Inc.









var lib$e = {
	/* top-level classes */
	Key: Key$1,
	parseKey: Key$1.parse,
	Fingerprint: Fingerprint$1,
	parseFingerprint: Fingerprint$1.parse,
	Signature: signature,
	parseSignature: signature.parse,
	PrivateKey: PrivateKey$1,
	parsePrivateKey: PrivateKey$1.parse,
	generatePrivateKey: PrivateKey$1.generate,
	Certificate: Certificate$1,
	parseCertificate: Certificate$1.parse,
	createSelfSignedCertificate: Certificate$1.createSelfSigned,
	createCertificate: Certificate$1.create,
	Identity: identity,
	identityFromDN: identity.parseDN,
	identityForHost: identity.forHost,
	identityForUser: identity.forUser,
	identityForEmail: identity.forEmail,
	identityFromArray: identity.fromArray,

	/* errors */
	FingerprintFormatError: errors$1.FingerprintFormatError,
	InvalidAlgorithmError: errors$1.InvalidAlgorithmError,
	KeyParseError: errors$1.KeyParseError,
	SignatureParseError: errors$1.SignatureParseError,
	KeyEncryptedError: errors$1.KeyEncryptedError,
	CertificateParseError: errors$1.CertificateParseError
};

// Copyright 2012 Joyent, Inc.  All rights reserved.





var HASH_ALGOS$1 = {
  'sha1': true,
  'sha256': true,
  'sha512': true
};

var PK_ALGOS$1 = {
  'rsa': true,
  'dsa': true,
  'ecdsa': true
};

function HttpSignatureError$2(message, caller) {
  if (Error.captureStackTrace)
    Error.captureStackTrace(this, caller || HttpSignatureError$2);

  this.message = message;
  this.name = caller.name;
}
util$2.inherits(HttpSignatureError$2, Error);

function InvalidAlgorithmError$2(message) {
  HttpSignatureError$2.call(this, message, InvalidAlgorithmError$2);
}
util$2.inherits(InvalidAlgorithmError$2, HttpSignatureError$2);

function validateAlgorithm$3(algorithm) {
  var alg = algorithm.toLowerCase().split('-');

  if (alg.length !== 2) {
    throw (new InvalidAlgorithmError$2(alg[0].toUpperCase() + ' is not a ' +
      'valid algorithm'));
  }

  if (alg[0] !== 'hmac' && !PK_ALGOS$1[alg[0]]) {
    throw (new InvalidAlgorithmError$2(alg[0].toUpperCase() + ' type keys ' +
      'are not supported'));
  }

  if (!HASH_ALGOS$1[alg[1]]) {
    throw (new InvalidAlgorithmError$2(alg[1].toUpperCase() + ' is not a ' +
      'supported hash algorithm'));
  }

  return (alg);
}

///--- API

var utils$1 = {

  HASH_ALGOS: HASH_ALGOS$1,
  PK_ALGOS: PK_ALGOS$1,

  HttpSignatureError: HttpSignatureError$2,
  InvalidAlgorithmError: InvalidAlgorithmError$2,

  validateAlgorithm: validateAlgorithm$3,

  /**
   * Converts an OpenSSH public key (rsa only) to a PKCS#8 PEM file.
   *
   * The intent of this module is to interoperate with OpenSSL only,
   * specifically the node crypto module's `verify` method.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} PEM encoded form of the RSA public key.
   * @throws {TypeError} on bad input.
   * @throws {Error} on invalid ssh key formatted data.
   */
  sshKeyToPEM: function sshKeyToPEM(key) {
    assert_1.string(key, 'ssh_key');

    var k = lib$e.parseKey(key, 'ssh');
    return (k.toString('pem'));
  },


  /**
   * Generates an OpenSSH fingerprint from an ssh public key.
   *
   * @param {String} key an OpenSSH public key.
   * @return {String} key fingerprint.
   * @throws {TypeError} on bad input.
   * @throws {Error} if what you passed doesn't look like an ssh public key.
   */
  fingerprint: function fingerprint(key) {
    assert_1.string(key, 'ssh_key');

    var k = lib$e.parseKey(key, 'ssh');
    return (k.fingerprint('md5').toString('hex'));
  },

  /**
   * Converts a PKGCS#8 PEM file to an OpenSSH public key (rsa)
   *
   * The reverse of the above function.
   */
  pemToRsaSSHKey: function pemToRsaSSHKey(pem, comment) {
    assert_1.equal('string', typeof (pem), 'typeof pem');

    var k = lib$e.parseKey(pem, 'pem');
    k.comment = comment;
    return (k.toString('ssh'));
  }
};

var HttpSignatureError$1 = utils$1.HttpSignatureError;
var InvalidAlgorithmError$1 = utils$1.InvalidAlgorithmError;
var validateAlgorithm$2 = utils$1.validateAlgorithm;

var State = {
  New: 0,
  Params: 1
};

var ParamsState = {
  Name: 0,
  Quote: 1,
  Value: 2,
  Comma: 3
};


///--- Specific Errors


function ExpiredRequestError(message) {
  HttpSignatureError$1.call(this, message, ExpiredRequestError);
}
util$2.inherits(ExpiredRequestError, HttpSignatureError$1);


function InvalidHeaderError(message) {
  HttpSignatureError$1.call(this, message, InvalidHeaderError);
}
util$2.inherits(InvalidHeaderError, HttpSignatureError$1);


function InvalidParamsError(message) {
  HttpSignatureError$1.call(this, message, InvalidParamsError);
}
util$2.inherits(InvalidParamsError, HttpSignatureError$1);


function MissingHeaderError$1(message) {
  HttpSignatureError$1.call(this, message, MissingHeaderError$1);
}
util$2.inherits(MissingHeaderError$1, HttpSignatureError$1);

function StrictParsingError$1(message) {
  HttpSignatureError$1.call(this, message, StrictParsingError$1);
}
util$2.inherits(StrictParsingError$1, HttpSignatureError$1);

///--- Exported API

var parser = {

  /**
   * Parses the 'Authorization' header out of an http.ServerRequest object.
   *
   * Note that this API will fully validate the Authorization header, and throw
   * on any error.  It will not however check the signature, or the keyId format
   * as those are specific to your environment.  You can use the options object
   * to pass in extra constraints.
   *
   * As a response object you can expect this:
   *
   *     {
   *       "scheme": "Signature",
   *       "params": {
   *         "keyId": "foo",
   *         "algorithm": "rsa-sha256",
   *         "headers": [
   *           "date" or "x-date",
   *           "digest"
   *         ],
   *         "signature": "base64"
   *       },
   *       "signingString": "ready to be passed to crypto.verify()"
   *     }
   *
   * @param {Object} request an http.ServerRequest.
   * @param {Object} options an optional options object with:
   *                   - clockSkew: allowed clock skew in seconds (default 300).
   *                   - headers: required header names (def: date or x-date)
   *                   - algorithms: algorithms to support (default: all).
   *                   - strict: should enforce latest spec parsing
   *                             (default: false).
   * @return {Object} parsed out object (see above).
   * @throws {TypeError} on invalid input.
   * @throws {InvalidHeaderError} on an invalid Authorization header error.
   * @throws {InvalidParamsError} if the params in the scheme are invalid.
   * @throws {MissingHeaderError} if the params indicate a header not present,
   *                              either in the request headers from the params,
   *                              or not in the params from a required header
   *                              in options.
   * @throws {StrictParsingError} if old attributes are used in strict parsing
   *                              mode.
   * @throws {ExpiredRequestError} if the value of date or x-date exceeds skew.
   */
  parseRequest: function parseRequest(request, options) {
    assert_1.object(request, 'request');
    assert_1.object(request.headers, 'request.headers');
    if (options === undefined) {
      options = {};
    }
    if (options.headers === undefined) {
      options.headers = [request.headers['x-date'] ? 'x-date' : 'date'];
    }
    assert_1.object(options, 'options');
    assert_1.arrayOfString(options.headers, 'options.headers');
    assert_1.optionalFinite(options.clockSkew, 'options.clockSkew');

    var authzHeaderName = options.authorizationHeaderName || 'authorization';

    if (!request.headers[authzHeaderName]) {
      throw new MissingHeaderError$1('no ' + authzHeaderName + ' header ' +
                                   'present in the request');
    }

    options.clockSkew = options.clockSkew || 300;


    var i = 0;
    var state = State.New;
    var substate = ParamsState.Name;
    var tmpName = '';
    var tmpValue = '';

    var parsed = {
      scheme: '',
      params: {},
      signingString: ''
    };

    var authz = request.headers[authzHeaderName];
    for (i = 0; i < authz.length; i++) {
      var c = authz.charAt(i);

      switch (Number(state)) {

      case State.New:
        if (c !== ' ') parsed.scheme += c;
        else state = State.Params;
        break;

      case State.Params:
        switch (Number(substate)) {

        case ParamsState.Name:
          var code = c.charCodeAt(0);
          // restricted name of A-Z / a-z
          if ((code >= 0x41 && code <= 0x5a) || // A-Z
              (code >= 0x61 && code <= 0x7a)) { // a-z
            tmpName += c;
          } else if (c === '=') {
            if (tmpName.length === 0)
              throw new InvalidHeaderError('bad param format');
            substate = ParamsState.Quote;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Quote:
          if (c === '"') {
            tmpValue = '';
            substate = ParamsState.Value;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        case ParamsState.Value:
          if (c === '"') {
            parsed.params[tmpName] = tmpValue;
            substate = ParamsState.Comma;
          } else {
            tmpValue += c;
          }
          break;

        case ParamsState.Comma:
          if (c === ',') {
            tmpName = '';
            substate = ParamsState.Name;
          } else {
            throw new InvalidHeaderError('bad param format');
          }
          break;

        default:
          throw new Error('Invalid substate');
        }
        break;

      default:
        throw new Error('Invalid substate');
      }

    }

    if (!parsed.params.headers || parsed.params.headers === '') {
      if (request.headers['x-date']) {
        parsed.params.headers = ['x-date'];
      } else {
        parsed.params.headers = ['date'];
      }
    } else {
      parsed.params.headers = parsed.params.headers.split(' ');
    }

    // Minimally validate the parsed object
    if (!parsed.scheme || parsed.scheme !== 'Signature')
      throw new InvalidHeaderError('scheme was not "Signature"');

    if (!parsed.params.keyId)
      throw new InvalidHeaderError('keyId was not specified');

    if (!parsed.params.algorithm)
      throw new InvalidHeaderError('algorithm was not specified');

    if (!parsed.params.signature)
      throw new InvalidHeaderError('signature was not specified');

    // Check the algorithm against the official list
    parsed.params.algorithm = parsed.params.algorithm.toLowerCase();
    try {
      validateAlgorithm$2(parsed.params.algorithm);
    } catch (e) {
      if (e instanceof InvalidAlgorithmError$1)
        throw (new InvalidParamsError(parsed.params.algorithm + ' is not ' +
          'supported'));
      else
        throw (e);
    }

    // Build the signingString
    for (i = 0; i < parsed.params.headers.length; i++) {
      var h = parsed.params.headers[i].toLowerCase();
      parsed.params.headers[i] = h;

      if (h === 'request-line') {
        if (!options.strict) {
          /*
           * We allow headers from the older spec drafts if strict parsing isn't
           * specified in options.
           */
          parsed.signingString +=
            request.method + ' ' + request.url + ' HTTP/' + request.httpVersion;
        } else {
          /* Strict parsing doesn't allow older draft headers. */
          throw (new StrictParsingError$1('request-line is not a valid header ' +
            'with strict parsing enabled.'));
        }
      } else if (h === '(request-target)') {
        parsed.signingString +=
          '(request-target): ' + request.method.toLowerCase() + ' ' +
          request.url;
      } else {
        var value = request.headers[h];
        if (value === undefined)
          throw new MissingHeaderError$1(h + ' was not in the request');
        parsed.signingString += h + ': ' + value;
      }

      if ((i + 1) < parsed.params.headers.length)
        parsed.signingString += '\n';
    }

    // Check against the constraints
    var date;
    if (request.headers.date || request.headers['x-date']) {
        if (request.headers['x-date']) {
          date = new Date(request.headers['x-date']);
        } else {
          date = new Date(request.headers.date);
        }
      var now = new Date();
      var skew = Math.abs(now.getTime() - date.getTime());

      if (skew > options.clockSkew * 1000) {
        throw new ExpiredRequestError('clock skew of ' +
                                      (skew / 1000) +
                                      's was greater than ' +
                                      options.clockSkew + 's');
      }
    }

    options.headers.forEach(function (hdr) {
      // Remember that we already checked any headers in the params
      // were in the request, so if this passes we're good.
      if (parsed.params.headers.indexOf(hdr.toLowerCase()) < 0)
        throw new MissingHeaderError$1(hdr + ' was not a signed header');
    });

    if (options.algorithms) {
      if (options.algorithms.indexOf(parsed.params.algorithm) === -1)
        throw new InvalidParamsError(parsed.params.algorithm +
                                     ' is not a supported algorithm');
    }

    parsed.algorithm = parsed.params.algorithm.toUpperCase();
    parsed.keyId = parsed.params.keyId;
    return parsed;
  }

};

/*
 * extsprintf.js: extended POSIX-style sprintf
 */

/*
 * Public interface
 */
var sprintf$2 = jsSprintf;
var printf = jsPrintf;
var fprintf = jsFprintf;

/*
 * Stripped down version of s[n]printf(3c).  We make a best effort to throw an
 * exception when given a format string we don't understand, rather than
 * ignoring it, so that we won't break existing programs if/when we go implement
 * the rest of this.
 *
 * This implementation currently supports specifying
 *	- field alignment ('-' flag),
 * 	- zero-pad ('0' flag)
 *	- always show numeric sign ('+' flag),
 *	- field width
 *	- conversions for strings, decimal integers, and floats (numbers).
 *	- argument size specifiers.  These are all accepted but ignored, since
 *	  Javascript has no notion of the physical size of an argument.
 *
 * Everything else is currently unsupported, most notably precision, unsigned
 * numbers, non-decimal numbers, and characters.
 */
function jsSprintf(fmt)
{
	var regex = [
	    '([^%]*)',				/* normal text */
	    '%',				/* start of format */
	    '([\'\\-+ #0]*?)',			/* flags (optional) */
	    '([1-9]\\d*)?',			/* width (optional) */
	    '(\\.([1-9]\\d*))?',		/* precision (optional) */
	    '[lhjztL]*?',			/* length mods (ignored) */
	    '([diouxXfFeEgGaAcCsSp%jr])'	/* conversion */
	].join('');

	var re = new RegExp(regex);
	var args = Array.prototype.slice.call(arguments, 1);
	var flags, width, precision, conversion;
	var left, pad, sign, arg, match;
	var ret = '';
	var argn = 1;

	assert.equal('string', typeof (fmt));

	while ((match = re.exec(fmt)) !== null) {
		ret += match[1];
		fmt = fmt.substring(match[0].length);

		flags = match[2] || '';
		width = match[3] || 0;
		precision = match[4] || '';
		conversion = match[6];
		left = false;
		sign = false;
		pad = ' ';

		if (conversion == '%') {
			ret += '%';
			continue;
		}

		if (args.length === 0)
			throw (new Error('too few args to sprintf'));

		arg = args.shift();
		argn++;

		if (flags.match(/[\' #]/))
			throw (new Error(
			    'unsupported flags: ' + flags));

		if (precision.length > 0)
			throw (new Error(
			    'non-zero precision not supported'));

		if (flags.match(/-/))
			left = true;

		if (flags.match(/0/))
			pad = '0';

		if (flags.match(/\+/))
			sign = true;

		switch (conversion) {
		case 's':
			if (arg === undefined || arg === null)
				throw (new Error('argument ' + argn +
				    ': attempted to print undefined or null ' +
				    'as a string'));
			ret += doPad(pad, width, left, arg.toString());
			break;

		case 'd':
			arg = Math.floor(arg);
			/*jsl:fallthru*/
		case 'f':
			sign = sign && arg > 0 ? '+' : '';
			ret += sign + doPad(pad, width, left,
			    arg.toString());
			break;

		case 'x':
			ret += doPad(pad, width, left, arg.toString(16));
			break;

		case 'j': /* non-standard */
			if (width === 0)
				width = 10;
			ret += util$2.inspect(arg, false, width);
			break;

		case 'r': /* non-standard */
			ret += dumpException(arg);
			break;

		default:
			throw (new Error('unsupported conversion: ' +
			    conversion));
		}
	}

	ret += fmt;
	return (ret);
}

function jsPrintf() {
	var args = Array.prototype.slice.call(arguments);
	args.unshift(process.stdout);
	jsFprintf.apply(null, args);
}

function jsFprintf(stream) {
	var args = Array.prototype.slice.call(arguments, 1);
	return (stream.write(jsSprintf.apply(this, args)));
}

function doPad(chr, width, left, str)
{
	var ret = str;

	while (ret.length < width) {
		if (left)
			ret += chr;
		else
			ret = chr + ret;
	}

	return (ret);
}

/*
 * This function dumps long stack traces for exceptions having a cause() method.
 * See node-verror for an example.
 */
function dumpException(ex)
{
	var ret;

	if (!(ex instanceof Error))
		throw (new Error(jsSprintf('invalid type for %%r: %j', ex)));

	/* Note that V8 prepends "ex.stack" with ex.toString(). */
	ret = 'EXCEPTION: ' + ex.constructor.name + ': ' + ex.stack;

	if (ex.cause && typeof (ex.cause) === 'function') {
		var cex = ex.cause();
		if (cex) {
			ret += '\nCaused by: ' + dumpException(cex);
		}
	}

	return (ret);
}

var extsprintf = {
	sprintf: sprintf$2,
	printf: printf,
	fprintf: fprintf
};

// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// NOTE: These type checking functions intentionally don't use `instanceof`
// because it is fragile and can be easily faked with `Object.create()`.

function isArray(arg) {
  if (Array.isArray) {
    return Array.isArray(arg);
  }
  return objectToString(arg) === '[object Array]';
}
var isArray_1 = isArray;

function isBoolean(arg) {
  return typeof arg === 'boolean';
}
var isBoolean_1 = isBoolean;

function isNull(arg) {
  return arg === null;
}
var isNull_1 = isNull;

function isNullOrUndefined(arg) {
  return arg == null;
}
var isNullOrUndefined_1 = isNullOrUndefined;

function isNumber(arg) {
  return typeof arg === 'number';
}
var isNumber_1 = isNumber;

function isString(arg) {
  return typeof arg === 'string';
}
var isString_1 = isString;

function isSymbol(arg) {
  return typeof arg === 'symbol';
}
var isSymbol_1 = isSymbol;

function isUndefined(arg) {
  return arg === void 0;
}
var isUndefined_1 = isUndefined;

function isRegExp$1(re) {
  return objectToString(re) === '[object RegExp]';
}
var isRegExp_1 = isRegExp$1;

function isObject(arg) {
  return typeof arg === 'object' && arg !== null;
}
var isObject_1 = isObject;

function isDate(d) {
  return objectToString(d) === '[object Date]';
}
var isDate_1 = isDate;

function isError(e) {
  return (objectToString(e) === '[object Error]' || e instanceof Error);
}
var isError_1 = isError;

function isFunction(arg) {
  return typeof arg === 'function';
}
var isFunction_1 = isFunction;

function isPrimitive(arg) {
  return arg === null ||
         typeof arg === 'boolean' ||
         typeof arg === 'number' ||
         typeof arg === 'string' ||
         typeof arg === 'symbol' ||  // ES6 symbol
         typeof arg === 'undefined';
}
var isPrimitive_1 = isPrimitive;

var isBuffer$1 = Buffer.isBuffer;

function objectToString(o) {
  return Object.prototype.toString.call(o);
}

var util$1 = {
	isArray: isArray_1,
	isBoolean: isBoolean_1,
	isNull: isNull_1,
	isNullOrUndefined: isNullOrUndefined_1,
	isNumber: isNumber_1,
	isString: isString_1,
	isSymbol: isSymbol_1,
	isUndefined: isUndefined_1,
	isRegExp: isRegExp_1,
	isObject: isObject_1,
	isDate: isDate_1,
	isError: isError_1,
	isFunction: isFunction_1,
	isPrimitive: isPrimitive_1,
	isBuffer: isBuffer$1
};

/*
 * verror.js: richer JavaScript errors
 */

var mod_isError = util$1.isError;
var sprintf$1 = extsprintf.sprintf;

/*
 * Public interface
 */

/* So you can 'var VError = require('verror')' */
var verror = VError;
/* For compatibility */
VError.VError = VError;
/* Other exported classes */
VError.SError = SError;
VError.WError = WError;
VError.MultiError = MultiError;

/*
 * Common function used to parse constructor arguments for VError, WError, and
 * SError.  Named arguments to this function:
 *
 *     strict		force strict interpretation of sprintf arguments, even
 *     			if the options in "argv" don't say so
 *
 *     argv		error's constructor arguments, which are to be
 *     			interpreted as described in README.md.  For quick
 *     			reference, "argv" has one of the following forms:
 *
 *          [ sprintf_args... ]           (argv[0] is a string)
 *          [ cause, sprintf_args... ]    (argv[0] is an Error)
 *          [ options, sprintf_args... ]  (argv[0] is an object)
 *
 * This function normalizes these forms, producing an object with the following
 * properties:
 *
 *    options           equivalent to "options" in third form.  This will never
 *    			be a direct reference to what the caller passed in
 *    			(i.e., it may be a shallow copy), so it can be freely
 *    			modified.
 *
 *    shortmessage      result of sprintf(sprintf_args), taking options.strict
 *    			into account as described in README.md.
 */
function parseConstructorArguments(args)
{
	var argv, options, sprintf_args, shortmessage, k;

	assert_1.object(args, 'args');
	assert_1.bool(args.strict, 'args.strict');
	assert_1.array(args.argv, 'args.argv');
	argv = args.argv;

	/*
	 * First, figure out which form of invocation we've been given.
	 */
	if (argv.length === 0) {
		options = {};
		sprintf_args = [];
	} else if (mod_isError(argv[0])) {
		options = { 'cause': argv[0] };
		sprintf_args = argv.slice(1);
	} else if (typeof (argv[0]) === 'object') {
		options = {};
		for (k in argv[0]) {
			options[k] = argv[0][k];
		}
		sprintf_args = argv.slice(1);
	} else {
		assert_1.string(argv[0],
		    'first argument to VError, SError, or WError ' +
		    'constructor must be a string, object, or Error');
		options = {};
		sprintf_args = argv;
	}

	/*
	 * Now construct the error's message.
	 *
	 * extsprintf (which we invoke here with our caller's arguments in order
	 * to construct this Error's message) is strict in its interpretation of
	 * values to be processed by the "%s" specifier.  The value passed to
	 * extsprintf must actually be a string or something convertible to a
	 * String using .toString().  Passing other values (notably "null" and
	 * "undefined") is considered a programmer error.  The assumption is
	 * that if you actually want to print the string "null" or "undefined",
	 * then that's easy to do that when you're calling extsprintf; on the
	 * other hand, if you did NOT want that (i.e., there's actually a bug
	 * where the program assumes some variable is non-null and tries to
	 * print it, which might happen when constructing a packet or file in
	 * some specific format), then it's better to stop immediately than
	 * produce bogus output.
	 *
	 * However, sometimes the bug is only in the code calling VError, and a
	 * programmer might prefer to have the error message contain "null" or
	 * "undefined" rather than have the bug in the error path crash the
	 * program (making the first bug harder to identify).  For that reason,
	 * by default VError converts "null" or "undefined" arguments to their
	 * string representations and passes those to extsprintf.  Programmers
	 * desiring the strict behavior can use the SError class or pass the
	 * "strict" option to the VError constructor.
	 */
	assert_1.object(options);
	if (!options.strict && !args.strict) {
		sprintf_args = sprintf_args.map(function (a) {
			return (a === null ? 'null' :
			    a === undefined ? 'undefined' : a);
		});
	}

	if (sprintf_args.length === 0) {
		shortmessage = '';
	} else {
		shortmessage = sprintf$1.apply(null, sprintf_args);
	}

	return ({
	    'options': options,
	    'shortmessage': shortmessage
	});
}

/*
 * See README.md for reference documentation.
 */
function VError()
{
	var args, obj, parsed, cause, ctor, message, k;

	args = Array.prototype.slice.call(arguments, 0);

	/*
	 * This is a regrettable pattern, but JavaScript's built-in Error class
	 * is defined to work this way, so we allow the constructor to be called
	 * without "new".
	 */
	if (!(this instanceof VError)) {
		obj = Object.create(VError.prototype);
		VError.apply(obj, arguments);
		return (obj);
	}

	/*
	 * For convenience and backwards compatibility, we support several
	 * different calling forms.  Normalize them here.
	 */
	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});

	/*
	 * If we've been given a name, apply it now.
	 */
	if (parsed.options.name) {
		assert_1.string(parsed.options.name,
		    'error\'s "name" must be a string');
		this.name = parsed.options.name;
	}

	/*
	 * For debugging, we keep track of the original short message (attached
	 * this Error particularly) separately from the complete message (which
	 * includes the messages of our cause chain).
	 */
	this.jse_shortmsg = parsed.shortmessage;
	message = parsed.shortmessage;

	/*
	 * If we've been given a cause, record a reference to it and update our
	 * message appropriately.
	 */
	cause = parsed.options.cause;
	if (cause) {
		assert_1.ok(mod_isError(cause), 'cause is not an Error');
		this.jse_cause = cause;

		if (!parsed.options.skipCauseMessage) {
			message += ': ' + cause.message;
		}
	}

	/*
	 * If we've been given an object with properties, shallow-copy that
	 * here.  We don't want to use a deep copy in case there are non-plain
	 * objects here, but we don't want to use the original object in case
	 * the caller modifies it later.
	 */
	this.jse_info = {};
	if (parsed.options.info) {
		for (k in parsed.options.info) {
			this.jse_info[k] = parsed.options.info[k];
		}
	}

	this.message = message;
	Error.call(this, message);

	if (Error.captureStackTrace) {
		ctor = parsed.options.constructorOpt || this.constructor;
		Error.captureStackTrace(this, ctor);
	}

	return (this);
}

util$2.inherits(VError, Error);
VError.prototype.name = 'VError';

VError.prototype.toString = function ve_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;

	return (str);
};

/*
 * This method is provided for compatibility.  New callers should use
 * VError.cause() instead.  That method also uses the saner `null` return value
 * when there is no cause.
 */
VError.prototype.cause = function ve_cause()
{
	var cause = VError.cause(this);
	return (cause === null ? undefined : cause);
};

/*
 * Static methods
 *
 * These class-level methods are provided so that callers can use them on
 * instances of Errors that are not VErrors.  New interfaces should be provided
 * only using static methods to eliminate the class of programming mistake where
 * people fail to check whether the Error object has the corresponding methods.
 */

VError.cause = function (err)
{
	assert_1.ok(mod_isError(err), 'err must be an Error');
	return (mod_isError(err.jse_cause) ? err.jse_cause : null);
};

VError.info = function (err)
{
	var rv, cause, k;

	assert_1.ok(mod_isError(err), 'err must be an Error');
	cause = VError.cause(err);
	if (cause !== null) {
		rv = VError.info(cause);
	} else {
		rv = {};
	}

	if (typeof (err.jse_info) == 'object' && err.jse_info !== null) {
		for (k in err.jse_info) {
			rv[k] = err.jse_info[k];
		}
	}

	return (rv);
};

VError.findCauseByName = function (err, name)
{
	var cause;

	assert_1.ok(mod_isError(err), 'err must be an Error');
	assert_1.string(name, 'name');
	assert_1.ok(name.length > 0, 'name cannot be empty');

	for (cause = err; cause !== null; cause = VError.cause(cause)) {
		assert_1.ok(mod_isError(cause));
		if (cause.name == name) {
			return (cause);
		}
	}

	return (null);
};

VError.hasCauseWithName = function (err, name)
{
	return (VError.findCauseByName(err, name) !== null);
};

VError.fullStack = function (err)
{
	assert_1.ok(mod_isError(err), 'err must be an Error');

	var cause = VError.cause(err);

	if (cause) {
		return (err.stack + '\ncaused by: ' + VError.fullStack(cause));
	}

	return (err.stack);
};

VError.errorFromList = function (errors)
{
	assert_1.arrayOfObject(errors, 'errors');

	if (errors.length === 0) {
		return (null);
	}

	errors.forEach(function (e) {
		assert_1.ok(mod_isError(e));
	});

	if (errors.length == 1) {
		return (errors[0]);
	}

	return (new MultiError(errors));
};

VError.errorForEach = function (err, func)
{
	assert_1.ok(mod_isError(err), 'err must be an Error');
	assert_1.func(func, 'func');

	if (err instanceof MultiError) {
		err.errors().forEach(function iterError(e) { func(e); });
	} else {
		func(err);
	}
};


/*
 * SError is like VError, but stricter about types.  You cannot pass "null" or
 * "undefined" as string arguments to the formatter.
 */
function SError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof SError)) {
		obj = Object.create(SError.prototype);
		SError.apply(obj, arguments);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': true
	});

	options = parsed.options;
	VError.call(this, options, '%s', parsed.shortmessage);

	return (this);
}

/*
 * We don't bother setting SError.prototype.name because once constructed,
 * SErrors are just like VErrors.
 */
util$2.inherits(SError, VError);


/*
 * Represents a collection of errors for the purpose of consumers that generally
 * only deal with one error.  Callers can extract the individual errors
 * contained in this object, but may also just treat it as a normal single
 * error, in which case a summary message will be printed.
 */
function MultiError(errors)
{
	assert_1.array(errors, 'list of errors');
	assert_1.ok(errors.length > 0, 'must be at least one error');
	this.ase_errors = errors;

	VError.call(this, {
	    'cause': errors[0]
	}, 'first of %d error%s', errors.length, errors.length == 1 ? '' : 's');
}

util$2.inherits(MultiError, VError);
MultiError.prototype.name = 'MultiError';

MultiError.prototype.errors = function me_errors()
{
	return (this.ase_errors.slice(0));
};


/*
 * See README.md for reference details.
 */
function WError()
{
	var args, obj, parsed, options;

	args = Array.prototype.slice.call(arguments, 0);
	if (!(this instanceof WError)) {
		obj = Object.create(WError.prototype);
		WError.apply(obj, args);
		return (obj);
	}

	parsed = parseConstructorArguments({
	    'argv': args,
	    'strict': false
	});

	options = parsed.options;
	options['skipCauseMessage'] = true;
	VError.call(this, options, '%s', parsed.shortmessage);

	return (this);
}

util$2.inherits(WError, VError);
WError.prototype.name = 'WError';

WError.prototype.toString = function we_toString()
{
	var str = (this.hasOwnProperty('name') && this.name ||
		this.constructor.name || this.constructor.prototype.name);
	if (this.message)
		str += ': ' + this.message;
	if (this.jse_cause && this.jse_cause.message)
		str += '; caused by ' + this.jse_cause.toString();

	return (str);
};

/*
 * For purely historical reasons, WError's cause() function allows you to set
 * the cause.
 */
WError.prototype.cause = function we_cause(c)
{
	if (mod_isError(c))
		this.jse_cause = c;

	return (this.jse_cause);
};

/**
 * JSONSchema Validator - Validates JavaScript objects using JSON Schemas
 *	(http://www.json.com/json-schema-proposal/)
 *
 * Copyright (c) 2007 Kris Zyp SitePen (www.sitepen.com)
 * Licensed under the MIT (MIT-LICENSE.txt) license.
To use the validator call the validate function with an instance object and an optional schema object.
If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
that schema will be used to validate and the schema parameter is not necessary (if both exist,
both validations will occur).
The validate method will return an array of validation errors. If there are no errors, then an
empty list will be returned. A validation error will have two properties:
"property" which indicates which property had the error
"message" which indicates what the error was
 */

var validate$3 = createCommonjsModule(function (module) {
(function (root, factory) {
    if (module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
    } else {
        // Browser globals
        root.jsonSchema = factory();
    }
}(commonjsGlobal, function () {// setup primitive classes to be JSON Schema types
var exports = validate;
exports.Integer = {type:"integer"};
var primitiveConstructors = {
	String: String,
	Boolean: Boolean,
	Number: Number,
	Object: Object,
	Array: Array,
	Date: Date
};
exports.validate = validate;
function validate(/*Any*/instance,/*Object*/schema) {
		// Summary:
		//  	To use the validator call JSONSchema.validate with an instance object and an optional schema object.
		// 		If a schema is provided, it will be used to validate. If the instance object refers to a schema (self-validating),
		// 		that schema will be used to validate and the schema parameter is not necessary (if both exist,
		// 		both validations will occur).
		// 		The validate method will return an object with two properties:
		// 			valid: A boolean indicating if the instance is valid by the schema
		// 			errors: An array of validation errors. If there are no errors, then an
		// 					empty list will be returned. A validation error will have two properties:
		// 						property: which indicates which property had the error
		// 						message: which indicates what the error was
		//
		return validate(instance, schema, {changing: false});//, coerce: false, existingOnly: false});
	}exports.checkPropertyChange = function(/*Any*/value,/*Object*/schema, /*String*/property) {
		// Summary:
		// 		The checkPropertyChange method will check to see if an value can legally be in property with the given schema
		// 		This is slightly different than the validate method in that it will fail if the schema is readonly and it will
		// 		not check for self-validation, it is assumed that the passed in value is already internally valid.
		// 		The checkPropertyChange method will return the same object type as validate, see JSONSchema.validate for
		// 		information.
		//
		return validate(value, schema, {changing: property || "property"});
	};
var validate = exports._validate = function(/*Any*/instance,/*Object*/schema,/*Object*/options) {

	if (!options) options = {};
	var _changing = options.changing;

	function getType(schema){
		return schema.type || (primitiveConstructors[schema.name] == schema && schema.name.toLowerCase());
	}
	var errors = [];
	// validate a value against a property definition
	function checkProp(value, schema, path,i){

		var l;
		path += path ? typeof i == 'number' ? '[' + i + ']' : typeof i == 'undefined' ? '' : '.' + i : i;
		function addError(message){
			errors.push({property:path,message:message});
		}

		if((typeof schema != 'object' || schema instanceof Array) && (path || typeof schema != 'function') && !(schema && getType(schema))){
			if(typeof schema == 'function'){
				if(!(value instanceof schema)){
					addError("is not an instance of the class/constructor " + schema.name);
				}
			}else if(schema){
				addError("Invalid schema/property definition " + schema);
			}
			return null;
		}
		if(_changing && schema.readonly){
			addError("is a readonly field, it can not be changed");
		}
		if(schema['extends']){ // if it extends another schema, it must pass that schema as well
			checkProp(value,schema['extends'],path,i);
		}
		// validate a value against a type definition
		function checkType(type,value){
			if(type){
				if(typeof type == 'string' && type != 'any' &&
						(type == 'null' ? value !== null : typeof value != type) &&
						!(value instanceof Array && type == 'array') &&
						!(value instanceof Date && type == 'date') &&
						!(type == 'integer' && value%1===0)){
					return [{property:path,message:(typeof value) + " value found, but a " + type + " is required"}];
				}
				if(type instanceof Array){
					var unionErrors=[];
					for(var j = 0; j < type.length; j++){ // a union type
						if(!(unionErrors=checkType(type[j],value)).length){
							break;
						}
					}
					if(unionErrors.length){
						return unionErrors;
					}
				}else if(typeof type == 'object'){
					var priorErrors = errors;
					errors = [];
					checkProp(value,type,path);
					var theseErrors = errors;
					errors = priorErrors;
					return theseErrors;
				}
			}
			return [];
		}
		if(value === undefined){
			if(schema.required){
				addError("is missing and it is required");
			}
		}else {
			errors = errors.concat(checkType(getType(schema),value));
			if(schema.disallow && !checkType(schema.disallow,value).length){
				addError(" disallowed value was matched");
			}
			if(value !== null){
				if(value instanceof Array){
					if(schema.items){
						var itemsIsArray = schema.items instanceof Array;
						var propDef = schema.items;
						for (i = 0, l = value.length; i < l; i += 1) {
							if (itemsIsArray)
								propDef = schema.items[i];
							if (options.coerce)
								value[i] = options.coerce(value[i], propDef);
							errors.concat(checkProp(value[i],propDef,path,i));
						}
					}
					if(schema.minItems && value.length < schema.minItems){
						addError("There must be a minimum of " + schema.minItems + " in the array");
					}
					if(schema.maxItems && value.length > schema.maxItems){
						addError("There must be a maximum of " + schema.maxItems + " in the array");
					}
				}else if(schema.properties || schema.additionalProperties){
					errors.concat(checkObj(value, schema.properties, path, schema.additionalProperties));
				}
				if(schema.pattern && typeof value == 'string' && !value.match(schema.pattern)){
					addError("does not match the regex pattern " + schema.pattern);
				}
				if(schema.maxLength && typeof value == 'string' && value.length > schema.maxLength){
					addError("may only be " + schema.maxLength + " characters long");
				}
				if(schema.minLength && typeof value == 'string' && value.length < schema.minLength){
					addError("must be at least " + schema.minLength + " characters long");
				}
				if(typeof schema.minimum !== undefined && typeof value == typeof schema.minimum &&
						schema.minimum > value){
					addError("must have a minimum value of " + schema.minimum);
				}
				if(typeof schema.maximum !== undefined && typeof value == typeof schema.maximum &&
						schema.maximum < value){
					addError("must have a maximum value of " + schema.maximum);
				}
				if(schema['enum']){
					var enumer = schema['enum'];
					l = enumer.length;
					var found;
					for(var j = 0; j < l; j++){
						if(enumer[j]===value){
							found=1;
							break;
						}
					}
					if(!found){
						addError("does not have a value in the enumeration " + enumer.join(", "));
					}
				}
				if(typeof schema.maxDecimal == 'number' &&
					(value.toString().match(new RegExp("\\.[0-9]{" + (schema.maxDecimal + 1) + ",}")))){
					addError("may only have " + schema.maxDecimal + " digits of decimal places");
				}
			}
		}
		return null;
	}
	// validate an object against a schema
	function checkObj(instance,objTypeDef,path,additionalProp){

		if(typeof objTypeDef =='object'){
			if(typeof instance != 'object' || instance instanceof Array){
				errors.push({property:path,message:"an object is required"});
			}
			
			for(var i in objTypeDef){ 
				if(objTypeDef.hasOwnProperty(i)){
					var value = instance[i];
					// skip _not_ specified properties
					if (value === undefined && options.existingOnly) continue;
					var propDef = objTypeDef[i];
					// set default
					if(value === undefined && propDef["default"]){
						value = instance[i] = propDef["default"];
					}
					if(options.coerce && i in instance){
						value = instance[i] = options.coerce(value, propDef);
					}
					checkProp(value,propDef,path,i);
				}
			}
		}
		for(i in instance){
			if(instance.hasOwnProperty(i) && !(i.charAt(0) == '_' && i.charAt(1) == '_') && objTypeDef && !objTypeDef[i] && additionalProp===false){
				if (options.filter) {
					delete instance[i];
					continue;
				} else {
					errors.push({property:path,message:(typeof value) + "The property " + i +
						" is not defined in the schema and the schema does not allow additional properties"});
				}
			}
			var requires = objTypeDef && objTypeDef[i] && objTypeDef[i].requires;
			if(requires && !(requires in instance)){
				errors.push({property:path,message:"the presence of the property " + i + " requires that " + requires + " also be present"});
			}
			value = instance[i];
			if(additionalProp && (!(objTypeDef && typeof objTypeDef == 'object') || !(i in objTypeDef))){
				if(options.coerce){
					value = instance[i] = options.coerce(value, additionalProp);
				}
				checkProp(value,additionalProp,path,i);
			}
			if(!_changing && value && value.$schema){
				errors = errors.concat(checkProp(value,value.$schema,path,i));
			}
		}
		return errors;
	}
	if(schema){
		checkProp(instance,schema,'',_changing || '');
	}
	if(!_changing && instance && instance.$schema){
		checkProp(instance,instance.$schema,'','');
	}
	return {valid:!errors.length,errors:errors};
};
exports.mustBeValid = function(result){
	//	summary:
	//		This checks to ensure that the result is valid and will throw an appropriate error message if it is not
	// result: the result returned from checkPropertyChange or validate
	if(!result.valid){
		throw new TypeError(result.errors.map(function(error){return "for property " + error.property + ': ' + error.message;}).join(", \n"));
	}
};

return exports;
}));
});

/*
 * lib/jsprim.js: utilities for primitive JavaScript types
 */

/*
 * Public interface
 */
var deepCopy_1 = deepCopy;
var deepEqual_1 = deepEqual;
var isEmpty_1 = isEmpty;
var hasKey_1 = hasKey;
var forEachKey_1 = forEachKey;
var pluck_1 = pluck;
var flattenObject_1 = flattenObject;
var flattenIter_1 = flattenIter;
var validateJsonObject = validateJsonObjectJS;
var validateJsonObjectJS_1 = validateJsonObjectJS;
var randElt_1 = randElt;
var extraProperties_1 = extraProperties;
var mergeObjects_1 = mergeObjects;

var startsWith_1 = startsWith;
var endsWith_1 = endsWith;

var parseInteger_1 = parseInteger;

var iso8601_1 = iso8601;
var rfc1123_1 = rfc1123;
var parseDateTime_1 = parseDateTime;

var hrtimediff = hrtimeDiff;
var hrtimeDiff_1 = hrtimeDiff;
var hrtimeAccum_1 = hrtimeAccum;
var hrtimeAdd_1 = hrtimeAdd;
var hrtimeNanosec_1 = hrtimeNanosec;
var hrtimeMicrosec_1 = hrtimeMicrosec;
var hrtimeMillisec_1 = hrtimeMillisec;


/*
 * Deep copy an acyclic *basic* Javascript object.  This only handles basic
 * scalars (strings, numbers, booleans) and arbitrarily deep arrays and objects
 * containing these.  This does *not* handle instances of other classes.
 */
function deepCopy(obj)
{
	var ret, key;
	var marker = '__deepCopy';

	if (obj && obj[marker])
		throw (new Error('attempted deep copy of cyclic object'));

	if (obj && obj.constructor == Object) {
		ret = {};
		obj[marker] = true;

		for (key in obj) {
			if (key == marker)
				continue;

			ret[key] = deepCopy(obj[key]);
		}

		delete (obj[marker]);
		return (ret);
	}

	if (obj && obj.constructor == Array) {
		ret = [];
		obj[marker] = true;

		for (key = 0; key < obj.length; key++)
			ret.push(deepCopy(obj[key]));

		delete (obj[marker]);
		return (ret);
	}

	/*
	 * It must be a primitive type -- just return it.
	 */
	return (obj);
}

function deepEqual(obj1, obj2)
{
	if (typeof (obj1) != typeof (obj2))
		return (false);

	if (obj1 === null || obj2 === null || typeof (obj1) != 'object')
		return (obj1 === obj2);

	if (obj1.constructor != obj2.constructor)
		return (false);

	var k;
	for (k in obj1) {
		if (!obj2.hasOwnProperty(k))
			return (false);

		if (!deepEqual(obj1[k], obj2[k]))
			return (false);
	}

	for (k in obj2) {
		if (!obj1.hasOwnProperty(k))
			return (false);
	}

	return (true);
}

function isEmpty(obj)
{
	var key;
	for (key in obj)
		return (false);
	return (true);
}

function hasKey(obj, key)
{
	assert_1.equal(typeof (key), 'string');
	return (Object.prototype.hasOwnProperty.call(obj, key));
}

function forEachKey(obj, callback)
{
	for (var key in obj) {
		if (hasKey(obj, key)) {
			callback(key, obj[key]);
		}
	}
}

function pluck(obj, key)
{
	assert_1.equal(typeof (key), 'string');
	return (pluckv(obj, key));
}

function pluckv(obj, key)
{
	if (obj === null || typeof (obj) !== 'object')
		return (undefined);

	if (obj.hasOwnProperty(key))
		return (obj[key]);

	var i = key.indexOf('.');
	if (i == -1)
		return (undefined);

	var key1 = key.substr(0, i);
	if (!obj.hasOwnProperty(key1))
		return (undefined);

	return (pluckv(obj[key1], key.substr(i + 1)));
}

/*
 * Invoke callback(row) for each entry in the array that would be returned by
 * flattenObject(data, depth).  This is just like flattenObject(data,
 * depth).forEach(callback), except that the intermediate array is never
 * created.
 */
function flattenIter(data, depth, callback)
{
	doFlattenIter(data, depth, [], callback);
}

function doFlattenIter(data, depth, accum, callback)
{
	var each;
	var key;

	if (depth === 0) {
		each = accum.slice(0);
		each.push(data);
		callback(each);
		return;
	}

	assert_1.ok(data !== null);
	assert_1.equal(typeof (data), 'object');
	assert_1.equal(typeof (depth), 'number');
	assert_1.ok(depth >= 0);

	for (key in data) {
		each = accum.slice(0);
		each.push(key);
		doFlattenIter(data[key], depth - 1, each, callback);
	}
}

function flattenObject(data, depth)
{
	if (depth === 0)
		return ([ data ]);

	assert_1.ok(data !== null);
	assert_1.equal(typeof (data), 'object');
	assert_1.equal(typeof (depth), 'number');
	assert_1.ok(depth >= 0);

	var rv = [];
	var key;

	for (key in data) {
		flattenObject(data[key], depth - 1).forEach(function (p) {
			rv.push([ key ].concat(p));
		});
	}

	return (rv);
}

function startsWith(str, prefix)
{
	return (str.substr(0, prefix.length) == prefix);
}

function endsWith(str, suffix)
{
	return (str.substr(
	    str.length - suffix.length, suffix.length) == suffix);
}

function iso8601(d)
{
	if (typeof (d) == 'number')
		d = new Date(d);
	assert_1.ok(d.constructor === Date);
	return (extsprintf.sprintf('%4d-%02d-%02dT%02d:%02d:%02d.%03dZ',
	    d.getUTCFullYear(), d.getUTCMonth() + 1, d.getUTCDate(),
	    d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(),
	    d.getUTCMilliseconds()));
}

var RFC1123_MONTHS = [
    'Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun',
    'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
var RFC1123_DAYS = [
    'Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];

function rfc1123(date) {
	return (extsprintf.sprintf('%s, %02d %s %04d %02d:%02d:%02d GMT',
	    RFC1123_DAYS[date.getUTCDay()], date.getUTCDate(),
	    RFC1123_MONTHS[date.getUTCMonth()], date.getUTCFullYear(),
	    date.getUTCHours(), date.getUTCMinutes(),
	    date.getUTCSeconds()));
}

/*
 * Parses a date expressed as a string, as either a number of milliseconds since
 * the epoch or any string format that Date accepts, giving preference to the
 * former where these two sets overlap (e.g., small numbers).
 */
function parseDateTime(str)
{
	/*
	 * This is irritatingly implicit, but significantly more concise than
	 * alternatives.  The "+str" will convert a string containing only a
	 * number directly to a Number, or NaN for other strings.  Thus, if the
	 * conversion succeeds, we use it (this is the milliseconds-since-epoch
	 * case).  Otherwise, we pass the string directly to the Date
	 * constructor to parse.
	 */
	var numeric = +str;
	if (!isNaN(numeric)) {
		return (new Date(numeric));
	} else {
		return (new Date(str));
	}
}


/*
 * Number.*_SAFE_INTEGER isn't present before node v0.12, so we hardcode
 * the ES6 definitions here, while allowing for them to someday be higher.
 */
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || 9007199254740991;
var MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -9007199254740991;


/*
 * Default options for parseInteger().
 */
var PI_DEFAULTS = {
	base: 10,
	allowSign: true,
	allowPrefix: false,
	allowTrailing: false,
	allowImprecise: false,
	trimWhitespace: false,
	leadingZeroIsOctal: false
};

var CP_0 = 0x30;
var CP_9 = 0x39;

var CP_A = 0x41;
var CP_B = 0x42;
var CP_O = 0x4f;
var CP_T = 0x54;
var CP_X = 0x58;
var CP_Z = 0x5a;

var CP_a = 0x61;
var CP_b = 0x62;
var CP_o = 0x6f;
var CP_t = 0x74;
var CP_x = 0x78;
var CP_z = 0x7a;

var PI_CONV_DEC = 0x30;
var PI_CONV_UC = 0x37;
var PI_CONV_LC = 0x57;


/*
 * A stricter version of parseInt() that provides options for changing what
 * is an acceptable string (for example, disallowing trailing characters).
 */
function parseInteger(str, uopts)
{
	assert_1.string(str, 'str');
	assert_1.optionalObject(uopts, 'options');

	var baseOverride = false;
	var options = PI_DEFAULTS;

	if (uopts) {
		baseOverride = hasKey(uopts, 'base');
		options = mergeObjects(options, uopts);
		assert_1.number(options.base, 'options.base');
		assert_1.ok(options.base >= 2, 'options.base >= 2');
		assert_1.ok(options.base <= 36, 'options.base <= 36');
		assert_1.bool(options.allowSign, 'options.allowSign');
		assert_1.bool(options.allowPrefix, 'options.allowPrefix');
		assert_1.bool(options.allowTrailing,
		    'options.allowTrailing');
		assert_1.bool(options.allowImprecise,
		    'options.allowImprecise');
		assert_1.bool(options.trimWhitespace,
		    'options.trimWhitespace');
		assert_1.bool(options.leadingZeroIsOctal,
		    'options.leadingZeroIsOctal');

		if (options.leadingZeroIsOctal) {
			assert_1.ok(!baseOverride,
			    '"base" and "leadingZeroIsOctal" are ' +
			    'mutually exclusive');
		}
	}

	var c;
	var pbase = -1;
	var base = options.base;
	var start;
	var mult = 1;
	var value = 0;
	var idx = 0;
	var len = str.length;

	/* Trim any whitespace on the left side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check the number for a leading sign. */
	if (options.allowSign) {
		if (str[idx] === '-') {
			idx += 1;
			mult = -1;
		} else if (str[idx] === '+') {
			idx += 1;
		}
	}

	/* Parse the base-indicating prefix if there is one. */
	if (str[idx] === '0') {
		if (options.allowPrefix) {
			pbase = prefixToBase(str.charCodeAt(idx + 1));
			if (pbase !== -1 && (!baseOverride || pbase === base)) {
				base = pbase;
				idx += 2;
			}
		}

		if (pbase === -1 && options.leadingZeroIsOctal) {
			base = 8;
		}
	}

	/* Parse the actual digits. */
	for (start = idx; idx < len; ++idx) {
		c = translateDigit(str.charCodeAt(idx));
		if (c !== -1 && c < base) {
			value *= base;
			value += c;
		} else {
			break;
		}
	}

	/* If we didn't parse any digits, we have an invalid number. */
	if (start === idx) {
		return (new Error('invalid number: ' + JSON.stringify(str)));
	}

	/* Trim any whitespace on the right side. */
	if (options.trimWhitespace) {
		while (idx < len && isSpace(str.charCodeAt(idx))) {
			++idx;
		}
	}

	/* Check for trailing characters. */
	if (idx < len && !options.allowTrailing) {
		return (new Error('trailing characters after number: ' +
		    JSON.stringify(str.slice(idx))));
	}

	/* If our value is 0, we return now, to avoid returning -0. */
	if (value === 0) {
		return (0);
	}

	/* Calculate our final value. */
	var result = value * mult;

	/*
	 * If the string represents a value that cannot be precisely represented
	 * by JavaScript, then we want to check that:
	 *
	 * - We never increased the value past MAX_SAFE_INTEGER
	 * - We don't make the result negative and below MIN_SAFE_INTEGER
	 *
	 * Because we only ever increment the value during parsing, there's no
	 * chance of moving past MAX_SAFE_INTEGER and then dropping below it
	 * again, losing precision in the process. This means that we only need
	 * to do our checks here, at the end.
	 */
	if (!options.allowImprecise &&
	    (value > MAX_SAFE_INTEGER || result < MIN_SAFE_INTEGER)) {
		return (new Error('number is outside of the supported range: ' +
		    JSON.stringify(str.slice(start, idx))));
	}

	return (result);
}


/*
 * Interpret a character code as a base-36 digit.
 */
function translateDigit(d)
{
	if (d >= CP_0 && d <= CP_9) {
		/* '0' to '9' -> 0 to 9 */
		return (d - PI_CONV_DEC);
	} else if (d >= CP_A && d <= CP_Z) {
		/* 'A' - 'Z' -> 10 to 35 */
		return (d - PI_CONV_UC);
	} else if (d >= CP_a && d <= CP_z) {
		/* 'a' - 'z' -> 10 to 35 */
		return (d - PI_CONV_LC);
	} else {
		/* Invalid character code */
		return (-1);
	}
}


/*
 * Test if a value matches the ECMAScript definition of trimmable whitespace.
 */
function isSpace(c)
{
	return (c === 0x20) ||
	    (c >= 0x0009 && c <= 0x000d) ||
	    (c === 0x00a0) ||
	    (c === 0x1680) ||
	    (c === 0x180e) ||
	    (c >= 0x2000 && c <= 0x200a) ||
	    (c === 0x2028) ||
	    (c === 0x2029) ||
	    (c === 0x202f) ||
	    (c === 0x205f) ||
	    (c === 0x3000) ||
	    (c === 0xfeff);
}


/*
 * Determine which base a character indicates (e.g., 'x' indicates hex).
 */
function prefixToBase(c)
{
	if (c === CP_b || c === CP_B) {
		/* 0b/0B (binary) */
		return (2);
	} else if (c === CP_o || c === CP_O) {
		/* 0o/0O (octal) */
		return (8);
	} else if (c === CP_t || c === CP_T) {
		/* 0t/0T (decimal) */
		return (10);
	} else if (c === CP_x || c === CP_X) {
		/* 0x/0X (hexadecimal) */
		return (16);
	} else {
		/* Not a meaningful character */
		return (-1);
	}
}


function validateJsonObjectJS(schema, input)
{
	var report = validate$3.validate(input, schema);

	if (report.errors.length === 0)
		return (null);

	/* Currently, we only do anything useful with the first error. */
	var error = report.errors[0];

	/* The failed property is given by a URI with an irrelevant prefix. */
	var propname = error['property'];
	var reason = error['message'].toLowerCase();
	var i, j;

	/*
	 * There's at least one case where the property error message is
	 * confusing at best.  We work around this here.
	 */
	if ((i = reason.indexOf('the property ')) != -1 &&
	    (j = reason.indexOf(' is not defined in the schema and the ' +
	    'schema does not allow additional properties')) != -1) {
		i += 'the property '.length;
		if (propname === '')
			propname = reason.substr(i, j - i);
		else
			propname = propname + '.' + reason.substr(i, j - i);

		reason = 'unsupported property';
	}

	var rv = new verror.VError('property "%s": %s', propname, reason);
	rv.jsv_details = error;
	return (rv);
}

function randElt(arr)
{
	assert_1.ok(Array.isArray(arr) && arr.length > 0,
	    'randElt argument must be a non-empty array');

	return (arr[Math.floor(Math.random() * arr.length)]);
}

function assertHrtime(a)
{
	assert_1.ok(a[0] >= 0 && a[1] >= 0,
	    'negative numbers not allowed in hrtimes');
	assert_1.ok(a[1] < 1e9, 'nanoseconds column overflow');
}

/*
 * Compute the time elapsed between hrtime readings A and B, where A is later
 * than B.  hrtime readings come from Node's process.hrtime().  There is no
 * defined way to represent negative deltas, so it's illegal to diff B from A
 * where the time denoted by B is later than the time denoted by A.  If this
 * becomes valuable, we can define a representation and extend the
 * implementation to support it.
 */
function hrtimeDiff(a, b)
{
	assertHrtime(a);
	assertHrtime(b);
	assert_1.ok(a[0] > b[0] || (a[0] == b[0] && a[1] >= b[1]),
	    'negative differences not allowed');

	var rv = [ a[0] - b[0], 0 ];

	if (a[1] >= b[1]) {
		rv[1] = a[1] - b[1];
	} else {
		rv[0]--;
		rv[1] = 1e9 - (b[1] - a[1]);
	}

	return (rv);
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of nanoseconds.
 */
function hrtimeNanosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e9 + a[1]));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of microseconds.
 */
function hrtimeMicrosec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e6 + a[1] / 1e3));
}

/*
 * Convert a hrtime reading from the array format returned by Node's
 * process.hrtime() into a scalar number of milliseconds.
 */
function hrtimeMillisec(a)
{
	assertHrtime(a);

	return (Math.floor(a[0] * 1e3 + a[1] / 1e6));
}

/*
 * Add two hrtime readings A and B, overwriting A with the result of the
 * addition.  This function is useful for accumulating several hrtime intervals
 * into a counter.  Returns A.
 */
function hrtimeAccum(a, b)
{
	assertHrtime(a);
	assertHrtime(b);

	/*
	 * Accumulate the nanosecond component.
	 */
	a[1] += b[1];
	if (a[1] >= 1e9) {
		/*
		 * The nanosecond component overflowed, so carry to the seconds
		 * field.
		 */
		a[0]++;
		a[1] -= 1e9;
	}

	/*
	 * Accumulate the seconds component.
	 */
	a[0] += b[0];

	return (a);
}

/*
 * Add two hrtime readings A and B, returning the result as a new hrtime array.
 * Does not modify either input argument.
 */
function hrtimeAdd(a, b)
{
	assertHrtime(a);

	var rv = [ a[0], a[1] ];

	return (hrtimeAccum(rv, b));
}


/*
 * Check an object for unexpected properties.  Accepts the object to check, and
 * an array of allowed property names (strings).  Returns an array of key names
 * that were found on the object, but did not appear in the list of allowed
 * properties.  If no properties were found, the returned array will be of
 * zero length.
 */
function extraProperties(obj, allowed)
{
	assert_1.ok(typeof (obj) === 'object' && obj !== null,
	    'obj argument must be a non-null object');
	assert_1.ok(Array.isArray(allowed),
	    'allowed argument must be an array of strings');
	for (var i = 0; i < allowed.length; i++) {
		assert_1.ok(typeof (allowed[i]) === 'string',
		    'allowed argument must be an array of strings');
	}

	return (Object.keys(obj).filter(function (key) {
		return (allowed.indexOf(key) === -1);
	}));
}

/*
 * Given three sets of properties "provided" (may be undefined), "overrides"
 * (required), and "defaults" (may be undefined), construct an object containing
 * the union of these sets with "overrides" overriding "provided", and
 * "provided" overriding "defaults".  None of the input objects are modified.
 */
function mergeObjects(provided, overrides, defaults)
{
	var rv, k;

	rv = {};
	if (defaults) {
		for (k in defaults)
			rv[k] = defaults[k];
	}

	if (provided) {
		for (k in provided)
			rv[k] = provided[k];
	}

	if (overrides) {
		for (k in overrides)
			rv[k] = overrides[k];
	}

	return (rv);
}

var jsprim = {
	deepCopy: deepCopy_1,
	deepEqual: deepEqual_1,
	isEmpty: isEmpty_1,
	hasKey: hasKey_1,
	forEachKey: forEachKey_1,
	pluck: pluck_1,
	flattenObject: flattenObject_1,
	flattenIter: flattenIter_1,
	validateJsonObject: validateJsonObject,
	validateJsonObjectJS: validateJsonObjectJS_1,
	randElt: randElt_1,
	extraProperties: extraProperties_1,
	mergeObjects: mergeObjects_1,
	startsWith: startsWith_1,
	endsWith: endsWith_1,
	parseInteger: parseInteger_1,
	iso8601: iso8601_1,
	rfc1123: rfc1123_1,
	parseDateTime: parseDateTime_1,
	hrtimediff: hrtimediff,
	hrtimeDiff: hrtimeDiff_1,
	hrtimeAccum: hrtimeAccum_1,
	hrtimeAdd: hrtimeAdd_1,
	hrtimeNanosec: hrtimeNanosec_1,
	hrtimeMicrosec: hrtimeMicrosec_1,
	hrtimeMillisec: hrtimeMillisec_1
};

// Copyright 2012 Joyent, Inc.  All rights reserved.









var sprintf = util$2.format;

var HASH_ALGOS = utils$1.HASH_ALGOS;
var PK_ALGOS = utils$1.PK_ALGOS;
var InvalidAlgorithmError = utils$1.InvalidAlgorithmError;
var HttpSignatureError = utils$1.HttpSignatureError;
var validateAlgorithm$1 = utils$1.validateAlgorithm;

///--- Globals

var AUTHZ_FMT =
  'Signature keyId="%s",algorithm="%s",headers="%s",signature="%s"';

///--- Specific Errors

function MissingHeaderError(message) {
  HttpSignatureError.call(this, message, MissingHeaderError);
}
util$2.inherits(MissingHeaderError, HttpSignatureError);

function StrictParsingError(message) {
  HttpSignatureError.call(this, message, StrictParsingError);
}
util$2.inherits(StrictParsingError, HttpSignatureError);

/* See createSigner() */
function RequestSigner(options) {
  assert_1.object(options, 'options');

  var alg = [];
  if (options.algorithm !== undefined) {
    assert_1.string(options.algorithm, 'options.algorithm');
    alg = validateAlgorithm$1(options.algorithm);
  }
  this.rs_alg = alg;

  /*
   * RequestSigners come in two varieties: ones with an rs_signFunc, and ones
   * with an rs_signer.
   *
   * rs_signFunc-based RequestSigners have to build up their entire signing
   * string within the rs_lines array and give it to rs_signFunc as a single
   * concat'd blob. rs_signer-based RequestSigners can add a line at a time to
   * their signing state by using rs_signer.update(), thus only needing to
   * buffer the hash function state and one line at a time.
   */
  if (options.sign !== undefined) {
    assert_1.func(options.sign, 'options.sign');
    this.rs_signFunc = options.sign;

  } else if (alg[0] === 'hmac' && options.key !== undefined) {
    assert_1.string(options.keyId, 'options.keyId');
    this.rs_keyId = options.keyId;

    if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
      throw (new TypeError('options.key for HMAC must be a string or Buffer'));

    /*
     * Make an rs_signer for HMACs, not a rs_signFunc -- HMACs digest their
     * data in chunks rather than requiring it all to be given in one go
     * at the end, so they are more similar to signers than signFuncs.
     */
    this.rs_signer = crypto$1.createHmac(alg[1].toUpperCase(), options.key);
    this.rs_signer.sign = function () {
      var digest = this.digest('base64');
      return ({
        hashAlgorithm: alg[1],
        toString: function () { return (digest); }
      });
    };

  } else if (options.key !== undefined) {
    var key = options.key;
    if (typeof (key) === 'string' || Buffer.isBuffer(key))
      key = lib$e.parsePrivateKey(key);

    assert_1.ok(lib$e.PrivateKey.isPrivateKey(key, [1, 2]),
      'options.key must be a sshpk.PrivateKey');
    this.rs_key = key;

    assert_1.string(options.keyId, 'options.keyId');
    this.rs_keyId = options.keyId;

    if (!PK_ALGOS[key.type]) {
      throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
        'keys are not supported'));
    }

    if (alg[0] !== undefined && key.type !== alg[0]) {
      throw (new InvalidAlgorithmError('options.key must be a ' +
        alg[0].toUpperCase() + ' key, was given a ' +
        key.type.toUpperCase() + ' key instead'));
    }

    this.rs_signer = key.createSign(alg[1]);

  } else {
    throw (new TypeError('options.sign (func) or options.key is required'));
  }

  this.rs_headers = [];
  this.rs_lines = [];
}

/**
 * Adds a header to be signed, with its value, into this signer.
 *
 * @param {String} header
 * @param {String} value
 * @return {String} value written
 */
RequestSigner.prototype.writeHeader = function (header, value) {
  assert_1.string(header, 'header');
  header = header.toLowerCase();
  assert_1.string(value, 'value');

  this.rs_headers.push(header);

  if (this.rs_signFunc) {
    this.rs_lines.push(header + ': ' + value);

  } else {
    var line = header + ': ' + value;
    if (this.rs_headers.length > 0)
      line = '\n' + line;
    this.rs_signer.update(line);
  }

  return (value);
};

/**
 * Adds a default Date header, returning its value.
 *
 * @return {String}
 */
RequestSigner.prototype.writeDateHeader = function () {
  return (this.writeHeader('date', jsprim.rfc1123(new Date())));
};

/**
 * Adds the request target line to be signed.
 *
 * @param {String} method, HTTP method (e.g. 'get', 'post', 'put')
 * @param {String} path
 */
RequestSigner.prototype.writeTarget = function (method, path) {
  assert_1.string(method, 'method');
  assert_1.string(path, 'path');
  method = method.toLowerCase();
  this.writeHeader('(request-target)', method + ' ' + path);
};

/**
 * Calculate the value for the Authorization header on this request
 * asynchronously.
 *
 * @param {Func} callback (err, authz)
 */
RequestSigner.prototype.sign = function (cb) {
  assert_1.func(cb, 'callback');

  if (this.rs_headers.length < 1)
    throw (new Error('At least one header must be signed'));

  var alg, authz;
  if (this.rs_signFunc) {
    var data = this.rs_lines.join('\n');
    var self = this;
    this.rs_signFunc(data, function (err, sig) {
      if (err) {
        cb(err);
        return;
      }
      try {
        assert_1.object(sig, 'signature');
        assert_1.string(sig.keyId, 'signature.keyId');
        assert_1.string(sig.algorithm, 'signature.algorithm');
        assert_1.string(sig.signature, 'signature.signature');
        alg = validateAlgorithm$1(sig.algorithm);

        authz = sprintf(AUTHZ_FMT,
          sig.keyId,
          sig.algorithm,
          self.rs_headers.join(' '),
          sig.signature);
      } catch (e) {
        cb(e);
        return;
      }
      cb(null, authz);
    });

  } else {
    try {
      var sigObj = this.rs_signer.sign();
    } catch (e) {
      cb(e);
      return;
    }
    alg = (this.rs_alg[0] || this.rs_key.type) + '-' + sigObj.hashAlgorithm;
    var signature = sigObj.toString();
    authz = sprintf(AUTHZ_FMT,
      this.rs_keyId,
      alg,
      this.rs_headers.join(' '),
      signature);
    cb(null, authz);
  }
};

///--- Exported API

var signer = {
  /**
   * Identifies whether a given object is a request signer or not.
   *
   * @param {Object} object, the object to identify
   * @returns {Boolean}
   */
  isSigner: function (obj) {
    if (typeof (obj) === 'object' && obj instanceof RequestSigner)
      return (true);
    return (false);
  },

  /**
   * Creates a request signer, used to asynchronously build a signature
   * for a request (does not have to be an http.ClientRequest).
   *
   * @param {Object} options, either:
   *                   - {String} keyId
   *                   - {String|Buffer} key
   *                   - {String} algorithm (optional, required for HMAC)
   *                 or:
   *                   - {Func} sign (data, cb)
   * @return {RequestSigner}
   */
  createSigner: function createSigner(options) {
    return (new RequestSigner(options));
  },

  /**
   * Adds an 'Authorization' header to an http.ClientRequest object.
   *
   * Note that this API will add a Date header if it's not already set. Any
   * other headers in the options.headers array MUST be present, or this
   * will throw.
   *
   * You shouldn't need to check the return type; it's just there if you want
   * to be pedantic.
   *
   * The optional flag indicates whether parsing should use strict enforcement
   * of the version draft-cavage-http-signatures-04 of the spec or beyond.
   * The default is to be loose and support
   * older versions for compatibility.
   *
   * @param {Object} request an instance of http.ClientRequest.
   * @param {Object} options signing parameters object:
   *                   - {String} keyId required.
   *                   - {String} key required (either a PEM or HMAC key).
   *                   - {Array} headers optional; defaults to ['date'].
   *                   - {String} algorithm optional (unless key is HMAC);
   *                              default is the same as the sshpk default
   *                              signing algorithm for the type of key given
   *                   - {String} httpVersion optional; defaults to '1.1'.
   *                   - {Boolean} strict optional; defaults to 'false'.
   * @return {Boolean} true if Authorization (and optionally Date) were added.
   * @throws {TypeError} on bad parameter types (input).
   * @throws {InvalidAlgorithmError} if algorithm was bad or incompatible with
   *                                 the given key.
   * @throws {sshpk.KeyParseError} if key was bad.
   * @throws {MissingHeaderError} if a header to be signed was specified but
   *                              was not present.
   */
  signRequest: function signRequest(request, options) {
    assert_1.object(request, 'request');
    assert_1.object(options, 'options');
    assert_1.optionalString(options.algorithm, 'options.algorithm');
    assert_1.string(options.keyId, 'options.keyId');
    assert_1.optionalArrayOfString(options.headers, 'options.headers');
    assert_1.optionalString(options.httpVersion, 'options.httpVersion');

    if (!request.getHeader('Date'))
      request.setHeader('Date', jsprim.rfc1123(new Date()));
    if (!options.headers)
      options.headers = ['date'];
    if (!options.httpVersion)
      options.httpVersion = '1.1';

    var alg = [];
    if (options.algorithm) {
      options.algorithm = options.algorithm.toLowerCase();
      alg = validateAlgorithm$1(options.algorithm);
    }

    var i;
    var stringToSign = '';
    for (i = 0; i < options.headers.length; i++) {
      if (typeof (options.headers[i]) !== 'string')
        throw new TypeError('options.headers must be an array of Strings');

      var h = options.headers[i].toLowerCase();

      if (h === 'request-line') {
        if (!options.strict) {
          /**
           * We allow headers from the older spec drafts if strict parsing isn't
           * specified in options.
           */
          stringToSign +=
            request.method + ' ' + request.path + ' HTTP/' +
            options.httpVersion;
        } else {
          /* Strict parsing doesn't allow older draft headers. */
          throw (new StrictParsingError('request-line is not a valid header ' +
            'with strict parsing enabled.'));
        }
      } else if (h === '(request-target)') {
        stringToSign +=
          '(request-target): ' + request.method.toLowerCase() + ' ' +
          request.path;
      } else {
        var value = request.getHeader(h);
        if (value === undefined || value === '') {
          throw new MissingHeaderError(h + ' was not in the request');
        }
        stringToSign += h + ': ' + value;
      }

      if ((i + 1) < options.headers.length)
        stringToSign += '\n';
    }

    /* This is just for unit tests. */
    if (request.hasOwnProperty('_stringToSign')) {
      request._stringToSign = stringToSign;
    }

    var signature;
    if (alg[0] === 'hmac') {
      if (typeof (options.key) !== 'string' && !Buffer.isBuffer(options.key))
        throw (new TypeError('options.key must be a string or Buffer'));

      var hmac = crypto$1.createHmac(alg[1].toUpperCase(), options.key);
      hmac.update(stringToSign);
      signature = hmac.digest('base64');

    } else {
      var key = options.key;
      if (typeof (key) === 'string' || Buffer.isBuffer(key))
        key = lib$e.parsePrivateKey(options.key);

      assert_1.ok(lib$e.PrivateKey.isPrivateKey(key, [1, 2]),
        'options.key must be a sshpk.PrivateKey');

      if (!PK_ALGOS[key.type]) {
        throw (new InvalidAlgorithmError(key.type.toUpperCase() + ' type ' +
          'keys are not supported'));
      }

      if (alg[0] !== undefined && key.type !== alg[0]) {
        throw (new InvalidAlgorithmError('options.key must be a ' +
          alg[0].toUpperCase() + ' key, was given a ' +
          key.type.toUpperCase() + ' key instead'));
      }

      var signer = key.createSign(alg[1]);
      signer.update(stringToSign);
      var sigObj = signer.sign();
      if (!HASH_ALGOS[sigObj.hashAlgorithm]) {
        throw (new InvalidAlgorithmError(sigObj.hashAlgorithm.toUpperCase() +
          ' is not a supported hash algorithm'));
      }
      options.algorithm = key.type + '-' + sigObj.hashAlgorithm;
      signature = sigObj.toString();
      assert_1.notStrictEqual(signature, '', 'empty signature produced');
    }

    var authzHeaderName = options.authorizationHeaderName || 'Authorization';

    request.setHeader(authzHeaderName, sprintf(AUTHZ_FMT,
                                               options.keyId,
                                               options.algorithm,
                                               options.headers.join(' '),
                                               signature));

    return true;
  }

};

var validateAlgorithm = utils$1.validateAlgorithm;

///--- Exported API

var verify = {
  /**
   * Verify RSA/DSA signature against public key.  You are expected to pass in
   * an object that was returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} pubkey RSA/DSA private key PEM.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   * @throws {InvalidAlgorithmError}
   */
  verifySignature: function verifySignature(parsedSignature, pubkey) {
    assert_1.object(parsedSignature, 'parsedSignature');
    if (typeof (pubkey) === 'string' || Buffer.isBuffer(pubkey))
      pubkey = lib$e.parseKey(pubkey);
    assert_1.ok(lib$e.Key.isKey(pubkey, [1, 1]), 'pubkey must be a sshpk.Key');

    var alg = validateAlgorithm(parsedSignature.algorithm);
    if (alg[0] === 'hmac' || alg[0] !== pubkey.type)
      return (false);

    var v = pubkey.createVerify(alg[1]);
    v.update(parsedSignature.signingString);
    return (v.verify(parsedSignature.params.signature, 'base64'));
  },

  /**
   * Verify HMAC against shared secret.  You are expected to pass in an object
   * that was returned from `parse()`.
   *
   * @param {Object} parsedSignature the object you got from `parse`.
   * @param {String} secret HMAC shared secret.
   * @return {Boolean} true if valid, false otherwise.
   * @throws {TypeError} if you pass in bad arguments.
   * @throws {InvalidAlgorithmError}
   */
  verifyHMAC: function verifyHMAC(parsedSignature, secret) {
    assert_1.object(parsedSignature, 'parsedHMAC');
    assert_1.string(secret, 'secret');

    var alg = validateAlgorithm(parsedSignature.algorithm);
    if (alg[0] !== 'hmac')
      return (false);

    var hashAlg = alg[1].toUpperCase();

    var hmac = crypto$1.createHmac(hashAlg, secret);
    hmac.update(parsedSignature.signingString);

    /*
     * Now double-hash to avoid leaking timing information - there's
     * no easy constant-time compare in JS, so we use this approach
     * instead. See for more info:
     * https://www.isecpartners.com/blog/2011/february/double-hmac-
     * verification.aspx
     */
    var h1 = crypto$1.createHmac(hashAlg, secret);
    h1.update(hmac.digest());
    h1 = h1.digest();
    var h2 = crypto$1.createHmac(hashAlg, secret);
    h2.update(new Buffer(parsedSignature.params.signature, 'base64'));
    h2 = h2.digest();

    /* Node 0.8 returns strings from .digest(). */
    if (typeof (h1) === 'string')
      return (h1 === h2);
    /* And node 0.10 lacks the .equals() method on Buffers. */
    if (Buffer.isBuffer(h1) && !h1.equals)
      return (h1.toString('binary') === h2.toString('binary'));

    return (h1.equals(h2));
  }
};

// Copyright 2015 Joyent, Inc.








///--- API

var lib$d = {

  parse: parser.parseRequest,
  parseRequest: parser.parseRequest,

  sign: signer.signRequest,
  signRequest: signer.signRequest,
  createSigner: signer.createSigner,
  isSigner: signer.isSigner,

  sshKeyToPEM: utils$1.sshKeyToPEM,
  sshKeyFingerprint: utils$1.fingerprint,
  pemToRsaSSHKey: utils$1.pemToRsaSSHKey,

  verify: verify.verifySignature,
  verifySignature: verify.verifySignature,
  verifyHMAC: verify.verifyHMAC
};

var require$$0$2 = {
	"application/1d-interleaved-parityfec": {
	source: "iana"
},
	"application/3gpdash-qoe-report+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/3gpp-ims+xml": {
	source: "iana",
	compressible: true
},
	"application/3gpphal+json": {
	source: "iana",
	compressible: true
},
	"application/3gpphalforms+json": {
	source: "iana",
	compressible: true
},
	"application/a2l": {
	source: "iana"
},
	"application/activemessage": {
	source: "iana"
},
	"application/activity+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-costmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-directory+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcost+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointcostparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointprop+json": {
	source: "iana",
	compressible: true
},
	"application/alto-endpointpropparams+json": {
	source: "iana",
	compressible: true
},
	"application/alto-error+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmap+json": {
	source: "iana",
	compressible: true
},
	"application/alto-networkmapfilter+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamcontrol+json": {
	source: "iana",
	compressible: true
},
	"application/alto-updatestreamparams+json": {
	source: "iana",
	compressible: true
},
	"application/aml": {
	source: "iana"
},
	"application/andrew-inset": {
	source: "iana",
	extensions: [
		"ez"
	]
},
	"application/applefile": {
	source: "iana"
},
	"application/applixware": {
	source: "apache",
	extensions: [
		"aw"
	]
},
	"application/atf": {
	source: "iana"
},
	"application/atfx": {
	source: "iana"
},
	"application/atom+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atom"
	]
},
	"application/atomcat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomcat"
	]
},
	"application/atomdeleted+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomdeleted"
	]
},
	"application/atomicmail": {
	source: "iana"
},
	"application/atomsvc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"atomsvc"
	]
},
	"application/atsc-dwd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dwd"
	]
},
	"application/atsc-dynamic-event-message": {
	source: "iana"
},
	"application/atsc-held+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"held"
	]
},
	"application/atsc-rdt+json": {
	source: "iana",
	compressible: true
},
	"application/atsc-rsat+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsat"
	]
},
	"application/atxml": {
	source: "iana"
},
	"application/auth-policy+xml": {
	source: "iana",
	compressible: true
},
	"application/bacnet-xdd+zip": {
	source: "iana",
	compressible: false
},
	"application/batch-smtp": {
	source: "iana"
},
	"application/bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/beep+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/calendar+json": {
	source: "iana",
	compressible: true
},
	"application/calendar+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xcs"
	]
},
	"application/call-completion": {
	source: "iana"
},
	"application/cals-1840": {
	source: "iana"
},
	"application/captive+json": {
	source: "iana",
	compressible: true
},
	"application/cbor": {
	source: "iana"
},
	"application/cbor-seq": {
	source: "iana"
},
	"application/cccex": {
	source: "iana"
},
	"application/ccmp+xml": {
	source: "iana",
	compressible: true
},
	"application/ccxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ccxml"
	]
},
	"application/cdfx+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdfx"
	]
},
	"application/cdmi-capability": {
	source: "iana",
	extensions: [
		"cdmia"
	]
},
	"application/cdmi-container": {
	source: "iana",
	extensions: [
		"cdmic"
	]
},
	"application/cdmi-domain": {
	source: "iana",
	extensions: [
		"cdmid"
	]
},
	"application/cdmi-object": {
	source: "iana",
	extensions: [
		"cdmio"
	]
},
	"application/cdmi-queue": {
	source: "iana",
	extensions: [
		"cdmiq"
	]
},
	"application/cdni": {
	source: "iana"
},
	"application/cea": {
	source: "iana"
},
	"application/cea-2018+xml": {
	source: "iana",
	compressible: true
},
	"application/cellml+xml": {
	source: "iana",
	compressible: true
},
	"application/cfw": {
	source: "iana"
},
	"application/clr": {
	source: "iana"
},
	"application/clue+xml": {
	source: "iana",
	compressible: true
},
	"application/clue_info+xml": {
	source: "iana",
	compressible: true
},
	"application/cms": {
	source: "iana"
},
	"application/cnrp+xml": {
	source: "iana",
	compressible: true
},
	"application/coap-group+json": {
	source: "iana",
	compressible: true
},
	"application/coap-payload": {
	source: "iana"
},
	"application/commonground": {
	source: "iana"
},
	"application/conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/cose": {
	source: "iana"
},
	"application/cose-key": {
	source: "iana"
},
	"application/cose-key-set": {
	source: "iana"
},
	"application/cpl+xml": {
	source: "iana",
	compressible: true
},
	"application/csrattrs": {
	source: "iana"
},
	"application/csta+xml": {
	source: "iana",
	compressible: true
},
	"application/cstadata+xml": {
	source: "iana",
	compressible: true
},
	"application/csvm+json": {
	source: "iana",
	compressible: true
},
	"application/cu-seeme": {
	source: "apache",
	extensions: [
		"cu"
	]
},
	"application/cwt": {
	source: "iana"
},
	"application/cybercash": {
	source: "iana"
},
	"application/dart": {
	compressible: true
},
	"application/dash+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpd"
	]
},
	"application/dashdelta": {
	source: "iana"
},
	"application/davmount+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"davmount"
	]
},
	"application/dca-rft": {
	source: "iana"
},
	"application/dcd": {
	source: "iana"
},
	"application/dec-dx": {
	source: "iana"
},
	"application/dialog-info+xml": {
	source: "iana",
	compressible: true
},
	"application/dicom": {
	source: "iana"
},
	"application/dicom+json": {
	source: "iana",
	compressible: true
},
	"application/dicom+xml": {
	source: "iana",
	compressible: true
},
	"application/dii": {
	source: "iana"
},
	"application/dit": {
	source: "iana"
},
	"application/dns": {
	source: "iana"
},
	"application/dns+json": {
	source: "iana",
	compressible: true
},
	"application/dns-message": {
	source: "iana"
},
	"application/docbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dbk"
	]
},
	"application/dots+cbor": {
	source: "iana"
},
	"application/dskpp+xml": {
	source: "iana",
	compressible: true
},
	"application/dssc+der": {
	source: "iana",
	extensions: [
		"dssc"
	]
},
	"application/dssc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdssc"
	]
},
	"application/dvcs": {
	source: "iana"
},
	"application/ecmascript": {
	source: "iana",
	compressible: true,
	extensions: [
		"es",
		"ecma"
	]
},
	"application/edi-consent": {
	source: "iana"
},
	"application/edi-x12": {
	source: "iana",
	compressible: false
},
	"application/edifact": {
	source: "iana",
	compressible: false
},
	"application/efi": {
	source: "iana"
},
	"application/elm+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/elm+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.cap+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/emergencycalldata.comment+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.control+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.deviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.ecall.msd": {
	source: "iana"
},
	"application/emergencycalldata.providerinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.serviceinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.subscriberinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/emergencycalldata.veds+xml": {
	source: "iana",
	compressible: true
},
	"application/emma+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emma"
	]
},
	"application/emotionml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"emotionml"
	]
},
	"application/encaprtp": {
	source: "iana"
},
	"application/epp+xml": {
	source: "iana",
	compressible: true
},
	"application/epub+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"epub"
	]
},
	"application/eshop": {
	source: "iana"
},
	"application/exi": {
	source: "iana",
	extensions: [
		"exi"
	]
},
	"application/expect-ct-report+json": {
	source: "iana",
	compressible: true
},
	"application/fastinfoset": {
	source: "iana"
},
	"application/fastsoap": {
	source: "iana"
},
	"application/fdt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fdt"
	]
},
	"application/fhir+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fhir+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/fido.trusted-apps+json": {
	compressible: true
},
	"application/fits": {
	source: "iana"
},
	"application/flexfec": {
	source: "iana"
},
	"application/font-sfnt": {
	source: "iana"
},
	"application/font-tdpfr": {
	source: "iana",
	extensions: [
		"pfr"
	]
},
	"application/font-woff": {
	source: "iana",
	compressible: false
},
	"application/framework-attributes+xml": {
	source: "iana",
	compressible: true
},
	"application/geo+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"geojson"
	]
},
	"application/geo+json-seq": {
	source: "iana"
},
	"application/geopackage+sqlite3": {
	source: "iana"
},
	"application/geoxacml+xml": {
	source: "iana",
	compressible: true
},
	"application/gltf-buffer": {
	source: "iana"
},
	"application/gml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"gml"
	]
},
	"application/gpx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"gpx"
	]
},
	"application/gxf": {
	source: "apache",
	extensions: [
		"gxf"
	]
},
	"application/gzip": {
	source: "iana",
	compressible: false,
	extensions: [
		"gz"
	]
},
	"application/h224": {
	source: "iana"
},
	"application/held+xml": {
	source: "iana",
	compressible: true
},
	"application/hjson": {
	extensions: [
		"hjson"
	]
},
	"application/http": {
	source: "iana"
},
	"application/hyperstudio": {
	source: "iana",
	extensions: [
		"stk"
	]
},
	"application/ibe-key-request+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pkg-reply+xml": {
	source: "iana",
	compressible: true
},
	"application/ibe-pp-data": {
	source: "iana"
},
	"application/iges": {
	source: "iana"
},
	"application/im-iscomposing+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/index": {
	source: "iana"
},
	"application/index.cmd": {
	source: "iana"
},
	"application/index.obj": {
	source: "iana"
},
	"application/index.response": {
	source: "iana"
},
	"application/index.vnd": {
	source: "iana"
},
	"application/inkml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ink",
		"inkml"
	]
},
	"application/iotp": {
	source: "iana"
},
	"application/ipfix": {
	source: "iana",
	extensions: [
		"ipfix"
	]
},
	"application/ipp": {
	source: "iana"
},
	"application/isup": {
	source: "iana"
},
	"application/its+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"its"
	]
},
	"application/java-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"jar",
		"war",
		"ear"
	]
},
	"application/java-serialized-object": {
	source: "apache",
	compressible: false,
	extensions: [
		"ser"
	]
},
	"application/java-vm": {
	source: "apache",
	compressible: false,
	extensions: [
		"class"
	]
},
	"application/javascript": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"js",
		"mjs"
	]
},
	"application/jf2feed+json": {
	source: "iana",
	compressible: true
},
	"application/jose": {
	source: "iana"
},
	"application/jose+json": {
	source: "iana",
	compressible: true
},
	"application/jrd+json": {
	source: "iana",
	compressible: true
},
	"application/jscalendar+json": {
	source: "iana",
	compressible: true
},
	"application/json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"json",
		"map"
	]
},
	"application/json-patch+json": {
	source: "iana",
	compressible: true
},
	"application/json-seq": {
	source: "iana"
},
	"application/json5": {
	extensions: [
		"json5"
	]
},
	"application/jsonml+json": {
	source: "apache",
	compressible: true,
	extensions: [
		"jsonml"
	]
},
	"application/jwk+json": {
	source: "iana",
	compressible: true
},
	"application/jwk-set+json": {
	source: "iana",
	compressible: true
},
	"application/jwt": {
	source: "iana"
},
	"application/kpml-request+xml": {
	source: "iana",
	compressible: true
},
	"application/kpml-response+xml": {
	source: "iana",
	compressible: true
},
	"application/ld+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"jsonld"
	]
},
	"application/lgr+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lgr"
	]
},
	"application/link-format": {
	source: "iana"
},
	"application/load-control+xml": {
	source: "iana",
	compressible: true
},
	"application/lost+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lostxml"
	]
},
	"application/lostsync+xml": {
	source: "iana",
	compressible: true
},
	"application/lpf+zip": {
	source: "iana",
	compressible: false
},
	"application/lxf": {
	source: "iana"
},
	"application/mac-binhex40": {
	source: "iana",
	extensions: [
		"hqx"
	]
},
	"application/mac-compactpro": {
	source: "apache",
	extensions: [
		"cpt"
	]
},
	"application/macwriteii": {
	source: "iana"
},
	"application/mads+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mads"
	]
},
	"application/manifest+json": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"webmanifest"
	]
},
	"application/marc": {
	source: "iana",
	extensions: [
		"mrc"
	]
},
	"application/marcxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mrcx"
	]
},
	"application/mathematica": {
	source: "iana",
	extensions: [
		"ma",
		"nb",
		"mb"
	]
},
	"application/mathml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mathml"
	]
},
	"application/mathml-content+xml": {
	source: "iana",
	compressible: true
},
	"application/mathml-presentation+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-associated-procedure-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-deregister+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-envelope+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-msk-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-protection-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-reception-report+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-register-response+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-schedule+xml": {
	source: "iana",
	compressible: true
},
	"application/mbms-user-service-description+xml": {
	source: "iana",
	compressible: true
},
	"application/mbox": {
	source: "iana",
	extensions: [
		"mbox"
	]
},
	"application/media-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/media_control+xml": {
	source: "iana",
	compressible: true
},
	"application/mediaservercontrol+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mscml"
	]
},
	"application/merge-patch+json": {
	source: "iana",
	compressible: true
},
	"application/metalink+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"metalink"
	]
},
	"application/metalink4+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"meta4"
	]
},
	"application/mets+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mets"
	]
},
	"application/mf4": {
	source: "iana"
},
	"application/mikey": {
	source: "iana"
},
	"application/mipc": {
	source: "iana"
},
	"application/missing-blocks+cbor-seq": {
	source: "iana"
},
	"application/mmt-aei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"maei"
	]
},
	"application/mmt-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musd"
	]
},
	"application/mods+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mods"
	]
},
	"application/moss-keys": {
	source: "iana"
},
	"application/moss-signature": {
	source: "iana"
},
	"application/mosskey-data": {
	source: "iana"
},
	"application/mosskey-request": {
	source: "iana"
},
	"application/mp21": {
	source: "iana",
	extensions: [
		"m21",
		"mp21"
	]
},
	"application/mp4": {
	source: "iana",
	extensions: [
		"mp4s",
		"m4p"
	]
},
	"application/mpeg4-generic": {
	source: "iana"
},
	"application/mpeg4-iod": {
	source: "iana"
},
	"application/mpeg4-iod-xmt": {
	source: "iana"
},
	"application/mrb-consumer+xml": {
	source: "iana",
	compressible: true
},
	"application/mrb-publish+xml": {
	source: "iana",
	compressible: true
},
	"application/msc-ivr+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msc-mixer+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/msword": {
	source: "iana",
	compressible: false,
	extensions: [
		"doc",
		"dot"
	]
},
	"application/mud+json": {
	source: "iana",
	compressible: true
},
	"application/multipart-core": {
	source: "iana"
},
	"application/mxf": {
	source: "iana",
	extensions: [
		"mxf"
	]
},
	"application/n-quads": {
	source: "iana",
	extensions: [
		"nq"
	]
},
	"application/n-triples": {
	source: "iana",
	extensions: [
		"nt"
	]
},
	"application/nasdata": {
	source: "iana"
},
	"application/news-checkgroups": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-groupinfo": {
	source: "iana",
	charset: "US-ASCII"
},
	"application/news-transmission": {
	source: "iana"
},
	"application/nlsml+xml": {
	source: "iana",
	compressible: true
},
	"application/node": {
	source: "iana",
	extensions: [
		"cjs"
	]
},
	"application/nss": {
	source: "iana"
},
	"application/oauth-authz-req+jwt": {
	source: "iana"
},
	"application/ocsp-request": {
	source: "iana"
},
	"application/ocsp-response": {
	source: "iana"
},
	"application/octet-stream": {
	source: "iana",
	compressible: false,
	extensions: [
		"bin",
		"dms",
		"lrf",
		"mar",
		"so",
		"dist",
		"distz",
		"pkg",
		"bpk",
		"dump",
		"elc",
		"deploy",
		"exe",
		"dll",
		"deb",
		"dmg",
		"iso",
		"img",
		"msi",
		"msp",
		"msm",
		"buffer"
	]
},
	"application/oda": {
	source: "iana",
	extensions: [
		"oda"
	]
},
	"application/odm+xml": {
	source: "iana",
	compressible: true
},
	"application/odx": {
	source: "iana"
},
	"application/oebps-package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"opf"
	]
},
	"application/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogx"
	]
},
	"application/omdoc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"omdoc"
	]
},
	"application/onenote": {
	source: "apache",
	extensions: [
		"onetoc",
		"onetoc2",
		"onetmp",
		"onepkg"
	]
},
	"application/opc-nodeset+xml": {
	source: "iana",
	compressible: true
},
	"application/oscore": {
	source: "iana"
},
	"application/oxps": {
	source: "iana",
	extensions: [
		"oxps"
	]
},
	"application/p21+zip": {
	source: "iana",
	compressible: false
},
	"application/p2p-overlay+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"relo"
	]
},
	"application/parityfec": {
	source: "iana"
},
	"application/passport": {
	source: "iana"
},
	"application/patch-ops-error+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xer"
	]
},
	"application/pdf": {
	source: "iana",
	compressible: false,
	extensions: [
		"pdf"
	]
},
	"application/pdx": {
	source: "iana"
},
	"application/pem-certificate-chain": {
	source: "iana"
},
	"application/pgp-encrypted": {
	source: "iana",
	compressible: false,
	extensions: [
		"pgp"
	]
},
	"application/pgp-keys": {
	source: "iana"
},
	"application/pgp-signature": {
	source: "iana",
	extensions: [
		"asc",
		"sig"
	]
},
	"application/pics-rules": {
	source: "apache",
	extensions: [
		"prf"
	]
},
	"application/pidf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pidf-diff+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/pkcs10": {
	source: "iana",
	extensions: [
		"p10"
	]
},
	"application/pkcs12": {
	source: "iana"
},
	"application/pkcs7-mime": {
	source: "iana",
	extensions: [
		"p7m",
		"p7c"
	]
},
	"application/pkcs7-signature": {
	source: "iana",
	extensions: [
		"p7s"
	]
},
	"application/pkcs8": {
	source: "iana",
	extensions: [
		"p8"
	]
},
	"application/pkcs8-encrypted": {
	source: "iana"
},
	"application/pkix-attr-cert": {
	source: "iana",
	extensions: [
		"ac"
	]
},
	"application/pkix-cert": {
	source: "iana",
	extensions: [
		"cer"
	]
},
	"application/pkix-crl": {
	source: "iana",
	extensions: [
		"crl"
	]
},
	"application/pkix-pkipath": {
	source: "iana",
	extensions: [
		"pkipath"
	]
},
	"application/pkixcmp": {
	source: "iana",
	extensions: [
		"pki"
	]
},
	"application/pls+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pls"
	]
},
	"application/poc-settings+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/postscript": {
	source: "iana",
	compressible: true,
	extensions: [
		"ai",
		"eps",
		"ps"
	]
},
	"application/ppsp-tracker+json": {
	source: "iana",
	compressible: true
},
	"application/problem+json": {
	source: "iana",
	compressible: true
},
	"application/problem+xml": {
	source: "iana",
	compressible: true
},
	"application/provenance+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"provx"
	]
},
	"application/prs.alvestrand.titrax-sheet": {
	source: "iana"
},
	"application/prs.cww": {
	source: "iana",
	extensions: [
		"cww"
	]
},
	"application/prs.cyn": {
	source: "iana",
	charset: "7-BIT"
},
	"application/prs.hpub+zip": {
	source: "iana",
	compressible: false
},
	"application/prs.nprend": {
	source: "iana"
},
	"application/prs.plucker": {
	source: "iana"
},
	"application/prs.rdf-xml-crypt": {
	source: "iana"
},
	"application/prs.xsf+xml": {
	source: "iana",
	compressible: true
},
	"application/pskc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"pskcxml"
	]
},
	"application/pvd+json": {
	source: "iana",
	compressible: true
},
	"application/qsig": {
	source: "iana"
},
	"application/raml+yaml": {
	compressible: true,
	extensions: [
		"raml"
	]
},
	"application/raptorfec": {
	source: "iana"
},
	"application/rdap+json": {
	source: "iana",
	compressible: true
},
	"application/rdf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rdf",
		"owl"
	]
},
	"application/reginfo+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rif"
	]
},
	"application/relax-ng-compact-syntax": {
	source: "iana",
	extensions: [
		"rnc"
	]
},
	"application/remote-printing": {
	source: "iana"
},
	"application/reputon+json": {
	source: "iana",
	compressible: true
},
	"application/resource-lists+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rl"
	]
},
	"application/resource-lists-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rld"
	]
},
	"application/rfc+xml": {
	source: "iana",
	compressible: true
},
	"application/riscos": {
	source: "iana"
},
	"application/rlmi+xml": {
	source: "iana",
	compressible: true
},
	"application/rls-services+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rs"
	]
},
	"application/route-apd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rapd"
	]
},
	"application/route-s-tsid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sls"
	]
},
	"application/route-usd+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rusd"
	]
},
	"application/rpki-ghostbusters": {
	source: "iana",
	extensions: [
		"gbr"
	]
},
	"application/rpki-manifest": {
	source: "iana",
	extensions: [
		"mft"
	]
},
	"application/rpki-publication": {
	source: "iana"
},
	"application/rpki-roa": {
	source: "iana",
	extensions: [
		"roa"
	]
},
	"application/rpki-updown": {
	source: "iana"
},
	"application/rsd+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rsd"
	]
},
	"application/rss+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"rss"
	]
},
	"application/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"application/rtploopback": {
	source: "iana"
},
	"application/rtx": {
	source: "iana"
},
	"application/samlassertion+xml": {
	source: "iana",
	compressible: true
},
	"application/samlmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/sarif+json": {
	source: "iana",
	compressible: true
},
	"application/sarif-external-properties+json": {
	source: "iana",
	compressible: true
},
	"application/sbe": {
	source: "iana"
},
	"application/sbml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sbml"
	]
},
	"application/scaip+xml": {
	source: "iana",
	compressible: true
},
	"application/scim+json": {
	source: "iana",
	compressible: true
},
	"application/scvp-cv-request": {
	source: "iana",
	extensions: [
		"scq"
	]
},
	"application/scvp-cv-response": {
	source: "iana",
	extensions: [
		"scs"
	]
},
	"application/scvp-vp-request": {
	source: "iana",
	extensions: [
		"spq"
	]
},
	"application/scvp-vp-response": {
	source: "iana",
	extensions: [
		"spp"
	]
},
	"application/sdp": {
	source: "iana",
	extensions: [
		"sdp"
	]
},
	"application/secevent+jwt": {
	source: "iana"
},
	"application/senml+cbor": {
	source: "iana"
},
	"application/senml+json": {
	source: "iana",
	compressible: true
},
	"application/senml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"senmlx"
	]
},
	"application/senml-etch+cbor": {
	source: "iana"
},
	"application/senml-etch+json": {
	source: "iana",
	compressible: true
},
	"application/senml-exi": {
	source: "iana"
},
	"application/sensml+cbor": {
	source: "iana"
},
	"application/sensml+json": {
	source: "iana",
	compressible: true
},
	"application/sensml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sensmlx"
	]
},
	"application/sensml-exi": {
	source: "iana"
},
	"application/sep+xml": {
	source: "iana",
	compressible: true
},
	"application/sep-exi": {
	source: "iana"
},
	"application/session-info": {
	source: "iana"
},
	"application/set-payment": {
	source: "iana"
},
	"application/set-payment-initiation": {
	source: "iana",
	extensions: [
		"setpay"
	]
},
	"application/set-registration": {
	source: "iana"
},
	"application/set-registration-initiation": {
	source: "iana",
	extensions: [
		"setreg"
	]
},
	"application/sgml": {
	source: "iana"
},
	"application/sgml-open-catalog": {
	source: "iana"
},
	"application/shf+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"shf"
	]
},
	"application/sieve": {
	source: "iana",
	extensions: [
		"siv",
		"sieve"
	]
},
	"application/simple-filter+xml": {
	source: "iana",
	compressible: true
},
	"application/simple-message-summary": {
	source: "iana"
},
	"application/simplesymbolcontainer": {
	source: "iana"
},
	"application/sipc": {
	source: "iana"
},
	"application/slate": {
	source: "iana"
},
	"application/smil": {
	source: "iana"
},
	"application/smil+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"smi",
		"smil"
	]
},
	"application/smpte336m": {
	source: "iana"
},
	"application/soap+fastinfoset": {
	source: "iana"
},
	"application/soap+xml": {
	source: "iana",
	compressible: true
},
	"application/sparql-query": {
	source: "iana",
	extensions: [
		"rq"
	]
},
	"application/sparql-results+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"srx"
	]
},
	"application/spirits-event+xml": {
	source: "iana",
	compressible: true
},
	"application/sql": {
	source: "iana"
},
	"application/srgs": {
	source: "iana",
	extensions: [
		"gram"
	]
},
	"application/srgs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"grxml"
	]
},
	"application/sru+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sru"
	]
},
	"application/ssdl+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ssdl"
	]
},
	"application/ssml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ssml"
	]
},
	"application/stix+json": {
	source: "iana",
	compressible: true
},
	"application/swid+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"swidtag"
	]
},
	"application/tamp-apex-update": {
	source: "iana"
},
	"application/tamp-apex-update-confirm": {
	source: "iana"
},
	"application/tamp-community-update": {
	source: "iana"
},
	"application/tamp-community-update-confirm": {
	source: "iana"
},
	"application/tamp-error": {
	source: "iana"
},
	"application/tamp-sequence-adjust": {
	source: "iana"
},
	"application/tamp-sequence-adjust-confirm": {
	source: "iana"
},
	"application/tamp-status-query": {
	source: "iana"
},
	"application/tamp-status-response": {
	source: "iana"
},
	"application/tamp-update": {
	source: "iana"
},
	"application/tamp-update-confirm": {
	source: "iana"
},
	"application/tar": {
	compressible: true
},
	"application/taxii+json": {
	source: "iana",
	compressible: true
},
	"application/td+json": {
	source: "iana",
	compressible: true
},
	"application/tei+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tei",
		"teicorpus"
	]
},
	"application/tetra_isi": {
	source: "iana"
},
	"application/thraud+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"tfi"
	]
},
	"application/timestamp-query": {
	source: "iana"
},
	"application/timestamp-reply": {
	source: "iana"
},
	"application/timestamped-data": {
	source: "iana",
	extensions: [
		"tsd"
	]
},
	"application/tlsrpt+gzip": {
	source: "iana"
},
	"application/tlsrpt+json": {
	source: "iana",
	compressible: true
},
	"application/tnauthlist": {
	source: "iana"
},
	"application/toml": {
	compressible: true,
	extensions: [
		"toml"
	]
},
	"application/trickle-ice-sdpfrag": {
	source: "iana"
},
	"application/trig": {
	source: "iana",
	extensions: [
		"trig"
	]
},
	"application/ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttml"
	]
},
	"application/tve-trigger": {
	source: "iana"
},
	"application/tzif": {
	source: "iana"
},
	"application/tzif-leap": {
	source: "iana"
},
	"application/ubjson": {
	compressible: false,
	extensions: [
		"ubj"
	]
},
	"application/ulpfec": {
	source: "iana"
},
	"application/urc-grpsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/urc-ressheet+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"rsheet"
	]
},
	"application/urc-targetdesc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"td"
	]
},
	"application/urc-uisocketdesc+xml": {
	source: "iana",
	compressible: true
},
	"application/vcard+json": {
	source: "iana",
	compressible: true
},
	"application/vcard+xml": {
	source: "iana",
	compressible: true
},
	"application/vemmi": {
	source: "iana"
},
	"application/vividence.scriptfile": {
	source: "apache"
},
	"application/vnd.1000minds.decision-model+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"1km"
	]
},
	"application/vnd.3gpp-prose+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-prose-pc3ch+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp-v2x-local-service-information": {
	source: "iana"
},
	"application/vnd.3gpp.5gnas": {
	source: "iana"
},
	"application/vnd.3gpp.access-transfer-events+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.bsf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gmop+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.gtpc": {
	source: "iana"
},
	"application/vnd.3gpp.interworking-data": {
	source: "iana"
},
	"application/vnd.3gpp.lpp": {
	source: "iana"
},
	"application/vnd.3gpp.mc-signalling-ear": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-payload": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-signalling": {
	source: "iana"
},
	"application/vnd.3gpp.mcdata-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcdata-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-floor-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-signed+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-ue-init-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcptt-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-command+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-affiliation-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-location-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-mbms-usage-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-service-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-transmission-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-ue-config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mcvideo-user-profile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.mid-call+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ngap": {
	source: "iana"
},
	"application/vnd.3gpp.pfcp": {
	source: "iana"
},
	"application/vnd.3gpp.pic-bw-large": {
	source: "iana",
	extensions: [
		"plb"
	]
},
	"application/vnd.3gpp.pic-bw-small": {
	source: "iana",
	extensions: [
		"psb"
	]
},
	"application/vnd.3gpp.pic-bw-var": {
	source: "iana",
	extensions: [
		"pvb"
	]
},
	"application/vnd.3gpp.s1ap": {
	source: "iana"
},
	"application/vnd.3gpp.sms": {
	source: "iana"
},
	"application/vnd.3gpp.sms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-ext+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.srvcc-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.state-and-event-info+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp.ussd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.bcmcsinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.3gpp2.sms": {
	source: "iana"
},
	"application/vnd.3gpp2.tcap": {
	source: "iana",
	extensions: [
		"tcap"
	]
},
	"application/vnd.3lightssoftware.imagescal": {
	source: "iana"
},
	"application/vnd.3m.post-it-notes": {
	source: "iana",
	extensions: [
		"pwn"
	]
},
	"application/vnd.accpac.simply.aso": {
	source: "iana",
	extensions: [
		"aso"
	]
},
	"application/vnd.accpac.simply.imp": {
	source: "iana",
	extensions: [
		"imp"
	]
},
	"application/vnd.acucobol": {
	source: "iana",
	extensions: [
		"acu"
	]
},
	"application/vnd.acucorp": {
	source: "iana",
	extensions: [
		"atc",
		"acutc"
	]
},
	"application/vnd.adobe.air-application-installer-package+zip": {
	source: "apache",
	compressible: false,
	extensions: [
		"air"
	]
},
	"application/vnd.adobe.flash.movie": {
	source: "iana"
},
	"application/vnd.adobe.formscentral.fcdt": {
	source: "iana",
	extensions: [
		"fcdt"
	]
},
	"application/vnd.adobe.fxp": {
	source: "iana",
	extensions: [
		"fxp",
		"fxpl"
	]
},
	"application/vnd.adobe.partial-upload": {
	source: "iana"
},
	"application/vnd.adobe.xdp+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdp"
	]
},
	"application/vnd.adobe.xfdf": {
	source: "iana",
	extensions: [
		"xfdf"
	]
},
	"application/vnd.aether.imp": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata": {
	source: "iana"
},
	"application/vnd.afpc.afplinedata-pagedef": {
	source: "iana"
},
	"application/vnd.afpc.cmoca-cmresource": {
	source: "iana"
},
	"application/vnd.afpc.foca-charset": {
	source: "iana"
},
	"application/vnd.afpc.foca-codedfont": {
	source: "iana"
},
	"application/vnd.afpc.foca-codepage": {
	source: "iana"
},
	"application/vnd.afpc.modca": {
	source: "iana"
},
	"application/vnd.afpc.modca-cmtable": {
	source: "iana"
},
	"application/vnd.afpc.modca-formdef": {
	source: "iana"
},
	"application/vnd.afpc.modca-mediummap": {
	source: "iana"
},
	"application/vnd.afpc.modca-objectcontainer": {
	source: "iana"
},
	"application/vnd.afpc.modca-overlay": {
	source: "iana"
},
	"application/vnd.afpc.modca-pagesegment": {
	source: "iana"
},
	"application/vnd.ah-barcode": {
	source: "iana"
},
	"application/vnd.ahead.space": {
	source: "iana",
	extensions: [
		"ahead"
	]
},
	"application/vnd.airzip.filesecure.azf": {
	source: "iana",
	extensions: [
		"azf"
	]
},
	"application/vnd.airzip.filesecure.azs": {
	source: "iana",
	extensions: [
		"azs"
	]
},
	"application/vnd.amadeus+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.amazon.ebook": {
	source: "apache",
	extensions: [
		"azw"
	]
},
	"application/vnd.amazon.mobi8-ebook": {
	source: "iana"
},
	"application/vnd.americandynamics.acc": {
	source: "iana",
	extensions: [
		"acc"
	]
},
	"application/vnd.amiga.ami": {
	source: "iana",
	extensions: [
		"ami"
	]
},
	"application/vnd.amundsen.maze+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.android.ota": {
	source: "iana"
},
	"application/vnd.android.package-archive": {
	source: "apache",
	compressible: false,
	extensions: [
		"apk"
	]
},
	"application/vnd.anki": {
	source: "iana"
},
	"application/vnd.anser-web-certificate-issue-initiation": {
	source: "iana",
	extensions: [
		"cii"
	]
},
	"application/vnd.anser-web-funds-transfer-initiation": {
	source: "apache",
	extensions: [
		"fti"
	]
},
	"application/vnd.antix.game-component": {
	source: "iana",
	extensions: [
		"atx"
	]
},
	"application/vnd.apache.arrow.file": {
	source: "iana"
},
	"application/vnd.apache.arrow.stream": {
	source: "iana"
},
	"application/vnd.apache.thrift.binary": {
	source: "iana"
},
	"application/vnd.apache.thrift.compact": {
	source: "iana"
},
	"application/vnd.apache.thrift.json": {
	source: "iana"
},
	"application/vnd.api+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.aplextor.warrp+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apothekende.reservation+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.apple.installer+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mpkg"
	]
},
	"application/vnd.apple.keynote": {
	source: "iana",
	extensions: [
		"key"
	]
},
	"application/vnd.apple.mpegurl": {
	source: "iana",
	extensions: [
		"m3u8"
	]
},
	"application/vnd.apple.numbers": {
	source: "iana",
	extensions: [
		"numbers"
	]
},
	"application/vnd.apple.pages": {
	source: "iana",
	extensions: [
		"pages"
	]
},
	"application/vnd.apple.pkpass": {
	compressible: false,
	extensions: [
		"pkpass"
	]
},
	"application/vnd.arastra.swi": {
	source: "iana"
},
	"application/vnd.aristanetworks.swi": {
	source: "iana",
	extensions: [
		"swi"
	]
},
	"application/vnd.artisan+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.artsquare": {
	source: "iana"
},
	"application/vnd.astraea-software.iota": {
	source: "iana",
	extensions: [
		"iota"
	]
},
	"application/vnd.audiograph": {
	source: "iana",
	extensions: [
		"aep"
	]
},
	"application/vnd.autopackage": {
	source: "iana"
},
	"application/vnd.avalon+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.avistar+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.balsamiq.bmml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmml"
	]
},
	"application/vnd.balsamiq.bmpr": {
	source: "iana"
},
	"application/vnd.banana-accounting": {
	source: "iana"
},
	"application/vnd.bbf.usp.error": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg": {
	source: "iana"
},
	"application/vnd.bbf.usp.msg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bekitzur-stech+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.bint.med-content": {
	source: "iana"
},
	"application/vnd.biopax.rdf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.blink-idb-value-wrapper": {
	source: "iana"
},
	"application/vnd.blueice.multipass": {
	source: "iana",
	extensions: [
		"mpm"
	]
},
	"application/vnd.bluetooth.ep.oob": {
	source: "iana"
},
	"application/vnd.bluetooth.le.oob": {
	source: "iana"
},
	"application/vnd.bmi": {
	source: "iana",
	extensions: [
		"bmi"
	]
},
	"application/vnd.bpf": {
	source: "iana"
},
	"application/vnd.bpf3": {
	source: "iana"
},
	"application/vnd.businessobjects": {
	source: "iana",
	extensions: [
		"rep"
	]
},
	"application/vnd.byu.uapi+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cab-jscript": {
	source: "iana"
},
	"application/vnd.canon-cpdl": {
	source: "iana"
},
	"application/vnd.canon-lips": {
	source: "iana"
},
	"application/vnd.capasystems-pg+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cendio.thinlinc.clientconf": {
	source: "iana"
},
	"application/vnd.century-systems.tcp_stream": {
	source: "iana"
},
	"application/vnd.chemdraw+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"cdxml"
	]
},
	"application/vnd.chess-pgn": {
	source: "iana"
},
	"application/vnd.chipnuts.karaoke-mmd": {
	source: "iana",
	extensions: [
		"mmd"
	]
},
	"application/vnd.ciedi": {
	source: "iana"
},
	"application/vnd.cinderella": {
	source: "iana",
	extensions: [
		"cdy"
	]
},
	"application/vnd.cirpack.isdn-ext": {
	source: "iana"
},
	"application/vnd.citationstyles.style+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"csl"
	]
},
	"application/vnd.claymore": {
	source: "iana",
	extensions: [
		"cla"
	]
},
	"application/vnd.cloanto.rp9": {
	source: "iana",
	extensions: [
		"rp9"
	]
},
	"application/vnd.clonk.c4group": {
	source: "iana",
	extensions: [
		"c4g",
		"c4d",
		"c4f",
		"c4p",
		"c4u"
	]
},
	"application/vnd.cluetrust.cartomobile-config": {
	source: "iana",
	extensions: [
		"c11amc"
	]
},
	"application/vnd.cluetrust.cartomobile-config-pkg": {
	source: "iana",
	extensions: [
		"c11amz"
	]
},
	"application/vnd.coffeescript": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.document-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.presentation-template": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet": {
	source: "iana"
},
	"application/vnd.collabio.xodocuments.spreadsheet-template": {
	source: "iana"
},
	"application/vnd.collection+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.doc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.collection.next+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.comicbook+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.comicbook-rar": {
	source: "iana"
},
	"application/vnd.commerce-battelle": {
	source: "iana"
},
	"application/vnd.commonspace": {
	source: "iana",
	extensions: [
		"csp"
	]
},
	"application/vnd.contact.cmsg": {
	source: "iana",
	extensions: [
		"cdbcmsg"
	]
},
	"application/vnd.coreos.ignition+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cosmocaller": {
	source: "iana",
	extensions: [
		"cmc"
	]
},
	"application/vnd.crick.clicker": {
	source: "iana",
	extensions: [
		"clkx"
	]
},
	"application/vnd.crick.clicker.keyboard": {
	source: "iana",
	extensions: [
		"clkk"
	]
},
	"application/vnd.crick.clicker.palette": {
	source: "iana",
	extensions: [
		"clkp"
	]
},
	"application/vnd.crick.clicker.template": {
	source: "iana",
	extensions: [
		"clkt"
	]
},
	"application/vnd.crick.clicker.wordbank": {
	source: "iana",
	extensions: [
		"clkw"
	]
},
	"application/vnd.criticaltools.wbs+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wbs"
	]
},
	"application/vnd.cryptii.pipe+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.crypto-shade-file": {
	source: "iana"
},
	"application/vnd.cryptomator.encrypted": {
	source: "iana"
},
	"application/vnd.cryptomator.vault": {
	source: "iana"
},
	"application/vnd.ctc-posml": {
	source: "iana",
	extensions: [
		"pml"
	]
},
	"application/vnd.ctct.ws+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cups-pdf": {
	source: "iana"
},
	"application/vnd.cups-postscript": {
	source: "iana"
},
	"application/vnd.cups-ppd": {
	source: "iana",
	extensions: [
		"ppd"
	]
},
	"application/vnd.cups-raster": {
	source: "iana"
},
	"application/vnd.cups-raw": {
	source: "iana"
},
	"application/vnd.curl": {
	source: "iana"
},
	"application/vnd.curl.car": {
	source: "apache",
	extensions: [
		"car"
	]
},
	"application/vnd.curl.pcurl": {
	source: "apache",
	extensions: [
		"pcurl"
	]
},
	"application/vnd.cyan.dean.root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.cybank": {
	source: "iana"
},
	"application/vnd.cyclonedx+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.cyclonedx+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.d2l.coursepackage1p0+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.d3m-dataset": {
	source: "iana"
},
	"application/vnd.d3m-problem": {
	source: "iana"
},
	"application/vnd.dart": {
	source: "iana",
	compressible: true,
	extensions: [
		"dart"
	]
},
	"application/vnd.data-vision.rdz": {
	source: "iana",
	extensions: [
		"rdz"
	]
},
	"application/vnd.datapackage+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dataresource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dbf": {
	source: "iana",
	extensions: [
		"dbf"
	]
},
	"application/vnd.debian.binary-package": {
	source: "iana"
},
	"application/vnd.dece.data": {
	source: "iana",
	extensions: [
		"uvf",
		"uvvf",
		"uvd",
		"uvvd"
	]
},
	"application/vnd.dece.ttml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uvt",
		"uvvt"
	]
},
	"application/vnd.dece.unspecified": {
	source: "iana",
	extensions: [
		"uvx",
		"uvvx"
	]
},
	"application/vnd.dece.zip": {
	source: "iana",
	extensions: [
		"uvz",
		"uvvz"
	]
},
	"application/vnd.denovo.fcselayout-link": {
	source: "iana",
	extensions: [
		"fe_launch"
	]
},
	"application/vnd.desmume.movie": {
	source: "iana"
},
	"application/vnd.dir-bi.plate-dl-nosuffix": {
	source: "iana"
},
	"application/vnd.dm.delegation+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dna": {
	source: "iana",
	extensions: [
		"dna"
	]
},
	"application/vnd.document+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.dolby.mlp": {
	source: "apache",
	extensions: [
		"mlp"
	]
},
	"application/vnd.dolby.mobile.1": {
	source: "iana"
},
	"application/vnd.dolby.mobile.2": {
	source: "iana"
},
	"application/vnd.doremir.scorecloud-binary-document": {
	source: "iana"
},
	"application/vnd.dpgraph": {
	source: "iana",
	extensions: [
		"dpg"
	]
},
	"application/vnd.dreamfactory": {
	source: "iana",
	extensions: [
		"dfac"
	]
},
	"application/vnd.drive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ds-keypoint": {
	source: "apache",
	extensions: [
		"kpxx"
	]
},
	"application/vnd.dtg.local": {
	source: "iana"
},
	"application/vnd.dtg.local.flash": {
	source: "iana"
},
	"application/vnd.dtg.local.html": {
	source: "iana"
},
	"application/vnd.dvb.ait": {
	source: "iana",
	extensions: [
		"ait"
	]
},
	"application/vnd.dvb.dvbisl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.dvbj": {
	source: "iana"
},
	"application/vnd.dvb.esgcontainer": {
	source: "iana"
},
	"application/vnd.dvb.ipdcdftnotifaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgaccess2": {
	source: "iana"
},
	"application/vnd.dvb.ipdcesgpdd": {
	source: "iana"
},
	"application/vnd.dvb.ipdcroaming": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-base": {
	source: "iana"
},
	"application/vnd.dvb.iptv.alfec-enhancement": {
	source: "iana"
},
	"application/vnd.dvb.notif-aggregate-root+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-container+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-generic+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-msglist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-ia-registration-response+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.notif-init+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.dvb.pfr": {
	source: "iana"
},
	"application/vnd.dvb.service": {
	source: "iana",
	extensions: [
		"svc"
	]
},
	"application/vnd.dxr": {
	source: "iana"
},
	"application/vnd.dynageo": {
	source: "iana",
	extensions: [
		"geo"
	]
},
	"application/vnd.dzr": {
	source: "iana"
},
	"application/vnd.easykaraoke.cdgdownload": {
	source: "iana"
},
	"application/vnd.ecdis-update": {
	source: "iana"
},
	"application/vnd.ecip.rlp": {
	source: "iana"
},
	"application/vnd.ecowin.chart": {
	source: "iana",
	extensions: [
		"mag"
	]
},
	"application/vnd.ecowin.filerequest": {
	source: "iana"
},
	"application/vnd.ecowin.fileupdate": {
	source: "iana"
},
	"application/vnd.ecowin.series": {
	source: "iana"
},
	"application/vnd.ecowin.seriesrequest": {
	source: "iana"
},
	"application/vnd.ecowin.seriesupdate": {
	source: "iana"
},
	"application/vnd.efi.img": {
	source: "iana"
},
	"application/vnd.efi.iso": {
	source: "iana"
},
	"application/vnd.emclient.accessrequest+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.enliven": {
	source: "iana",
	extensions: [
		"nml"
	]
},
	"application/vnd.enphase.envoy": {
	source: "iana"
},
	"application/vnd.eprints.data+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.epson.esf": {
	source: "iana",
	extensions: [
		"esf"
	]
},
	"application/vnd.epson.msf": {
	source: "iana",
	extensions: [
		"msf"
	]
},
	"application/vnd.epson.quickanime": {
	source: "iana",
	extensions: [
		"qam"
	]
},
	"application/vnd.epson.salt": {
	source: "iana",
	extensions: [
		"slt"
	]
},
	"application/vnd.epson.ssf": {
	source: "iana",
	extensions: [
		"ssf"
	]
},
	"application/vnd.ericsson.quickcall": {
	source: "iana"
},
	"application/vnd.espass-espass+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.eszigno3+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"es3",
		"et3"
	]
},
	"application/vnd.etsi.aoc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.asic-e+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.asic-s+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.etsi.cug+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvcommand+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-bc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-cod+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsad-npvr+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvservice+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvsync+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.iptvueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mcid+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.mheg5": {
	source: "iana"
},
	"application/vnd.etsi.overload-control-policy-dataset+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.pstn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.sci+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.simservs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.timestamp-token": {
	source: "iana"
},
	"application/vnd.etsi.tsl+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.etsi.tsl.der": {
	source: "iana"
},
	"application/vnd.eudora.data": {
	source: "iana"
},
	"application/vnd.evolv.ecig.profile": {
	source: "iana"
},
	"application/vnd.evolv.ecig.settings": {
	source: "iana"
},
	"application/vnd.evolv.ecig.theme": {
	source: "iana"
},
	"application/vnd.exstream-empower+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.exstream-package": {
	source: "iana"
},
	"application/vnd.ezpix-album": {
	source: "iana",
	extensions: [
		"ez2"
	]
},
	"application/vnd.ezpix-package": {
	source: "iana",
	extensions: [
		"ez3"
	]
},
	"application/vnd.f-secure.mobile": {
	source: "iana"
},
	"application/vnd.fastcopy-disk-image": {
	source: "iana"
},
	"application/vnd.fdf": {
	source: "iana",
	extensions: [
		"fdf"
	]
},
	"application/vnd.fdsn.mseed": {
	source: "iana",
	extensions: [
		"mseed"
	]
},
	"application/vnd.fdsn.seed": {
	source: "iana",
	extensions: [
		"seed",
		"dataless"
	]
},
	"application/vnd.ffsns": {
	source: "iana"
},
	"application/vnd.ficlab.flb+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.filmit.zfc": {
	source: "iana"
},
	"application/vnd.fints": {
	source: "iana"
},
	"application/vnd.firemonkeys.cloudcell": {
	source: "iana"
},
	"application/vnd.flographit": {
	source: "iana",
	extensions: [
		"gph"
	]
},
	"application/vnd.fluxtime.clip": {
	source: "iana",
	extensions: [
		"ftc"
	]
},
	"application/vnd.font-fontforge-sfd": {
	source: "iana"
},
	"application/vnd.framemaker": {
	source: "iana",
	extensions: [
		"fm",
		"frame",
		"maker",
		"book"
	]
},
	"application/vnd.frogans.fnc": {
	source: "iana",
	extensions: [
		"fnc"
	]
},
	"application/vnd.frogans.ltf": {
	source: "iana",
	extensions: [
		"ltf"
	]
},
	"application/vnd.fsc.weblaunch": {
	source: "iana",
	extensions: [
		"fsc"
	]
},
	"application/vnd.fujifilm.fb.docuworks": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.binder": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujifilm.fb.jfi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.fujitsu.oasys": {
	source: "iana",
	extensions: [
		"oas"
	]
},
	"application/vnd.fujitsu.oasys2": {
	source: "iana",
	extensions: [
		"oa2"
	]
},
	"application/vnd.fujitsu.oasys3": {
	source: "iana",
	extensions: [
		"oa3"
	]
},
	"application/vnd.fujitsu.oasysgp": {
	source: "iana",
	extensions: [
		"fg5"
	]
},
	"application/vnd.fujitsu.oasysprs": {
	source: "iana",
	extensions: [
		"bh2"
	]
},
	"application/vnd.fujixerox.art-ex": {
	source: "iana"
},
	"application/vnd.fujixerox.art4": {
	source: "iana"
},
	"application/vnd.fujixerox.ddd": {
	source: "iana",
	extensions: [
		"ddd"
	]
},
	"application/vnd.fujixerox.docuworks": {
	source: "iana",
	extensions: [
		"xdw"
	]
},
	"application/vnd.fujixerox.docuworks.binder": {
	source: "iana",
	extensions: [
		"xbd"
	]
},
	"application/vnd.fujixerox.docuworks.container": {
	source: "iana"
},
	"application/vnd.fujixerox.hbpl": {
	source: "iana"
},
	"application/vnd.fut-misnet": {
	source: "iana"
},
	"application/vnd.futoin+cbor": {
	source: "iana"
},
	"application/vnd.futoin+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.fuzzysheet": {
	source: "iana",
	extensions: [
		"fzs"
	]
},
	"application/vnd.genomatix.tuxedo": {
	source: "iana",
	extensions: [
		"txd"
	]
},
	"application/vnd.gentics.grd+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geo+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.geocube+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.geogebra.file": {
	source: "iana",
	extensions: [
		"ggb"
	]
},
	"application/vnd.geogebra.slides": {
	source: "iana"
},
	"application/vnd.geogebra.tool": {
	source: "iana",
	extensions: [
		"ggt"
	]
},
	"application/vnd.geometry-explorer": {
	source: "iana",
	extensions: [
		"gex",
		"gre"
	]
},
	"application/vnd.geonext": {
	source: "iana",
	extensions: [
		"gxt"
	]
},
	"application/vnd.geoplan": {
	source: "iana",
	extensions: [
		"g2w"
	]
},
	"application/vnd.geospace": {
	source: "iana",
	extensions: [
		"g3w"
	]
},
	"application/vnd.gerber": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt": {
	source: "iana"
},
	"application/vnd.globalplatform.card-content-mgt-response": {
	source: "iana"
},
	"application/vnd.gmx": {
	source: "iana",
	extensions: [
		"gmx"
	]
},
	"application/vnd.google-apps.document": {
	compressible: false,
	extensions: [
		"gdoc"
	]
},
	"application/vnd.google-apps.presentation": {
	compressible: false,
	extensions: [
		"gslides"
	]
},
	"application/vnd.google-apps.spreadsheet": {
	compressible: false,
	extensions: [
		"gsheet"
	]
},
	"application/vnd.google-earth.kml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"kml"
	]
},
	"application/vnd.google-earth.kmz": {
	source: "iana",
	compressible: false,
	extensions: [
		"kmz"
	]
},
	"application/vnd.gov.sk.e-form+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.gov.sk.e-form+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.gov.sk.xmldatacontainer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.grafeq": {
	source: "iana",
	extensions: [
		"gqf",
		"gqs"
	]
},
	"application/vnd.gridmp": {
	source: "iana"
},
	"application/vnd.groove-account": {
	source: "iana",
	extensions: [
		"gac"
	]
},
	"application/vnd.groove-help": {
	source: "iana",
	extensions: [
		"ghf"
	]
},
	"application/vnd.groove-identity-message": {
	source: "iana",
	extensions: [
		"gim"
	]
},
	"application/vnd.groove-injector": {
	source: "iana",
	extensions: [
		"grv"
	]
},
	"application/vnd.groove-tool-message": {
	source: "iana",
	extensions: [
		"gtm"
	]
},
	"application/vnd.groove-tool-template": {
	source: "iana",
	extensions: [
		"tpl"
	]
},
	"application/vnd.groove-vcard": {
	source: "iana",
	extensions: [
		"vcg"
	]
},
	"application/vnd.hal+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hal+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"hal"
	]
},
	"application/vnd.handheld-entertainment+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zmm"
	]
},
	"application/vnd.hbci": {
	source: "iana",
	extensions: [
		"hbci"
	]
},
	"application/vnd.hc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hcl-bireports": {
	source: "iana"
},
	"application/vnd.hdt": {
	source: "iana"
},
	"application/vnd.heroku+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hhe.lesson-player": {
	source: "iana",
	extensions: [
		"les"
	]
},
	"application/vnd.hp-hpgl": {
	source: "iana",
	extensions: [
		"hpgl"
	]
},
	"application/vnd.hp-hpid": {
	source: "iana",
	extensions: [
		"hpid"
	]
},
	"application/vnd.hp-hps": {
	source: "iana",
	extensions: [
		"hps"
	]
},
	"application/vnd.hp-jlyt": {
	source: "iana",
	extensions: [
		"jlt"
	]
},
	"application/vnd.hp-pcl": {
	source: "iana",
	extensions: [
		"pcl"
	]
},
	"application/vnd.hp-pclxl": {
	source: "iana",
	extensions: [
		"pclxl"
	]
},
	"application/vnd.httphone": {
	source: "iana"
},
	"application/vnd.hydrostatix.sof-data": {
	source: "iana",
	extensions: [
		"sfd-hdstx"
	]
},
	"application/vnd.hyper+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyper-item+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hyperdrive+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.hzn-3d-crossword": {
	source: "iana"
},
	"application/vnd.ibm.afplinedata": {
	source: "iana"
},
	"application/vnd.ibm.electronic-media": {
	source: "iana"
},
	"application/vnd.ibm.minipay": {
	source: "iana",
	extensions: [
		"mpy"
	]
},
	"application/vnd.ibm.modcap": {
	source: "iana",
	extensions: [
		"afp",
		"listafp",
		"list3820"
	]
},
	"application/vnd.ibm.rights-management": {
	source: "iana",
	extensions: [
		"irm"
	]
},
	"application/vnd.ibm.secure-container": {
	source: "iana",
	extensions: [
		"sc"
	]
},
	"application/vnd.iccprofile": {
	source: "iana",
	extensions: [
		"icc",
		"icm"
	]
},
	"application/vnd.ieee.1905": {
	source: "iana"
},
	"application/vnd.igloader": {
	source: "iana",
	extensions: [
		"igl"
	]
},
	"application/vnd.imagemeter.folder+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.imagemeter.image+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.immervision-ivp": {
	source: "iana",
	extensions: [
		"ivp"
	]
},
	"application/vnd.immervision-ivu": {
	source: "iana",
	extensions: [
		"ivu"
	]
},
	"application/vnd.ims.imsccv1p1": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p2": {
	source: "iana"
},
	"application/vnd.ims.imsccv1p3": {
	source: "iana"
},
	"application/vnd.ims.lis.v2.result+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolconsumerprofile+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolproxy.id+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.ims.lti.v2.toolsettings.simple+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.informedcontrol.rms+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.informix-visionary": {
	source: "iana"
},
	"application/vnd.infotech.project": {
	source: "iana"
},
	"application/vnd.infotech.project+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.innopath.wamp.notification": {
	source: "iana"
},
	"application/vnd.insors.igm": {
	source: "iana",
	extensions: [
		"igm"
	]
},
	"application/vnd.intercon.formnet": {
	source: "iana",
	extensions: [
		"xpw",
		"xpx"
	]
},
	"application/vnd.intergeo": {
	source: "iana",
	extensions: [
		"i2g"
	]
},
	"application/vnd.intertrust.digibox": {
	source: "iana"
},
	"application/vnd.intertrust.nncp": {
	source: "iana"
},
	"application/vnd.intu.qbo": {
	source: "iana",
	extensions: [
		"qbo"
	]
},
	"application/vnd.intu.qfx": {
	source: "iana",
	extensions: [
		"qfx"
	]
},
	"application/vnd.iptc.g2.catalogitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.conceptitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.knowledgeitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.newsmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.packageitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.iptc.g2.planningitem+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ipunplugged.rcprofile": {
	source: "iana",
	extensions: [
		"rcprofile"
	]
},
	"application/vnd.irepository.package+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"irp"
	]
},
	"application/vnd.is-xpr": {
	source: "iana",
	extensions: [
		"xpr"
	]
},
	"application/vnd.isac.fcs": {
	source: "iana",
	extensions: [
		"fcs"
	]
},
	"application/vnd.iso11783-10+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.jam": {
	source: "iana",
	extensions: [
		"jam"
	]
},
	"application/vnd.japannet-directory-service": {
	source: "iana"
},
	"application/vnd.japannet-jpnstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-payment-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-registration": {
	source: "iana"
},
	"application/vnd.japannet-registration-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-setstore-wakeup": {
	source: "iana"
},
	"application/vnd.japannet-verification": {
	source: "iana"
},
	"application/vnd.japannet-verification-wakeup": {
	source: "iana"
},
	"application/vnd.jcp.javame.midlet-rms": {
	source: "iana",
	extensions: [
		"rms"
	]
},
	"application/vnd.jisp": {
	source: "iana",
	extensions: [
		"jisp"
	]
},
	"application/vnd.joost.joda-archive": {
	source: "iana",
	extensions: [
		"joda"
	]
},
	"application/vnd.jsk.isdn-ngn": {
	source: "iana"
},
	"application/vnd.kahootz": {
	source: "iana",
	extensions: [
		"ktz",
		"ktr"
	]
},
	"application/vnd.kde.karbon": {
	source: "iana",
	extensions: [
		"karbon"
	]
},
	"application/vnd.kde.kchart": {
	source: "iana",
	extensions: [
		"chrt"
	]
},
	"application/vnd.kde.kformula": {
	source: "iana",
	extensions: [
		"kfo"
	]
},
	"application/vnd.kde.kivio": {
	source: "iana",
	extensions: [
		"flw"
	]
},
	"application/vnd.kde.kontour": {
	source: "iana",
	extensions: [
		"kon"
	]
},
	"application/vnd.kde.kpresenter": {
	source: "iana",
	extensions: [
		"kpr",
		"kpt"
	]
},
	"application/vnd.kde.kspread": {
	source: "iana",
	extensions: [
		"ksp"
	]
},
	"application/vnd.kde.kword": {
	source: "iana",
	extensions: [
		"kwd",
		"kwt"
	]
},
	"application/vnd.kenameaapp": {
	source: "iana",
	extensions: [
		"htke"
	]
},
	"application/vnd.kidspiration": {
	source: "iana",
	extensions: [
		"kia"
	]
},
	"application/vnd.kinar": {
	source: "iana",
	extensions: [
		"kne",
		"knp"
	]
},
	"application/vnd.koan": {
	source: "iana",
	extensions: [
		"skp",
		"skd",
		"skt",
		"skm"
	]
},
	"application/vnd.kodak-descriptor": {
	source: "iana",
	extensions: [
		"sse"
	]
},
	"application/vnd.las": {
	source: "iana"
},
	"application/vnd.las.las+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.las.las+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lasxml"
	]
},
	"application/vnd.laszip": {
	source: "iana"
},
	"application/vnd.leap+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.liberty-request+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.llamagraphics.life-balance.desktop": {
	source: "iana",
	extensions: [
		"lbd"
	]
},
	"application/vnd.llamagraphics.life-balance.exchange+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"lbe"
	]
},
	"application/vnd.logipipe.circuit+zip": {
	source: "iana",
	compressible: false
},
	"application/vnd.loom": {
	source: "iana"
},
	"application/vnd.lotus-1-2-3": {
	source: "iana",
	extensions: [
		"123"
	]
},
	"application/vnd.lotus-approach": {
	source: "iana",
	extensions: [
		"apr"
	]
},
	"application/vnd.lotus-freelance": {
	source: "iana",
	extensions: [
		"pre"
	]
},
	"application/vnd.lotus-notes": {
	source: "iana",
	extensions: [
		"nsf"
	]
},
	"application/vnd.lotus-organizer": {
	source: "iana",
	extensions: [
		"org"
	]
},
	"application/vnd.lotus-screencam": {
	source: "iana",
	extensions: [
		"scm"
	]
},
	"application/vnd.lotus-wordpro": {
	source: "iana",
	extensions: [
		"lwp"
	]
},
	"application/vnd.macports.portpkg": {
	source: "iana",
	extensions: [
		"portpkg"
	]
},
	"application/vnd.mapbox-vector-tile": {
	source: "iana",
	extensions: [
		"mvt"
	]
},
	"application/vnd.marlin.drm.actiontoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.conftoken+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.license+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.marlin.drm.mdcf": {
	source: "iana"
},
	"application/vnd.mason+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.maxmind.maxmind-db": {
	source: "iana"
},
	"application/vnd.mcd": {
	source: "iana",
	extensions: [
		"mcd"
	]
},
	"application/vnd.medcalcdata": {
	source: "iana",
	extensions: [
		"mc1"
	]
},
	"application/vnd.mediastation.cdkey": {
	source: "iana",
	extensions: [
		"cdkey"
	]
},
	"application/vnd.meridian-slingshot": {
	source: "iana"
},
	"application/vnd.mfer": {
	source: "iana",
	extensions: [
		"mwf"
	]
},
	"application/vnd.mfmp": {
	source: "iana",
	extensions: [
		"mfm"
	]
},
	"application/vnd.micro+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.micrografx.flo": {
	source: "iana",
	extensions: [
		"flo"
	]
},
	"application/vnd.micrografx.igx": {
	source: "iana",
	extensions: [
		"igx"
	]
},
	"application/vnd.microsoft.portable-executable": {
	source: "iana"
},
	"application/vnd.microsoft.windows.thumbnail-cache": {
	source: "iana"
},
	"application/vnd.miele+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.mif": {
	source: "iana",
	extensions: [
		"mif"
	]
},
	"application/vnd.minisoft-hp3000-save": {
	source: "iana"
},
	"application/vnd.mitsubishi.misty-guard.trustweb": {
	source: "iana"
},
	"application/vnd.mobius.daf": {
	source: "iana",
	extensions: [
		"daf"
	]
},
	"application/vnd.mobius.dis": {
	source: "iana",
	extensions: [
		"dis"
	]
},
	"application/vnd.mobius.mbk": {
	source: "iana",
	extensions: [
		"mbk"
	]
},
	"application/vnd.mobius.mqy": {
	source: "iana",
	extensions: [
		"mqy"
	]
},
	"application/vnd.mobius.msl": {
	source: "iana",
	extensions: [
		"msl"
	]
},
	"application/vnd.mobius.plc": {
	source: "iana",
	extensions: [
		"plc"
	]
},
	"application/vnd.mobius.txf": {
	source: "iana",
	extensions: [
		"txf"
	]
},
	"application/vnd.mophun.application": {
	source: "iana",
	extensions: [
		"mpn"
	]
},
	"application/vnd.mophun.certificate": {
	source: "iana",
	extensions: [
		"mpc"
	]
},
	"application/vnd.motorola.flexsuite": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.adsi": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.fis": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.gotap": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.kmr": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.ttc": {
	source: "iana"
},
	"application/vnd.motorola.flexsuite.wem": {
	source: "iana"
},
	"application/vnd.motorola.iprm": {
	source: "iana"
},
	"application/vnd.mozilla.xul+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xul"
	]
},
	"application/vnd.ms-3mfdocument": {
	source: "iana"
},
	"application/vnd.ms-artgalry": {
	source: "iana",
	extensions: [
		"cil"
	]
},
	"application/vnd.ms-asf": {
	source: "iana"
},
	"application/vnd.ms-cab-compressed": {
	source: "iana",
	extensions: [
		"cab"
	]
},
	"application/vnd.ms-color.iccprofile": {
	source: "apache"
},
	"application/vnd.ms-excel": {
	source: "iana",
	compressible: false,
	extensions: [
		"xls",
		"xlm",
		"xla",
		"xlc",
		"xlt",
		"xlw"
	]
},
	"application/vnd.ms-excel.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlam"
	]
},
	"application/vnd.ms-excel.sheet.binary.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsb"
	]
},
	"application/vnd.ms-excel.sheet.macroenabled.12": {
	source: "iana",
	extensions: [
		"xlsm"
	]
},
	"application/vnd.ms-excel.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"xltm"
	]
},
	"application/vnd.ms-fontobject": {
	source: "iana",
	compressible: true,
	extensions: [
		"eot"
	]
},
	"application/vnd.ms-htmlhelp": {
	source: "iana",
	extensions: [
		"chm"
	]
},
	"application/vnd.ms-ims": {
	source: "iana",
	extensions: [
		"ims"
	]
},
	"application/vnd.ms-lrm": {
	source: "iana",
	extensions: [
		"lrm"
	]
},
	"application/vnd.ms-office.activex+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-officetheme": {
	source: "iana",
	extensions: [
		"thmx"
	]
},
	"application/vnd.ms-opentype": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-outlook": {
	compressible: false,
	extensions: [
		"msg"
	]
},
	"application/vnd.ms-package.obfuscated-opentype": {
	source: "apache"
},
	"application/vnd.ms-pki.seccat": {
	source: "apache",
	extensions: [
		"cat"
	]
},
	"application/vnd.ms-pki.stl": {
	source: "apache",
	extensions: [
		"stl"
	]
},
	"application/vnd.ms-playready.initiator+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-powerpoint": {
	source: "iana",
	compressible: false,
	extensions: [
		"ppt",
		"pps",
		"pot"
	]
},
	"application/vnd.ms-powerpoint.addin.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppam"
	]
},
	"application/vnd.ms-powerpoint.presentation.macroenabled.12": {
	source: "iana",
	extensions: [
		"pptm"
	]
},
	"application/vnd.ms-powerpoint.slide.macroenabled.12": {
	source: "iana",
	extensions: [
		"sldm"
	]
},
	"application/vnd.ms-powerpoint.slideshow.macroenabled.12": {
	source: "iana",
	extensions: [
		"ppsm"
	]
},
	"application/vnd.ms-powerpoint.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"potm"
	]
},
	"application/vnd.ms-printdevicecapabilities+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-printing.printticket+xml": {
	source: "apache",
	compressible: true
},
	"application/vnd.ms-printschematicket+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.ms-project": {
	source: "iana",
	extensions: [
		"mpp",
		"mpt"
	]
},
	"application/vnd.ms-tnef": {
	source: "iana"
},
	"application/vnd.ms-windows.devicepairing": {
	source: "iana"
},
	"application/vnd.ms-windows.nwprinting.oob": {
	source: "iana"
},
	"application/vnd.ms-windows.printerpairing": {
	source: "iana"
},
	"application/vnd.ms-windows.wsd.oob": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.lic-resp": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-chlg-req": {
	source: "iana"
},
	"application/vnd.ms-wmdrm.meter-resp": {
	source: "iana"
},
	"application/vnd.ms-word.document.macroenabled.12": {
	source: "iana",
	extensions: [
		"docm"
	]
},
	"application/vnd.ms-word.template.macroenabled.12": {
	source: "iana",
	extensions: [
		"dotm"
	]
},
	"application/vnd.ms-works": {
	source: "iana",
	extensions: [
		"wps",
		"wks",
		"wcm",
		"wdb"
	]
},
	"application/vnd.ms-wpl": {
	source: "iana",
	extensions: [
		"wpl"
	]
},
	"application/vnd.ms-xpsdocument": {
	source: "iana",
	compressible: false,
	extensions: [
		"xps"
	]
},
	"application/vnd.msa-disk-image": {
	source: "iana"
},
	"application/vnd.mseq": {
	source: "iana",
	extensions: [
		"mseq"
	]
},
	"application/vnd.msign": {
	source: "iana"
},
	"application/vnd.multiad.creator": {
	source: "iana"
},
	"application/vnd.multiad.creator.cif": {
	source: "iana"
},
	"application/vnd.music-niff": {
	source: "iana"
},
	"application/vnd.musician": {
	source: "iana",
	extensions: [
		"mus"
	]
},
	"application/vnd.muvee.style": {
	source: "iana",
	extensions: [
		"msty"
	]
},
	"application/vnd.mynfc": {
	source: "iana",
	extensions: [
		"taglet"
	]
},
	"application/vnd.ncd.control": {
	source: "iana"
},
	"application/vnd.ncd.reference": {
	source: "iana"
},
	"application/vnd.nearst.inv+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.nebumind.line": {
	source: "iana"
},
	"application/vnd.nervana": {
	source: "iana"
},
	"application/vnd.netfpx": {
	source: "iana"
},
	"application/vnd.neurolanguage.nlu": {
	source: "iana",
	extensions: [
		"nlu"
	]
},
	"application/vnd.nimn": {
	source: "iana"
},
	"application/vnd.nintendo.nitro.rom": {
	source: "iana"
},
	"application/vnd.nintendo.snes.rom": {
	source: "iana"
},
	"application/vnd.nitf": {
	source: "iana",
	extensions: [
		"ntf",
		"nitf"
	]
},
	"application/vnd.noblenet-directory": {
	source: "iana",
	extensions: [
		"nnd"
	]
},
	"application/vnd.noblenet-sealer": {
	source: "iana",
	extensions: [
		"nns"
	]
},
	"application/vnd.noblenet-web": {
	source: "iana",
	extensions: [
		"nnw"
	]
},
	"application/vnd.nokia.catalogs": {
	source: "iana"
},
	"application/vnd.nokia.conml+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.conml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.iptv.config+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.isds-radio-presets": {
	source: "iana"
},
	"application/vnd.nokia.landmark+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.landmark+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.landmarkcollection+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.n-gage.ac+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"ac"
	]
},
	"application/vnd.nokia.n-gage.data": {
	source: "iana",
	extensions: [
		"ngdat"
	]
},
	"application/vnd.nokia.n-gage.symbian.install": {
	source: "iana",
	extensions: [
		"n-gage"
	]
},
	"application/vnd.nokia.ncd": {
	source: "iana"
},
	"application/vnd.nokia.pcd+wbxml": {
	source: "iana"
},
	"application/vnd.nokia.pcd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.nokia.radio-preset": {
	source: "iana",
	extensions: [
		"rpst"
	]
},
	"application/vnd.nokia.radio-presets": {
	source: "iana",
	extensions: [
		"rpss"
	]
},
	"application/vnd.novadigm.edm": {
	source: "iana",
	extensions: [
		"edm"
	]
},
	"application/vnd.novadigm.edx": {
	source: "iana",
	extensions: [
		"edx"
	]
},
	"application/vnd.novadigm.ext": {
	source: "iana",
	extensions: [
		"ext"
	]
},
	"application/vnd.ntt-local.content-share": {
	source: "iana"
},
	"application/vnd.ntt-local.file-transfer": {
	source: "iana"
},
	"application/vnd.ntt-local.ogw_remote-access": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_remote": {
	source: "iana"
},
	"application/vnd.ntt-local.sip-ta_tcp_stream": {
	source: "iana"
},
	"application/vnd.oasis.opendocument.chart": {
	source: "iana",
	extensions: [
		"odc"
	]
},
	"application/vnd.oasis.opendocument.chart-template": {
	source: "iana",
	extensions: [
		"otc"
	]
},
	"application/vnd.oasis.opendocument.database": {
	source: "iana",
	extensions: [
		"odb"
	]
},
	"application/vnd.oasis.opendocument.formula": {
	source: "iana",
	extensions: [
		"odf"
	]
},
	"application/vnd.oasis.opendocument.formula-template": {
	source: "iana",
	extensions: [
		"odft"
	]
},
	"application/vnd.oasis.opendocument.graphics": {
	source: "iana",
	compressible: false,
	extensions: [
		"odg"
	]
},
	"application/vnd.oasis.opendocument.graphics-template": {
	source: "iana",
	extensions: [
		"otg"
	]
},
	"application/vnd.oasis.opendocument.image": {
	source: "iana",
	extensions: [
		"odi"
	]
},
	"application/vnd.oasis.opendocument.image-template": {
	source: "iana",
	extensions: [
		"oti"
	]
},
	"application/vnd.oasis.opendocument.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"odp"
	]
},
	"application/vnd.oasis.opendocument.presentation-template": {
	source: "iana",
	extensions: [
		"otp"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"ods"
	]
},
	"application/vnd.oasis.opendocument.spreadsheet-template": {
	source: "iana",
	extensions: [
		"ots"
	]
},
	"application/vnd.oasis.opendocument.text": {
	source: "iana",
	compressible: false,
	extensions: [
		"odt"
	]
},
	"application/vnd.oasis.opendocument.text-master": {
	source: "iana",
	extensions: [
		"odm"
	]
},
	"application/vnd.oasis.opendocument.text-template": {
	source: "iana",
	extensions: [
		"ott"
	]
},
	"application/vnd.oasis.opendocument.text-web": {
	source: "iana",
	extensions: [
		"oth"
	]
},
	"application/vnd.obn": {
	source: "iana"
},
	"application/vnd.ocf+cbor": {
	source: "iana"
},
	"application/vnd.oci.image.manifest.v1+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oftn.l10n+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessdownload+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.contentaccessstreaming+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.cspg-hexbinary": {
	source: "iana"
},
	"application/vnd.oipf.dae.svg+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.dae.xhtml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.mippvcontrolmessage+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.pae.gem": {
	source: "iana"
},
	"application/vnd.oipf.spdiscovery+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.spdlist+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.ueprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oipf.userprofile+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.olpc-sugar": {
	source: "iana",
	extensions: [
		"xo"
	]
},
	"application/vnd.oma-scws-config": {
	source: "iana"
},
	"application/vnd.oma-scws-http-request": {
	source: "iana"
},
	"application/vnd.oma-scws-http-response": {
	source: "iana"
},
	"application/vnd.oma.bcast.associated-procedure-parameter+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.drm-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.imd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.ltkm": {
	source: "iana"
},
	"application/vnd.oma.bcast.notification+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.provisioningtrigger": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgboot": {
	source: "iana"
},
	"application/vnd.oma.bcast.sgdd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sgdu": {
	source: "iana"
},
	"application/vnd.oma.bcast.simple-symbol-container": {
	source: "iana"
},
	"application/vnd.oma.bcast.smartcard-trigger+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.sprov+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.bcast.stkm": {
	source: "iana"
},
	"application/vnd.oma.cab-address-book+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-feature-handler+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-pcc+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-subs-invite+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.cab-user-prefs+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.dcd": {
	source: "iana"
},
	"application/vnd.oma.dcdc": {
	source: "iana"
},
	"application/vnd.oma.dd2+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dd2"
	]
},
	"application/vnd.oma.drm.risd+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.group-usage-list+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+cbor": {
	source: "iana"
},
	"application/vnd.oma.lwm2m+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.lwm2m+tlv": {
	source: "iana"
},
	"application/vnd.oma.pal+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.detailed-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.final-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.groups+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.invocation-descriptor+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.poc.optimized-progress-report+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.push": {
	source: "iana"
},
	"application/vnd.oma.scidm.messages+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oma.xcap-directory+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.omads-email+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-file+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omads-folder+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.omaloc-supl-init": {
	source: "iana"
},
	"application/vnd.onepager": {
	source: "iana"
},
	"application/vnd.onepagertamp": {
	source: "iana"
},
	"application/vnd.onepagertamx": {
	source: "iana"
},
	"application/vnd.onepagertat": {
	source: "iana"
},
	"application/vnd.onepagertatp": {
	source: "iana"
},
	"application/vnd.onepagertatx": {
	source: "iana"
},
	"application/vnd.openblox.game+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"obgx"
	]
},
	"application/vnd.openblox.game-binary": {
	source: "iana"
},
	"application/vnd.openeye.oeb": {
	source: "iana"
},
	"application/vnd.openofficeorg.extension": {
	source: "apache",
	extensions: [
		"oxt"
	]
},
	"application/vnd.openstreetmap.data+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osm"
	]
},
	"application/vnd.opentimestamps.ots": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.custom-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.customxmlproperties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawing+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chart+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.chartshapes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramcolors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramdata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramlayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.drawingml.diagramstyle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.extended-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.commentauthors+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.handoutmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesmaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.notesslide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation": {
	source: "iana",
	compressible: false,
	extensions: [
		"pptx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.presentation.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.presprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide": {
	source: "iana",
	extensions: [
		"sldx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slide+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidelayout+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slidemaster+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow": {
	source: "iana",
	extensions: [
		"ppsx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideshow.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.slideupdateinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tablestyles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.tags+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.template": {
	source: "iana",
	extensions: [
		"potx"
	]
},
	"application/vnd.openxmlformats-officedocument.presentationml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.presentationml.viewprops+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.calcchain+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.chartsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.connections+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.dialogsheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.externallink+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcachedefinition+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivotcacherecords+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.pivottable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.querytable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionheaders+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.revisionlog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sharedstrings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet": {
	source: "iana",
	compressible: false,
	extensions: [
		"xlsx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.sheetmetadata+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.table+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.tablesinglecells+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template": {
	source: "iana",
	extensions: [
		"xltx"
	]
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.usernames+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.volatiledependencies+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.spreadsheetml.worksheet+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.theme+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.themeoverride+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.vmldrawing": {
	source: "iana"
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.comments+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document": {
	source: "iana",
	compressible: false,
	extensions: [
		"docx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.glossary+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.document.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.endnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.fonttable+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footer+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.footnotes+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.numbering+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.settings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.styles+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template": {
	source: "iana",
	extensions: [
		"dotx"
	]
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.template.main+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-officedocument.wordprocessingml.websettings+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.core-properties+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.digital-signature-xmlsignature+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.openxmlformats-package.relationships+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oracle.resource+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.orange.indata": {
	source: "iana"
},
	"application/vnd.osa.netdeploy": {
	source: "iana"
},
	"application/vnd.osgeo.mapguide.package": {
	source: "iana",
	extensions: [
		"mgp"
	]
},
	"application/vnd.osgi.bundle": {
	source: "iana"
},
	"application/vnd.osgi.dp": {
	source: "iana",
	extensions: [
		"dp"
	]
},
	"application/vnd.osgi.subsystem": {
	source: "iana",
	extensions: [
		"esa"
	]
},
	"application/vnd.otps.ct-kip+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.oxli.countgraph": {
	source: "iana"
},
	"application/vnd.pagerduty+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.palm": {
	source: "iana",
	extensions: [
		"pdb",
		"pqa",
		"oprc"
	]
},
	"application/vnd.panoply": {
	source: "iana"
},
	"application/vnd.paos.xml": {
	source: "iana"
},
	"application/vnd.patentdive": {
	source: "iana"
},
	"application/vnd.patientecommsdoc": {
	source: "iana"
},
	"application/vnd.pawaafile": {
	source: "iana",
	extensions: [
		"paw"
	]
},
	"application/vnd.pcos": {
	source: "iana"
},
	"application/vnd.pg.format": {
	source: "iana",
	extensions: [
		"str"
	]
},
	"application/vnd.pg.osasli": {
	source: "iana",
	extensions: [
		"ei6"
	]
},
	"application/vnd.piaccess.application-licence": {
	source: "iana"
},
	"application/vnd.picsel": {
	source: "iana",
	extensions: [
		"efif"
	]
},
	"application/vnd.pmi.widget": {
	source: "iana",
	extensions: [
		"wg"
	]
},
	"application/vnd.poc.group-advertisement+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.pocketlearn": {
	source: "iana",
	extensions: [
		"plf"
	]
},
	"application/vnd.powerbuilder6": {
	source: "iana",
	extensions: [
		"pbd"
	]
},
	"application/vnd.powerbuilder6-s": {
	source: "iana"
},
	"application/vnd.powerbuilder7": {
	source: "iana"
},
	"application/vnd.powerbuilder7-s": {
	source: "iana"
},
	"application/vnd.powerbuilder75": {
	source: "iana"
},
	"application/vnd.powerbuilder75-s": {
	source: "iana"
},
	"application/vnd.preminet": {
	source: "iana"
},
	"application/vnd.previewsystems.box": {
	source: "iana",
	extensions: [
		"box"
	]
},
	"application/vnd.proteus.magazine": {
	source: "iana",
	extensions: [
		"mgz"
	]
},
	"application/vnd.psfs": {
	source: "iana"
},
	"application/vnd.publishare-delta-tree": {
	source: "iana",
	extensions: [
		"qps"
	]
},
	"application/vnd.pvi.ptid1": {
	source: "iana",
	extensions: [
		"ptid"
	]
},
	"application/vnd.pwg-multiplexed": {
	source: "iana"
},
	"application/vnd.pwg-xhtml-print+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.qualcomm.brew-app-res": {
	source: "iana"
},
	"application/vnd.quarantainenet": {
	source: "iana"
},
	"application/vnd.quark.quarkxpress": {
	source: "iana",
	extensions: [
		"qxd",
		"qxt",
		"qwd",
		"qwt",
		"qxl",
		"qxb"
	]
},
	"application/vnd.quobject-quoxdocument": {
	source: "iana"
},
	"application/vnd.radisys.moml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-conn+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-audit-stream+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-conf+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-base+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-detect+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-fax-sendrecv+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-group+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-speech+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.radisys.msml-dialog-transform+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.rainstor.data": {
	source: "iana"
},
	"application/vnd.rapid": {
	source: "iana"
},
	"application/vnd.rar": {
	source: "iana",
	extensions: [
		"rar"
	]
},
	"application/vnd.realvnc.bed": {
	source: "iana",
	extensions: [
		"bed"
	]
},
	"application/vnd.recordare.musicxml": {
	source: "iana",
	extensions: [
		"mxl"
	]
},
	"application/vnd.recordare.musicxml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"musicxml"
	]
},
	"application/vnd.renlearn.rlprint": {
	source: "iana"
},
	"application/vnd.resilient.logic": {
	source: "iana"
},
	"application/vnd.restful+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.rig.cryptonote": {
	source: "iana",
	extensions: [
		"cryptonote"
	]
},
	"application/vnd.rim.cod": {
	source: "apache",
	extensions: [
		"cod"
	]
},
	"application/vnd.rn-realmedia": {
	source: "apache",
	extensions: [
		"rm"
	]
},
	"application/vnd.rn-realmedia-vbr": {
	source: "apache",
	extensions: [
		"rmvb"
	]
},
	"application/vnd.route66.link66+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"link66"
	]
},
	"application/vnd.rs-274x": {
	source: "iana"
},
	"application/vnd.ruckus.download": {
	source: "iana"
},
	"application/vnd.s3sms": {
	source: "iana"
},
	"application/vnd.sailingtracker.track": {
	source: "iana",
	extensions: [
		"st"
	]
},
	"application/vnd.sar": {
	source: "iana"
},
	"application/vnd.sbm.cid": {
	source: "iana"
},
	"application/vnd.sbm.mid2": {
	source: "iana"
},
	"application/vnd.scribus": {
	source: "iana"
},
	"application/vnd.sealed.3df": {
	source: "iana"
},
	"application/vnd.sealed.csf": {
	source: "iana"
},
	"application/vnd.sealed.doc": {
	source: "iana"
},
	"application/vnd.sealed.eml": {
	source: "iana"
},
	"application/vnd.sealed.mht": {
	source: "iana"
},
	"application/vnd.sealed.net": {
	source: "iana"
},
	"application/vnd.sealed.ppt": {
	source: "iana"
},
	"application/vnd.sealed.tiff": {
	source: "iana"
},
	"application/vnd.sealed.xls": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.html": {
	source: "iana"
},
	"application/vnd.sealedmedia.softseal.pdf": {
	source: "iana"
},
	"application/vnd.seemail": {
	source: "iana",
	extensions: [
		"see"
	]
},
	"application/vnd.seis+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.sema": {
	source: "iana",
	extensions: [
		"sema"
	]
},
	"application/vnd.semd": {
	source: "iana",
	extensions: [
		"semd"
	]
},
	"application/vnd.semf": {
	source: "iana",
	extensions: [
		"semf"
	]
},
	"application/vnd.shade-save-file": {
	source: "iana"
},
	"application/vnd.shana.informed.formdata": {
	source: "iana",
	extensions: [
		"ifm"
	]
},
	"application/vnd.shana.informed.formtemplate": {
	source: "iana",
	extensions: [
		"itp"
	]
},
	"application/vnd.shana.informed.interchange": {
	source: "iana",
	extensions: [
		"iif"
	]
},
	"application/vnd.shana.informed.package": {
	source: "iana",
	extensions: [
		"ipk"
	]
},
	"application/vnd.shootproof+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shopkick+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.shp": {
	source: "iana"
},
	"application/vnd.shx": {
	source: "iana"
},
	"application/vnd.sigrok.session": {
	source: "iana"
},
	"application/vnd.simtech-mindmapper": {
	source: "iana",
	extensions: [
		"twd",
		"twds"
	]
},
	"application/vnd.siren+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.smaf": {
	source: "iana",
	extensions: [
		"mmf"
	]
},
	"application/vnd.smart.notebook": {
	source: "iana"
},
	"application/vnd.smart.teacher": {
	source: "iana",
	extensions: [
		"teacher"
	]
},
	"application/vnd.snesdev-page-table": {
	source: "iana"
},
	"application/vnd.software602.filler.form+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"fo"
	]
},
	"application/vnd.software602.filler.form-xml-zip": {
	source: "iana"
},
	"application/vnd.solent.sdkm+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"sdkm",
		"sdkd"
	]
},
	"application/vnd.spotfire.dxp": {
	source: "iana",
	extensions: [
		"dxp"
	]
},
	"application/vnd.spotfire.sfs": {
	source: "iana",
	extensions: [
		"sfs"
	]
},
	"application/vnd.sqlite3": {
	source: "iana"
},
	"application/vnd.sss-cod": {
	source: "iana"
},
	"application/vnd.sss-dtf": {
	source: "iana"
},
	"application/vnd.sss-ntf": {
	source: "iana"
},
	"application/vnd.stardivision.calc": {
	source: "apache",
	extensions: [
		"sdc"
	]
},
	"application/vnd.stardivision.draw": {
	source: "apache",
	extensions: [
		"sda"
	]
},
	"application/vnd.stardivision.impress": {
	source: "apache",
	extensions: [
		"sdd"
	]
},
	"application/vnd.stardivision.math": {
	source: "apache",
	extensions: [
		"smf"
	]
},
	"application/vnd.stardivision.writer": {
	source: "apache",
	extensions: [
		"sdw",
		"vor"
	]
},
	"application/vnd.stardivision.writer-global": {
	source: "apache",
	extensions: [
		"sgl"
	]
},
	"application/vnd.stepmania.package": {
	source: "iana",
	extensions: [
		"smzip"
	]
},
	"application/vnd.stepmania.stepchart": {
	source: "iana",
	extensions: [
		"sm"
	]
},
	"application/vnd.street-stream": {
	source: "iana"
},
	"application/vnd.sun.wadl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wadl"
	]
},
	"application/vnd.sun.xml.calc": {
	source: "apache",
	extensions: [
		"sxc"
	]
},
	"application/vnd.sun.xml.calc.template": {
	source: "apache",
	extensions: [
		"stc"
	]
},
	"application/vnd.sun.xml.draw": {
	source: "apache",
	extensions: [
		"sxd"
	]
},
	"application/vnd.sun.xml.draw.template": {
	source: "apache",
	extensions: [
		"std"
	]
},
	"application/vnd.sun.xml.impress": {
	source: "apache",
	extensions: [
		"sxi"
	]
},
	"application/vnd.sun.xml.impress.template": {
	source: "apache",
	extensions: [
		"sti"
	]
},
	"application/vnd.sun.xml.math": {
	source: "apache",
	extensions: [
		"sxm"
	]
},
	"application/vnd.sun.xml.writer": {
	source: "apache",
	extensions: [
		"sxw"
	]
},
	"application/vnd.sun.xml.writer.global": {
	source: "apache",
	extensions: [
		"sxg"
	]
},
	"application/vnd.sun.xml.writer.template": {
	source: "apache",
	extensions: [
		"stw"
	]
},
	"application/vnd.sus-calendar": {
	source: "iana",
	extensions: [
		"sus",
		"susp"
	]
},
	"application/vnd.svd": {
	source: "iana",
	extensions: [
		"svd"
	]
},
	"application/vnd.swiftview-ics": {
	source: "iana"
},
	"application/vnd.sycle+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.symbian.install": {
	source: "apache",
	extensions: [
		"sis",
		"sisx"
	]
},
	"application/vnd.syncml+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xsm"
	]
},
	"application/vnd.syncml.dm+wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"bdm"
	]
},
	"application/vnd.syncml.dm+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"xdm"
	]
},
	"application/vnd.syncml.dm.notification": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmddf+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"ddf"
	]
},
	"application/vnd.syncml.dmtnds+wbxml": {
	source: "iana"
},
	"application/vnd.syncml.dmtnds+xml": {
	source: "iana",
	charset: "UTF-8",
	compressible: true
},
	"application/vnd.syncml.ds.notification": {
	source: "iana"
},
	"application/vnd.tableschema+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tao.intent-module-archive": {
	source: "iana",
	extensions: [
		"tao"
	]
},
	"application/vnd.tcpdump.pcap": {
	source: "iana",
	extensions: [
		"pcap",
		"cap",
		"dmp"
	]
},
	"application/vnd.think-cell.ppttc+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.tmd.mediaflex.api+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.tml": {
	source: "iana"
},
	"application/vnd.tmobile-livetv": {
	source: "iana",
	extensions: [
		"tmo"
	]
},
	"application/vnd.tri.onesource": {
	source: "iana"
},
	"application/vnd.trid.tpt": {
	source: "iana",
	extensions: [
		"tpt"
	]
},
	"application/vnd.triscape.mxs": {
	source: "iana",
	extensions: [
		"mxs"
	]
},
	"application/vnd.trueapp": {
	source: "iana",
	extensions: [
		"tra"
	]
},
	"application/vnd.truedoc": {
	source: "iana"
},
	"application/vnd.ubisoft.webplayer": {
	source: "iana"
},
	"application/vnd.ufdl": {
	source: "iana",
	extensions: [
		"ufd",
		"ufdl"
	]
},
	"application/vnd.uiq.theme": {
	source: "iana",
	extensions: [
		"utz"
	]
},
	"application/vnd.umajin": {
	source: "iana",
	extensions: [
		"umj"
	]
},
	"application/vnd.unity": {
	source: "iana",
	extensions: [
		"unityweb"
	]
},
	"application/vnd.uoml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"uoml"
	]
},
	"application/vnd.uplanet.alert": {
	source: "iana"
},
	"application/vnd.uplanet.alert-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice": {
	source: "iana"
},
	"application/vnd.uplanet.bearer-choice-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop": {
	source: "iana"
},
	"application/vnd.uplanet.cacheop-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.channel": {
	source: "iana"
},
	"application/vnd.uplanet.channel-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.list": {
	source: "iana"
},
	"application/vnd.uplanet.list-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd": {
	source: "iana"
},
	"application/vnd.uplanet.listcmd-wbxml": {
	source: "iana"
},
	"application/vnd.uplanet.signal": {
	source: "iana"
},
	"application/vnd.uri-map": {
	source: "iana"
},
	"application/vnd.valve.source.material": {
	source: "iana"
},
	"application/vnd.vcx": {
	source: "iana",
	extensions: [
		"vcx"
	]
},
	"application/vnd.vd-study": {
	source: "iana"
},
	"application/vnd.vectorworks": {
	source: "iana"
},
	"application/vnd.vel+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.verimatrix.vcas": {
	source: "iana"
},
	"application/vnd.veritone.aion+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.veryant.thin": {
	source: "iana"
},
	"application/vnd.ves.encrypted": {
	source: "iana"
},
	"application/vnd.vidsoft.vidconference": {
	source: "iana"
},
	"application/vnd.visio": {
	source: "iana",
	extensions: [
		"vsd",
		"vst",
		"vss",
		"vsw"
	]
},
	"application/vnd.visionary": {
	source: "iana",
	extensions: [
		"vis"
	]
},
	"application/vnd.vividence.scriptfile": {
	source: "iana"
},
	"application/vnd.vsf": {
	source: "iana",
	extensions: [
		"vsf"
	]
},
	"application/vnd.wap.sic": {
	source: "iana"
},
	"application/vnd.wap.slc": {
	source: "iana"
},
	"application/vnd.wap.wbxml": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"wbxml"
	]
},
	"application/vnd.wap.wmlc": {
	source: "iana",
	extensions: [
		"wmlc"
	]
},
	"application/vnd.wap.wmlscriptc": {
	source: "iana",
	extensions: [
		"wmlsc"
	]
},
	"application/vnd.webturbo": {
	source: "iana",
	extensions: [
		"wtb"
	]
},
	"application/vnd.wfa.dpp": {
	source: "iana"
},
	"application/vnd.wfa.p2p": {
	source: "iana"
},
	"application/vnd.wfa.wsc": {
	source: "iana"
},
	"application/vnd.windows.devicepairing": {
	source: "iana"
},
	"application/vnd.wmc": {
	source: "iana"
},
	"application/vnd.wmf.bootstrap": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica": {
	source: "iana"
},
	"application/vnd.wolfram.mathematica.package": {
	source: "iana"
},
	"application/vnd.wolfram.player": {
	source: "iana",
	extensions: [
		"nbp"
	]
},
	"application/vnd.wordperfect": {
	source: "iana",
	extensions: [
		"wpd"
	]
},
	"application/vnd.wqd": {
	source: "iana",
	extensions: [
		"wqd"
	]
},
	"application/vnd.wrq-hp3000-labelled": {
	source: "iana"
},
	"application/vnd.wt.stf": {
	source: "iana",
	extensions: [
		"stf"
	]
},
	"application/vnd.wv.csp+wbxml": {
	source: "iana"
},
	"application/vnd.wv.csp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.wv.ssp+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xacml+json": {
	source: "iana",
	compressible: true
},
	"application/vnd.xara": {
	source: "iana",
	extensions: [
		"xar"
	]
},
	"application/vnd.xfdl": {
	source: "iana",
	extensions: [
		"xfdl"
	]
},
	"application/vnd.xfdl.webform": {
	source: "iana"
},
	"application/vnd.xmi+xml": {
	source: "iana",
	compressible: true
},
	"application/vnd.xmpie.cpkg": {
	source: "iana"
},
	"application/vnd.xmpie.dpkg": {
	source: "iana"
},
	"application/vnd.xmpie.plan": {
	source: "iana"
},
	"application/vnd.xmpie.ppkg": {
	source: "iana"
},
	"application/vnd.xmpie.xlim": {
	source: "iana"
},
	"application/vnd.yamaha.hv-dic": {
	source: "iana",
	extensions: [
		"hvd"
	]
},
	"application/vnd.yamaha.hv-script": {
	source: "iana",
	extensions: [
		"hvs"
	]
},
	"application/vnd.yamaha.hv-voice": {
	source: "iana",
	extensions: [
		"hvp"
	]
},
	"application/vnd.yamaha.openscoreformat": {
	source: "iana",
	extensions: [
		"osf"
	]
},
	"application/vnd.yamaha.openscoreformat.osfpvg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"osfpvg"
	]
},
	"application/vnd.yamaha.remote-setup": {
	source: "iana"
},
	"application/vnd.yamaha.smaf-audio": {
	source: "iana",
	extensions: [
		"saf"
	]
},
	"application/vnd.yamaha.smaf-phrase": {
	source: "iana",
	extensions: [
		"spf"
	]
},
	"application/vnd.yamaha.through-ngn": {
	source: "iana"
},
	"application/vnd.yamaha.tunnel-udpencap": {
	source: "iana"
},
	"application/vnd.yaoweme": {
	source: "iana"
},
	"application/vnd.yellowriver-custom-menu": {
	source: "iana",
	extensions: [
		"cmp"
	]
},
	"application/vnd.youtube.yt": {
	source: "iana"
},
	"application/vnd.zul": {
	source: "iana",
	extensions: [
		"zir",
		"zirz"
	]
},
	"application/vnd.zzazz.deck+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"zaz"
	]
},
	"application/voicexml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"vxml"
	]
},
	"application/voucher-cms+json": {
	source: "iana",
	compressible: true
},
	"application/vq-rtcpxr": {
	source: "iana"
},
	"application/wasm": {
	source: "iana",
	compressible: true,
	extensions: [
		"wasm"
	]
},
	"application/watcherinfo+xml": {
	source: "iana",
	compressible: true
},
	"application/webpush-options+json": {
	source: "iana",
	compressible: true
},
	"application/whoispp-query": {
	source: "iana"
},
	"application/whoispp-response": {
	source: "iana"
},
	"application/widget": {
	source: "iana",
	extensions: [
		"wgt"
	]
},
	"application/winhlp": {
	source: "apache",
	extensions: [
		"hlp"
	]
},
	"application/wita": {
	source: "iana"
},
	"application/wordperfect5.1": {
	source: "iana"
},
	"application/wsdl+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wsdl"
	]
},
	"application/wspolicy+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"wspolicy"
	]
},
	"application/x-7z-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"7z"
	]
},
	"application/x-abiword": {
	source: "apache",
	extensions: [
		"abw"
	]
},
	"application/x-ace-compressed": {
	source: "apache",
	extensions: [
		"ace"
	]
},
	"application/x-amf": {
	source: "apache"
},
	"application/x-apple-diskimage": {
	source: "apache",
	extensions: [
		"dmg"
	]
},
	"application/x-arj": {
	compressible: false,
	extensions: [
		"arj"
	]
},
	"application/x-authorware-bin": {
	source: "apache",
	extensions: [
		"aab",
		"x32",
		"u32",
		"vox"
	]
},
	"application/x-authorware-map": {
	source: "apache",
	extensions: [
		"aam"
	]
},
	"application/x-authorware-seg": {
	source: "apache",
	extensions: [
		"aas"
	]
},
	"application/x-bcpio": {
	source: "apache",
	extensions: [
		"bcpio"
	]
},
	"application/x-bdoc": {
	compressible: false,
	extensions: [
		"bdoc"
	]
},
	"application/x-bittorrent": {
	source: "apache",
	extensions: [
		"torrent"
	]
},
	"application/x-blorb": {
	source: "apache",
	extensions: [
		"blb",
		"blorb"
	]
},
	"application/x-bzip": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz"
	]
},
	"application/x-bzip2": {
	source: "apache",
	compressible: false,
	extensions: [
		"bz2",
		"boz"
	]
},
	"application/x-cbr": {
	source: "apache",
	extensions: [
		"cbr",
		"cba",
		"cbt",
		"cbz",
		"cb7"
	]
},
	"application/x-cdlink": {
	source: "apache",
	extensions: [
		"vcd"
	]
},
	"application/x-cfs-compressed": {
	source: "apache",
	extensions: [
		"cfs"
	]
},
	"application/x-chat": {
	source: "apache",
	extensions: [
		"chat"
	]
},
	"application/x-chess-pgn": {
	source: "apache",
	extensions: [
		"pgn"
	]
},
	"application/x-chrome-extension": {
	extensions: [
		"crx"
	]
},
	"application/x-cocoa": {
	source: "nginx",
	extensions: [
		"cco"
	]
},
	"application/x-compress": {
	source: "apache"
},
	"application/x-conference": {
	source: "apache",
	extensions: [
		"nsc"
	]
},
	"application/x-cpio": {
	source: "apache",
	extensions: [
		"cpio"
	]
},
	"application/x-csh": {
	source: "apache",
	extensions: [
		"csh"
	]
},
	"application/x-deb": {
	compressible: false
},
	"application/x-debian-package": {
	source: "apache",
	extensions: [
		"deb",
		"udeb"
	]
},
	"application/x-dgc-compressed": {
	source: "apache",
	extensions: [
		"dgc"
	]
},
	"application/x-director": {
	source: "apache",
	extensions: [
		"dir",
		"dcr",
		"dxr",
		"cst",
		"cct",
		"cxt",
		"w3d",
		"fgd",
		"swa"
	]
},
	"application/x-doom": {
	source: "apache",
	extensions: [
		"wad"
	]
},
	"application/x-dtbncx+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"ncx"
	]
},
	"application/x-dtbook+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"dtb"
	]
},
	"application/x-dtbresource+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"res"
	]
},
	"application/x-dvi": {
	source: "apache",
	compressible: false,
	extensions: [
		"dvi"
	]
},
	"application/x-envoy": {
	source: "apache",
	extensions: [
		"evy"
	]
},
	"application/x-eva": {
	source: "apache",
	extensions: [
		"eva"
	]
},
	"application/x-font-bdf": {
	source: "apache",
	extensions: [
		"bdf"
	]
},
	"application/x-font-dos": {
	source: "apache"
},
	"application/x-font-framemaker": {
	source: "apache"
},
	"application/x-font-ghostscript": {
	source: "apache",
	extensions: [
		"gsf"
	]
},
	"application/x-font-libgrx": {
	source: "apache"
},
	"application/x-font-linux-psf": {
	source: "apache",
	extensions: [
		"psf"
	]
},
	"application/x-font-pcf": {
	source: "apache",
	extensions: [
		"pcf"
	]
},
	"application/x-font-snf": {
	source: "apache",
	extensions: [
		"snf"
	]
},
	"application/x-font-speedo": {
	source: "apache"
},
	"application/x-font-sunos-news": {
	source: "apache"
},
	"application/x-font-type1": {
	source: "apache",
	extensions: [
		"pfa",
		"pfb",
		"pfm",
		"afm"
	]
},
	"application/x-font-vfont": {
	source: "apache"
},
	"application/x-freearc": {
	source: "apache",
	extensions: [
		"arc"
	]
},
	"application/x-futuresplash": {
	source: "apache",
	extensions: [
		"spl"
	]
},
	"application/x-gca-compressed": {
	source: "apache",
	extensions: [
		"gca"
	]
},
	"application/x-glulx": {
	source: "apache",
	extensions: [
		"ulx"
	]
},
	"application/x-gnumeric": {
	source: "apache",
	extensions: [
		"gnumeric"
	]
},
	"application/x-gramps-xml": {
	source: "apache",
	extensions: [
		"gramps"
	]
},
	"application/x-gtar": {
	source: "apache",
	extensions: [
		"gtar"
	]
},
	"application/x-gzip": {
	source: "apache"
},
	"application/x-hdf": {
	source: "apache",
	extensions: [
		"hdf"
	]
},
	"application/x-httpd-php": {
	compressible: true,
	extensions: [
		"php"
	]
},
	"application/x-install-instructions": {
	source: "apache",
	extensions: [
		"install"
	]
},
	"application/x-iso9660-image": {
	source: "apache",
	extensions: [
		"iso"
	]
},
	"application/x-java-archive-diff": {
	source: "nginx",
	extensions: [
		"jardiff"
	]
},
	"application/x-java-jnlp-file": {
	source: "apache",
	compressible: false,
	extensions: [
		"jnlp"
	]
},
	"application/x-javascript": {
	compressible: true
},
	"application/x-keepass2": {
	extensions: [
		"kdbx"
	]
},
	"application/x-latex": {
	source: "apache",
	compressible: false,
	extensions: [
		"latex"
	]
},
	"application/x-lua-bytecode": {
	extensions: [
		"luac"
	]
},
	"application/x-lzh-compressed": {
	source: "apache",
	extensions: [
		"lzh",
		"lha"
	]
},
	"application/x-makeself": {
	source: "nginx",
	extensions: [
		"run"
	]
},
	"application/x-mie": {
	source: "apache",
	extensions: [
		"mie"
	]
},
	"application/x-mobipocket-ebook": {
	source: "apache",
	extensions: [
		"prc",
		"mobi"
	]
},
	"application/x-mpegurl": {
	compressible: false
},
	"application/x-ms-application": {
	source: "apache",
	extensions: [
		"application"
	]
},
	"application/x-ms-shortcut": {
	source: "apache",
	extensions: [
		"lnk"
	]
},
	"application/x-ms-wmd": {
	source: "apache",
	extensions: [
		"wmd"
	]
},
	"application/x-ms-wmz": {
	source: "apache",
	extensions: [
		"wmz"
	]
},
	"application/x-ms-xbap": {
	source: "apache",
	extensions: [
		"xbap"
	]
},
	"application/x-msaccess": {
	source: "apache",
	extensions: [
		"mdb"
	]
},
	"application/x-msbinder": {
	source: "apache",
	extensions: [
		"obd"
	]
},
	"application/x-mscardfile": {
	source: "apache",
	extensions: [
		"crd"
	]
},
	"application/x-msclip": {
	source: "apache",
	extensions: [
		"clp"
	]
},
	"application/x-msdos-program": {
	extensions: [
		"exe"
	]
},
	"application/x-msdownload": {
	source: "apache",
	extensions: [
		"exe",
		"dll",
		"com",
		"bat",
		"msi"
	]
},
	"application/x-msmediaview": {
	source: "apache",
	extensions: [
		"mvb",
		"m13",
		"m14"
	]
},
	"application/x-msmetafile": {
	source: "apache",
	extensions: [
		"wmf",
		"wmz",
		"emf",
		"emz"
	]
},
	"application/x-msmoney": {
	source: "apache",
	extensions: [
		"mny"
	]
},
	"application/x-mspublisher": {
	source: "apache",
	extensions: [
		"pub"
	]
},
	"application/x-msschedule": {
	source: "apache",
	extensions: [
		"scd"
	]
},
	"application/x-msterminal": {
	source: "apache",
	extensions: [
		"trm"
	]
},
	"application/x-mswrite": {
	source: "apache",
	extensions: [
		"wri"
	]
},
	"application/x-netcdf": {
	source: "apache",
	extensions: [
		"nc",
		"cdf"
	]
},
	"application/x-ns-proxy-autoconfig": {
	compressible: true,
	extensions: [
		"pac"
	]
},
	"application/x-nzb": {
	source: "apache",
	extensions: [
		"nzb"
	]
},
	"application/x-perl": {
	source: "nginx",
	extensions: [
		"pl",
		"pm"
	]
},
	"application/x-pilot": {
	source: "nginx",
	extensions: [
		"prc",
		"pdb"
	]
},
	"application/x-pkcs12": {
	source: "apache",
	compressible: false,
	extensions: [
		"p12",
		"pfx"
	]
},
	"application/x-pkcs7-certificates": {
	source: "apache",
	extensions: [
		"p7b",
		"spc"
	]
},
	"application/x-pkcs7-certreqresp": {
	source: "apache",
	extensions: [
		"p7r"
	]
},
	"application/x-pki-message": {
	source: "iana"
},
	"application/x-rar-compressed": {
	source: "apache",
	compressible: false,
	extensions: [
		"rar"
	]
},
	"application/x-redhat-package-manager": {
	source: "nginx",
	extensions: [
		"rpm"
	]
},
	"application/x-research-info-systems": {
	source: "apache",
	extensions: [
		"ris"
	]
},
	"application/x-sea": {
	source: "nginx",
	extensions: [
		"sea"
	]
},
	"application/x-sh": {
	source: "apache",
	compressible: true,
	extensions: [
		"sh"
	]
},
	"application/x-shar": {
	source: "apache",
	extensions: [
		"shar"
	]
},
	"application/x-shockwave-flash": {
	source: "apache",
	compressible: false,
	extensions: [
		"swf"
	]
},
	"application/x-silverlight-app": {
	source: "apache",
	extensions: [
		"xap"
	]
},
	"application/x-sql": {
	source: "apache",
	extensions: [
		"sql"
	]
},
	"application/x-stuffit": {
	source: "apache",
	compressible: false,
	extensions: [
		"sit"
	]
},
	"application/x-stuffitx": {
	source: "apache",
	extensions: [
		"sitx"
	]
},
	"application/x-subrip": {
	source: "apache",
	extensions: [
		"srt"
	]
},
	"application/x-sv4cpio": {
	source: "apache",
	extensions: [
		"sv4cpio"
	]
},
	"application/x-sv4crc": {
	source: "apache",
	extensions: [
		"sv4crc"
	]
},
	"application/x-t3vm-image": {
	source: "apache",
	extensions: [
		"t3"
	]
},
	"application/x-tads": {
	source: "apache",
	extensions: [
		"gam"
	]
},
	"application/x-tar": {
	source: "apache",
	compressible: true,
	extensions: [
		"tar"
	]
},
	"application/x-tcl": {
	source: "apache",
	extensions: [
		"tcl",
		"tk"
	]
},
	"application/x-tex": {
	source: "apache",
	extensions: [
		"tex"
	]
},
	"application/x-tex-tfm": {
	source: "apache",
	extensions: [
		"tfm"
	]
},
	"application/x-texinfo": {
	source: "apache",
	extensions: [
		"texinfo",
		"texi"
	]
},
	"application/x-tgif": {
	source: "apache",
	extensions: [
		"obj"
	]
},
	"application/x-ustar": {
	source: "apache",
	extensions: [
		"ustar"
	]
},
	"application/x-virtualbox-hdd": {
	compressible: true,
	extensions: [
		"hdd"
	]
},
	"application/x-virtualbox-ova": {
	compressible: true,
	extensions: [
		"ova"
	]
},
	"application/x-virtualbox-ovf": {
	compressible: true,
	extensions: [
		"ovf"
	]
},
	"application/x-virtualbox-vbox": {
	compressible: true,
	extensions: [
		"vbox"
	]
},
	"application/x-virtualbox-vbox-extpack": {
	compressible: false,
	extensions: [
		"vbox-extpack"
	]
},
	"application/x-virtualbox-vdi": {
	compressible: true,
	extensions: [
		"vdi"
	]
},
	"application/x-virtualbox-vhd": {
	compressible: true,
	extensions: [
		"vhd"
	]
},
	"application/x-virtualbox-vmdk": {
	compressible: true,
	extensions: [
		"vmdk"
	]
},
	"application/x-wais-source": {
	source: "apache",
	extensions: [
		"src"
	]
},
	"application/x-web-app-manifest+json": {
	compressible: true,
	extensions: [
		"webapp"
	]
},
	"application/x-www-form-urlencoded": {
	source: "iana",
	compressible: true
},
	"application/x-x509-ca-cert": {
	source: "iana",
	extensions: [
		"der",
		"crt",
		"pem"
	]
},
	"application/x-x509-ca-ra-cert": {
	source: "iana"
},
	"application/x-x509-next-ca-cert": {
	source: "iana"
},
	"application/x-xfig": {
	source: "apache",
	extensions: [
		"fig"
	]
},
	"application/x-xliff+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/x-xpinstall": {
	source: "apache",
	compressible: false,
	extensions: [
		"xpi"
	]
},
	"application/x-xz": {
	source: "apache",
	extensions: [
		"xz"
	]
},
	"application/x-zmachine": {
	source: "apache",
	extensions: [
		"z1",
		"z2",
		"z3",
		"z4",
		"z5",
		"z6",
		"z7",
		"z8"
	]
},
	"application/x400-bp": {
	source: "iana"
},
	"application/xacml+xml": {
	source: "iana",
	compressible: true
},
	"application/xaml+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xaml"
	]
},
	"application/xcap-att+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xav"
	]
},
	"application/xcap-caps+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xca"
	]
},
	"application/xcap-diff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xdf"
	]
},
	"application/xcap-el+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xel"
	]
},
	"application/xcap-error+xml": {
	source: "iana",
	compressible: true
},
	"application/xcap-ns+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xns"
	]
},
	"application/xcon-conference-info+xml": {
	source: "iana",
	compressible: true
},
	"application/xcon-conference-info-diff+xml": {
	source: "iana",
	compressible: true
},
	"application/xenc+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xenc"
	]
},
	"application/xhtml+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xhtml",
		"xht"
	]
},
	"application/xhtml-voice+xml": {
	source: "apache",
	compressible: true
},
	"application/xliff+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xlf"
	]
},
	"application/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml",
		"xsl",
		"xsd",
		"rng"
	]
},
	"application/xml-dtd": {
	source: "iana",
	compressible: true,
	extensions: [
		"dtd"
	]
},
	"application/xml-external-parsed-entity": {
	source: "iana"
},
	"application/xml-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/xmpp+xml": {
	source: "iana",
	compressible: true
},
	"application/xop+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xop"
	]
},
	"application/xproc+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xpl"
	]
},
	"application/xslt+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xsl",
		"xslt"
	]
},
	"application/xspf+xml": {
	source: "apache",
	compressible: true,
	extensions: [
		"xspf"
	]
},
	"application/xv+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"mxml",
		"xhvml",
		"xvml",
		"xvm"
	]
},
	"application/yang": {
	source: "iana",
	extensions: [
		"yang"
	]
},
	"application/yang-data+json": {
	source: "iana",
	compressible: true
},
	"application/yang-data+xml": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+json": {
	source: "iana",
	compressible: true
},
	"application/yang-patch+xml": {
	source: "iana",
	compressible: true
},
	"application/yin+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"yin"
	]
},
	"application/zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"zip"
	]
},
	"application/zlib": {
	source: "iana"
},
	"application/zstd": {
	source: "iana"
},
	"audio/1d-interleaved-parityfec": {
	source: "iana"
},
	"audio/32kadpcm": {
	source: "iana"
},
	"audio/3gpp": {
	source: "iana",
	compressible: false,
	extensions: [
		"3gpp"
	]
},
	"audio/3gpp2": {
	source: "iana"
},
	"audio/aac": {
	source: "iana"
},
	"audio/ac3": {
	source: "iana"
},
	"audio/adpcm": {
	source: "apache",
	extensions: [
		"adp"
	]
},
	"audio/amr": {
	source: "iana",
	extensions: [
		"amr"
	]
},
	"audio/amr-wb": {
	source: "iana"
},
	"audio/amr-wb+": {
	source: "iana"
},
	"audio/aptx": {
	source: "iana"
},
	"audio/asc": {
	source: "iana"
},
	"audio/atrac-advanced-lossless": {
	source: "iana"
},
	"audio/atrac-x": {
	source: "iana"
},
	"audio/atrac3": {
	source: "iana"
},
	"audio/basic": {
	source: "iana",
	compressible: false,
	extensions: [
		"au",
		"snd"
	]
},
	"audio/bv16": {
	source: "iana"
},
	"audio/bv32": {
	source: "iana"
},
	"audio/clearmode": {
	source: "iana"
},
	"audio/cn": {
	source: "iana"
},
	"audio/dat12": {
	source: "iana"
},
	"audio/dls": {
	source: "iana"
},
	"audio/dsr-es201108": {
	source: "iana"
},
	"audio/dsr-es202050": {
	source: "iana"
},
	"audio/dsr-es202211": {
	source: "iana"
},
	"audio/dsr-es202212": {
	source: "iana"
},
	"audio/dv": {
	source: "iana"
},
	"audio/dvi4": {
	source: "iana"
},
	"audio/eac3": {
	source: "iana"
},
	"audio/encaprtp": {
	source: "iana"
},
	"audio/evrc": {
	source: "iana"
},
	"audio/evrc-qcp": {
	source: "iana"
},
	"audio/evrc0": {
	source: "iana"
},
	"audio/evrc1": {
	source: "iana"
},
	"audio/evrcb": {
	source: "iana"
},
	"audio/evrcb0": {
	source: "iana"
},
	"audio/evrcb1": {
	source: "iana"
},
	"audio/evrcnw": {
	source: "iana"
},
	"audio/evrcnw0": {
	source: "iana"
},
	"audio/evrcnw1": {
	source: "iana"
},
	"audio/evrcwb": {
	source: "iana"
},
	"audio/evrcwb0": {
	source: "iana"
},
	"audio/evrcwb1": {
	source: "iana"
},
	"audio/evs": {
	source: "iana"
},
	"audio/flexfec": {
	source: "iana"
},
	"audio/fwdred": {
	source: "iana"
},
	"audio/g711-0": {
	source: "iana"
},
	"audio/g719": {
	source: "iana"
},
	"audio/g722": {
	source: "iana"
},
	"audio/g7221": {
	source: "iana"
},
	"audio/g723": {
	source: "iana"
},
	"audio/g726-16": {
	source: "iana"
},
	"audio/g726-24": {
	source: "iana"
},
	"audio/g726-32": {
	source: "iana"
},
	"audio/g726-40": {
	source: "iana"
},
	"audio/g728": {
	source: "iana"
},
	"audio/g729": {
	source: "iana"
},
	"audio/g7291": {
	source: "iana"
},
	"audio/g729d": {
	source: "iana"
},
	"audio/g729e": {
	source: "iana"
},
	"audio/gsm": {
	source: "iana"
},
	"audio/gsm-efr": {
	source: "iana"
},
	"audio/gsm-hr-08": {
	source: "iana"
},
	"audio/ilbc": {
	source: "iana"
},
	"audio/ip-mr_v2.5": {
	source: "iana"
},
	"audio/isac": {
	source: "apache"
},
	"audio/l16": {
	source: "iana"
},
	"audio/l20": {
	source: "iana"
},
	"audio/l24": {
	source: "iana",
	compressible: false
},
	"audio/l8": {
	source: "iana"
},
	"audio/lpc": {
	source: "iana"
},
	"audio/melp": {
	source: "iana"
},
	"audio/melp1200": {
	source: "iana"
},
	"audio/melp2400": {
	source: "iana"
},
	"audio/melp600": {
	source: "iana"
},
	"audio/mhas": {
	source: "iana"
},
	"audio/midi": {
	source: "apache",
	extensions: [
		"mid",
		"midi",
		"kar",
		"rmi"
	]
},
	"audio/mobile-xmf": {
	source: "iana",
	extensions: [
		"mxmf"
	]
},
	"audio/mp3": {
	compressible: false,
	extensions: [
		"mp3"
	]
},
	"audio/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"m4a",
		"mp4a"
	]
},
	"audio/mp4a-latm": {
	source: "iana"
},
	"audio/mpa": {
	source: "iana"
},
	"audio/mpa-robust": {
	source: "iana"
},
	"audio/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpga",
		"mp2",
		"mp2a",
		"mp3",
		"m2a",
		"m3a"
	]
},
	"audio/mpeg4-generic": {
	source: "iana"
},
	"audio/musepack": {
	source: "apache"
},
	"audio/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"oga",
		"ogg",
		"spx",
		"opus"
	]
},
	"audio/opus": {
	source: "iana"
},
	"audio/parityfec": {
	source: "iana"
},
	"audio/pcma": {
	source: "iana"
},
	"audio/pcma-wb": {
	source: "iana"
},
	"audio/pcmu": {
	source: "iana"
},
	"audio/pcmu-wb": {
	source: "iana"
},
	"audio/prs.sid": {
	source: "iana"
},
	"audio/qcelp": {
	source: "iana"
},
	"audio/raptorfec": {
	source: "iana"
},
	"audio/red": {
	source: "iana"
},
	"audio/rtp-enc-aescm128": {
	source: "iana"
},
	"audio/rtp-midi": {
	source: "iana"
},
	"audio/rtploopback": {
	source: "iana"
},
	"audio/rtx": {
	source: "iana"
},
	"audio/s3m": {
	source: "apache",
	extensions: [
		"s3m"
	]
},
	"audio/scip": {
	source: "iana"
},
	"audio/silk": {
	source: "apache",
	extensions: [
		"sil"
	]
},
	"audio/smv": {
	source: "iana"
},
	"audio/smv-qcp": {
	source: "iana"
},
	"audio/smv0": {
	source: "iana"
},
	"audio/sofa": {
	source: "iana"
},
	"audio/sp-midi": {
	source: "iana"
},
	"audio/speex": {
	source: "iana"
},
	"audio/t140c": {
	source: "iana"
},
	"audio/t38": {
	source: "iana"
},
	"audio/telephone-event": {
	source: "iana"
},
	"audio/tetra_acelp": {
	source: "iana"
},
	"audio/tetra_acelp_bb": {
	source: "iana"
},
	"audio/tone": {
	source: "iana"
},
	"audio/tsvcis": {
	source: "iana"
},
	"audio/uemclip": {
	source: "iana"
},
	"audio/ulpfec": {
	source: "iana"
},
	"audio/usac": {
	source: "iana"
},
	"audio/vdvi": {
	source: "iana"
},
	"audio/vmr-wb": {
	source: "iana"
},
	"audio/vnd.3gpp.iufp": {
	source: "iana"
},
	"audio/vnd.4sb": {
	source: "iana"
},
	"audio/vnd.audiokoz": {
	source: "iana"
},
	"audio/vnd.celp": {
	source: "iana"
},
	"audio/vnd.cisco.nse": {
	source: "iana"
},
	"audio/vnd.cmles.radio-events": {
	source: "iana"
},
	"audio/vnd.cns.anp1": {
	source: "iana"
},
	"audio/vnd.cns.inf1": {
	source: "iana"
},
	"audio/vnd.dece.audio": {
	source: "iana",
	extensions: [
		"uva",
		"uvva"
	]
},
	"audio/vnd.digital-winds": {
	source: "iana",
	extensions: [
		"eol"
	]
},
	"audio/vnd.dlna.adts": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.1": {
	source: "iana"
},
	"audio/vnd.dolby.heaac.2": {
	source: "iana"
},
	"audio/vnd.dolby.mlp": {
	source: "iana"
},
	"audio/vnd.dolby.mps": {
	source: "iana"
},
	"audio/vnd.dolby.pl2": {
	source: "iana"
},
	"audio/vnd.dolby.pl2x": {
	source: "iana"
},
	"audio/vnd.dolby.pl2z": {
	source: "iana"
},
	"audio/vnd.dolby.pulse.1": {
	source: "iana"
},
	"audio/vnd.dra": {
	source: "iana",
	extensions: [
		"dra"
	]
},
	"audio/vnd.dts": {
	source: "iana",
	extensions: [
		"dts"
	]
},
	"audio/vnd.dts.hd": {
	source: "iana",
	extensions: [
		"dtshd"
	]
},
	"audio/vnd.dts.uhd": {
	source: "iana"
},
	"audio/vnd.dvb.file": {
	source: "iana"
},
	"audio/vnd.everad.plj": {
	source: "iana"
},
	"audio/vnd.hns.audio": {
	source: "iana"
},
	"audio/vnd.lucent.voice": {
	source: "iana",
	extensions: [
		"lvp"
	]
},
	"audio/vnd.ms-playready.media.pya": {
	source: "iana",
	extensions: [
		"pya"
	]
},
	"audio/vnd.nokia.mobile-xmf": {
	source: "iana"
},
	"audio/vnd.nortel.vbk": {
	source: "iana"
},
	"audio/vnd.nuera.ecelp4800": {
	source: "iana",
	extensions: [
		"ecelp4800"
	]
},
	"audio/vnd.nuera.ecelp7470": {
	source: "iana",
	extensions: [
		"ecelp7470"
	]
},
	"audio/vnd.nuera.ecelp9600": {
	source: "iana",
	extensions: [
		"ecelp9600"
	]
},
	"audio/vnd.octel.sbc": {
	source: "iana"
},
	"audio/vnd.presonus.multitrack": {
	source: "iana"
},
	"audio/vnd.qcelp": {
	source: "iana"
},
	"audio/vnd.rhetorex.32kadpcm": {
	source: "iana"
},
	"audio/vnd.rip": {
	source: "iana",
	extensions: [
		"rip"
	]
},
	"audio/vnd.rn-realaudio": {
	compressible: false
},
	"audio/vnd.sealedmedia.softseal.mpeg": {
	source: "iana"
},
	"audio/vnd.vmx.cvsd": {
	source: "iana"
},
	"audio/vnd.wave": {
	compressible: false
},
	"audio/vorbis": {
	source: "iana",
	compressible: false
},
	"audio/vorbis-config": {
	source: "iana"
},
	"audio/wav": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/wave": {
	compressible: false,
	extensions: [
		"wav"
	]
},
	"audio/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"weba"
	]
},
	"audio/x-aac": {
	source: "apache",
	compressible: false,
	extensions: [
		"aac"
	]
},
	"audio/x-aiff": {
	source: "apache",
	extensions: [
		"aif",
		"aiff",
		"aifc"
	]
},
	"audio/x-caf": {
	source: "apache",
	compressible: false,
	extensions: [
		"caf"
	]
},
	"audio/x-flac": {
	source: "apache",
	extensions: [
		"flac"
	]
},
	"audio/x-m4a": {
	source: "nginx",
	extensions: [
		"m4a"
	]
},
	"audio/x-matroska": {
	source: "apache",
	extensions: [
		"mka"
	]
},
	"audio/x-mpegurl": {
	source: "apache",
	extensions: [
		"m3u"
	]
},
	"audio/x-ms-wax": {
	source: "apache",
	extensions: [
		"wax"
	]
},
	"audio/x-ms-wma": {
	source: "apache",
	extensions: [
		"wma"
	]
},
	"audio/x-pn-realaudio": {
	source: "apache",
	extensions: [
		"ram",
		"ra"
	]
},
	"audio/x-pn-realaudio-plugin": {
	source: "apache",
	extensions: [
		"rmp"
	]
},
	"audio/x-realaudio": {
	source: "nginx",
	extensions: [
		"ra"
	]
},
	"audio/x-tta": {
	source: "apache"
},
	"audio/x-wav": {
	source: "apache",
	extensions: [
		"wav"
	]
},
	"audio/xm": {
	source: "apache",
	extensions: [
		"xm"
	]
},
	"chemical/x-cdx": {
	source: "apache",
	extensions: [
		"cdx"
	]
},
	"chemical/x-cif": {
	source: "apache",
	extensions: [
		"cif"
	]
},
	"chemical/x-cmdf": {
	source: "apache",
	extensions: [
		"cmdf"
	]
},
	"chemical/x-cml": {
	source: "apache",
	extensions: [
		"cml"
	]
},
	"chemical/x-csml": {
	source: "apache",
	extensions: [
		"csml"
	]
},
	"chemical/x-pdb": {
	source: "apache"
},
	"chemical/x-xyz": {
	source: "apache",
	extensions: [
		"xyz"
	]
},
	"font/collection": {
	source: "iana",
	extensions: [
		"ttc"
	]
},
	"font/otf": {
	source: "iana",
	compressible: true,
	extensions: [
		"otf"
	]
},
	"font/sfnt": {
	source: "iana"
},
	"font/ttf": {
	source: "iana",
	compressible: true,
	extensions: [
		"ttf"
	]
},
	"font/woff": {
	source: "iana",
	extensions: [
		"woff"
	]
},
	"font/woff2": {
	source: "iana",
	extensions: [
		"woff2"
	]
},
	"image/aces": {
	source: "iana",
	extensions: [
		"exr"
	]
},
	"image/apng": {
	compressible: false,
	extensions: [
		"apng"
	]
},
	"image/avci": {
	source: "iana"
},
	"image/avcs": {
	source: "iana"
},
	"image/avif": {
	source: "iana",
	compressible: false,
	extensions: [
		"avif"
	]
},
	"image/bmp": {
	source: "iana",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/cgm": {
	source: "iana",
	extensions: [
		"cgm"
	]
},
	"image/dicom-rle": {
	source: "iana",
	extensions: [
		"drle"
	]
},
	"image/emf": {
	source: "iana",
	extensions: [
		"emf"
	]
},
	"image/fits": {
	source: "iana",
	extensions: [
		"fits"
	]
},
	"image/g3fax": {
	source: "iana",
	extensions: [
		"g3"
	]
},
	"image/gif": {
	source: "iana",
	compressible: false,
	extensions: [
		"gif"
	]
},
	"image/heic": {
	source: "iana",
	extensions: [
		"heic"
	]
},
	"image/heic-sequence": {
	source: "iana",
	extensions: [
		"heics"
	]
},
	"image/heif": {
	source: "iana",
	extensions: [
		"heif"
	]
},
	"image/heif-sequence": {
	source: "iana",
	extensions: [
		"heifs"
	]
},
	"image/hej2k": {
	source: "iana",
	extensions: [
		"hej2"
	]
},
	"image/hsj2": {
	source: "iana",
	extensions: [
		"hsj2"
	]
},
	"image/ief": {
	source: "iana",
	extensions: [
		"ief"
	]
},
	"image/jls": {
	source: "iana",
	extensions: [
		"jls"
	]
},
	"image/jp2": {
	source: "iana",
	compressible: false,
	extensions: [
		"jp2",
		"jpg2"
	]
},
	"image/jpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpeg",
		"jpg",
		"jpe"
	]
},
	"image/jph": {
	source: "iana",
	extensions: [
		"jph"
	]
},
	"image/jphc": {
	source: "iana",
	extensions: [
		"jhc"
	]
},
	"image/jpm": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpm"
	]
},
	"image/jpx": {
	source: "iana",
	compressible: false,
	extensions: [
		"jpx",
		"jpf"
	]
},
	"image/jxr": {
	source: "iana",
	extensions: [
		"jxr"
	]
},
	"image/jxra": {
	source: "iana",
	extensions: [
		"jxra"
	]
},
	"image/jxrs": {
	source: "iana",
	extensions: [
		"jxrs"
	]
},
	"image/jxs": {
	source: "iana",
	extensions: [
		"jxs"
	]
},
	"image/jxsc": {
	source: "iana",
	extensions: [
		"jxsc"
	]
},
	"image/jxsi": {
	source: "iana",
	extensions: [
		"jxsi"
	]
},
	"image/jxss": {
	source: "iana",
	extensions: [
		"jxss"
	]
},
	"image/ktx": {
	source: "iana",
	extensions: [
		"ktx"
	]
},
	"image/ktx2": {
	source: "iana",
	extensions: [
		"ktx2"
	]
},
	"image/naplps": {
	source: "iana"
},
	"image/pjpeg": {
	compressible: false
},
	"image/png": {
	source: "iana",
	compressible: false,
	extensions: [
		"png"
	]
},
	"image/prs.btif": {
	source: "iana",
	extensions: [
		"btif"
	]
},
	"image/prs.pti": {
	source: "iana",
	extensions: [
		"pti"
	]
},
	"image/pwg-raster": {
	source: "iana"
},
	"image/sgi": {
	source: "apache",
	extensions: [
		"sgi"
	]
},
	"image/svg+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"svg",
		"svgz"
	]
},
	"image/t38": {
	source: "iana",
	extensions: [
		"t38"
	]
},
	"image/tiff": {
	source: "iana",
	compressible: false,
	extensions: [
		"tif",
		"tiff"
	]
},
	"image/tiff-fx": {
	source: "iana",
	extensions: [
		"tfx"
	]
},
	"image/vnd.adobe.photoshop": {
	source: "iana",
	compressible: true,
	extensions: [
		"psd"
	]
},
	"image/vnd.airzip.accelerator.azv": {
	source: "iana",
	extensions: [
		"azv"
	]
},
	"image/vnd.cns.inf2": {
	source: "iana"
},
	"image/vnd.dece.graphic": {
	source: "iana",
	extensions: [
		"uvi",
		"uvvi",
		"uvg",
		"uvvg"
	]
},
	"image/vnd.djvu": {
	source: "iana",
	extensions: [
		"djvu",
		"djv"
	]
},
	"image/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"image/vnd.dwg": {
	source: "iana",
	extensions: [
		"dwg"
	]
},
	"image/vnd.dxf": {
	source: "iana",
	extensions: [
		"dxf"
	]
},
	"image/vnd.fastbidsheet": {
	source: "iana",
	extensions: [
		"fbs"
	]
},
	"image/vnd.fpx": {
	source: "iana",
	extensions: [
		"fpx"
	]
},
	"image/vnd.fst": {
	source: "iana",
	extensions: [
		"fst"
	]
},
	"image/vnd.fujixerox.edmics-mmr": {
	source: "iana",
	extensions: [
		"mmr"
	]
},
	"image/vnd.fujixerox.edmics-rlc": {
	source: "iana",
	extensions: [
		"rlc"
	]
},
	"image/vnd.globalgraphics.pgb": {
	source: "iana"
},
	"image/vnd.microsoft.icon": {
	source: "iana",
	extensions: [
		"ico"
	]
},
	"image/vnd.mix": {
	source: "iana"
},
	"image/vnd.mozilla.apng": {
	source: "iana"
},
	"image/vnd.ms-dds": {
	extensions: [
		"dds"
	]
},
	"image/vnd.ms-modi": {
	source: "iana",
	extensions: [
		"mdi"
	]
},
	"image/vnd.ms-photo": {
	source: "apache",
	extensions: [
		"wdp"
	]
},
	"image/vnd.net-fpx": {
	source: "iana",
	extensions: [
		"npx"
	]
},
	"image/vnd.pco.b16": {
	source: "iana",
	extensions: [
		"b16"
	]
},
	"image/vnd.radiance": {
	source: "iana"
},
	"image/vnd.sealed.png": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.gif": {
	source: "iana"
},
	"image/vnd.sealedmedia.softseal.jpg": {
	source: "iana"
},
	"image/vnd.svf": {
	source: "iana"
},
	"image/vnd.tencent.tap": {
	source: "iana",
	extensions: [
		"tap"
	]
},
	"image/vnd.valve.source.texture": {
	source: "iana",
	extensions: [
		"vtf"
	]
},
	"image/vnd.wap.wbmp": {
	source: "iana",
	extensions: [
		"wbmp"
	]
},
	"image/vnd.xiff": {
	source: "iana",
	extensions: [
		"xif"
	]
},
	"image/vnd.zbrush.pcx": {
	source: "iana",
	extensions: [
		"pcx"
	]
},
	"image/webp": {
	source: "apache",
	extensions: [
		"webp"
	]
},
	"image/wmf": {
	source: "iana",
	extensions: [
		"wmf"
	]
},
	"image/x-3ds": {
	source: "apache",
	extensions: [
		"3ds"
	]
},
	"image/x-cmu-raster": {
	source: "apache",
	extensions: [
		"ras"
	]
},
	"image/x-cmx": {
	source: "apache",
	extensions: [
		"cmx"
	]
},
	"image/x-freehand": {
	source: "apache",
	extensions: [
		"fh",
		"fhc",
		"fh4",
		"fh5",
		"fh7"
	]
},
	"image/x-icon": {
	source: "apache",
	compressible: true,
	extensions: [
		"ico"
	]
},
	"image/x-jng": {
	source: "nginx",
	extensions: [
		"jng"
	]
},
	"image/x-mrsid-image": {
	source: "apache",
	extensions: [
		"sid"
	]
},
	"image/x-ms-bmp": {
	source: "nginx",
	compressible: true,
	extensions: [
		"bmp"
	]
},
	"image/x-pcx": {
	source: "apache",
	extensions: [
		"pcx"
	]
},
	"image/x-pict": {
	source: "apache",
	extensions: [
		"pic",
		"pct"
	]
},
	"image/x-portable-anymap": {
	source: "apache",
	extensions: [
		"pnm"
	]
},
	"image/x-portable-bitmap": {
	source: "apache",
	extensions: [
		"pbm"
	]
},
	"image/x-portable-graymap": {
	source: "apache",
	extensions: [
		"pgm"
	]
},
	"image/x-portable-pixmap": {
	source: "apache",
	extensions: [
		"ppm"
	]
},
	"image/x-rgb": {
	source: "apache",
	extensions: [
		"rgb"
	]
},
	"image/x-tga": {
	source: "apache",
	extensions: [
		"tga"
	]
},
	"image/x-xbitmap": {
	source: "apache",
	extensions: [
		"xbm"
	]
},
	"image/x-xcf": {
	compressible: false
},
	"image/x-xpixmap": {
	source: "apache",
	extensions: [
		"xpm"
	]
},
	"image/x-xwindowdump": {
	source: "apache",
	extensions: [
		"xwd"
	]
},
	"message/cpim": {
	source: "iana"
},
	"message/delivery-status": {
	source: "iana"
},
	"message/disposition-notification": {
	source: "iana",
	extensions: [
		"disposition-notification"
	]
},
	"message/external-body": {
	source: "iana"
},
	"message/feedback-report": {
	source: "iana"
},
	"message/global": {
	source: "iana",
	extensions: [
		"u8msg"
	]
},
	"message/global-delivery-status": {
	source: "iana",
	extensions: [
		"u8dsn"
	]
},
	"message/global-disposition-notification": {
	source: "iana",
	extensions: [
		"u8mdn"
	]
},
	"message/global-headers": {
	source: "iana",
	extensions: [
		"u8hdr"
	]
},
	"message/http": {
	source: "iana",
	compressible: false
},
	"message/imdn+xml": {
	source: "iana",
	compressible: true
},
	"message/news": {
	source: "iana"
},
	"message/partial": {
	source: "iana",
	compressible: false
},
	"message/rfc822": {
	source: "iana",
	compressible: true,
	extensions: [
		"eml",
		"mime"
	]
},
	"message/s-http": {
	source: "iana"
},
	"message/sip": {
	source: "iana"
},
	"message/sipfrag": {
	source: "iana"
},
	"message/tracking-status": {
	source: "iana"
},
	"message/vnd.si.simp": {
	source: "iana"
},
	"message/vnd.wfa.wsc": {
	source: "iana",
	extensions: [
		"wsc"
	]
},
	"model/3mf": {
	source: "iana",
	extensions: [
		"3mf"
	]
},
	"model/e57": {
	source: "iana"
},
	"model/gltf+json": {
	source: "iana",
	compressible: true,
	extensions: [
		"gltf"
	]
},
	"model/gltf-binary": {
	source: "iana",
	compressible: true,
	extensions: [
		"glb"
	]
},
	"model/iges": {
	source: "iana",
	compressible: false,
	extensions: [
		"igs",
		"iges"
	]
},
	"model/mesh": {
	source: "iana",
	compressible: false,
	extensions: [
		"msh",
		"mesh",
		"silo"
	]
},
	"model/mtl": {
	source: "iana",
	extensions: [
		"mtl"
	]
},
	"model/obj": {
	source: "iana",
	extensions: [
		"obj"
	]
},
	"model/step+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpz"
	]
},
	"model/step-xml+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"stpxz"
	]
},
	"model/stl": {
	source: "iana",
	extensions: [
		"stl"
	]
},
	"model/vnd.collada+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"dae"
	]
},
	"model/vnd.dwf": {
	source: "iana",
	extensions: [
		"dwf"
	]
},
	"model/vnd.flatland.3dml": {
	source: "iana"
},
	"model/vnd.gdl": {
	source: "iana",
	extensions: [
		"gdl"
	]
},
	"model/vnd.gs-gdl": {
	source: "apache"
},
	"model/vnd.gs.gdl": {
	source: "iana"
},
	"model/vnd.gtw": {
	source: "iana",
	extensions: [
		"gtw"
	]
},
	"model/vnd.moml+xml": {
	source: "iana",
	compressible: true
},
	"model/vnd.mts": {
	source: "iana",
	extensions: [
		"mts"
	]
},
	"model/vnd.opengex": {
	source: "iana",
	extensions: [
		"ogex"
	]
},
	"model/vnd.parasolid.transmit.binary": {
	source: "iana",
	extensions: [
		"x_b"
	]
},
	"model/vnd.parasolid.transmit.text": {
	source: "iana",
	extensions: [
		"x_t"
	]
},
	"model/vnd.pytha.pyox": {
	source: "iana"
},
	"model/vnd.rosette.annotated-data-model": {
	source: "iana"
},
	"model/vnd.sap.vds": {
	source: "iana",
	extensions: [
		"vds"
	]
},
	"model/vnd.usdz+zip": {
	source: "iana",
	compressible: false,
	extensions: [
		"usdz"
	]
},
	"model/vnd.valve.source.compiled-map": {
	source: "iana",
	extensions: [
		"bsp"
	]
},
	"model/vnd.vtu": {
	source: "iana",
	extensions: [
		"vtu"
	]
},
	"model/vrml": {
	source: "iana",
	compressible: false,
	extensions: [
		"wrl",
		"vrml"
	]
},
	"model/x3d+binary": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3db",
		"x3dbz"
	]
},
	"model/x3d+fastinfoset": {
	source: "iana",
	extensions: [
		"x3db"
	]
},
	"model/x3d+vrml": {
	source: "apache",
	compressible: false,
	extensions: [
		"x3dv",
		"x3dvz"
	]
},
	"model/x3d+xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"x3d",
		"x3dz"
	]
},
	"model/x3d-vrml": {
	source: "iana",
	extensions: [
		"x3dv"
	]
},
	"multipart/alternative": {
	source: "iana",
	compressible: false
},
	"multipart/appledouble": {
	source: "iana"
},
	"multipart/byteranges": {
	source: "iana"
},
	"multipart/digest": {
	source: "iana"
},
	"multipart/encrypted": {
	source: "iana",
	compressible: false
},
	"multipart/form-data": {
	source: "iana",
	compressible: false
},
	"multipart/header-set": {
	source: "iana"
},
	"multipart/mixed": {
	source: "iana"
},
	"multipart/multilingual": {
	source: "iana"
},
	"multipart/parallel": {
	source: "iana"
},
	"multipart/related": {
	source: "iana",
	compressible: false
},
	"multipart/report": {
	source: "iana"
},
	"multipart/signed": {
	source: "iana",
	compressible: false
},
	"multipart/vnd.bint.med-plus": {
	source: "iana"
},
	"multipart/voice-message": {
	source: "iana"
},
	"multipart/x-mixed-replace": {
	source: "iana"
},
	"text/1d-interleaved-parityfec": {
	source: "iana"
},
	"text/cache-manifest": {
	source: "iana",
	compressible: true,
	extensions: [
		"appcache",
		"manifest"
	]
},
	"text/calendar": {
	source: "iana",
	extensions: [
		"ics",
		"ifb"
	]
},
	"text/calender": {
	compressible: true
},
	"text/cmd": {
	compressible: true
},
	"text/coffeescript": {
	extensions: [
		"coffee",
		"litcoffee"
	]
},
	"text/cql": {
	source: "iana"
},
	"text/cql-expression": {
	source: "iana"
},
	"text/cql-identifier": {
	source: "iana"
},
	"text/css": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"css"
	]
},
	"text/csv": {
	source: "iana",
	compressible: true,
	extensions: [
		"csv"
	]
},
	"text/csv-schema": {
	source: "iana"
},
	"text/directory": {
	source: "iana"
},
	"text/dns": {
	source: "iana"
},
	"text/ecmascript": {
	source: "iana"
},
	"text/encaprtp": {
	source: "iana"
},
	"text/enriched": {
	source: "iana"
},
	"text/fhirpath": {
	source: "iana"
},
	"text/flexfec": {
	source: "iana"
},
	"text/fwdred": {
	source: "iana"
},
	"text/gff3": {
	source: "iana"
},
	"text/grammar-ref-list": {
	source: "iana"
},
	"text/html": {
	source: "iana",
	compressible: true,
	extensions: [
		"html",
		"htm",
		"shtml"
	]
},
	"text/jade": {
	extensions: [
		"jade"
	]
},
	"text/javascript": {
	source: "iana",
	compressible: true
},
	"text/jcr-cnd": {
	source: "iana"
},
	"text/jsx": {
	compressible: true,
	extensions: [
		"jsx"
	]
},
	"text/less": {
	compressible: true,
	extensions: [
		"less"
	]
},
	"text/markdown": {
	source: "iana",
	compressible: true,
	extensions: [
		"markdown",
		"md"
	]
},
	"text/mathml": {
	source: "nginx",
	extensions: [
		"mml"
	]
},
	"text/mdx": {
	compressible: true,
	extensions: [
		"mdx"
	]
},
	"text/mizar": {
	source: "iana"
},
	"text/n3": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"n3"
	]
},
	"text/parameters": {
	source: "iana",
	charset: "UTF-8"
},
	"text/parityfec": {
	source: "iana"
},
	"text/plain": {
	source: "iana",
	compressible: true,
	extensions: [
		"txt",
		"text",
		"conf",
		"def",
		"list",
		"log",
		"in",
		"ini"
	]
},
	"text/provenance-notation": {
	source: "iana",
	charset: "UTF-8"
},
	"text/prs.fallenstein.rst": {
	source: "iana"
},
	"text/prs.lines.tag": {
	source: "iana",
	extensions: [
		"dsc"
	]
},
	"text/prs.prop.logic": {
	source: "iana"
},
	"text/raptorfec": {
	source: "iana"
},
	"text/red": {
	source: "iana"
},
	"text/rfc822-headers": {
	source: "iana"
},
	"text/richtext": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtx"
	]
},
	"text/rtf": {
	source: "iana",
	compressible: true,
	extensions: [
		"rtf"
	]
},
	"text/rtp-enc-aescm128": {
	source: "iana"
},
	"text/rtploopback": {
	source: "iana"
},
	"text/rtx": {
	source: "iana"
},
	"text/sgml": {
	source: "iana",
	extensions: [
		"sgml",
		"sgm"
	]
},
	"text/shaclc": {
	source: "iana"
},
	"text/shex": {
	source: "iana",
	extensions: [
		"shex"
	]
},
	"text/slim": {
	extensions: [
		"slim",
		"slm"
	]
},
	"text/spdx": {
	source: "iana",
	extensions: [
		"spdx"
	]
},
	"text/strings": {
	source: "iana"
},
	"text/stylus": {
	extensions: [
		"stylus",
		"styl"
	]
},
	"text/t140": {
	source: "iana"
},
	"text/tab-separated-values": {
	source: "iana",
	compressible: true,
	extensions: [
		"tsv"
	]
},
	"text/troff": {
	source: "iana",
	extensions: [
		"t",
		"tr",
		"roff",
		"man",
		"me",
		"ms"
	]
},
	"text/turtle": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"ttl"
	]
},
	"text/ulpfec": {
	source: "iana"
},
	"text/uri-list": {
	source: "iana",
	compressible: true,
	extensions: [
		"uri",
		"uris",
		"urls"
	]
},
	"text/vcard": {
	source: "iana",
	compressible: true,
	extensions: [
		"vcard"
	]
},
	"text/vnd.a": {
	source: "iana"
},
	"text/vnd.abc": {
	source: "iana"
},
	"text/vnd.ascii-art": {
	source: "iana"
},
	"text/vnd.curl": {
	source: "iana",
	extensions: [
		"curl"
	]
},
	"text/vnd.curl.dcurl": {
	source: "apache",
	extensions: [
		"dcurl"
	]
},
	"text/vnd.curl.mcurl": {
	source: "apache",
	extensions: [
		"mcurl"
	]
},
	"text/vnd.curl.scurl": {
	source: "apache",
	extensions: [
		"scurl"
	]
},
	"text/vnd.debian.copyright": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.dmclientscript": {
	source: "iana"
},
	"text/vnd.dvb.subtitle": {
	source: "iana",
	extensions: [
		"sub"
	]
},
	"text/vnd.esmertec.theme-descriptor": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.ficlab.flt": {
	source: "iana"
},
	"text/vnd.fly": {
	source: "iana",
	extensions: [
		"fly"
	]
},
	"text/vnd.fmi.flexstor": {
	source: "iana",
	extensions: [
		"flx"
	]
},
	"text/vnd.gml": {
	source: "iana"
},
	"text/vnd.graphviz": {
	source: "iana",
	extensions: [
		"gv"
	]
},
	"text/vnd.hans": {
	source: "iana"
},
	"text/vnd.hgl": {
	source: "iana"
},
	"text/vnd.in3d.3dml": {
	source: "iana",
	extensions: [
		"3dml"
	]
},
	"text/vnd.in3d.spot": {
	source: "iana",
	extensions: [
		"spot"
	]
},
	"text/vnd.iptc.newsml": {
	source: "iana"
},
	"text/vnd.iptc.nitf": {
	source: "iana"
},
	"text/vnd.latex-z": {
	source: "iana"
},
	"text/vnd.motorola.reflex": {
	source: "iana"
},
	"text/vnd.ms-mediapackage": {
	source: "iana"
},
	"text/vnd.net2phone.commcenter.command": {
	source: "iana"
},
	"text/vnd.radisys.msml-basic-layout": {
	source: "iana"
},
	"text/vnd.senx.warpscript": {
	source: "iana"
},
	"text/vnd.si.uricatalogue": {
	source: "iana"
},
	"text/vnd.sosi": {
	source: "iana"
},
	"text/vnd.sun.j2me.app-descriptor": {
	source: "iana",
	charset: "UTF-8",
	extensions: [
		"jad"
	]
},
	"text/vnd.trolltech.linguist": {
	source: "iana",
	charset: "UTF-8"
},
	"text/vnd.wap.si": {
	source: "iana"
},
	"text/vnd.wap.sl": {
	source: "iana"
},
	"text/vnd.wap.wml": {
	source: "iana",
	extensions: [
		"wml"
	]
},
	"text/vnd.wap.wmlscript": {
	source: "iana",
	extensions: [
		"wmls"
	]
},
	"text/vtt": {
	source: "iana",
	charset: "UTF-8",
	compressible: true,
	extensions: [
		"vtt"
	]
},
	"text/x-asm": {
	source: "apache",
	extensions: [
		"s",
		"asm"
	]
},
	"text/x-c": {
	source: "apache",
	extensions: [
		"c",
		"cc",
		"cxx",
		"cpp",
		"h",
		"hh",
		"dic"
	]
},
	"text/x-component": {
	source: "nginx",
	extensions: [
		"htc"
	]
},
	"text/x-fortran": {
	source: "apache",
	extensions: [
		"f",
		"for",
		"f77",
		"f90"
	]
},
	"text/x-gwt-rpc": {
	compressible: true
},
	"text/x-handlebars-template": {
	extensions: [
		"hbs"
	]
},
	"text/x-java-source": {
	source: "apache",
	extensions: [
		"java"
	]
},
	"text/x-jquery-tmpl": {
	compressible: true
},
	"text/x-lua": {
	extensions: [
		"lua"
	]
},
	"text/x-markdown": {
	compressible: true,
	extensions: [
		"mkd"
	]
},
	"text/x-nfo": {
	source: "apache",
	extensions: [
		"nfo"
	]
},
	"text/x-opml": {
	source: "apache",
	extensions: [
		"opml"
	]
},
	"text/x-org": {
	compressible: true,
	extensions: [
		"org"
	]
},
	"text/x-pascal": {
	source: "apache",
	extensions: [
		"p",
		"pas"
	]
},
	"text/x-processing": {
	compressible: true,
	extensions: [
		"pde"
	]
},
	"text/x-sass": {
	extensions: [
		"sass"
	]
},
	"text/x-scss": {
	extensions: [
		"scss"
	]
},
	"text/x-setext": {
	source: "apache",
	extensions: [
		"etx"
	]
},
	"text/x-sfv": {
	source: "apache",
	extensions: [
		"sfv"
	]
},
	"text/x-suse-ymp": {
	compressible: true,
	extensions: [
		"ymp"
	]
},
	"text/x-uuencode": {
	source: "apache",
	extensions: [
		"uu"
	]
},
	"text/x-vcalendar": {
	source: "apache",
	extensions: [
		"vcs"
	]
},
	"text/x-vcard": {
	source: "apache",
	extensions: [
		"vcf"
	]
},
	"text/xml": {
	source: "iana",
	compressible: true,
	extensions: [
		"xml"
	]
},
	"text/xml-external-parsed-entity": {
	source: "iana"
},
	"text/yaml": {
	compressible: true,
	extensions: [
		"yaml",
		"yml"
	]
},
	"video/1d-interleaved-parityfec": {
	source: "iana"
},
	"video/3gpp": {
	source: "iana",
	extensions: [
		"3gp",
		"3gpp"
	]
},
	"video/3gpp-tt": {
	source: "iana"
},
	"video/3gpp2": {
	source: "iana",
	extensions: [
		"3g2"
	]
},
	"video/av1": {
	source: "iana"
},
	"video/bmpeg": {
	source: "iana"
},
	"video/bt656": {
	source: "iana"
},
	"video/celb": {
	source: "iana"
},
	"video/dv": {
	source: "iana"
},
	"video/encaprtp": {
	source: "iana"
},
	"video/ffv1": {
	source: "iana"
},
	"video/flexfec": {
	source: "iana"
},
	"video/h261": {
	source: "iana",
	extensions: [
		"h261"
	]
},
	"video/h263": {
	source: "iana",
	extensions: [
		"h263"
	]
},
	"video/h263-1998": {
	source: "iana"
},
	"video/h263-2000": {
	source: "iana"
},
	"video/h264": {
	source: "iana",
	extensions: [
		"h264"
	]
},
	"video/h264-rcdo": {
	source: "iana"
},
	"video/h264-svc": {
	source: "iana"
},
	"video/h265": {
	source: "iana"
},
	"video/iso.segment": {
	source: "iana",
	extensions: [
		"m4s"
	]
},
	"video/jpeg": {
	source: "iana",
	extensions: [
		"jpgv"
	]
},
	"video/jpeg2000": {
	source: "iana"
},
	"video/jpm": {
	source: "apache",
	extensions: [
		"jpm",
		"jpgm"
	]
},
	"video/mj2": {
	source: "iana",
	extensions: [
		"mj2",
		"mjp2"
	]
},
	"video/mp1s": {
	source: "iana"
},
	"video/mp2p": {
	source: "iana"
},
	"video/mp2t": {
	source: "iana",
	extensions: [
		"ts"
	]
},
	"video/mp4": {
	source: "iana",
	compressible: false,
	extensions: [
		"mp4",
		"mp4v",
		"mpg4"
	]
},
	"video/mp4v-es": {
	source: "iana"
},
	"video/mpeg": {
	source: "iana",
	compressible: false,
	extensions: [
		"mpeg",
		"mpg",
		"mpe",
		"m1v",
		"m2v"
	]
},
	"video/mpeg4-generic": {
	source: "iana"
},
	"video/mpv": {
	source: "iana"
},
	"video/nv": {
	source: "iana"
},
	"video/ogg": {
	source: "iana",
	compressible: false,
	extensions: [
		"ogv"
	]
},
	"video/parityfec": {
	source: "iana"
},
	"video/pointer": {
	source: "iana"
},
	"video/quicktime": {
	source: "iana",
	compressible: false,
	extensions: [
		"qt",
		"mov"
	]
},
	"video/raptorfec": {
	source: "iana"
},
	"video/raw": {
	source: "iana"
},
	"video/rtp-enc-aescm128": {
	source: "iana"
},
	"video/rtploopback": {
	source: "iana"
},
	"video/rtx": {
	source: "iana"
},
	"video/scip": {
	source: "iana"
},
	"video/smpte291": {
	source: "iana"
},
	"video/smpte292m": {
	source: "iana"
},
	"video/ulpfec": {
	source: "iana"
},
	"video/vc1": {
	source: "iana"
},
	"video/vc2": {
	source: "iana"
},
	"video/vnd.cctv": {
	source: "iana"
},
	"video/vnd.dece.hd": {
	source: "iana",
	extensions: [
		"uvh",
		"uvvh"
	]
},
	"video/vnd.dece.mobile": {
	source: "iana",
	extensions: [
		"uvm",
		"uvvm"
	]
},
	"video/vnd.dece.mp4": {
	source: "iana"
},
	"video/vnd.dece.pd": {
	source: "iana",
	extensions: [
		"uvp",
		"uvvp"
	]
},
	"video/vnd.dece.sd": {
	source: "iana",
	extensions: [
		"uvs",
		"uvvs"
	]
},
	"video/vnd.dece.video": {
	source: "iana",
	extensions: [
		"uvv",
		"uvvv"
	]
},
	"video/vnd.directv.mpeg": {
	source: "iana"
},
	"video/vnd.directv.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dlna.mpeg-tts": {
	source: "iana"
},
	"video/vnd.dvb.file": {
	source: "iana",
	extensions: [
		"dvb"
	]
},
	"video/vnd.fvt": {
	source: "iana",
	extensions: [
		"fvt"
	]
},
	"video/vnd.hns.video": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.1dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-1010": {
	source: "iana"
},
	"video/vnd.iptvforum.2dparityfec-2005": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsavc": {
	source: "iana"
},
	"video/vnd.iptvforum.ttsmpeg2": {
	source: "iana"
},
	"video/vnd.motorola.video": {
	source: "iana"
},
	"video/vnd.motorola.videop": {
	source: "iana"
},
	"video/vnd.mpegurl": {
	source: "iana",
	extensions: [
		"mxu",
		"m4u"
	]
},
	"video/vnd.ms-playready.media.pyv": {
	source: "iana",
	extensions: [
		"pyv"
	]
},
	"video/vnd.nokia.interleaved-multimedia": {
	source: "iana"
},
	"video/vnd.nokia.mp4vr": {
	source: "iana"
},
	"video/vnd.nokia.videovoip": {
	source: "iana"
},
	"video/vnd.objectvideo": {
	source: "iana"
},
	"video/vnd.radgamettools.bink": {
	source: "iana"
},
	"video/vnd.radgamettools.smacker": {
	source: "iana"
},
	"video/vnd.sealed.mpeg1": {
	source: "iana"
},
	"video/vnd.sealed.mpeg4": {
	source: "iana"
},
	"video/vnd.sealed.swf": {
	source: "iana"
},
	"video/vnd.sealedmedia.softseal.mov": {
	source: "iana"
},
	"video/vnd.uvvu.mp4": {
	source: "iana",
	extensions: [
		"uvu",
		"uvvu"
	]
},
	"video/vnd.vivo": {
	source: "iana",
	extensions: [
		"viv"
	]
},
	"video/vnd.youtube.yt": {
	source: "iana"
},
	"video/vp8": {
	source: "iana"
},
	"video/vp9": {
	source: "iana"
},
	"video/webm": {
	source: "apache",
	compressible: false,
	extensions: [
		"webm"
	]
},
	"video/x-f4v": {
	source: "apache",
	extensions: [
		"f4v"
	]
},
	"video/x-fli": {
	source: "apache",
	extensions: [
		"fli"
	]
},
	"video/x-flv": {
	source: "apache",
	compressible: false,
	extensions: [
		"flv"
	]
},
	"video/x-m4v": {
	source: "apache",
	extensions: [
		"m4v"
	]
},
	"video/x-matroska": {
	source: "apache",
	compressible: false,
	extensions: [
		"mkv",
		"mk3d",
		"mks"
	]
},
	"video/x-mng": {
	source: "apache",
	extensions: [
		"mng"
	]
},
	"video/x-ms-asf": {
	source: "apache",
	extensions: [
		"asf",
		"asx"
	]
},
	"video/x-ms-vob": {
	source: "apache",
	extensions: [
		"vob"
	]
},
	"video/x-ms-wm": {
	source: "apache",
	extensions: [
		"wm"
	]
},
	"video/x-ms-wmv": {
	source: "apache",
	compressible: false,
	extensions: [
		"wmv"
	]
},
	"video/x-ms-wmx": {
	source: "apache",
	extensions: [
		"wmx"
	]
},
	"video/x-ms-wvx": {
	source: "apache",
	extensions: [
		"wvx"
	]
},
	"video/x-msvideo": {
	source: "apache",
	extensions: [
		"avi"
	]
},
	"video/x-sgi-movie": {
	source: "apache",
	extensions: [
		"movie"
	]
},
	"video/x-smv": {
	source: "apache",
	extensions: [
		"smv"
	]
},
	"x-conference/x-cooltalk": {
	source: "apache",
	extensions: [
		"ice"
	]
},
	"x-shader/x-fragment": {
	compressible: true
},
	"x-shader/x-vertex": {
	compressible: true
}
};

/*!
 * mime-db
 * Copyright(c) 2014 Jonathan Ong
 * MIT Licensed
 */

/**
 * Module exports.
 */

var mimeDb = require$$0$2;

/*!
 * mime-types
 * Copyright(c) 2014 Jonathan Ong
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */

var mimeTypes = createCommonjsModule(function (module, exports) {

/**
 * Module dependencies.
 * @private
 */


var extname = path.extname;

/**
 * Module variables.
 * @private
 */

var EXTRACT_TYPE_REGEXP = /^\s*([^;\s]*)(?:;|\s|$)/;
var TEXT_TYPE_REGEXP = /^text\//i;

/**
 * Module exports.
 * @public
 */

exports.charset = charset;
exports.charsets = { lookup: charset };
exports.contentType = contentType;
exports.extension = extension;
exports.extensions = Object.create(null);
exports.lookup = lookup;
exports.types = Object.create(null);

// Populate the extensions/types maps
populateMaps(exports.extensions, exports.types);

/**
 * Get the default charset for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function charset (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type);
  var mime = match && mimeDb[match[1].toLowerCase()];

  if (mime && mime.charset) {
    return mime.charset
  }

  // default text/* to utf-8
  if (match && TEXT_TYPE_REGEXP.test(match[1])) {
    return 'UTF-8'
  }

  return false
}

/**
 * Create a full Content-Type header given a MIME type or extension.
 *
 * @param {string} str
 * @return {boolean|string}
 */

function contentType (str) {
  // TODO: should this even be in this module?
  if (!str || typeof str !== 'string') {
    return false
  }

  var mime = str.indexOf('/') === -1
    ? exports.lookup(str)
    : str;

  if (!mime) {
    return false
  }

  // TODO: use content-type or other module
  if (mime.indexOf('charset') === -1) {
    var charset = exports.charset(mime);
    if (charset) mime += '; charset=' + charset.toLowerCase();
  }

  return mime
}

/**
 * Get the default extension for a MIME type.
 *
 * @param {string} type
 * @return {boolean|string}
 */

function extension (type) {
  if (!type || typeof type !== 'string') {
    return false
  }

  // TODO: use media-typer
  var match = EXTRACT_TYPE_REGEXP.exec(type);

  // get extensions
  var exts = match && exports.extensions[match[1].toLowerCase()];

  if (!exts || !exts.length) {
    return false
  }

  return exts[0]
}

/**
 * Lookup the MIME type for a file path/extension.
 *
 * @param {string} path
 * @return {boolean|string}
 */

function lookup (path) {
  if (!path || typeof path !== 'string') {
    return false
  }

  // get the extension ("ext" or ".ext" or full path)
  var extension = extname('x.' + path)
    .toLowerCase()
    .substr(1);

  if (!extension) {
    return false
  }

  return exports.types[extension] || false
}

/**
 * Populate the extensions and types maps.
 * @private
 */

function populateMaps (extensions, types) {
  // source preference (least -> most)
  var preference = ['nginx', 'apache', undefined, 'iana'];

  Object.keys(mimeDb).forEach(function forEachMimeType (type) {
    var mime = mimeDb[type];
    var exts = mime.extensions;

    if (!exts || !exts.length) {
      return
    }

    // mime -> extensions
    extensions[type] = exts;

    // extension -> mime
    for (var i = 0; i < exts.length; i++) {
      var extension = exts[i];

      if (types[extension]) {
        var from = preference.indexOf(mimeDb[types[extension]].source);
        var to = preference.indexOf(mime.source);

        if (types[extension] !== 'application/octet-stream' &&
          (from > to || (from === to && types[extension].substr(0, 12) === 'application/'))) {
          // skip the remapping
          continue
        }
      }

      // set the extension -> mime
      types[extension] = type;
    }
  });
}
});

function Caseless (dict) {
  this.dict = dict || {};
}
Caseless.prototype.set = function (name, value, clobber) {
  if (typeof name === 'object') {
    for (var i in name) {
      this.set(i, name[i], value);
    }
  } else {
    if (typeof clobber === 'undefined') clobber = true;
    var has = this.has(name);

    if (!clobber && has) this.dict[has] = this.dict[has] + ',' + value;
    else this.dict[has || name] = value;
    return has
  }
};
Caseless.prototype.has = function (name) {
  var keys = Object.keys(this.dict)
    , name = name.toLowerCase()
    ;
  for (var i=0;i<keys.length;i++) {
    if (keys[i].toLowerCase() === name) return keys[i]
  }
  return false
};
Caseless.prototype.get = function (name) {
  name = name.toLowerCase();
  var result, _key;
  var headers = this.dict;
  Object.keys(headers).forEach(function (key) {
    _key = key.toLowerCase();
    if (name === _key) result = headers[key];
  });
  return result
};
Caseless.prototype.swap = function (name) {
  var has = this.has(name);
  if (has === name) return
  if (!has) throw new Error('There is no header than matches "'+name+'"')
  this.dict[name] = this.dict[has];
  delete this.dict[has];
};
Caseless.prototype.del = function (name) {
  var has = this.has(name);
  return delete this.dict[has || name]
};

var caseless = function (dict) {return new Caseless(dict)};
var httpify = function (resp, headers) {
  var c = new Caseless(headers);
  resp.setHeader = function (key, value, clobber) {
    if (typeof value === 'undefined') return
    return c.set(key, value, clobber)
  };
  resp.hasHeader = function (key) {
    return c.has(key)
  };
  resp.getHeader = function (key) {
    return c.get(key)
  };
  resp.removeHeader = function (key) {
    return c.del(key)
  };
  resp.headers = c.dict;
  return c
};
caseless.httpify = httpify;

var foreverAgent = ForeverAgent;
ForeverAgent.SSL = ForeverAgentSSL;

var Agent = http.Agent
  , AgentSSL = https.Agent;
  
function getConnectionName(host, port) {  
  var name = '';
  if (typeof host === 'string') {
    name = host + ':' + port;
  } else {
    // For node.js v012.0 and iojs-v1.5.1, host is an object. And any existing localAddress is part of the connection name.
    name = host.host + ':' + host.port + ':' + (host.localAddress ? (host.localAddress + ':') : ':');
  }
  return name
}    

function ForeverAgent(options) {
  var self = this;
  self.options = options || {};
  self.requests = {};
  self.sockets = {};
  self.freeSockets = {};
  self.maxSockets = self.options.maxSockets || Agent.defaultMaxSockets;
  self.minSockets = self.options.minSockets || ForeverAgent.defaultMinSockets;
  self.on('free', function(socket, host, port) {
    var name = getConnectionName(host, port);

    if (self.requests[name] && self.requests[name].length) {
      self.requests[name].shift().onSocket(socket);
    } else if (self.sockets[name].length < self.minSockets) {
      if (!self.freeSockets[name]) self.freeSockets[name] = [];
      self.freeSockets[name].push(socket);
      
      // if an error happens while we don't use the socket anyway, meh, throw the socket away
      var onIdleError = function() {
        socket.destroy();
      };
      socket._onIdleError = onIdleError;
      socket.on('error', onIdleError);
    } else {
      // If there are no pending requests just destroy the
      // socket and it will get removed from the pool. This
      // gets us out of timeout issues and allows us to
      // default to Connection:keep-alive.
      socket.destroy();
    }
  });

}
util$2.inherits(ForeverAgent, Agent);

ForeverAgent.defaultMinSockets = 5;


ForeverAgent.prototype.createConnection = net$1.createConnection;
ForeverAgent.prototype.addRequestNoreuse = Agent.prototype.addRequest;
ForeverAgent.prototype.addRequest = function(req, host, port) {
  var name = getConnectionName(host, port);
  
  if (typeof host !== 'string') {
    var options = host;
    port = options.port;
    host = options.host;
  }

  if (this.freeSockets[name] && this.freeSockets[name].length > 0 && !req.useChunkedEncodingByDefault) {
    var idleSocket = this.freeSockets[name].pop();
    idleSocket.removeListener('error', idleSocket._onIdleError);
    delete idleSocket._onIdleError;
    req._reusedSocket = true;
    req.onSocket(idleSocket);
  } else {
    this.addRequestNoreuse(req, host, port);
  }
};

ForeverAgent.prototype.removeSocket = function(s, name, host, port) {
  if (this.sockets[name]) {
    var index = this.sockets[name].indexOf(s);
    if (index !== -1) {
      this.sockets[name].splice(index, 1);
    }
  } else if (this.sockets[name] && this.sockets[name].length === 0) {
    // don't leak
    delete this.sockets[name];
    delete this.requests[name];
  }
  
  if (this.freeSockets[name]) {
    var index = this.freeSockets[name].indexOf(s);
    if (index !== -1) {
      this.freeSockets[name].splice(index, 1);
      if (this.freeSockets[name].length === 0) {
        delete this.freeSockets[name];
      }
    }
  }

  if (this.requests[name] && this.requests[name].length) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createSocket(name, host, port).emit('free');
  }
};

function ForeverAgentSSL (options) {
  ForeverAgent.call(this, options);
}
util$2.inherits(ForeverAgentSSL, ForeverAgent);

ForeverAgentSSL.prototype.createConnection = createConnectionSSL;
ForeverAgentSSL.prototype.addRequestNoreuse = AgentSSL.prototype.addRequest;

function createConnectionSSL (port, host, options) {
  if (typeof port === 'object') {
    options = port;
  } else if (typeof host === 'object') {
    options = host;
  } else if (typeof options === 'object') {
    options = options;
  } else {
    options = {};
  }

  if (typeof port === 'number') {
    options.port = port;
  }

  if (typeof host === 'string') {
    options.host = host;
  }

  return tls.connect(options);
}

/* eslint-env browser */
var browser$2 = typeof self == 'object' ? self.FormData : window.FormData;

function isStream (obj) {
  return obj instanceof stream.Stream
}


function isReadable (obj) {
  return isStream(obj) && typeof obj._read == 'function' && typeof obj._readableState == 'object'
}


function isWritable (obj) {
  return isStream(obj) && typeof obj._write == 'function' && typeof obj._writableState == 'object'
}


function isDuplex (obj) {
  return isReadable(obj) && isWritable(obj)
}


var isstream            = isStream;
var isReadable_1 = isReadable;
var isWritable_1 = isWritable;
var isDuplex_1   = isDuplex;
isstream.isReadable = isReadable_1;
isstream.isWritable = isWritable_1;
isstream.isDuplex = isDuplex_1;

var isTypedarray      = isTypedArray$1;
isTypedArray$1.strict = isStrictTypedArray;
isTypedArray$1.loose  = isLooseTypedArray;

var toString = Object.prototype.toString;
var names = {
    '[object Int8Array]': true
  , '[object Int16Array]': true
  , '[object Int32Array]': true
  , '[object Uint8Array]': true
  , '[object Uint8ClampedArray]': true
  , '[object Uint16Array]': true
  , '[object Uint32Array]': true
  , '[object Float32Array]': true
  , '[object Float64Array]': true
};

function isTypedArray$1(arr) {
  return (
       isStrictTypedArray(arr)
    || isLooseTypedArray(arr)
  )
}

function isStrictTypedArray(arr) {
  return (
       arr instanceof Int8Array
    || arr instanceof Int16Array
    || arr instanceof Int32Array
    || arr instanceof Uint8Array
    || arr instanceof Uint8ClampedArray
    || arr instanceof Uint16Array
    || arr instanceof Uint32Array
    || arr instanceof Float32Array
    || arr instanceof Float64Array
  )
}

function isLooseTypedArray(arr) {
  return names[toString.call(arr)]
}

function formatHostname (hostname) {
  // canonicalize the hostname, so that 'oogle.com' won't match 'google.com'
  return hostname.replace(/^\.*/, '.').toLowerCase()
}

function parseNoProxyZone (zone) {
  zone = zone.trim().toLowerCase();

  var zoneParts = zone.split(':', 2);
  var zoneHost = formatHostname(zoneParts[0]);
  var zonePort = zoneParts[1];
  var hasPort = zone.indexOf(':') > -1;

  return {hostname: zoneHost, port: zonePort, hasPort: hasPort}
}

function uriInNoProxy (uri, noProxy) {
  var port = uri.port || (uri.protocol === 'https:' ? '443' : '80');
  var hostname = formatHostname(uri.hostname);
  var noProxyList = noProxy.split(',');

  // iterate through the noProxyList until it finds a match.
  return noProxyList.map(parseNoProxyZone).some(function (noProxyZone) {
    var isMatchedAt = hostname.indexOf(noProxyZone.hostname);
    var hostnameMatched = (
      isMatchedAt > -1 &&
        (isMatchedAt === hostname.length - noProxyZone.hostname.length)
    );

    if (noProxyZone.hasPort) {
      return (port === noProxyZone.port) && hostnameMatched
    }

    return hostnameMatched
  })
}

function getProxyFromURI (uri) {
  // Decide the proper request proxy to use based on the request URI object and the
  // environmental variables (NO_PROXY, HTTP_PROXY, etc.)
  // respect NO_PROXY environment variables (see: https://lynx.invisible-island.net/lynx2.8.7/breakout/lynx_help/keystrokes/environments.html)

  var noProxy = process.env.NO_PROXY || process.env.no_proxy || '';

  // if the noProxy is a wildcard then return null

  if (noProxy === '*') {
    return null
  }

  // if the noProxy is not empty and the uri is found return null

  if (noProxy !== '' && uriInNoProxy(uri, noProxy)) {
    return null
  }

  // Check for HTTP or HTTPS Proxy in environment Else default to null

  if (uri.protocol === 'http:') {
    return process.env.HTTP_PROXY ||
      process.env.http_proxy || null
  }

  if (uri.protocol === 'https:') {
    return process.env.HTTPS_PROXY ||
      process.env.https_proxy ||
      process.env.HTTP_PROXY ||
      process.env.http_proxy || null
  }

  // if none of that works, return null
  // (What uri protocol are you using then?)

  return null
}

var getProxyFromURI_1 = getProxyFromURI;

var has$1 = Object.prototype.hasOwnProperty;

var hexTable = (function () {
    var array = [];
    for (var i = 0; i < 256; ++i) {
        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());
    }

    return array;
}());

var compactQueue = function compactQueue(queue) {
    var obj;

    while (queue.length) {
        var item = queue.pop();
        obj = item.obj[item.prop];

        if (Array.isArray(obj)) {
            var compacted = [];

            for (var j = 0; j < obj.length; ++j) {
                if (typeof obj[j] !== 'undefined') {
                    compacted.push(obj[j]);
                }
            }

            item.obj[item.prop] = compacted;
        }
    }

    return obj;
};

var arrayToObject = function arrayToObject(source, options) {
    var obj = options && options.plainObjects ? Object.create(null) : {};
    for (var i = 0; i < source.length; ++i) {
        if (typeof source[i] !== 'undefined') {
            obj[i] = source[i];
        }
    }

    return obj;
};

var merge = function merge(target, source, options) {
    if (!source) {
        return target;
    }

    if (typeof source !== 'object') {
        if (Array.isArray(target)) {
            target.push(source);
        } else if (typeof target === 'object') {
            if (options.plainObjects || options.allowPrototypes || !has$1.call(Object.prototype, source)) {
                target[source] = true;
            }
        } else {
            return [target, source];
        }

        return target;
    }

    if (typeof target !== 'object') {
        return [target].concat(source);
    }

    var mergeTarget = target;
    if (Array.isArray(target) && !Array.isArray(source)) {
        mergeTarget = arrayToObject(target, options);
    }

    if (Array.isArray(target) && Array.isArray(source)) {
        source.forEach(function (item, i) {
            if (has$1.call(target, i)) {
                if (target[i] && typeof target[i] === 'object') {
                    target[i] = merge(target[i], item, options);
                } else {
                    target.push(item);
                }
            } else {
                target[i] = item;
            }
        });
        return target;
    }

    return Object.keys(source).reduce(function (acc, key) {
        var value = source[key];

        if (has$1.call(acc, key)) {
            acc[key] = merge(acc[key], value, options);
        } else {
            acc[key] = value;
        }
        return acc;
    }, mergeTarget);
};

var assign = function assignSingleSource(target, source) {
    return Object.keys(source).reduce(function (acc, key) {
        acc[key] = source[key];
        return acc;
    }, target);
};

var decode = function (str) {
    try {
        return decodeURIComponent(str.replace(/\+/g, ' '));
    } catch (e) {
        return str;
    }
};

var encode = function encode(str) {
    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.
    // It has been adapted here for stricter adherence to RFC 3986
    if (str.length === 0) {
        return str;
    }

    var string = typeof str === 'string' ? str : String(str);

    var out = '';
    for (var i = 0; i < string.length; ++i) {
        var c = string.charCodeAt(i);

        if (
            c === 0x2D // -
            || c === 0x2E // .
            || c === 0x5F // _
            || c === 0x7E // ~
            || (c >= 0x30 && c <= 0x39) // 0-9
            || (c >= 0x41 && c <= 0x5A) // a-z
            || (c >= 0x61 && c <= 0x7A) // A-Z
        ) {
            out += string.charAt(i);
            continue;
        }

        if (c < 0x80) {
            out = out + hexTable[c];
            continue;
        }

        if (c < 0x800) {
            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        if (c < 0xD800 || c >= 0xE000) {
            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);
            continue;
        }

        i += 1;
        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));
        out += hexTable[0xF0 | (c >> 18)]
            + hexTable[0x80 | ((c >> 12) & 0x3F)]
            + hexTable[0x80 | ((c >> 6) & 0x3F)]
            + hexTable[0x80 | (c & 0x3F)];
    }

    return out;
};

var compact = function compact(value) {
    var queue = [{ obj: { o: value }, prop: 'o' }];
    var refs = [];

    for (var i = 0; i < queue.length; ++i) {
        var item = queue[i];
        var obj = item.obj[item.prop];

        var keys = Object.keys(obj);
        for (var j = 0; j < keys.length; ++j) {
            var key = keys[j];
            var val = obj[key];
            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {
                queue.push({ obj: obj, prop: key });
                refs.push(val);
            }
        }
    }

    return compactQueue(queue);
};

var isRegExp = function isRegExp(obj) {
    return Object.prototype.toString.call(obj) === '[object RegExp]';
};

var isBuffer = function isBuffer(obj) {
    if (obj === null || typeof obj === 'undefined') {
        return false;
    }

    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));
};

var utils = {
    arrayToObject: arrayToObject,
    assign: assign,
    compact: compact,
    decode: decode,
    encode: encode,
    isBuffer: isBuffer,
    isRegExp: isRegExp,
    merge: merge
};

var replace = String.prototype.replace;
var percentTwenties = /%20/g;

var formats$1 = {
    'default': 'RFC3986',
    formatters: {
        RFC1738: function (value) {
            return replace.call(value, percentTwenties, '+');
        },
        RFC3986: function (value) {
            return value;
        }
    },
    RFC1738: 'RFC1738',
    RFC3986: 'RFC3986'
};

var arrayPrefixGenerators = {
    brackets: function brackets(prefix) { // eslint-disable-line func-name-matching
        return prefix + '[]';
    },
    indices: function indices(prefix, key) { // eslint-disable-line func-name-matching
        return prefix + '[' + key + ']';
    },
    repeat: function repeat(prefix) { // eslint-disable-line func-name-matching
        return prefix;
    }
};

var toISO = Date.prototype.toISOString;

var defaults$1 = {
    delimiter: '&',
    encode: true,
    encoder: utils.encode,
    encodeValuesOnly: false,
    serializeDate: function serializeDate(date) { // eslint-disable-line func-name-matching
        return toISO.call(date);
    },
    skipNulls: false,
    strictNullHandling: false
};

var stringify = function stringify( // eslint-disable-line func-name-matching
    object,
    prefix,
    generateArrayPrefix,
    strictNullHandling,
    skipNulls,
    encoder,
    filter,
    sort,
    allowDots,
    serializeDate,
    formatter,
    encodeValuesOnly
) {
    var obj = object;
    if (typeof filter === 'function') {
        obj = filter(prefix, obj);
    } else if (obj instanceof Date) {
        obj = serializeDate(obj);
    } else if (obj === null) {
        if (strictNullHandling) {
            return encoder && !encodeValuesOnly ? encoder(prefix, defaults$1.encoder) : prefix;
        }

        obj = '';
    }

    if (typeof obj === 'string' || typeof obj === 'number' || typeof obj === 'boolean' || utils.isBuffer(obj)) {
        if (encoder) {
            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults$1.encoder);
            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults$1.encoder))];
        }
        return [formatter(prefix) + '=' + formatter(String(obj))];
    }

    var values = [];

    if (typeof obj === 'undefined') {
        return values;
    }

    var objKeys;
    if (Array.isArray(filter)) {
        objKeys = filter;
    } else {
        var keys = Object.keys(obj);
        objKeys = sort ? keys.sort(sort) : keys;
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        if (Array.isArray(obj)) {
            values = values.concat(stringify(
                obj[key],
                generateArrayPrefix(prefix, key),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        } else {
            values = values.concat(stringify(
                obj[key],
                prefix + (allowDots ? '.' + key : '[' + key + ']'),
                generateArrayPrefix,
                strictNullHandling,
                skipNulls,
                encoder,
                filter,
                sort,
                allowDots,
                serializeDate,
                formatter,
                encodeValuesOnly
            ));
        }
    }

    return values;
};

var stringify_1 = function (object, opts) {
    var obj = object;
    var options = opts ? utils.assign({}, opts) : {};

    if (options.encoder !== null && options.encoder !== undefined && typeof options.encoder !== 'function') {
        throw new TypeError('Encoder has to be a function.');
    }

    var delimiter = typeof options.delimiter === 'undefined' ? defaults$1.delimiter : options.delimiter;
    var strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults$1.strictNullHandling;
    var skipNulls = typeof options.skipNulls === 'boolean' ? options.skipNulls : defaults$1.skipNulls;
    var encode = typeof options.encode === 'boolean' ? options.encode : defaults$1.encode;
    var encoder = typeof options.encoder === 'function' ? options.encoder : defaults$1.encoder;
    var sort = typeof options.sort === 'function' ? options.sort : null;
    var allowDots = typeof options.allowDots === 'undefined' ? false : options.allowDots;
    var serializeDate = typeof options.serializeDate === 'function' ? options.serializeDate : defaults$1.serializeDate;
    var encodeValuesOnly = typeof options.encodeValuesOnly === 'boolean' ? options.encodeValuesOnly : defaults$1.encodeValuesOnly;
    if (typeof options.format === 'undefined') {
        options.format = formats$1['default'];
    } else if (!Object.prototype.hasOwnProperty.call(formats$1.formatters, options.format)) {
        throw new TypeError('Unknown format option provided.');
    }
    var formatter = formats$1.formatters[options.format];
    var objKeys;
    var filter;

    if (typeof options.filter === 'function') {
        filter = options.filter;
        obj = filter('', obj);
    } else if (Array.isArray(options.filter)) {
        filter = options.filter;
        objKeys = filter;
    }

    var keys = [];

    if (typeof obj !== 'object' || obj === null) {
        return '';
    }

    var arrayFormat;
    if (options.arrayFormat in arrayPrefixGenerators) {
        arrayFormat = options.arrayFormat;
    } else if ('indices' in options) {
        arrayFormat = options.indices ? 'indices' : 'repeat';
    } else {
        arrayFormat = 'indices';
    }

    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];

    if (!objKeys) {
        objKeys = Object.keys(obj);
    }

    if (sort) {
        objKeys.sort(sort);
    }

    for (var i = 0; i < objKeys.length; ++i) {
        var key = objKeys[i];

        if (skipNulls && obj[key] === null) {
            continue;
        }

        keys = keys.concat(stringify(
            obj[key],
            key,
            generateArrayPrefix,
            strictNullHandling,
            skipNulls,
            encode ? encoder : null,
            filter,
            sort,
            allowDots,
            serializeDate,
            formatter,
            encodeValuesOnly
        ));
    }

    var joined = keys.join(delimiter);
    var prefix = options.addQueryPrefix === true ? '?' : '';

    return joined.length > 0 ? prefix + joined : '';
};

var has = Object.prototype.hasOwnProperty;

var defaults = {
    allowDots: false,
    allowPrototypes: false,
    arrayLimit: 20,
    decoder: utils.decode,
    delimiter: '&',
    depth: 5,
    parameterLimit: 1000,
    plainObjects: false,
    strictNullHandling: false
};

var parseValues = function parseQueryStringValues(str, options) {
    var obj = {};
    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\?/, '') : str;
    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;
    var parts = cleanStr.split(options.delimiter, limit);

    for (var i = 0; i < parts.length; ++i) {
        var part = parts[i];

        var bracketEqualsPos = part.indexOf(']=');
        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;

        var key, val;
        if (pos === -1) {
            key = options.decoder(part, defaults.decoder);
            val = options.strictNullHandling ? null : '';
        } else {
            key = options.decoder(part.slice(0, pos), defaults.decoder);
            val = options.decoder(part.slice(pos + 1), defaults.decoder);
        }
        if (has.call(obj, key)) {
            obj[key] = [].concat(obj[key]).concat(val);
        } else {
            obj[key] = val;
        }
    }

    return obj;
};

var parseObject = function (chain, val, options) {
    var leaf = val;

    for (var i = chain.length - 1; i >= 0; --i) {
        var obj;
        var root = chain[i];

        if (root === '[]') {
            obj = [];
            obj = obj.concat(leaf);
        } else {
            obj = options.plainObjects ? Object.create(null) : {};
            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;
            var index = parseInt(cleanRoot, 10);
            if (
                !isNaN(index)
                && root !== cleanRoot
                && String(index) === cleanRoot
                && index >= 0
                && (options.parseArrays && index <= options.arrayLimit)
            ) {
                obj = [];
                obj[index] = leaf;
            } else {
                obj[cleanRoot] = leaf;
            }
        }

        leaf = obj;
    }

    return leaf;
};

var parseKeys = function parseQueryStringKeys(givenKey, val, options) {
    if (!givenKey) {
        return;
    }

    // Transform dot notation to bracket notation
    var key = options.allowDots ? givenKey.replace(/\.([^.[]+)/g, '[$1]') : givenKey;

    // The regex chunks

    var brackets = /(\[[^[\]]*])/;
    var child = /(\[[^[\]]*])/g;

    // Get the parent

    var segment = brackets.exec(key);
    var parent = segment ? key.slice(0, segment.index) : key;

    // Stash the parent if it exists

    var keys = [];
    if (parent) {
        // If we aren't using plain objects, optionally prefix keys
        // that would overwrite object prototype properties
        if (!options.plainObjects && has.call(Object.prototype, parent)) {
            if (!options.allowPrototypes) {
                return;
            }
        }

        keys.push(parent);
    }

    // Loop through children appending to the array until we hit depth

    var i = 0;
    while ((segment = child.exec(key)) !== null && i < options.depth) {
        i += 1;
        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {
            if (!options.allowPrototypes) {
                return;
            }
        }
        keys.push(segment[1]);
    }

    // If there's a remainder, just add whatever is left

    if (segment) {
        keys.push('[' + key.slice(segment.index) + ']');
    }

    return parseObject(keys, val, options);
};

var parse$1 = function (str, opts) {
    var options = opts ? utils.assign({}, opts) : {};

    if (options.decoder !== null && options.decoder !== undefined && typeof options.decoder !== 'function') {
        throw new TypeError('Decoder has to be a function.');
    }

    options.ignoreQueryPrefix = options.ignoreQueryPrefix === true;
    options.delimiter = typeof options.delimiter === 'string' || utils.isRegExp(options.delimiter) ? options.delimiter : defaults.delimiter;
    options.depth = typeof options.depth === 'number' ? options.depth : defaults.depth;
    options.arrayLimit = typeof options.arrayLimit === 'number' ? options.arrayLimit : defaults.arrayLimit;
    options.parseArrays = options.parseArrays !== false;
    options.decoder = typeof options.decoder === 'function' ? options.decoder : defaults.decoder;
    options.allowDots = typeof options.allowDots === 'boolean' ? options.allowDots : defaults.allowDots;
    options.plainObjects = typeof options.plainObjects === 'boolean' ? options.plainObjects : defaults.plainObjects;
    options.allowPrototypes = typeof options.allowPrototypes === 'boolean' ? options.allowPrototypes : defaults.allowPrototypes;
    options.parameterLimit = typeof options.parameterLimit === 'number' ? options.parameterLimit : defaults.parameterLimit;
    options.strictNullHandling = typeof options.strictNullHandling === 'boolean' ? options.strictNullHandling : defaults.strictNullHandling;

    if (str === '' || str === null || typeof str === 'undefined') {
        return options.plainObjects ? Object.create(null) : {};
    }

    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;
    var obj = options.plainObjects ? Object.create(null) : {};

    // Iterate over the keys and setup the new object

    var keys = Object.keys(tempObj);
    for (var i = 0; i < keys.length; ++i) {
        var key = keys[i];
        var newObj = parseKeys(key, tempObj[key], options);
        obj = utils.merge(obj, newObj, options);
    }

    return utils.compact(obj);
};

var lib$c = {
    formats: formats$1,
    parse: parse$1,
    stringify: stringify_1
};

function Querystring$1 (request) {
  this.request = request;
  this.lib = null;
  this.useQuerystring = null;
  this.parseOptions = null;
  this.stringifyOptions = null;
}

Querystring$1.prototype.init = function (options) {
  if (this.lib) { return }

  this.useQuerystring = options.useQuerystring;
  this.lib = (this.useQuerystring ? querystring : lib$c);

  this.parseOptions = options.qsParseOptions || {};
  this.stringifyOptions = options.qsStringifyOptions || {};
};

Querystring$1.prototype.stringify = function (obj) {
  return (this.useQuerystring)
    ? this.rfc3986(this.lib.stringify(obj,
      this.stringifyOptions.sep || null,
      this.stringifyOptions.eq || null,
      this.stringifyOptions))
    : this.lib.stringify(obj, this.stringifyOptions)
};

Querystring$1.prototype.parse = function (str) {
  return (this.useQuerystring)
    ? this.lib.parse(str,
      this.parseOptions.sep || null,
      this.parseOptions.eq || null,
      this.parseOptions)
    : this.lib.parse(str, this.parseOptions)
};

Querystring$1.prototype.rfc3986 = function (str) {
  return str.replace(/[!'()*]/g, function (c) {
    return '%' + c.charCodeAt(0).toString(16).toUpperCase()
  })
};

Querystring$1.prototype.unescape = querystring.unescape;

var Querystring_1 = Querystring$1;

var querystring_1 = {
	Querystring: Querystring_1
};

/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */

var uri_all = createCommonjsModule(function (module, exports) {
(function (global, factory) {
	factory(exports) ;
}(commonjsGlobal, (function (exports) {
function merge() {
    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {
        sets[_key] = arguments[_key];
    }

    if (sets.length > 1) {
        sets[0] = sets[0].slice(0, -1);
        var xl = sets.length - 1;
        for (var x = 1; x < xl; ++x) {
            sets[x] = sets[x].slice(1, -1);
        }
        sets[xl] = sets[xl].slice(1);
        return sets.join('');
    } else {
        return sets[0];
    }
}
function subexp(str) {
    return "(?:" + str + ")";
}
function typeOf(o) {
    return o === undefined ? "undefined" : o === null ? "null" : Object.prototype.toString.call(o).split(" ").pop().split("]").shift().toLowerCase();
}
function toUpperCase(str) {
    return str.toUpperCase();
}
function toArray(obj) {
    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== "number" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];
}
function assign(target, source) {
    var obj = target;
    if (source) {
        for (var key in source) {
            obj[key] = source[key];
        }
    }
    return obj;
}

function buildExps(isIRI) {
    var ALPHA$$ = "[A-Za-z]",
        DIGIT$$ = "[0-9]",
        HEXDIG$$ = merge(DIGIT$$, "[A-Fa-f]"),
        PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)),
        //expanded
    GEN_DELIMS$$ = "[\\:\\/\\?\\#\\[\\]\\@]",
        SUB_DELIMS$$ = "[\\!\\$\\&\\'\\(\\)\\*\\+\\,\\;\\=]",
        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),
        UCSCHAR$$ = isIRI ? "[\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF]" : "[]",
        //subset, excludes bidi control characters
    IPRIVATE$$ = isIRI ? "[\\uE000-\\uF8FF]" : "[]",
        //subset
    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, "[\\-\\.\\_\\~]", UCSCHAR$$);
        subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, "[\\+\\-\\.]") + "*");
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]")) + "*");
        var DEC_OCTET_RELAXED$ = subexp(subexp("25[0-5]") + "|" + subexp("2[0-4]" + DIGIT$$) + "|" + subexp("1" + DIGIT$$ + DIGIT$$) + "|" + subexp("0?[1-9]" + DIGIT$$) + "|0?0?" + DIGIT$$),
        //relaxed parsing rules
    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$ + "\\." + DEC_OCTET_RELAXED$),
        H16$ = subexp(HEXDIG$$ + "{1,4}"),
        LS32$ = subexp(subexp(H16$ + "\\:" + H16$) + "|" + IPV4ADDRESS$),
        IPV6ADDRESS1$ = subexp(subexp(H16$ + "\\:") + "{6}" + LS32$),
        //                           6( h16 ":" ) ls32
    IPV6ADDRESS2$ = subexp("\\:\\:" + subexp(H16$ + "\\:") + "{5}" + LS32$),
        //                      "::" 5( h16 ":" ) ls32
    IPV6ADDRESS3$ = subexp(subexp(H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{4}" + LS32$),
        //[               h16 ] "::" 4( h16 ":" ) ls32
    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,1}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{3}" + LS32$),
        //[ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,2}" + H16$) + "?\\:\\:" + subexp(H16$ + "\\:") + "{2}" + LS32$),
        //[ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,3}" + H16$) + "?\\:\\:" + H16$ + "\\:" + LS32$),
        //[ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,4}" + H16$) + "?\\:\\:" + LS32$),
        //[ *4( h16 ":" ) h16 ] "::"              ls32
    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,5}" + H16$) + "?\\:\\:" + H16$),
        //[ *5( h16 ":" ) h16 ] "::"              h16
    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + "\\:") + "{0,6}" + H16$) + "?\\:\\:"),
        //[ *6( h16 ":" ) h16 ] "::"
    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join("|")),
        ZONEID$ = subexp(subexp(UNRESERVED$$ + "|" + PCT_ENCODED$) + "+");
        //RFC 6874, with relaxed parsing rules
    subexp("[vV]" + HEXDIG$$ + "+\\." + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:]") + "+");
        //RFC 6874
    subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$)) + "*");
        var PCHAR$ = subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@]"));
        subexp(subexp(PCT_ENCODED$ + "|" + merge(UNRESERVED$$, SUB_DELIMS$$, "[\\@]")) + "+");
        subexp(subexp(PCHAR$ + "|" + merge("[\\/\\?]", IPRIVATE$$)) + "*");
    return {
        NOT_SCHEME: new RegExp(merge("[^]", ALPHA$$, DIGIT$$, "[\\+\\-\\.]"), "g"),
        NOT_USERINFO: new RegExp(merge("[^\\%\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_HOST: new RegExp(merge("[^\\%\\[\\]\\:]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH: new RegExp(merge("[^\\%\\/\\:\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_PATH_NOSCHEME: new RegExp(merge("[^\\%\\/\\@]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        NOT_QUERY: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]", IPRIVATE$$), "g"),
        NOT_FRAGMENT: new RegExp(merge("[^\\%]", UNRESERVED$$, SUB_DELIMS$$, "[\\:\\@\\/\\?]"), "g"),
        ESCAPE: new RegExp(merge("[^]", UNRESERVED$$, SUB_DELIMS$$), "g"),
        UNRESERVED: new RegExp(UNRESERVED$$, "g"),
        OTHER_CHARS: new RegExp(merge("[^\\%]", UNRESERVED$$, RESERVED$$), "g"),
        PCT_ENCODED: new RegExp(PCT_ENCODED$, "g"),
        IPV4ADDRESS: new RegExp("^(" + IPV4ADDRESS$ + ")$"),
        IPV6ADDRESS: new RegExp("^\\[?(" + IPV6ADDRESS$ + ")" + subexp(subexp("\\%25|\\%(?!" + HEXDIG$$ + "{2})") + "(" + ZONEID$ + ")") + "?\\]?$") //RFC 6874, with relaxed parsing rules
    };
}
var URI_PROTOCOL = buildExps(false);

var IRI_PROTOCOL = buildExps(true);

var slicedToArray = function () {
  function sliceIterator(arr, i) {
    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"]) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  return function (arr, i) {
    if (Array.isArray(arr)) {
      return arr;
    } else if (Symbol.iterator in Object(arr)) {
      return sliceIterator(arr, i);
    } else {
      throw new TypeError("Invalid attempt to destructure non-iterable instance");
    }
  };
}();













var toConsumableArray = function (arr) {
  if (Array.isArray(arr)) {
    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

    return arr2;
  } else {
    return Array.from(arr);
  }
};

/** Highest positive signed 32-bit float value */

var maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1

/** Bootstring parameters */
var base = 36;
var tMin = 1;
var tMax = 26;
var skew = 38;
var damp = 700;
var initialBias = 72;
var initialN = 128; // 0x80
var delimiter = '-'; // '\x2D'

/** Regular expressions */
var regexPunycode = /^xn--/;
var regexNonASCII = /[^\0-\x7E]/; // non-ASCII chars
var regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g; // RFC 3490 separators

/** Error messages */
var errors = {
	'overflow': 'Overflow: input needs wider integers to process',
	'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
	'invalid-input': 'Invalid input'
};

/** Convenience shortcuts */
var baseMinusTMin = base - tMin;
var floor = Math.floor;
var stringFromCharCode = String.fromCharCode;

/*--------------------------------------------------------------------------*/

/**
 * A generic error utility function.
 * @private
 * @param {String} type The error type.
 * @returns {Error} Throws a `RangeError` with the applicable error message.
 */
function error$1(type) {
	throw new RangeError(errors[type]);
}

/**
 * A generic `Array#map` utility function.
 * @private
 * @param {Array} array The array to iterate over.
 * @param {Function} callback The function that gets called for every array
 * item.
 * @returns {Array} A new array of values returned by the callback function.
 */
function map(array, fn) {
	var result = [];
	var length = array.length;
	while (length--) {
		result[length] = fn(array[length]);
	}
	return result;
}

/**
 * A simple `Array#map`-like wrapper to work with domain name strings or email
 * addresses.
 * @private
 * @param {String} domain The domain name or email address.
 * @param {Function} callback The function that gets called for every
 * character.
 * @returns {Array} A new string of characters returned by the callback
 * function.
 */
function mapDomain(string, fn) {
	var parts = string.split('@');
	var result = '';
	if (parts.length > 1) {
		// In email addresses, only the domain name should be punycoded. Leave
		// the local part (i.e. everything up to `@`) intact.
		result = parts[0] + '@';
		string = parts[1];
	}
	// Avoid `split(regex)` for IE8 compatibility. See #17.
	string = string.replace(regexSeparators, '\x2E');
	var labels = string.split('.');
	var encoded = map(labels, fn).join('.');
	return result + encoded;
}

/**
 * Creates an array containing the numeric code points of each Unicode
 * character in the string. While JavaScript uses UCS-2 internally,
 * this function will convert a pair of surrogate halves (each of which
 * UCS-2 exposes as separate characters) into a single code point,
 * matching UTF-16.
 * @see `punycode.ucs2.encode`
 * @see <https://mathiasbynens.be/notes/javascript-encoding>
 * @memberOf punycode.ucs2
 * @name decode
 * @param {String} string The Unicode input string (UCS-2).
 * @returns {Array} The new array of code points.
 */
function ucs2decode(string) {
	var output = [];
	var counter = 0;
	var length = string.length;
	while (counter < length) {
		var value = string.charCodeAt(counter++);
		if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
			// It's a high surrogate, and there is a next character.
			var extra = string.charCodeAt(counter++);
			if ((extra & 0xFC00) == 0xDC00) {
				// Low surrogate.
				output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
			} else {
				// It's an unmatched surrogate; only append this code unit, in case the
				// next code unit is the high surrogate of a surrogate pair.
				output.push(value);
				counter--;
			}
		} else {
			output.push(value);
		}
	}
	return output;
}

/**
 * Creates a string based on an array of numeric code points.
 * @see `punycode.ucs2.decode`
 * @memberOf punycode.ucs2
 * @name encode
 * @param {Array} codePoints The array of numeric code points.
 * @returns {String} The new Unicode string (UCS-2).
 */
var ucs2encode = function ucs2encode(array) {
	return String.fromCodePoint.apply(String, toConsumableArray(array));
};

/**
 * Converts a basic code point into a digit/integer.
 * @see `digitToBasic()`
 * @private
 * @param {Number} codePoint The basic numeric code point value.
 * @returns {Number} The numeric value of a basic code point (for use in
 * representing integers) in the range `0` to `base - 1`, or `base` if
 * the code point does not represent a value.
 */
var basicToDigit = function basicToDigit(codePoint) {
	if (codePoint - 0x30 < 0x0A) {
		return codePoint - 0x16;
	}
	if (codePoint - 0x41 < 0x1A) {
		return codePoint - 0x41;
	}
	if (codePoint - 0x61 < 0x1A) {
		return codePoint - 0x61;
	}
	return base;
};

/**
 * Converts a digit/integer into a basic code point.
 * @see `basicToDigit()`
 * @private
 * @param {Number} digit The numeric value of a basic code point.
 * @returns {Number} The basic code point whose value (when used for
 * representing integers) is `digit`, which needs to be in the range
 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
 * used; else, the lowercase form is used. The behavior is undefined
 * if `flag` is non-zero and `digit` has no uppercase form.
 */
var digitToBasic = function digitToBasic(digit, flag) {
	//  0..25 map to ASCII a..z or A..Z
	// 26..35 map to ASCII 0..9
	return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
};

/**
 * Bias adaptation function as per section 3.4 of RFC 3492.
 * https://tools.ietf.org/html/rfc3492#section-3.4
 * @private
 */
var adapt = function adapt(delta, numPoints, firstTime) {
	var k = 0;
	delta = firstTime ? floor(delta / damp) : delta >> 1;
	delta += floor(delta / numPoints);
	for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
		delta = floor(delta / baseMinusTMin);
	}
	return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
};

/**
 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
 * symbols.
 * @memberOf punycode
 * @param {String} input The Punycode string of ASCII-only symbols.
 * @returns {String} The resulting string of Unicode symbols.
 */
var decode = function decode(input) {
	// Don't use UCS-2.
	var output = [];
	var inputLength = input.length;
	var i = 0;
	var n = initialN;
	var bias = initialBias;

	// Handle the basic code points: let `basic` be the number of input code
	// points before the last delimiter, or `0` if there is none, then copy
	// the first basic code points to the output.

	var basic = input.lastIndexOf(delimiter);
	if (basic < 0) {
		basic = 0;
	}

	for (var j = 0; j < basic; ++j) {
		// if it's not a basic code point
		if (input.charCodeAt(j) >= 0x80) {
			error$1('not-basic');
		}
		output.push(input.charCodeAt(j));
	}

	// Main decoding loop: start just after the last delimiter if any basic code
	// points were copied; start at the beginning otherwise.

	for (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

		// `index` is the index of the next character to be consumed.
		// Decode a generalized variable-length integer into `delta`,
		// which gets added to `i`. The overflow checking is easier
		// if we increase `i` as we go, then subtract off its starting
		// value at the end to obtain `delta`.
		var oldi = i;
		for (var w = 1, k = base;; /* no condition */k += base) {

			if (index >= inputLength) {
				error$1('invalid-input');
			}

			var digit = basicToDigit(input.charCodeAt(index++));

			if (digit >= base || digit > floor((maxInt - i) / w)) {
				error$1('overflow');
			}

			i += digit * w;
			var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

			if (digit < t) {
				break;
			}

			var baseMinusT = base - t;
			if (w > floor(maxInt / baseMinusT)) {
				error$1('overflow');
			}

			w *= baseMinusT;
		}

		var out = output.length + 1;
		bias = adapt(i - oldi, out, oldi == 0);

		// `i` was supposed to wrap around from `out` to `0`,
		// incrementing `n` each time, so we'll fix that now:
		if (floor(i / out) > maxInt - n) {
			error$1('overflow');
		}

		n += floor(i / out);
		i %= out;

		// Insert `n` at position `i` of the output.
		output.splice(i++, 0, n);
	}

	return String.fromCodePoint.apply(String, output);
};

/**
 * Converts a string of Unicode symbols (e.g. a domain name label) to a
 * Punycode string of ASCII-only symbols.
 * @memberOf punycode
 * @param {String} input The string of Unicode symbols.
 * @returns {String} The resulting Punycode string of ASCII-only symbols.
 */
var encode = function encode(input) {
	var output = [];

	// Convert the input in UCS-2 to an array of Unicode code points.
	input = ucs2decode(input);

	// Cache the length.
	var inputLength = input.length;

	// Initialize the state.
	var n = initialN;
	var delta = 0;
	var bias = initialBias;

	// Handle the basic code points.
	var _iteratorNormalCompletion = true;
	var _didIteratorError = false;
	var _iteratorError = undefined;

	try {
		for (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
			var _currentValue2 = _step.value;

			if (_currentValue2 < 0x80) {
				output.push(stringFromCharCode(_currentValue2));
			}
		}
	} catch (err) {
		_didIteratorError = true;
		_iteratorError = err;
	} finally {
		try {
			if (!_iteratorNormalCompletion && _iterator.return) {
				_iterator.return();
			}
		} finally {
			if (_didIteratorError) {
				throw _iteratorError;
			}
		}
	}

	var basicLength = output.length;
	var handledCPCount = basicLength;

	// `handledCPCount` is the number of code points that have been handled;
	// `basicLength` is the number of basic code points.

	// Finish the basic string with a delimiter unless it's empty.
	if (basicLength) {
		output.push(delimiter);
	}

	// Main encoding loop:
	while (handledCPCount < inputLength) {

		// All non-basic code points < n have been handled already. Find the next
		// larger one:
		var m = maxInt;
		var _iteratorNormalCompletion2 = true;
		var _didIteratorError2 = false;
		var _iteratorError2 = undefined;

		try {
			for (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
				var currentValue = _step2.value;

				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow.
		} catch (err) {
			_didIteratorError2 = true;
			_iteratorError2 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion2 && _iterator2.return) {
					_iterator2.return();
				}
			} finally {
				if (_didIteratorError2) {
					throw _iteratorError2;
				}
			}
		}

		var handledCPCountPlusOne = handledCPCount + 1;
		if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
			error$1('overflow');
		}

		delta += (m - n) * handledCPCountPlusOne;
		n = m;

		var _iteratorNormalCompletion3 = true;
		var _didIteratorError3 = false;
		var _iteratorError3 = undefined;

		try {
			for (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
				var _currentValue = _step3.value;

				if (_currentValue < n && ++delta > maxInt) {
					error$1('overflow');
				}
				if (_currentValue == n) {
					// Represent delta as a generalized variable-length integer.
					var q = delta;
					for (var k = base;; /* no condition */k += base) {
						var t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
						if (q < t) {
							break;
						}
						var qMinusT = q - t;
						var baseMinusT = base - t;
						output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}
		} catch (err) {
			_didIteratorError3 = true;
			_iteratorError3 = err;
		} finally {
			try {
				if (!_iteratorNormalCompletion3 && _iterator3.return) {
					_iterator3.return();
				}
			} finally {
				if (_didIteratorError3) {
					throw _iteratorError3;
				}
			}
		}

		++delta;
		++n;
	}
	return output.join('');
};

/**
 * Converts a Punycode string representing a domain name or an email address
 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
 * it doesn't matter if you call it on a string that has already been
 * converted to Unicode.
 * @memberOf punycode
 * @param {String} input The Punycoded domain name or email address to
 * convert to Unicode.
 * @returns {String} The Unicode representation of the given Punycode
 * string.
 */
var toUnicode = function toUnicode(input) {
	return mapDomain(input, function (string) {
		return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
	});
};

/**
 * Converts a Unicode string representing a domain name or an email address to
 * Punycode. Only the non-ASCII parts of the domain name will be converted,
 * i.e. it doesn't matter if you call it with a domain that's already in
 * ASCII.
 * @memberOf punycode
 * @param {String} input The domain name or email address to convert, as a
 * Unicode string.
 * @returns {String} The Punycode representation of the given domain name or
 * email address.
 */
var toASCII = function toASCII(input) {
	return mapDomain(input, function (string) {
		return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
	});
};

/*--------------------------------------------------------------------------*/

/** Define the public API */
var punycode = {
	/**
  * A string representing the current Punycode.js version number.
  * @memberOf punycode
  * @type String
  */
	'version': '2.1.0',
	/**
  * An object of methods to convert from JavaScript's internal character
  * representation (UCS-2) to Unicode code points, and back.
  * @see <https://mathiasbynens.be/notes/javascript-encoding>
  * @memberOf punycode
  * @type Object
  */
	'ucs2': {
		'decode': ucs2decode,
		'encode': ucs2encode
	},
	'decode': decode,
	'encode': encode,
	'toASCII': toASCII,
	'toUnicode': toUnicode
};

/**
 * URI.js
 *
 * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.
 * @author <a href="mailto:gary.court@gmail.com">Gary Court</a>
 * @see http://github.com/garycourt/uri-js
 */
/**
 * Copyright 2011 Gary Court. All rights reserved.
 *
 * Redistribution and use in source and binary forms, with or without modification, are
 * permitted provided that the following conditions are met:
 *
 *    1. Redistributions of source code must retain the above copyright notice, this list of
 *       conditions and the following disclaimer.
 *
 *    2. Redistributions in binary form must reproduce the above copyright notice, this list
 *       of conditions and the following disclaimer in the documentation and/or other materials
 *       provided with the distribution.
 *
 * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED
 * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
 * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR
 * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR
 * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
 * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF
 * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * The views and conclusions contained in the software and documentation are those of the
 * authors and should not be interpreted as representing official policies, either expressed
 * or implied, of Gary Court.
 */
var SCHEMES = {};
function pctEncChar(chr) {
    var c = chr.charCodeAt(0);
    var e = void 0;
    if (c < 16) e = "%0" + c.toString(16).toUpperCase();else if (c < 128) e = "%" + c.toString(16).toUpperCase();else if (c < 2048) e = "%" + (c >> 6 | 192).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();else e = "%" + (c >> 12 | 224).toString(16).toUpperCase() + "%" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + "%" + (c & 63 | 128).toString(16).toUpperCase();
    return e;
}
function pctDecChars(str) {
    var newStr = "";
    var i = 0;
    var il = str.length;
    while (i < il) {
        var c = parseInt(str.substr(i + 1, 2), 16);
        if (c < 128) {
            newStr += String.fromCharCode(c);
            i += 3;
        } else if (c >= 194 && c < 224) {
            if (il - i >= 6) {
                var c2 = parseInt(str.substr(i + 4, 2), 16);
                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);
            } else {
                newStr += str.substr(i, 6);
            }
            i += 6;
        } else if (c >= 224) {
            if (il - i >= 9) {
                var _c = parseInt(str.substr(i + 4, 2), 16);
                var c3 = parseInt(str.substr(i + 7, 2), 16);
                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);
            } else {
                newStr += str.substr(i, 9);
            }
            i += 9;
        } else {
            newStr += str.substr(i, 3);
            i += 3;
        }
    }
    return newStr;
}
function _normalizeComponentEncoding(components, protocol) {
    function decodeUnreserved(str) {
        var decStr = pctDecChars(str);
        return !decStr.match(protocol.UNRESERVED) ? str : decStr;
    }
    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, "");
    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);
    return components;
}

function _stripLeadingZeros(str) {
    return str.replace(/^0*(.*)/, "$1") || "0";
}
function _normalizeIPv4(host, protocol) {
    var matches = host.match(protocol.IPV4ADDRESS) || [];

    var _matches = slicedToArray(matches, 2),
        address = _matches[1];

    if (address) {
        return address.split(".").map(_stripLeadingZeros).join(".");
    } else {
        return host;
    }
}
function _normalizeIPv6(host, protocol) {
    var matches = host.match(protocol.IPV6ADDRESS) || [];

    var _matches2 = slicedToArray(matches, 3),
        address = _matches2[1],
        zone = _matches2[2];

    if (address) {
        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),
            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),
            last = _address$toLowerCase$2[0],
            first = _address$toLowerCase$2[1];

        var firstFields = first ? first.split(":").map(_stripLeadingZeros) : [];
        var lastFields = last.split(":").map(_stripLeadingZeros);
        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);
        var fieldCount = isLastFieldIPv4Address ? 7 : 8;
        var lastFieldsStart = lastFields.length - fieldCount;
        var fields = Array(fieldCount);
        for (var x = 0; x < fieldCount; ++x) {
            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';
        }
        if (isLastFieldIPv4Address) {
            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);
        }
        var allZeroFields = fields.reduce(function (acc, field, index) {
            if (!field || field === "0") {
                var lastLongest = acc[acc.length - 1];
                if (lastLongest && lastLongest.index + lastLongest.length === index) {
                    lastLongest.length++;
                } else {
                    acc.push({ index: index, length: 1 });
                }
            }
            return acc;
        }, []);
        var longestZeroFields = allZeroFields.sort(function (a, b) {
            return b.length - a.length;
        })[0];
        var newHost = void 0;
        if (longestZeroFields && longestZeroFields.length > 1) {
            var newFirst = fields.slice(0, longestZeroFields.index);
            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);
            newHost = newFirst.join(":") + "::" + newLast.join(":");
        } else {
            newHost = fields.join(":");
        }
        if (zone) {
            newHost += "%" + zone;
        }
        return newHost;
    } else {
        return host;
    }
}
var URI_PARSE = /^(?:([^:\/?#]+):)?(?:\/\/((?:([^\/?#@]*)@)?(\[[^\/?#\]]+\]|[^\/?#:]*)(?:\:(\d*))?))?([^?#]*)(?:\?([^#]*))?(?:#((?:.|\n|\r)*))?/i;
var NO_MATCH_IS_UNDEFINED = "".match(/(){0}/)[1] === undefined;
function parse(uriString) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var components = {};
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    if (options.reference === "suffix") uriString = (options.scheme ? options.scheme + ":" : "") + "//" + uriString;
    var matches = uriString.match(URI_PARSE);
    if (matches) {
        if (NO_MATCH_IS_UNDEFINED) {
            //store each component
            components.scheme = matches[1];
            components.userinfo = matches[3];
            components.host = matches[4];
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = matches[7];
            components.fragment = matches[8];
            //fix port number
            if (isNaN(components.port)) {
                components.port = matches[5];
            }
        } else {
            //IE FIX for improper RegExp matching
            //store each component
            components.scheme = matches[1] || undefined;
            components.userinfo = uriString.indexOf("@") !== -1 ? matches[3] : undefined;
            components.host = uriString.indexOf("//") !== -1 ? matches[4] : undefined;
            components.port = parseInt(matches[5], 10);
            components.path = matches[6] || "";
            components.query = uriString.indexOf("?") !== -1 ? matches[7] : undefined;
            components.fragment = uriString.indexOf("#") !== -1 ? matches[8] : undefined;
            //fix port number
            if (isNaN(components.port)) {
                components.port = uriString.match(/\/\/(?:.|\n)*\:(?:\/|\?|\#|$)/) ? matches[4] : undefined;
            }
        }
        if (components.host) {
            //normalize IP hosts
            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);
        }
        //determine reference type
        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {
            components.reference = "same-document";
        } else if (components.scheme === undefined) {
            components.reference = "relative";
        } else if (components.fragment === undefined) {
            components.reference = "absolute";
        } else {
            components.reference = "uri";
        }
        //check for reference errors
        if (options.reference && options.reference !== "suffix" && options.reference !== components.reference) {
            components.error = components.error || "URI is not a " + options.reference + " reference.";
        }
        //find scheme handler
        var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
        //check if scheme can't handle IRIs
        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {
            //if host component is a domain name
            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to ASCII via punycode: " + e;
                }
            }
            //convert IRI -> URI
            _normalizeComponentEncoding(components, URI_PROTOCOL);
        } else {
            //normalize encodings
            _normalizeComponentEncoding(components, protocol);
        }
        //perform scheme specific parsing
        if (schemeHandler && schemeHandler.parse) {
            schemeHandler.parse(components, options);
        }
    } else {
        components.error = components.error || "URI can not be parsed.";
    }
    return components;
}

function _recomposeAuthority(components, options) {
    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    if (components.userinfo !== undefined) {
        uriTokens.push(components.userinfo);
        uriTokens.push("@");
    }
    if (components.host !== undefined) {
        //normalize IP hosts, add brackets and escape zone separator for IPv6
        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {
            return "[" + $1 + ($2 ? "%25" + $2 : "") + "]";
        }));
    }
    if (typeof components.port === "number" || typeof components.port === "string") {
        uriTokens.push(":");
        uriTokens.push(String(components.port));
    }
    return uriTokens.length ? uriTokens.join("") : undefined;
}

var RDS1 = /^\.\.?\//;
var RDS2 = /^\/\.(\/|$)/;
var RDS3 = /^\/\.\.(\/|$)/;
var RDS5 = /^\/?(?:.|\n)*?(?=\/|$)/;
function removeDotSegments(input) {
    var output = [];
    while (input.length) {
        if (input.match(RDS1)) {
            input = input.replace(RDS1, "");
        } else if (input.match(RDS2)) {
            input = input.replace(RDS2, "/");
        } else if (input.match(RDS3)) {
            input = input.replace(RDS3, "/");
            output.pop();
        } else if (input === "." || input === "..") {
            input = "";
        } else {
            var im = input.match(RDS5);
            if (im) {
                var s = im[0];
                input = input.slice(s.length);
                output.push(s);
            } else {
                throw new Error("Unexpected dot segment condition");
            }
        }
    }
    return output.join("");
}

function serialize(components) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;
    var uriTokens = [];
    //find scheme handler
    var schemeHandler = SCHEMES[(options.scheme || components.scheme || "").toLowerCase()];
    //perform scheme specific serialization
    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);
    if (components.host) {
        //if host component is an IPv6 address
        if (protocol.IPV6ADDRESS.test(components.host)) ;
        //TODO: normalize IPv6 address as per RFC 5952

        //if host component is a domain name
        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {
                //convert IDN via punycode
                try {
                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);
                } catch (e) {
                    components.error = components.error || "Host's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
            }
    }
    //normalize encoding
    _normalizeComponentEncoding(components, protocol);
    if (options.reference !== "suffix" && components.scheme) {
        uriTokens.push(components.scheme);
        uriTokens.push(":");
    }
    var authority = _recomposeAuthority(components, options);
    if (authority !== undefined) {
        if (options.reference !== "suffix") {
            uriTokens.push("//");
        }
        uriTokens.push(authority);
        if (components.path && components.path.charAt(0) !== "/") {
            uriTokens.push("/");
        }
    }
    if (components.path !== undefined) {
        var s = components.path;
        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {
            s = removeDotSegments(s);
        }
        if (authority === undefined) {
            s = s.replace(/^\/\//, "/%2F"); //don't allow the path to start with "//"
        }
        uriTokens.push(s);
    }
    if (components.query !== undefined) {
        uriTokens.push("?");
        uriTokens.push(components.query);
    }
    if (components.fragment !== undefined) {
        uriTokens.push("#");
        uriTokens.push(components.fragment);
    }
    return uriTokens.join(""); //merge tokens into a string
}

function resolveComponents(base, relative) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    var skipNormalization = arguments[3];

    var target = {};
    if (!skipNormalization) {
        base = parse(serialize(base, options), options); //normalize base components
        relative = parse(serialize(relative, options), options); //normalize relative components
    }
    options = options || {};
    if (!options.tolerant && relative.scheme) {
        target.scheme = relative.scheme;
        //target.authority = relative.authority;
        target.userinfo = relative.userinfo;
        target.host = relative.host;
        target.port = relative.port;
        target.path = removeDotSegments(relative.path || "");
        target.query = relative.query;
    } else {
        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {
            //target.authority = relative.authority;
            target.userinfo = relative.userinfo;
            target.host = relative.host;
            target.port = relative.port;
            target.path = removeDotSegments(relative.path || "");
            target.query = relative.query;
        } else {
            if (!relative.path) {
                target.path = base.path;
                if (relative.query !== undefined) {
                    target.query = relative.query;
                } else {
                    target.query = base.query;
                }
            } else {
                if (relative.path.charAt(0) === "/") {
                    target.path = removeDotSegments(relative.path);
                } else {
                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {
                        target.path = "/" + relative.path;
                    } else if (!base.path) {
                        target.path = relative.path;
                    } else {
                        target.path = base.path.slice(0, base.path.lastIndexOf("/") + 1) + relative.path;
                    }
                    target.path = removeDotSegments(target.path);
                }
                target.query = relative.query;
            }
            //target.authority = base.authority;
            target.userinfo = base.userinfo;
            target.host = base.host;
            target.port = base.port;
        }
        target.scheme = base.scheme;
    }
    target.fragment = relative.fragment;
    return target;
}

function resolve(baseURI, relativeURI, options) {
    var schemelessOptions = assign({ scheme: 'null' }, options);
    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);
}

function normalize(uri, options) {
    if (typeof uri === "string") {
        uri = serialize(parse(uri, options), options);
    } else if (typeOf(uri) === "object") {
        uri = parse(serialize(uri, options), options);
    }
    return uri;
}

function equal(uriA, uriB, options) {
    if (typeof uriA === "string") {
        uriA = serialize(parse(uriA, options), options);
    } else if (typeOf(uriA) === "object") {
        uriA = serialize(uriA, options);
    }
    if (typeof uriB === "string") {
        uriB = serialize(parse(uriB, options), options);
    } else if (typeOf(uriB) === "object") {
        uriB = serialize(uriB, options);
    }
    return uriA === uriB;
}

function escapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);
}

function unescapeComponent(str, options) {
    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);
}

var handler = {
    scheme: "http",
    domainHost: true,
    parse: function parse(components, options) {
        //report missing host
        if (!components.host) {
            components.error = components.error || "HTTP URIs must have a host.";
        }
        return components;
    },
    serialize: function serialize(components, options) {
        var secure = String(components.scheme).toLowerCase() === "https";
        //normalize the default port
        if (components.port === (secure ? 443 : 80) || components.port === "") {
            components.port = undefined;
        }
        //normalize the empty path
        if (!components.path) {
            components.path = "/";
        }
        //NOTE: We do not parse query strings for HTTP URIs
        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,
        //and not the HTTP spec.
        return components;
    }
};

var handler$1 = {
    scheme: "https",
    domainHost: handler.domainHost,
    parse: handler.parse,
    serialize: handler.serialize
};

function isSecure(wsComponents) {
    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === "wss";
}
//RFC 6455
var handler$2 = {
    scheme: "ws",
    domainHost: true,
    parse: function parse(components, options) {
        var wsComponents = components;
        //indicate if the secure flag is set
        wsComponents.secure = isSecure(wsComponents);
        //construct resouce name
        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');
        wsComponents.path = undefined;
        wsComponents.query = undefined;
        return wsComponents;
    },
    serialize: function serialize(wsComponents, options) {
        //normalize the default port
        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === "") {
            wsComponents.port = undefined;
        }
        //ensure scheme matches secure flag
        if (typeof wsComponents.secure === 'boolean') {
            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';
            wsComponents.secure = undefined;
        }
        //reconstruct path from resource name
        if (wsComponents.resourceName) {
            var _wsComponents$resourc = wsComponents.resourceName.split('?'),
                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),
                path = _wsComponents$resourc2[0],
                query = _wsComponents$resourc2[1];

            wsComponents.path = path && path !== '/' ? path : undefined;
            wsComponents.query = query;
            wsComponents.resourceName = undefined;
        }
        //forbid fragment component
        wsComponents.fragment = undefined;
        return wsComponents;
    }
};

var handler$3 = {
    scheme: "wss",
    domainHost: handler$2.domainHost,
    parse: handler$2.parse,
    serialize: handler$2.serialize
};

var O = {};
//RFC 3986
var UNRESERVED$$ = "[A-Za-z0-9\\-\\.\\_\\~" + ("\\xA0-\\u200D\\u2010-\\u2029\\u202F-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF" ) + "]";
var HEXDIG$$ = "[0-9A-Fa-f]"; //case-insensitive
var PCT_ENCODED$ = subexp(subexp("%[EFef]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%[89A-Fa-f]" + HEXDIG$$ + "%" + HEXDIG$$ + HEXDIG$$) + "|" + subexp("%" + HEXDIG$$ + HEXDIG$$)); //expanded
//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =
//const ATEXT$$ = "[A-Za-z0-9\\!\\#\\$\\%\\&\\'\\*\\+\\-\\/\\=\\?\\^\\_\\`\\{\\|\\}\\~]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QTEXT$$ = "[\\x01-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F]";  //(%d1-8 / %d11-12 / %d14-31 / %d127)
//const QTEXT$$ = merge("[\\x21\\x23-\\x5B\\x5D-\\x7E]", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext
//const VCHAR$$ = "[\\x21-\\x7E]";
//const WSP$$ = "[\\x20\\x09]";
//const OBS_QP$ = subexp("\\\\" + merge("[\\x00\\x0D\\x0A]", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext
//const FWS$ = subexp(subexp(WSP$$ + "*" + "\\x0D\\x0A") + "?" + WSP$$ + "+");
//const QUOTED_PAIR$ = subexp(subexp("\\\\" + subexp(VCHAR$$ + "|" + WSP$$)) + "|" + OBS_QP$);
//const QUOTED_STRING$ = subexp('\\"' + subexp(FWS$ + "?" + QCONTENT$) + "*" + FWS$ + "?" + '\\"');
var ATEXT$$ = "[A-Za-z0-9\\!\\$\\%\\'\\*\\+\\-\\^\\_\\`\\{\\|\\}\\~]";
var QTEXT$$ = "[\\!\\$\\%\\'\\(\\)\\*\\+\\,\\-\\.0-9\\<\\>A-Z\\x5E-\\x7E]";
var VCHAR$$ = merge(QTEXT$$, "[\\\"\\\\]");
var SOME_DELIMS$$ = "[\\!\\$\\'\\(\\)\\*\\+\\,\\;\\:\\@]";
var UNRESERVED = new RegExp(UNRESERVED$$, "g");
var PCT_ENCODED = new RegExp(PCT_ENCODED$, "g");
var NOT_LOCAL_PART = new RegExp(merge("[^]", ATEXT$$, "[\\.]", '[\\"]', VCHAR$$), "g");
var NOT_HFNAME = new RegExp(merge("[^]", UNRESERVED$$, SOME_DELIMS$$), "g");
var NOT_HFVALUE = NOT_HFNAME;
function decodeUnreserved(str) {
    var decStr = pctDecChars(str);
    return !decStr.match(UNRESERVED) ? str : decStr;
}
var handler$4 = {
    scheme: "mailto",
    parse: function parse$$1(components, options) {
        var mailtoComponents = components;
        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(",") : [];
        mailtoComponents.path = undefined;
        if (mailtoComponents.query) {
            var unknownHeaders = false;
            var headers = {};
            var hfields = mailtoComponents.query.split("&");
            for (var x = 0, xl = hfields.length; x < xl; ++x) {
                var hfield = hfields[x].split("=");
                switch (hfield[0]) {
                    case "to":
                        var toAddrs = hfield[1].split(",");
                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {
                            to.push(toAddrs[_x]);
                        }
                        break;
                    case "subject":
                        mailtoComponents.subject = unescapeComponent(hfield[1], options);
                        break;
                    case "body":
                        mailtoComponents.body = unescapeComponent(hfield[1], options);
                        break;
                    default:
                        unknownHeaders = true;
                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);
                        break;
                }
            }
            if (unknownHeaders) mailtoComponents.headers = headers;
        }
        mailtoComponents.query = undefined;
        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {
            var addr = to[_x2].split("@");
            addr[0] = unescapeComponent(addr[0]);
            if (!options.unicodeSupport) {
                //convert Unicode IDN -> ASCII IDN
                try {
                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());
                } catch (e) {
                    mailtoComponents.error = mailtoComponents.error || "Email address's domain name can not be converted to ASCII via punycode: " + e;
                }
            } else {
                addr[1] = unescapeComponent(addr[1], options).toLowerCase();
            }
            to[_x2] = addr.join("@");
        }
        return mailtoComponents;
    },
    serialize: function serialize$$1(mailtoComponents, options) {
        var components = mailtoComponents;
        var to = toArray(mailtoComponents.to);
        if (to) {
            for (var x = 0, xl = to.length; x < xl; ++x) {
                var toAddr = String(to[x]);
                var atIdx = toAddr.lastIndexOf("@");
                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);
                var domain = toAddr.slice(atIdx + 1);
                //convert IDN via punycode
                try {
                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);
                } catch (e) {
                    components.error = components.error || "Email address's domain name can not be converted to " + (!options.iri ? "ASCII" : "Unicode") + " via punycode: " + e;
                }
                to[x] = localPart + "@" + domain;
            }
            components.path = to.join(",");
        }
        var headers = mailtoComponents.headers = mailtoComponents.headers || {};
        if (mailtoComponents.subject) headers["subject"] = mailtoComponents.subject;
        if (mailtoComponents.body) headers["body"] = mailtoComponents.body;
        var fields = [];
        for (var name in headers) {
            if (headers[name] !== O[name]) {
                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + "=" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));
            }
        }
        if (fields.length) {
            components.query = fields.join("&");
        }
        return components;
    }
};

var URN_PARSE = /^([^\:]+)\:(.*)/;
//RFC 2141
var handler$5 = {
    scheme: "urn",
    parse: function parse$$1(components, options) {
        var matches = components.path && components.path.match(URN_PARSE);
        var urnComponents = components;
        if (matches) {
            var scheme = options.scheme || urnComponents.scheme || "urn";
            var nid = matches[1].toLowerCase();
            var nss = matches[2];
            var urnScheme = scheme + ":" + (options.nid || nid);
            var schemeHandler = SCHEMES[urnScheme];
            urnComponents.nid = nid;
            urnComponents.nss = nss;
            urnComponents.path = undefined;
            if (schemeHandler) {
                urnComponents = schemeHandler.parse(urnComponents, options);
            }
        } else {
            urnComponents.error = urnComponents.error || "URN can not be parsed.";
        }
        return urnComponents;
    },
    serialize: function serialize$$1(urnComponents, options) {
        var scheme = options.scheme || urnComponents.scheme || "urn";
        var nid = urnComponents.nid;
        var urnScheme = scheme + ":" + (options.nid || nid);
        var schemeHandler = SCHEMES[urnScheme];
        if (schemeHandler) {
            urnComponents = schemeHandler.serialize(urnComponents, options);
        }
        var uriComponents = urnComponents;
        var nss = urnComponents.nss;
        uriComponents.path = (nid || options.nid) + ":" + nss;
        return uriComponents;
    }
};

var UUID = /^[0-9A-Fa-f]{8}(?:\-[0-9A-Fa-f]{4}){3}\-[0-9A-Fa-f]{12}$/;
//RFC 4122
var handler$6 = {
    scheme: "urn:uuid",
    parse: function parse(urnComponents, options) {
        var uuidComponents = urnComponents;
        uuidComponents.uuid = uuidComponents.nss;
        uuidComponents.nss = undefined;
        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {
            uuidComponents.error = uuidComponents.error || "UUID is not valid.";
        }
        return uuidComponents;
    },
    serialize: function serialize(uuidComponents, options) {
        var urnComponents = uuidComponents;
        //normalize UUID
        urnComponents.nss = (uuidComponents.uuid || "").toLowerCase();
        return urnComponents;
    }
};

SCHEMES[handler.scheme] = handler;
SCHEMES[handler$1.scheme] = handler$1;
SCHEMES[handler$2.scheme] = handler$2;
SCHEMES[handler$3.scheme] = handler$3;
SCHEMES[handler$4.scheme] = handler$4;
SCHEMES[handler$5.scheme] = handler$5;
SCHEMES[handler$6.scheme] = handler$6;

exports.SCHEMES = SCHEMES;
exports.pctEncChar = pctEncChar;
exports.pctDecChars = pctDecChars;
exports.parse = parse;
exports.removeDotSegments = removeDotSegments;
exports.serialize = serialize;
exports.resolveComponents = resolveComponents;
exports.resolve = resolve;
exports.normalize = normalize;
exports.equal = equal;
exports.escapeComponent = escapeComponent;
exports.unescapeComponent = unescapeComponent;

Object.defineProperty(exports, '__esModule', { value: true });

})));

});

// do not edit .js files directly - edit src/index.jst



var fastDeepEqual = function equal(a, b) {
  if (a === b) return true;

  if (a && b && typeof a == 'object' && typeof b == 'object') {
    if (a.constructor !== b.constructor) return false;

    var length, i, keys;
    if (Array.isArray(a)) {
      length = a.length;
      if (length != b.length) return false;
      for (i = length; i-- !== 0;)
        if (!equal(a[i], b[i])) return false;
      return true;
    }



    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;
    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();
    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();

    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) return false;

    for (i = length; i-- !== 0;)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = length; i-- !== 0;) {
      var key = keys[i];

      if (!equal(a[key], b[key])) return false;
    }

    return true;
  }

  // true if both NaN, false otherwise
  return a!==a && b!==b;
};

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
var ucs2length$1 = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

var util = {
  copy: copy$1,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash$1,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  equal: fastDeepEqual,
  ucs2length: ucs2length$1,
  varOccurences: varOccurences,
  varReplace: varReplace,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  schemaUnknownRules: schemaUnknownRules,
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  unescapeJsonPointer: unescapeJsonPointer,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy$1(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, strictNumbers, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data +
                           (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    case 'number': return '(typeof ' + data + EQUAL + '"' + dataType + '"' +
                          (strictNumbers ? (AND + OK + 'isFinite(' + data + ')') : '') + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data, strictNumbers) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, strictNumbers, true);
    default:
      var code = '';
      var types = toHash$1(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, strictNumbers, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash$1([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash$1(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER$1 = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER$1.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


function schemaHasRules(schema, rules) {
  if (typeof schema == 'boolean') return !schema;
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function schemaUnknownRules(schema, rules) {
  if (typeof schema == 'boolean') return;
  for (var key in schema) if (!rules[key]) return key;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER$1 = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER$1 = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER$1.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER$1);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/([^\\])' \+ '/g, '$1');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

var schema_obj = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

var jsonSchemaTraverse = createCommonjsModule(function (module) {

var traverse = module.exports = function (schema, opts, cb) {
  // Legacy support for v0.3.1 and earlier.
  if (typeof opts == 'function') {
    cb = opts;
    opts = {};
  }

  cb = opts.cb || cb;
  var pre = (typeof cb == 'function') ? cb : cb.pre || function() {};
  var post = cb.post || function() {};

  _traverse(opts, pre, post, schema, '', schema);
};


traverse.keywords = {
  additionalItems: true,
  items: true,
  contains: true,
  additionalProperties: true,
  propertyNames: true,
  not: true
};

traverse.arrayKeywords = {
  items: true,
  allOf: true,
  anyOf: true,
  oneOf: true
};

traverse.propsKeywords = {
  definitions: true,
  properties: true,
  patternProperties: true,
  dependencies: true
};

traverse.skipKeywords = {
  default: true,
  enum: true,
  const: true,
  required: true,
  maximum: true,
  minimum: true,
  exclusiveMaximum: true,
  exclusiveMinimum: true,
  multipleOf: true,
  maxLength: true,
  minLength: true,
  pattern: true,
  format: true,
  maxItems: true,
  minItems: true,
  uniqueItems: true,
  maxProperties: true,
  minProperties: true
};


function _traverse(opts, pre, post, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
  if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
    pre(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
    for (var key in schema) {
      var sch = schema[key];
      if (Array.isArray(sch)) {
        if (key in traverse.arrayKeywords) {
          for (var i=0; i<sch.length; i++)
            _traverse(opts, pre, post, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
        }
      } else if (key in traverse.propsKeywords) {
        if (sch && typeof sch == 'object') {
          for (var prop in sch)
            _traverse(opts, pre, post, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
        }
      } else if (key in traverse.keywords || (opts.allKeys && !(key in traverse.skipKeywords))) {
        _traverse(opts, pre, post, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
      }
    }
    post(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
  }
}


function escapeJsonPtr(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}
});

var resolve_1 = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof schema_obj) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof schema_obj) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema !== undefined) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = uri_all.parse(ref)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(this._getId(root.schema));
  if (Object.keys(root.schema).length === 0 || refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof schema_obj) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof schema_obj) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(this._getId(root.schema));
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    var id = this._getId(schema);
    if (id) baseId = resolveUrl(baseId, id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.fragment = parsedRef.fragment || '';
  if (parsedRef.fragment.slice(0,1) != '/') return;
  var parts = parsedRef.fragment.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (schema === undefined) break;
      var id;
      if (!PREVENT_SCOPE_CHANGE[part]) {
        id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        if (schema.$ref) {
          var $ref = resolveUrl(baseId, schema.$ref);
          var res = resolveSchema.call(this, root, $ref);
          if (res) {
            schema = res.schema;
            root = res.root;
            baseId = res.baseId;
          }
        }
      }
    }
  }
  if (schema !== undefined && schema !== root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = uri_all.parse(id);
  return _getFullPath(p);
}


function _getFullPath(p) {
  return uri_all.serialize(p).split('#')[0] + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return uri_all.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  var schemaId = normalizeId(this._getId(schema));
  var baseIds = {'': schemaId};
  var fullPaths = {'': getFullPath(schemaId, false)};
  var localRefs = {};
  var self = this;

  jsonSchemaTraverse(schema, {allKeys: true}, function(sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
    if (jsonPtr === '') return;
    var id = self._getId(sch);
    var baseId = baseIds[parentJsonPtr];
    var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
    if (keyIndex !== undefined)
      fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

    if (typeof id == 'string') {
      id = baseId = normalizeId(baseId ? uri_all.resolve(baseId, id) : id);

      var refVal = self._refs[id];
      if (typeof refVal == 'string') refVal = self._refs[refVal];
      if (refVal && refVal.schema) {
        if (!fastDeepEqual(sch, refVal.schema))
          throw new Error('id "' + id + '" resolves to more than one schema');
      } else if (id != normalizeId(fullPath)) {
        if (id[0] == '#') {
          if (localRefs[id] && !fastDeepEqual(sch, localRefs[id]))
            throw new Error('id "' + id + '" resolves to more than one schema');
          localRefs[id] = sch;
        } else {
          self._refs[id] = fullPath;
        }
      }
    }
    baseIds[jsonPtr] = baseId;
    fullPaths[jsonPtr] = fullPath;
  });

  return localRefs;
}

var error_classes = {
  Validation: errorSubclass(ValidationError$1),
  MissingRef: errorSubclass(MissingRefError$1)
};


function ValidationError$1(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


MissingRefError$1.message = function (baseId, ref) {
  return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
};


function MissingRefError$1(baseId, ref, message) {
  this.message = message || MissingRefError$1.message(baseId, ref);
  this.missingRef = resolve_1.url(baseId, ref);
  this.missingSchema = resolve_1.normalizeId(resolve_1.fullPath(this.missingRef));
}


function errorSubclass(Subclass) {
  Subclass.prototype = Object.create(Error.prototype);
  Subclass.prototype.constructor = Subclass;
  return Subclass;
}

var fastJsonStableStringify = function (data, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
            out = '[';
            for (i = 0; i < node.length; i++) {
                if (i) out += ',';
                out += stringify(node[i]) || 'null';
            }
            return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
            if (cycles) return JSON.stringify('__cycle__');
            throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
            var key = keys[i];
            var value = stringify(node[key]);

            if (!value) continue;
            if (out) out += ',';
            out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
    })(data);
};

var validate$2 = function generate_validate(it, $keyword, $ruleType) {
  var out = '';
  var $async = it.schema.$async === true,
    $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
    $id = it.self._getId(it.schema);
  if (it.opts.strictKeywords) {
    var $unknownKwd = it.util.schemaUnknownRules(it.schema, it.RULES.keywords);
    if ($unknownKwd) {
      var $keywordsMsg = 'unknown keyword: ' + $unknownKwd;
      if (it.opts.strictKeywords === 'log') it.logger.warn($keywordsMsg);
      else throw new Error($keywordsMsg);
    }
  }
  if (it.isTop) {
    out += ' var validate = ';
    if ($async) {
      it.async = true;
      out += 'async ';
    }
    out += 'function(data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
    if ($id && (it.opts.sourceCode || it.opts.processCode)) {
      out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
    }
  }
  if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
    var $keyword = 'false schema';
    var $lvl = it.level;
    var $dataLvl = it.dataLevel;
    var $schema = it.schema[$keyword];
    var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
    var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
    var $breakOnError = !it.opts.allErrors;
    var $errorKeyword;
    var $data = 'data' + ($dataLvl || '');
    var $valid = 'valid' + $lvl;
    if (it.schema === false) {
      if (it.isTop) {
        $breakOnError = true;
      } else {
        out += ' var ' + ($valid) + ' = false; ';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'boolean schema is false\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      if (it.isTop) {
        if ($async) {
          out += ' return data; ';
        } else {
          out += ' validate.errors = null; return true; ';
        }
      } else {
        out += ' var ' + ($valid) + ' = true; ';
      }
    }
    if (it.isTop) {
      out += ' }; return validate; ';
    }
    return out;
  }
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
    it.baseId = it.baseId || it.rootId;
    delete it.isTop;
    it.dataPathArr = [""];
    if (it.schema.default !== undefined && it.opts.useDefaults && it.opts.strictDefaults) {
      var $defaultMsg = 'default is ignored in the schema root';
      if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
      else throw new Error($defaultMsg);
    }
    out += ' var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data; ';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if ($id) it.baseId = it.resolve.url(it.baseId, $id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '';
  var $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.nullable && it.schema.nullable === true) {
    if ($typeIsArray) {
      if ($typeSchema.indexOf('null') == -1) $typeSchema = $typeSchema.concat('null');
    } else if ($typeSchema != 'null') {
      $typeSchema = [$typeSchema, 'null'];
      $typeIsArray = true;
    }
  }
  if ($typeIsArray && $typeSchema.length == 1) {
    $typeSchema = $typeSchema[0];
    $typeIsArray = false;
  }
  if (it.schema.$ref && $refKeywords) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
    } else if (it.opts.extendRefs !== true) {
      $refKeywords = false;
      it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    }
  }
  if (it.schema.$comment && it.opts.$comment) {
    out += ' ' + (it.RULES.all.$comment.code(it, '$comment'));
  }
  if ($typeSchema) {
    if (it.opts.coerceTypes) {
      var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    }
    var $rulesGroup = it.RULES.types[$typeSchema];
    if ($coerceToTypes || $typeIsArray || $rulesGroup === true || ($rulesGroup && !$shouldUseGroup($rulesGroup))) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type';
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, it.opts.strictNumbers, true)) + ') { ';
      if ($coerceToTypes) {
        var $dataType = 'dataType' + $lvl,
          $coerced = 'coerced' + $lvl;
        out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; var ' + ($coerced) + ' = undefined; ';
        if (it.opts.coerceTypes == 'array') {
          out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ') && ' + ($data) + '.length == 1) { ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + '; if (' + (it.util.checkDataType(it.schema.type, $data, it.opts.strictNumbers)) + ') ' + ($coerced) + ' = ' + ($data) + '; } ';
        }
        out += ' if (' + ($coerced) + ' !== undefined) ; ';
        var arr1 = $coerceToTypes;
        if (arr1) {
          var $type, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $type = arr1[$i += 1];
            if ($type == 'string') {
              out += ' else if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
            } else if ($type == 'number' || $type == 'integer') {
              out += ' else if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
              if ($type == 'integer') {
                out += ' && !(' + ($data) + ' % 1)';
              }
              out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
            } else if ($type == 'boolean') {
              out += ' else if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
            } else if ($type == 'null') {
              out += ' else if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
            } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
              out += ' else if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
            }
          }
        }
        out += ' else {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } if (' + ($coerced) + ' !== undefined) {  ';
        var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
          $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
        if (!$dataLvl) {
          out += 'if (' + ($parentData) + ' !== undefined)';
        }
        out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } ';
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should be ';
            if ($typeIsArray) {
              out += '' + ($typeSchema.join(","));
            } else {
              out += '' + ($typeSchema);
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      }
      out += ' } ';
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data, it.opts.strictNumbers)) + ') { ';
          }
          if (it.opts.useDefaults) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    if (it.compositeRule) {
                      if (it.opts.strictDefaults) {
                        var $defaultMsg = 'default is ignored for: ' + $passData;
                        if (it.opts.strictDefaults === 'log') it.logger.warn($defaultMsg);
                        else throw new Error($defaultMsg);
                      }
                    } else {
                      out += ' if (' + ($passData) + ' === undefined ';
                      if (it.opts.useDefaults == 'empty') {
                        out += ' || ' + ($passData) + ' === null || ' + ($passData) + ' === \'\' ';
                      }
                      out += ' ) ' + ($passData) + ' = ';
                      if (it.opts.useDefaults == 'shared') {
                        out += ' ' + (it.useDefault($sch.default)) + ' ';
                      } else {
                        out += ' ' + (JSON.stringify($sch.default)) + ' ';
                      }
                      out += '; ';
                    }
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                if ($code) {
                  out += ' ' + ($code) + ' ';
                  if ($breakOnError) {
                    $closingBraces1 += '}';
                  }
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return data;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }; return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }

  function $shouldUseGroup($rulesGroup) {
    var rules = $rulesGroup.rules;
    for (var i = 0; i < rules.length; i++)
      if ($shouldUseRule(rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.implements && $ruleImplementsSomeKeyword($rule));
  }

  function $ruleImplementsSomeKeyword($rule) {
    var impl = $rule.implements;
    for (var i = 0; i < impl.length; i++)
      if (it.schema[impl[i]] !== undefined) return true;
  }
  return out;
};

/**
 * Functions below are used inside compiled validations function
 */

var ucs2length = util.ucs2length;


// this error is thrown by async schemas to return validation errors via exception
var ValidationError = error_classes.Validation;

var compile_1 = compile$1;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile$1(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = [];

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (opts.sourceCode) cv.source = v.source;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var validate = compilation.validate;
    var result = validate.apply(this, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile$1.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;

    var sourceCode = validate$2({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      MissingRefError: error_classes.MissingRef,
      RULES: RULES,
      validate: validate$2,
      util: util,
      resolve: resolve_1,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      logger: self.logger,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.processCode) sourceCode = opts.processCode(sourceCode, _schema);
    // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
    var validate;
    try {
      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'equal',
        'ucs2length',
        'ValidationError',
        sourceCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        fastDeepEqual,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      self.logger.error('Error compiling schema, function code:', sourceCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (opts.sourceCode === true) {
      validate.source = {
        code: sourceCode,
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve_1.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve_1.call(self, localCompile, root, ref);
    if (v === undefined) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve_1.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile$1.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v === undefined) {
      removeLocalRef(ref);
    } else {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function removeLocalRef(ref) {
    delete refs[ref];
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object' || typeof refVal == 'boolean'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && !!refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = fastJsonStableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    if (self._opts.validateSchema !== false) {
      var deps = rule.definition.dependencies;
      if (deps && !deps.every(function(keyword) {
        return Object.prototype.hasOwnProperty.call(parentSchema, keyword);
      }))
        throw new Error('parent schema must have all required keywords: ' + deps.join(','));

      var validateSchema = rule.definition.validateSchema;
      if (validateSchema) {
        var valid = validateSchema(schema);
        if (!valid) {
          var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
          if (self._opts.validateSchema == 'log') self.logger.error(message);
          else throw new Error(message);
        }
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
      if (!validate) return;
    }

    if (validate === undefined)
      throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

var cache$1 = createCommonjsModule(function (module) {


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};
});

var DATE = /^(\d\d\d\d)-(\d\d)-(\d\d)$/;
var DAYS = [0,31,28,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d(?::?\d\d)?)?$/i;
var HOSTNAME = /^(?=.{1,253}\.?$)[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*\.?$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
// uri-template: https://tools.ietf.org/html/rfc6570
var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
// For the source: https://gist.github.com/dperini/729294
// For test cases: https://mathiasbynens.be/demo/url-regex
// @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
// var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-)*(?:[0-9a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[a-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$/;
var JSON_POINTER_URI_FRAGMENT = /^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;


var formats_1 = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  return util.copy(formats[mode]);
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^(?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s](?:[0-2]\d:[0-5]\d:[0-5]\d|23:59:60)(?:\.\d+)?(?:z|[+-]\d\d(?::?\d\d)?)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/)?[^\s]*$/i,
  'uri-reference': /^(?:(?:[a-z][a-z0-9+\-.]*:)?\/?\/)?(?:[^\\\s#][^\s#]*)?(?:#[^\\\s]*)?$/i,
  'uri-template': URITEMPLATE,
  url: URL,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  'uri-reference': URIREF,
  'uri-template': URITEMPLATE,
  url: URL,
  email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&'*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: HOSTNAME,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'json-pointer-uri-fragment': JSON_POINTER_URI_FRAGMENT,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


function isLeapYear(year) {
  // https://tools.ietf.org/html/rfc3339#appendix-C
  return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
}


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var year = +matches[1];
  var month = +matches[2];
  var day = +matches[3];

  return month >= 1 && month <= 12 && day >= 1 &&
          day <= (month == 2 && isLeapYear(year) ? 29 : DAYS[month]);
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return ((hour <= 23 && minute <= 59 && second <= 59) ||
          (hour == 23 && minute == 59 && second == 60)) &&
         (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


var NOT_URI_FRAGMENT = /\/|:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


var Z_ANCHOR = /[^\\]\\Z/;
function regex(str) {
  if (Z_ANCHOR.test(str)) return false;
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}

var ref = function generate_ref(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = it.MissingRefError.message(it.baseId, $schema);
      if (it.opts.missingRefs == 'fail') {
        it.logger.error($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        it.logger.warn($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        throw new it.MissingRefError(it.baseId, $schema, $message);
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true || (it.async && $refVal.$async !== false);
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      if ($breakOnError) {
        out += ' var ' + ($valid) + '; ';
      }
      out += ' try { await ' + (__callValidate) + '; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = true; ';
      }
      out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
      if ($breakOnError) {
        out += ' ' + ($valid) + ' = false; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
};

var allOf = function generate_allOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  return out;
};

var anyOf = function generate_anyOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return (it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all));
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var comment = function generate_comment(it, $keyword, $ruleType) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  !it.opts.allErrors;
  var $comment = it.util.toQuotedString($schema);
  if (it.opts.$comment === true) {
    out += ' console.log(' + ($comment) + ');';
  } else if (typeof it.opts.$comment == 'function') {
    out += ' self._opts.$comment(' + ($comment) + ', ' + (it.util.toQuotedString($errSchemaPath)) + ', validate.root.schema);';
  }
  return out;
};

var _const = function generate_const(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('const') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValue: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var contains = function generate_contains(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId,
    $nonEmptySchema = (it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all));
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($nonEmptySchema) {
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($nextValid) + ' = false; for (var ' + ($idx) + ' = 0; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    out += ' if (' + ($nextValid) + ') break; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($nextValid) + ') {';
  } else {
    out += ' if (' + ($data) + '.length == 0) {';
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('contains') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should contain a valid item\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } else { ';
  if ($nonEmptySchema) {
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
  }
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var dependencies = function generate_dependencies(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {},
    $ownProperties = it.opts.ownProperties;
  for ($property in $schema) {
    if ($property == '__proto__') continue;
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    if ($deps.length) {
      out += ' if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      if ($breakOnError) {
        out += ' && ( ';
        var arr1 = $deps;
        if (arr1) {
          var $propertyKey, $i = -1,
            l1 = arr1.length - 1;
          while ($i < l1) {
            $propertyKey = arr1[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ')) {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should have ';
            if ($deps.length == 1) {
              out += 'property ' + (it.util.escapeQuotes($deps[0]));
            } else {
              out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
            }
            out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
      } else {
        out += ' ) { ';
        var arr2 = $deps;
        if (arr2) {
          var $propertyKey, i2 = -1,
            l2 = arr2.length - 1;
          while (i2 < l2) {
            $propertyKey = arr2[i2 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + (it.util.escapeQuotes($deps[0]));
                } else {
                  out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
                }
                out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
      out += ' }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
      out += ' ' + ($nextValid) + ' = true; if ( ' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
      if ($ownProperties) {
        out += ' && Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($property)) + '\') ';
      }
      out += ') { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _enum = function generate_enum(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var format = function generate_format(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl,
      $isObject = 'isObject' + $lvl,
      $formatType = 'formatType' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var ' + ($isObject) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; var ' + ($formatType) + ' = ' + ($isObject) + ' && ' + ($format) + '.type || \'string\'; if (' + ($isObject) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats != 'ignore') {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && ' + ($formatType) + ' == \'' + ($ruleType) + '\' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? await ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats == 'ignore') {
        it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      } else {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    var $formatType = $isObject && $format.type || 'string';
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($formatType != $ruleType) {
      if ($breakOnError) {
        out += ' if (true) { ';
      }
      return out;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(await ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _if = function generate_if(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $thenSch = it.schema['then'],
    $elseSch = it.schema['else'],
    $thenPresent = $thenSch !== undefined && (it.opts.strictKeywords ? (typeof $thenSch == 'object' && Object.keys($thenSch).length > 0) || $thenSch === false : it.util.schemaHasRules($thenSch, it.RULES.all)),
    $elsePresent = $elseSch !== undefined && (it.opts.strictKeywords ? (typeof $elseSch == 'object' && Object.keys($elseSch).length > 0) || $elseSch === false : it.util.schemaHasRules($elseSch, it.RULES.all)),
    $currentBaseId = $it.baseId;
  if ($thenPresent || $elsePresent) {
    var $ifClause;
    $it.createErrors = false;
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = true;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    out += '  ' + (it.validate($it)) + ' ';
    $it.baseId = $currentBaseId;
    $it.createErrors = true;
    out += '  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }  ';
    it.compositeRule = $it.compositeRule = $wasComposite;
    if ($thenPresent) {
      out += ' if (' + ($nextValid) + ') {  ';
      $it.schema = it.schema['then'];
      $it.schemaPath = it.schemaPath + '.then';
      $it.errSchemaPath = it.errSchemaPath + '/then';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'then\'; ';
      } else {
        $ifClause = '\'then\'';
      }
      out += ' } ';
      if ($elsePresent) {
        out += ' else { ';
      }
    } else {
      out += ' if (!' + ($nextValid) + ') { ';
    }
    if ($elsePresent) {
      $it.schema = it.schema['else'];
      $it.schemaPath = it.schemaPath + '.else';
      $it.errSchemaPath = it.errSchemaPath + '/else';
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' ' + ($valid) + ' = ' + ($nextValid) + '; ';
      if ($thenPresent && $elsePresent) {
        $ifClause = 'ifClause' + $lvl;
        out += ' var ' + ($ifClause) + ' = \'else\'; ';
      } else {
        $ifClause = '\'else\'';
      }
      out += ' } ';
    }
    out += ' if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('if') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { failingKeyword: ' + ($ifClause) + ' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match "\' + ' + ($ifClause) + ' + \'" schema\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

var items = function generate_items(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ('additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && (it.opts.strictKeywords ? (typeof $additionalItems == 'object' && Object.keys($additionalItems).length > 0) || $additionalItems === false : it.util.schemaHasRules($additionalItems, it.RULES.all))) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var _limit = function generate__limit(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<',
    $errorKeyword = undefined;
  if (!($isData || typeof $schema == 'number' || $schema === undefined)) {
    throw new Error($keyword + ' must be number');
  }
  if (!($isDataExcl || $schemaExcl === undefined || typeof $schemaExcl == 'number' || typeof $schemaExcl == 'boolean')) {
    throw new Error($exclusiveKeyword + ' must be number or boolean');
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $exclType = 'exclType' + $lvl,
      $exclIsNumber = 'exclIsNumber' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var ' + ($exclusive) + '; var ' + ($exclType) + ' = typeof ' + ($schemaValueExcl) + '; if (' + ($exclType) + ' != \'boolean\' && ' + ($exclType) + ' != \'undefined\' && ' + ($exclType) + ' != \'number\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($exclType) + ' == \'number\' ? ( (' + ($exclusive) + ' = ' + ($schemaValue) + ' === undefined || ' + ($schemaValueExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ') ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValueExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) : ( (' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\'; ';
    if ($schema === undefined) {
      $errorKeyword = $exclusiveKeyword;
      $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
      $schemaValue = $schemaValueExcl;
      $isData = $isDataExcl;
    }
  } else {
    var $exclIsNumber = typeof $schemaExcl == 'number',
      $opStr = $op;
    if ($exclIsNumber && $isData) {
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ( ' + ($schemaValue) + ' === undefined || ' + ($schemaExcl) + ' ' + ($op) + '= ' + ($schemaValue) + ' ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaExcl) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' ) || ' + ($data) + ' !== ' + ($data) + ') { ';
    } else {
      if ($exclIsNumber && $schema === undefined) {
        $exclusive = true;
        $errorKeyword = $exclusiveKeyword;
        $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
        $schemaValue = $schemaExcl;
        $notOp += '=';
      } else {
        if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
        if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
          $exclusive = true;
          $errorKeyword = $exclusiveKeyword;
          $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
          $notOp += '=';
        } else {
          $exclusive = false;
          $opStr += '=';
        }
      }
      var $opExpr = '\'' + $opStr + '\'';
      out += ' if ( ';
      if ($isData) {
        out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
      }
      out += ' ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') { ';
    }
  }
  $errorKeyword = $errorKeyword || $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitItems = function generate__limitItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitLength = function generate__limitLength(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var _limitProperties = function generate__limitProperties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'fewer';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var multipleOf = function generate_multipleOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!($isData || typeof $schema == 'number')) {
    throw new Error($keyword + ' must be number');
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schemaValue) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var not = function generate_not(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
};

var oneOf = function generate_oneOf(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $prevValid = 'prevValid' + $lvl,
    $passingSchemas = 'passingSchemas' + $lvl;
  out += 'var ' + ($errs) + ' = errors , ' + ($prevValid) + ' = false , ' + ($valid) + ' = false , ' + ($passingSchemas) + ' = null; ';
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && ' + ($prevValid) + ') { ' + ($valid) + ' = false; ' + ($passingSchemas) + ' = [' + ($passingSchemas) + ', ' + ($i) + ']; } else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') { ' + ($valid) + ' = ' + ($prevValid) + ' = true; ' + ($passingSchemas) + ' = ' + ($i) + '; }';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   var err =   '; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { passingSchemas: ' + ($passingSchemas) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; return false; ';
    }
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
};

var pattern = function generate_pattern(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ('pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) {
    /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
};

var properties$l = function generate_properties(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $idx = 'idx' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $dataProperties = 'dataProperties' + $lvl;
  var $schemaKeys = Object.keys($schema || {}).filter(notProto),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties).filter(notProto),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.$data && $required.$data) && $required.length < it.opts.loopRequired) {
    var $requiredHash = it.util.toHash($required);
  }

  function notProto(p) {
    return p !== '__proto__';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($ownProperties) {
    out += ' var ' + ($dataProperties) + ' = undefined;';
  }
  if ($checkAdditional) {
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 8) {
          out += ' || validate.schema' + ($schemaPath) + '.hasOwnProperty(' + ($key) + ') ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is an invalid additional property';
              } else {
                out += 'should NOT have additional properties';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr3 = $schemaKeys;
    if (arr3) {
      var $propertyKey, i3 = -1,
        l3 = arr3.length - 1;
      while (i3 < l3) {
        $propertyKey = arr3[i3 += 1];
        var $sch = $schema[$propertyKey];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if ( ' + ($useData) + ' === undefined ';
              if ($ownProperties) {
                out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
              }
              out += ') { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if ( ' + ($useData) + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ') { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined ';
                if ($ownProperties) {
                  out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
                }
                out += ' ) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($pPropertyKeys.length) {
    var arr4 = $pPropertyKeys;
    if (arr4) {
      var $pProperty, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $pProperty = arr4[i4 += 1];
        var $sch = $pProperties[$pProperty];
        if ((it.opts.strictKeywords ? (typeof $sch == 'object' && Object.keys($sch).length > 0) || $sch === false : it.util.schemaHasRules($sch, it.RULES.all))) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
          $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
          if ($ownProperties) {
            out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
          } else {
            out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
          }
          out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var propertyNames = function generate_propertyNames(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;';
  if ((it.opts.strictKeywords ? (typeof $schema == 'object' && Object.keys($schema).length > 0) || $schema === false : it.util.schemaHasRules($schema, it.RULES.all))) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    var $key = 'key' + $lvl,
      $idx = 'idx' + $lvl,
      $i = 'i' + $lvl,
      $invalidName = '\' + ' + $key + ' + \'',
      $dataNxt = $it.dataLevel = it.dataLevel + 1,
      $nextData = 'data' + $dataNxt,
      $dataProperties = 'dataProperties' + $lvl,
      $ownProperties = it.opts.ownProperties,
      $currentBaseId = it.baseId;
    if ($ownProperties) {
      out += ' var ' + ($dataProperties) + ' = undefined; ';
    }
    if ($ownProperties) {
      out += ' ' + ($dataProperties) + ' = ' + ($dataProperties) + ' || Object.keys(' + ($data) + '); for (var ' + ($idx) + '=0; ' + ($idx) + '<' + ($dataProperties) + '.length; ' + ($idx) + '++) { var ' + ($key) + ' = ' + ($dataProperties) + '[' + ($idx) + ']; ';
    } else {
      out += ' for (var ' + ($key) + ' in ' + ($data) + ') { ';
    }
    out += ' var startErrs' + ($lvl) + ' = errors; ';
    var $passData = $key;
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (!' + ($nextValid) + ') { for (var ' + ($i) + '=startErrs' + ($lvl) + '; ' + ($i) + '<errors; ' + ($i) + '++) { vErrors[' + ($i) + '].propertyName = ' + ($key) + '; }   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('propertyNames') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { propertyName: \'' + ($invalidName) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'property name \\\'' + ($invalidName) + '\\\' is invalid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
    if ($breakOnError) {
      out += ' break; ';
    }
    out += ' } }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  return out;
};

var required$h = function generate_required(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && (it.opts.strictKeywords ? (typeof $propertySch == 'object' && Object.keys($propertySch).length > 0) || $propertySch === false : it.util.schemaHasRules($propertySch, it.RULES.all)))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired,
      $ownProperties = it.opts.ownProperties;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined ';
        if ($ownProperties) {
          out += ' &&   Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += '; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var $propertyKey, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $propertyKey = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty($propertyKey),
              $useData = $data + $prop;
            out += ' ( ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined ';
        if ($ownProperties) {
          out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + ']) ';
        }
        out += ') {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $propertyKey, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $propertyKey = arr3[i3 += 1];
            var $prop = it.util.getProperty($propertyKey),
              $missingProperty = it.util.escapeQuotes($propertyKey),
              $useData = $data + $prop;
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
            }
            out += ' if ( ' + ($useData) + ' === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + ($data) + ', \'' + (it.util.escapeQuotes($propertyKey)) + '\') ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ('required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
};

var uniqueItems = function generate_uniqueItems(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var i = ' + ($data) + '.length , ' + ($valid) + ' = true , j; if (i > 1) { ';
    var $itemType = it.schema.items && it.schema.items.type,
      $typeIsArray = Array.isArray($itemType);
    if (!$itemType || $itemType == 'object' || $itemType == 'array' || ($typeIsArray && ($itemType.indexOf('object') >= 0 || $itemType.indexOf('array') >= 0))) {
      out += ' outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } ';
    } else {
      out += ' var itemIndices = {}, item; for (;i--;) { var item = ' + ($data) + '[i]; ';
      var $method = 'checkDataType' + ($typeIsArray ? 's' : '');
      out += ' if (' + (it.util[$method]($itemType, 'item', it.opts.strictNumbers, true)) + ') continue; ';
      if ($typeIsArray) {
        out += ' if (typeof item == \'string\') item = \'"\' + item; ';
      }
      out += ' if (typeof itemIndices[item] == \'number\') { ' + ($valid) + ' = false; j = itemIndices[item]; break; } itemIndices[item] = i; } ';
    }
    out += ' } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ('uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
};

//all requires must be explicit because browserify won't work with dynamic requires
var dotjs = {
  '$ref': ref,
  allOf: allOf,
  anyOf: anyOf,
  '$comment': comment,
  const: _const,
  contains: contains,
  dependencies: dependencies,
  'enum': _enum,
  format: format,
  'if': _if,
  items: items,
  maximum: _limit,
  minimum: _limit,
  maxItems: _limitItems,
  minItems: _limitItems,
  maxLength: _limitLength,
  minLength: _limitLength,
  maxProperties: _limitProperties,
  minProperties: _limitProperties,
  multipleOf: multipleOf,
  not: not,
  oneOf: oneOf,
  pattern: pattern,
  properties: properties$l,
  propertyNames: propertyNames,
  required: required$h,
  uniqueItems: uniqueItems,
  validate: validate$2
};

var toHash = util.toHash;

var rules = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ { 'maximum': ['exclusiveMaximum'] },
               { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'items', 'contains', 'uniqueItems' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames',
               { 'properties': ['additionalProperties', 'patternProperties'] } ] },
    { rules: [ '$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf', 'if' ] }
  ];

  var ALL = [ 'type', '$comment' ];
  var KEYWORDS = [
    '$schema', '$id', 'id', '$data', '$async', 'title',
    'description', 'default', 'definitions',
    'examples', 'readOnly', 'writeOnly',
    'contentMediaType', 'contentEncoding',
    'additionalItems', 'then', 'else'
  ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);
  RULES.types = toHash(TYPES);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      var implKeywords;
      if (typeof keyword == 'object') {
        var key = Object.keys(keyword)[0];
        implKeywords = keyword[key];
        keyword = key;
        implKeywords.forEach(function (k) {
          ALL.push(k);
          RULES.all[k] = true;
        });
      }
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: dotjs[keyword],
        implements: implKeywords
      };
      return rule;
    });

    RULES.all.$comment = {
      keyword: '$comment',
      code: dotjs.$comment
    };

    if (group.type) RULES.types[group.type] = group;
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.custom = {};

  return RULES;
};

var KEYWORDS = [
  'multipleOf',
  'maximum',
  'exclusiveMaximum',
  'minimum',
  'exclusiveMinimum',
  'maxLength',
  'minLength',
  'pattern',
  'additionalItems',
  'maxItems',
  'minItems',
  'uniqueItems',
  'maxProperties',
  'minProperties',
  'required',
  'additionalProperties',
  'enum',
  'format',
  'const'
];

var data = function (metaSchema, keywordsJsonPointers) {
  for (var i=0; i<keywordsJsonPointers.length; i++) {
    metaSchema = JSON.parse(JSON.stringify(metaSchema));
    var segments = keywordsJsonPointers[i].split('/');
    var keywords = metaSchema;
    var j;
    for (j=1; j<segments.length; j++)
      keywords = keywords[segments[j]];

    for (j=0; j<KEYWORDS.length; j++) {
      var key = KEYWORDS[j];
      var schema = keywords[key];
      if (schema) {
        keywords[key] = {
          anyOf: [
            schema,
            { $ref: 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
    }
  }

  return metaSchema;
};

var MissingRefError = error_classes.MissingRef;

var async$1 = compileAsync;


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
 * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
 * @return {Promise} promise that resolves with a validating function.
 */
function compileAsync(schema, meta, callback) {
  /* eslint no-shadow: 0 */
  /* global Promise */
  /* jshint validthis: true */
  var self = this;
  if (typeof this._opts.loadSchema != 'function')
    throw new Error('options.loadSchema should be a function');

  if (typeof meta == 'function') {
    callback = meta;
    meta = undefined;
  }

  var p = loadMetaSchemaOf(schema).then(function () {
    var schemaObj = self._addSchema(schema, undefined, meta);
    return schemaObj.validate || _compileAsync(schemaObj);
  });

  if (callback) {
    p.then(
      function(v) { callback(null, v); },
      callback
    );
  }

  return p;


  function loadMetaSchemaOf(sch) {
    var $schema = sch.$schema;
    return $schema && !self.getSchema($schema)
            ? compileAsync.call(self, { $ref: $schema }, true)
            : Promise.resolve();
  }


  function _compileAsync(schemaObj) {
    try { return self._compile(schemaObj); }
    catch(e) {
      if (e instanceof MissingRefError) return loadMissingSchema(e);
      throw e;
    }


    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

      var schemaPromise = self._loadingSchemas[ref];
      if (!schemaPromise) {
        schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
        schemaPromise.then(removePromise, removePromise);
      }

      return schemaPromise.then(function (sch) {
        if (!added(ref)) {
          return loadMetaSchemaOf(sch).then(function () {
            if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
          });
        }
      }).then(function() {
        return _compileAsync(schemaObj);
      });

      function removePromise() {
        delete self._loadingSchemas[ref];
      }

      function added(ref) {
        return self._refs[ref] || self._schemas[ref];
      }
    }
  }
}

var custom = function generate_custom(it, $keyword, $ruleType) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.$data && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $closingBraces = '';
  var $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    if (!$ruleValidate) return;
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($isData && $rDef.$data) {
    $closingBraces += '}';
    out += ' if (' + ($schemaValue) + ' === undefined) { ' + ($valid) + ' = true; } else { ';
    if ($validateSchema) {
      $closingBraces += '}';
      out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') { ';
    }
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    var $closingBraces = '';
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += 'await ';
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = await ' + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' if (' + ($parentData) + ') ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  out += '' + ($closingBraces);
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) {
      /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
};

var $schema$k = "http://json-schema.org/draft-07/schema#";
var $id$k = "http://json-schema.org/draft-07/schema#";
var title$1 = "Core schema meta-schema";
var definitions$1 = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type$i = [
	"object",
	"boolean"
];
var properties$k = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	$comment: {
		type: "string"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": true,
	readOnly: {
		type: "boolean",
		"default": false
	},
	examples: {
		type: "array",
		items: true
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": true
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		propertyNames: {
			format: "regex"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": true,
	"enum": {
		type: "array",
		items: true,
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	contentMediaType: {
		type: "string"
	},
	contentEncoding: {
		type: "string"
	},
	"if": {
		$ref: "#"
	},
	then: {
		$ref: "#"
	},
	"else": {
		$ref: "#"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$2$1 = {
	$schema: $schema$k,
	$id: $id$k,
	title: title$1,
	definitions: definitions$1,
	type: type$i,
	properties: properties$k,
	"default": true
};

var definition_schema = {
  $id: 'https://github.com/ajv-validator/ajv/blob/master/lib/definition_schema.js',
  definitions: {
    simpleTypes: require$$2$1.definitions.simpleTypes
  },
  type: 'object',
  dependencies: {
    schema: ['validate'],
    $data: ['validate'],
    statements: ['inline'],
    valid: {not: {required: ['macro']}}
  },
  properties: {
    type: require$$2$1.properties.type,
    schema: {type: 'boolean'},
    statements: {type: 'boolean'},
    dependencies: {
      type: 'array',
      items: {type: 'string'}
    },
    metaSchema: {type: 'object'},
    modifying: {type: 'boolean'},
    valid: {type: 'boolean'},
    $data: {type: 'boolean'},
    async: {type: 'boolean'},
    errors: {
      anyOf: [
        {type: 'boolean'},
        {const: 'full'}
      ]
    }
  }
};

var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;



var keyword = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword,
  validate: validateKeyword
};


/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 * @return {Ajv} this for method chaining
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;
  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    this.validateKeyword(definition, true);

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      for (var i=0; i<dataType.length; i++)
        _addRule(keyword, dataType[i], definition);
    } else {
      _addRule(keyword, dataType, definition);
    }

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if (definition.$data && this._opts.$data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: custom,
      implements: definition.implements
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }

  return this;
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Ajv} this for method chaining
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
  return this;
}


/**
 * Validate keyword definition
 * @this  Ajv
 * @param {Object} definition keyword definition object.
 * @param {Boolean} throwError true to throw exception if definition is invalid
 * @return {boolean} validation result
 */
function validateKeyword(definition, throwError) {
  validateKeyword.errors = null;
  var v = this._validateKeyword = this._validateKeyword
                                  || this.compile(definition_schema, true);

  if (v(definition)) return true;
  validateKeyword.errors = v.errors;
  if (throwError)
    throw new Error('custom keyword definition is invalid: '  + this.errorsText(v.errors));
  else
    return false;
}

var $schema$j = "http://json-schema.org/draft-07/schema#";
var $id$j = "https://raw.githubusercontent.com/ajv-validator/ajv/master/lib/refs/data.json#";
var description = "Meta-schema for $data reference (JSON Schema extension proposal)";
var type$h = "object";
var required$g = [
	"$data"
];
var properties$j = {
	$data: {
		type: "string",
		anyOf: [
			{
				format: "relative-json-pointer"
			},
			{
				format: "json-pointer"
			}
		]
	}
};
var additionalProperties = false;
var require$$1$1 = {
	$schema: $schema$j,
	$id: $id$j,
	description: description,
	type: type$h,
	required: required$g,
	properties: properties$j,
	additionalProperties: additionalProperties
};

var ajv$1 = Ajv;

Ajv.prototype.validate = validate$1;
Ajv.prototype.compile = compile;
Ajv.prototype.addSchema = addSchema;
Ajv.prototype.addMetaSchema = addMetaSchema;
Ajv.prototype.validateSchema = validateSchema;
Ajv.prototype.getSchema = getSchema;
Ajv.prototype.removeSchema = removeSchema;
Ajv.prototype.addFormat = addFormat;
Ajv.prototype.errorsText = errorsText;

Ajv.prototype._addSchema = _addSchema;
Ajv.prototype._compile = _compile;

Ajv.prototype.compileAsync = async$1;

Ajv.prototype.addKeyword = keyword.add;
Ajv.prototype.getKeyword = keyword.get;
Ajv.prototype.removeKeyword = keyword.remove;
Ajv.prototype.validateKeyword = keyword.validate;


Ajv.ValidationError = error_classes.Validation;
Ajv.MissingRefError = error_classes.MissingRef;
Ajv.$dataMetaSchema = data;

var META_SCHEMA_ID = 'http://json-schema.org/draft-07/schema';

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes', 'strictDefaults' ];
var META_SUPPORT_DATA = ['/properties'];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  opts = this._opts = util.copy(opts) || {};
  setLogger(this);
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats_1(opts.format);

  this._cache = opts.cache || new cache$1;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();
  this._getId = chooseGetId(opts);

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  if (opts.serialize === undefined) opts.serialize = fastJsonStableStringify;
  this._metaOpts = getMetaSchemaOptions(this);

  if (opts.formats) addInitialFormats(this);
  if (opts.keywords) addInitialKeywords(this);
  addDefaultMetaSchema(this);
  if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
  if (opts.nullable) this.addKeyword('nullable', {metaSchema: {type: 'boolean'}});
  addInitialSchemas(this);
}



/**
 * Validate data using schema
 * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
 * @this   Ajv
 * @param  {String|Object} schemaKeyRef key, ref or schema object
 * @param  {Any} data to be validated
 * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
 */
function validate$1(schemaKeyRef, data) {
  var v;
  if (typeof schemaKeyRef == 'string') {
    v = this.getSchema(schemaKeyRef);
    if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
  } else {
    var schemaObj = this._addSchema(schemaKeyRef);
    v = schemaObj.validate || this._compile(schemaObj);
  }

  var valid = v(data);
  if (v.$async !== true) this.errors = v.errors;
  return valid;
}


/**
 * Create validating function for passed schema.
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
 * @return {Function} validating function
 */
function compile(schema, _meta) {
  var schemaObj = this._addSchema(schema, undefined, _meta);
  return schemaObj.validate || this._compile(schemaObj);
}


/**
 * Adds schema to the instance.
 * @this   Ajv
 * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
 * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
 * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
 * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
 * @return {Ajv} this for method chaining
 */
function addSchema(schema, key, _skipValidation, _meta) {
  if (Array.isArray(schema)){
    for (var i=0; i<schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
    return this;
  }
  var id = this._getId(schema);
  if (id !== undefined && typeof id != 'string')
    throw new Error('schema id must be string');
  key = resolve_1.normalizeId(key || id);
  checkUnique(this, key);
  this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
  return this;
}


/**
 * Add schema that will be used to validate other schemas
 * options in META_IGNORE_OPTIONS are alway set to false
 * @this   Ajv
 * @param {Object} schema schema object
 * @param {String} key optional schema key
 * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
 * @return {Ajv} this for method chaining
 */
function addMetaSchema(schema, key, skipValidation) {
  this.addSchema(schema, key, skipValidation, true);
  return this;
}


/**
 * Validate schema
 * @this   Ajv
 * @param {Object} schema schema to validate
 * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
 * @return {Boolean} true if schema is valid
 */
function validateSchema(schema, throwOrLogError) {
  var $schema = schema.$schema;
  if ($schema !== undefined && typeof $schema != 'string')
    throw new Error('$schema must be a string');
  $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
  if (!$schema) {
    this.logger.warn('meta-schema not available');
    this.errors = null;
    return true;
  }
  var valid = this.validate($schema, schema);
  if (!valid && throwOrLogError) {
    var message = 'schema is invalid: ' + this.errorsText();
    if (this._opts.validateSchema == 'log') this.logger.error(message);
    else throw new Error(message);
  }
  return valid;
}


function defaultMeta(self) {
  var meta = self._opts.meta;
  self._opts.defaultMeta = typeof meta == 'object'
                            ? self._getId(meta) || meta
                            : self.getSchema(META_SCHEMA_ID)
                              ? META_SCHEMA_ID
                              : undefined;
  return self._opts.defaultMeta;
}


/**
 * Get compiled schema from the instance by `key` or `ref`.
 * @this   Ajv
 * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
 * @return {Function} schema validating function (with property `schema`).
 */
function getSchema(keyRef) {
  var schemaObj = _getSchemaObj(this, keyRef);
  switch (typeof schemaObj) {
    case 'object': return schemaObj.validate || this._compile(schemaObj);
    case 'string': return this.getSchema(schemaObj);
    case 'undefined': return _getSchemaFragment(this, keyRef);
  }
}


function _getSchemaFragment(self, ref) {
  var res = resolve_1.schema.call(self, { schema: {} }, ref);
  if (res) {
    var schema = res.schema
      , root = res.root
      , baseId = res.baseId;
    var v = compile_1.call(self, schema, root, undefined, baseId);
    self._fragments[ref] = new schema_obj({
      ref: ref,
      fragment: true,
      schema: schema,
      root: root,
      baseId: baseId,
      validate: v
    });
    return v;
  }
}


function _getSchemaObj(self, keyRef) {
  keyRef = resolve_1.normalizeId(keyRef);
  return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
}


/**
 * Remove cached schema(s).
 * If no parameter is passed all schemas but meta-schemas are removed.
 * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
 * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
 * @this   Ajv
 * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
 * @return {Ajv} this for method chaining
 */
function removeSchema(schemaKeyRef) {
  if (schemaKeyRef instanceof RegExp) {
    _removeAllSchemas(this, this._schemas, schemaKeyRef);
    _removeAllSchemas(this, this._refs, schemaKeyRef);
    return this;
  }
  switch (typeof schemaKeyRef) {
    case 'undefined':
      _removeAllSchemas(this, this._schemas);
      _removeAllSchemas(this, this._refs);
      this._cache.clear();
      return this;
    case 'string':
      var schemaObj = _getSchemaObj(this, schemaKeyRef);
      if (schemaObj) this._cache.del(schemaObj.cacheKey);
      delete this._schemas[schemaKeyRef];
      delete this._refs[schemaKeyRef];
      return this;
    case 'object':
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
      this._cache.del(cacheKey);
      var id = this._getId(schemaKeyRef);
      if (id) {
        id = resolve_1.normalizeId(id);
        delete this._schemas[id];
        delete this._refs[id];
      }
  }
  return this;
}


function _removeAllSchemas(self, schemas, regex) {
  for (var keyRef in schemas) {
    var schemaObj = schemas[keyRef];
    if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
      self._cache.del(schemaObj.cacheKey);
      delete schemas[keyRef];
    }
  }
}


/* @this   Ajv */
function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
  if (typeof schema != 'object' && typeof schema != 'boolean')
    throw new Error('schema should be object or boolean');
  var serialize = this._opts.serialize;
  var cacheKey = serialize ? serialize(schema) : schema;
  var cached = this._cache.get(cacheKey);
  if (cached) return cached;

  shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

  var id = resolve_1.normalizeId(this._getId(schema));
  if (id && shouldAddSchema) checkUnique(this, id);

  var willValidate = this._opts.validateSchema !== false && !skipValidation;
  var recursiveMeta;
  if (willValidate && !(recursiveMeta = id && id == resolve_1.normalizeId(schema.$schema)))
    this.validateSchema(schema, true);

  var localRefs = resolve_1.ids.call(this, schema);

  var schemaObj = new schema_obj({
    id: id,
    schema: schema,
    localRefs: localRefs,
    cacheKey: cacheKey,
    meta: meta
  });

  if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
  this._cache.put(cacheKey, schemaObj);

  if (willValidate && recursiveMeta) this.validateSchema(schema, true);

  return schemaObj;
}


/* @this   Ajv */
function _compile(schemaObj, root) {
  if (schemaObj.compiling) {
    schemaObj.validate = callValidate;
    callValidate.schema = schemaObj.schema;
    callValidate.errors = null;
    callValidate.root = root ? root : callValidate;
    if (schemaObj.schema.$async === true)
      callValidate.$async = true;
    return callValidate;
  }
  schemaObj.compiling = true;

  var currentOpts;
  if (schemaObj.meta) {
    currentOpts = this._opts;
    this._opts = this._metaOpts;
  }

  var v;
  try { v = compile_1.call(this, schemaObj.schema, root, schemaObj.localRefs); }
  catch(e) {
    delete schemaObj.validate;
    throw e;
  }
  finally {
    schemaObj.compiling = false;
    if (schemaObj.meta) this._opts = currentOpts;
  }

  schemaObj.validate = v;
  schemaObj.refs = v.refs;
  schemaObj.refVal = v.refVal;
  schemaObj.root = v.root;
  return v;


  /* @this   {*} - custom context, see passContext option */
  function callValidate() {
    /* jshint validthis: true */
    var _validate = schemaObj.validate;
    var result = _validate.apply(this, arguments);
    callValidate.errors = _validate.errors;
    return result;
  }
}


function chooseGetId(opts) {
  switch (opts.schemaId) {
    case 'auto': return _get$IdOrId;
    case 'id': return _getId;
    default: return _get$Id;
  }
}

/* @this   Ajv */
function _getId(schema) {
  if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
  return schema.id;
}

/* @this   Ajv */
function _get$Id(schema) {
  if (schema.id) this.logger.warn('schema id ignored', schema.id);
  return schema.$id;
}


function _get$IdOrId(schema) {
  if (schema.$id && schema.id && schema.$id != schema.id)
    throw new Error('schema $id is different from id');
  return schema.$id || schema.id;
}


/**
 * Convert array of error message objects to string
 * @this   Ajv
 * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
 * @param  {Object} options optional options with properties `separator` and `dataVar`.
 * @return {String} human readable string with all errors descriptions
 */
function errorsText(errors, options) {
  errors = errors || this.errors;
  if (!errors) return 'No errors';
  options = options || {};
  var separator = options.separator === undefined ? ', ' : options.separator;
  var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

  var text = '';
  for (var i=0; i<errors.length; i++) {
    var e = errors[i];
    if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
  }
  return text.slice(0, -separator.length);
}


/**
 * Add custom format
 * @this   Ajv
 * @param {String} name format name
 * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
 * @return {Ajv} this for method chaining
 */
function addFormat(name, format) {
  if (typeof format == 'string') format = new RegExp(format);
  this._formats[name] = format;
  return this;
}


function addDefaultMetaSchema(self) {
  var $dataSchema;
  if (self._opts.$data) {
    $dataSchema = require$$1$1;
    self.addMetaSchema($dataSchema, $dataSchema.$id, true);
  }
  if (self._opts.meta === false) return;
  var metaSchema = require$$2$1;
  if (self._opts.$data) metaSchema = data(metaSchema, META_SUPPORT_DATA);
  self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
  self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
}


function addInitialSchemas(self) {
  var optsSchemas = self._opts.schemas;
  if (!optsSchemas) return;
  if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);
  else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
}


function addInitialFormats(self) {
  for (var name in self._opts.formats) {
    var format = self._opts.formats[name];
    self.addFormat(name, format);
  }
}


function addInitialKeywords(self) {
  for (var name in self._opts.keywords) {
    var keyword = self._opts.keywords[name];
    self.addKeyword(name, keyword);
  }
}


function checkUnique(self, id) {
  if (self._schemas[id] || self._refs[id])
    throw new Error('schema with key or id "' + id + '" already exists');
}


function getMetaSchemaOptions(self) {
  var metaOpts = util.copy(self._opts);
  for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
    delete metaOpts[META_IGNORE_OPTIONS[i]];
  return metaOpts;
}


function setLogger(self) {
  var logger = self._opts.logger;
  if (logger === false) {
    self.logger = {log: noop, warn: noop, error: noop};
  } else {
    if (logger === undefined) logger = console;
    if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error))
      throw new Error('logger must implement log, warn and error methods');
    self.logger = logger;
  }
}


function noop() {}

function HARError (errors) {
  var message = 'validation failed';

  this.name = 'HARError';
  this.message = message;
  this.errors = errors;

  if (typeof Error.captureStackTrace === 'function') {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = (new Error(message)).stack;
  }
}

HARError.prototype = Error.prototype;

var error = HARError;

var $id$i = "afterRequest.json#";
var $schema$i = "http://json-schema.org/draft-06/schema#";
var type$g = "object";
var optional$4 = true;
var required$f = [
	"lastAccess",
	"eTag",
	"hitCount"
];
var properties$i = {
	expires: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	lastAccess: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	eTag: {
		type: "string"
	},
	hitCount: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$0$1 = {
	$id: $id$i,
	$schema: $schema$i,
	type: type$g,
	optional: optional$4,
	required: required$f,
	properties: properties$i
};

var $id$h = "beforeRequest.json#";
var $schema$h = "http://json-schema.org/draft-06/schema#";
var type$f = "object";
var optional$3 = true;
var required$e = [
	"lastAccess",
	"eTag",
	"hitCount"
];
var properties$h = {
	expires: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	lastAccess: {
		type: "string",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))?"
	},
	eTag: {
		type: "string"
	},
	hitCount: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$1 = {
	$id: $id$h,
	$schema: $schema$h,
	type: type$f,
	optional: optional$3,
	required: required$e,
	properties: properties$h
};

var $id$g = "browser.json#";
var $schema$g = "http://json-schema.org/draft-06/schema#";
var type$e = "object";
var required$d = [
	"name",
	"version"
];
var properties$g = {
	name: {
		type: "string"
	},
	version: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$2 = {
	$id: $id$g,
	$schema: $schema$g,
	type: type$e,
	required: required$d,
	properties: properties$g
};

var $id$f = "cache.json#";
var $schema$f = "http://json-schema.org/draft-06/schema#";
var properties$f = {
	beforeRequest: {
		oneOf: [
			{
				type: "null"
			},
			{
				$ref: "beforeRequest.json#"
			}
		]
	},
	afterRequest: {
		oneOf: [
			{
				type: "null"
			},
			{
				$ref: "afterRequest.json#"
			}
		]
	},
	comment: {
		type: "string"
	}
};
var require$$3 = {
	$id: $id$f,
	$schema: $schema$f,
	properties: properties$f
};

var $id$e = "content.json#";
var $schema$e = "http://json-schema.org/draft-06/schema#";
var type$d = "object";
var required$c = [
	"size",
	"mimeType"
];
var properties$e = {
	size: {
		type: "integer"
	},
	compression: {
		type: "integer"
	},
	mimeType: {
		type: "string"
	},
	text: {
		type: "string"
	},
	encoding: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$4 = {
	$id: $id$e,
	$schema: $schema$e,
	type: type$d,
	required: required$c,
	properties: properties$e
};

var $id$d = "cookie.json#";
var $schema$d = "http://json-schema.org/draft-06/schema#";
var type$c = "object";
var required$b = [
	"name",
	"value"
];
var properties$d = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	path: {
		type: "string"
	},
	domain: {
		type: "string"
	},
	expires: {
		type: [
			"string",
			"null"
		],
		format: "date-time"
	},
	httpOnly: {
		type: "boolean"
	},
	secure: {
		type: "boolean"
	},
	comment: {
		type: "string"
	}
};
var require$$5 = {
	$id: $id$d,
	$schema: $schema$d,
	type: type$c,
	required: required$b,
	properties: properties$d
};

var $id$c = "creator.json#";
var $schema$c = "http://json-schema.org/draft-06/schema#";
var type$b = "object";
var required$a = [
	"name",
	"version"
];
var properties$c = {
	name: {
		type: "string"
	},
	version: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$6 = {
	$id: $id$c,
	$schema: $schema$c,
	type: type$b,
	required: required$a,
	properties: properties$c
};

var $id$b = "entry.json#";
var $schema$b = "http://json-schema.org/draft-06/schema#";
var type$a = "object";
var optional$2 = true;
var required$9 = [
	"startedDateTime",
	"time",
	"request",
	"response",
	"cache",
	"timings"
];
var properties$b = {
	pageref: {
		type: "string"
	},
	startedDateTime: {
		type: "string",
		format: "date-time",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
	},
	time: {
		type: "number",
		min: 0
	},
	request: {
		$ref: "request.json#"
	},
	response: {
		$ref: "response.json#"
	},
	cache: {
		$ref: "cache.json#"
	},
	timings: {
		$ref: "timings.json#"
	},
	serverIPAddress: {
		type: "string",
		oneOf: [
			{
				format: "ipv4"
			},
			{
				format: "ipv6"
			}
		]
	},
	connection: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$7 = {
	$id: $id$b,
	$schema: $schema$b,
	type: type$a,
	optional: optional$2,
	required: required$9,
	properties: properties$b
};

var $id$a = "har.json#";
var $schema$a = "http://json-schema.org/draft-06/schema#";
var type$9 = "object";
var required$8 = [
	"log"
];
var properties$a = {
	log: {
		$ref: "log.json#"
	}
};
var require$$8 = {
	$id: $id$a,
	$schema: $schema$a,
	type: type$9,
	required: required$8,
	properties: properties$a
};

var $id$9 = "header.json#";
var $schema$9 = "http://json-schema.org/draft-06/schema#";
var type$8 = "object";
var required$7 = [
	"name",
	"value"
];
var properties$9 = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$9 = {
	$id: $id$9,
	$schema: $schema$9,
	type: type$8,
	required: required$7,
	properties: properties$9
};

var $id$8 = "log.json#";
var $schema$8 = "http://json-schema.org/draft-06/schema#";
var type$7 = "object";
var required$6 = [
	"version",
	"creator",
	"entries"
];
var properties$8 = {
	version: {
		type: "string"
	},
	creator: {
		$ref: "creator.json#"
	},
	browser: {
		$ref: "browser.json#"
	},
	pages: {
		type: "array",
		items: {
			$ref: "page.json#"
		}
	},
	entries: {
		type: "array",
		items: {
			$ref: "entry.json#"
		}
	},
	comment: {
		type: "string"
	}
};
var require$$10 = {
	$id: $id$8,
	$schema: $schema$8,
	type: type$7,
	required: required$6,
	properties: properties$8
};

var $id$7 = "page.json#";
var $schema$7 = "http://json-schema.org/draft-06/schema#";
var type$6 = "object";
var optional$1 = true;
var required$5 = [
	"startedDateTime",
	"id",
	"title",
	"pageTimings"
];
var properties$7 = {
	startedDateTime: {
		type: "string",
		format: "date-time",
		pattern: "^(\\d{4})(-)?(\\d\\d)(-)?(\\d\\d)(T)?(\\d\\d)(:)?(\\d\\d)(:)?(\\d\\d)(\\.\\d+)?(Z|([+-])(\\d\\d)(:)?(\\d\\d))"
	},
	id: {
		type: "string",
		unique: true
	},
	title: {
		type: "string"
	},
	pageTimings: {
		$ref: "pageTimings.json#"
	},
	comment: {
		type: "string"
	}
};
var require$$11 = {
	$id: $id$7,
	$schema: $schema$7,
	type: type$6,
	optional: optional$1,
	required: required$5,
	properties: properties$7
};

var $id$6 = "pageTimings.json#";
var $schema$6 = "http://json-schema.org/draft-06/schema#";
var type$5 = "object";
var properties$6 = {
	onContentLoad: {
		type: "number",
		min: -1
	},
	onLoad: {
		type: "number",
		min: -1
	},
	comment: {
		type: "string"
	}
};
var require$$12 = {
	$id: $id$6,
	$schema: $schema$6,
	type: type$5,
	properties: properties$6
};

var $id$5 = "postData.json#";
var $schema$5 = "http://json-schema.org/draft-06/schema#";
var type$4 = "object";
var optional = true;
var required$4 = [
	"mimeType"
];
var properties$5 = {
	mimeType: {
		type: "string"
	},
	text: {
		type: "string"
	},
	params: {
		type: "array",
		required: [
			"name"
		],
		properties: {
			name: {
				type: "string"
			},
			value: {
				type: "string"
			},
			fileName: {
				type: "string"
			},
			contentType: {
				type: "string"
			},
			comment: {
				type: "string"
			}
		}
	},
	comment: {
		type: "string"
	}
};
var require$$13 = {
	$id: $id$5,
	$schema: $schema$5,
	type: type$4,
	optional: optional,
	required: required$4,
	properties: properties$5
};

var $id$4 = "query.json#";
var $schema$4 = "http://json-schema.org/draft-06/schema#";
var type$3 = "object";
var required$3 = [
	"name",
	"value"
];
var properties$4 = {
	name: {
		type: "string"
	},
	value: {
		type: "string"
	},
	comment: {
		type: "string"
	}
};
var require$$14 = {
	$id: $id$4,
	$schema: $schema$4,
	type: type$3,
	required: required$3,
	properties: properties$4
};

var $id$3 = "request.json#";
var $schema$3 = "http://json-schema.org/draft-06/schema#";
var type$2 = "object";
var required$2 = [
	"method",
	"url",
	"httpVersion",
	"cookies",
	"headers",
	"queryString",
	"headersSize",
	"bodySize"
];
var properties$3 = {
	method: {
		type: "string"
	},
	url: {
		type: "string",
		format: "uri"
	},
	httpVersion: {
		type: "string"
	},
	cookies: {
		type: "array",
		items: {
			$ref: "cookie.json#"
		}
	},
	headers: {
		type: "array",
		items: {
			$ref: "header.json#"
		}
	},
	queryString: {
		type: "array",
		items: {
			$ref: "query.json#"
		}
	},
	postData: {
		$ref: "postData.json#"
	},
	headersSize: {
		type: "integer"
	},
	bodySize: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$15 = {
	$id: $id$3,
	$schema: $schema$3,
	type: type$2,
	required: required$2,
	properties: properties$3
};

var $id$2 = "response.json#";
var $schema$2 = "http://json-schema.org/draft-06/schema#";
var type$1 = "object";
var required$1 = [
	"status",
	"statusText",
	"httpVersion",
	"cookies",
	"headers",
	"content",
	"redirectURL",
	"headersSize",
	"bodySize"
];
var properties$2 = {
	status: {
		type: "integer"
	},
	statusText: {
		type: "string"
	},
	httpVersion: {
		type: "string"
	},
	cookies: {
		type: "array",
		items: {
			$ref: "cookie.json#"
		}
	},
	headers: {
		type: "array",
		items: {
			$ref: "header.json#"
		}
	},
	content: {
		$ref: "content.json#"
	},
	redirectURL: {
		type: "string"
	},
	headersSize: {
		type: "integer"
	},
	bodySize: {
		type: "integer"
	},
	comment: {
		type: "string"
	}
};
var require$$16 = {
	$id: $id$2,
	$schema: $schema$2,
	type: type$1,
	required: required$1,
	properties: properties$2
};

var $id$1 = "timings.json#";
var $schema$1 = "http://json-schema.org/draft-06/schema#";
var required = [
	"send",
	"wait",
	"receive"
];
var properties$1 = {
	dns: {
		type: "number",
		min: -1
	},
	connect: {
		type: "number",
		min: -1
	},
	blocked: {
		type: "number",
		min: -1
	},
	send: {
		type: "number",
		min: -1
	},
	wait: {
		type: "number",
		min: -1
	},
	receive: {
		type: "number",
		min: -1
	},
	ssl: {
		type: "number",
		min: -1
	},
	comment: {
		type: "string"
	}
};
var require$$17 = {
	$id: $id$1,
	$schema: $schema$1,
	required: required,
	properties: properties$1
};

var lib$b = {
  afterRequest: require$$0$1,
  beforeRequest: require$$1,
  browser: require$$2,
  cache: require$$3,
  content: require$$4,
  cookie: require$$5,
  creator: require$$6,
  entry: require$$7,
  har: require$$8,
  header: require$$9,
  log: require$$10,
  page: require$$11,
  pageTimings: require$$12,
  postData: require$$13,
  query: require$$14,
  request: require$$15,
  response: require$$16,
  timings: require$$17
};

var $schema = "http://json-schema.org/draft-06/schema#";
var $id = "http://json-schema.org/draft-06/schema#";
var title = "Core schema meta-schema";
var definitions = {
	schemaArray: {
		type: "array",
		minItems: 1,
		items: {
			$ref: "#"
		}
	},
	nonNegativeInteger: {
		type: "integer",
		minimum: 0
	},
	nonNegativeIntegerDefault0: {
		allOf: [
			{
				$ref: "#/definitions/nonNegativeInteger"
			},
			{
				"default": 0
			}
		]
	},
	simpleTypes: {
		"enum": [
			"array",
			"boolean",
			"integer",
			"null",
			"number",
			"object",
			"string"
		]
	},
	stringArray: {
		type: "array",
		items: {
			type: "string"
		},
		uniqueItems: true,
		"default": [
		]
	}
};
var type = [
	"object",
	"boolean"
];
var properties = {
	$id: {
		type: "string",
		format: "uri-reference"
	},
	$schema: {
		type: "string",
		format: "uri"
	},
	$ref: {
		type: "string",
		format: "uri-reference"
	},
	title: {
		type: "string"
	},
	description: {
		type: "string"
	},
	"default": {
	},
	examples: {
		type: "array",
		items: {
		}
	},
	multipleOf: {
		type: "number",
		exclusiveMinimum: 0
	},
	maximum: {
		type: "number"
	},
	exclusiveMaximum: {
		type: "number"
	},
	minimum: {
		type: "number"
	},
	exclusiveMinimum: {
		type: "number"
	},
	maxLength: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minLength: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	pattern: {
		type: "string",
		format: "regex"
	},
	additionalItems: {
		$ref: "#"
	},
	items: {
		anyOf: [
			{
				$ref: "#"
			},
			{
				$ref: "#/definitions/schemaArray"
			}
		],
		"default": {
		}
	},
	maxItems: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minItems: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	uniqueItems: {
		type: "boolean",
		"default": false
	},
	contains: {
		$ref: "#"
	},
	maxProperties: {
		$ref: "#/definitions/nonNegativeInteger"
	},
	minProperties: {
		$ref: "#/definitions/nonNegativeIntegerDefault0"
	},
	required: {
		$ref: "#/definitions/stringArray"
	},
	additionalProperties: {
		$ref: "#"
	},
	definitions: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	properties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	patternProperties: {
		type: "object",
		additionalProperties: {
			$ref: "#"
		},
		"default": {
		}
	},
	dependencies: {
		type: "object",
		additionalProperties: {
			anyOf: [
				{
					$ref: "#"
				},
				{
					$ref: "#/definitions/stringArray"
				}
			]
		}
	},
	propertyNames: {
		$ref: "#"
	},
	"const": {
	},
	"enum": {
		type: "array",
		minItems: 1,
		uniqueItems: true
	},
	type: {
		anyOf: [
			{
				$ref: "#/definitions/simpleTypes"
			},
			{
				type: "array",
				items: {
					$ref: "#/definitions/simpleTypes"
				},
				minItems: 1,
				uniqueItems: true
			}
		]
	},
	format: {
		type: "string"
	},
	allOf: {
		$ref: "#/definitions/schemaArray"
	},
	anyOf: {
		$ref: "#/definitions/schemaArray"
	},
	oneOf: {
		$ref: "#/definitions/schemaArray"
	},
	not: {
		$ref: "#"
	}
};
var require$$0 = {
	$schema: $schema,
	$id: $id,
	title: title,
	definitions: definitions,
	type: type,
	properties: properties,
	"default": {
}
};

var ajv;

function createAjvInstance () {
  var ajv = new ajv$1({
    allErrors: true
  });
  ajv.addMetaSchema(require$$0);
  ajv.addSchema(lib$b);

  return ajv
}

function validate (name, data) {
  data = data || {};

  // validator config
  ajv = ajv || createAjvInstance();

  var validate = ajv.getSchema(name + '.json');

  return new Promise(function (resolve, reject) {
    var valid = validate(data);

    !valid ? reject(new error(validate.errors)) : resolve(data);
  })
}

var afterRequest = function (data) {
  return validate('afterRequest', data)
};

var beforeRequest = function (data) {
  return validate('beforeRequest', data)
};

var browser$1 = function (data) {
  return validate('browser', data)
};

var cache = function (data) {
  return validate('cache', data)
};

var content = function (data) {
  return validate('content', data)
};

var cookie = function (data) {
  return validate('cookie', data)
};

var creator = function (data) {
  return validate('creator', data)
};

var entry = function (data) {
  return validate('entry', data)
};

var har$1 = function (data) {
  return validate('har', data)
};

var header = function (data) {
  return validate('header', data)
};

var log = function (data) {
  return validate('log', data)
};

var page = function (data) {
  return validate('page', data)
};

var pageTimings = function (data) {
  return validate('pageTimings', data)
};

var postData = function (data) {
  return validate('postData', data)
};

var query = function (data) {
  return validate('query', data)
};

var request$2 = function (data) {
  return validate('request', data)
};

var response = function (data) {
  return validate('response', data)
};

var timings = function (data) {
  return validate('timings', data)
};

var promise = {
	afterRequest: afterRequest,
	beforeRequest: beforeRequest,
	browser: browser$1,
	cache: cache,
	content: content,
	cookie: cookie,
	creator: creator,
	entry: entry,
	har: har$1,
	header: header,
	log: log,
	page: page,
	pageTimings: pageTimings,
	postData: postData,
	query: query,
	request: request$2,
	response: response,
	timings: timings
};

function Har$1 (request) {
  this.request = request;
}

Har$1.prototype.reducer = function (obj, pair) {
  // new property ?
  if (obj[pair.name] === undefined) {
    obj[pair.name] = pair.value;
    return obj
  }

  // existing? convert to array
  var arr = [
    obj[pair.name],
    pair.value
  ];

  obj[pair.name] = arr;

  return obj
};

Har$1.prototype.prep = function (data) {
  // construct utility properties
  data.queryObj = {};
  data.headersObj = {};
  data.postData.jsonObj = false;
  data.postData.paramsObj = false;

  // construct query objects
  if (data.queryString && data.queryString.length) {
    data.queryObj = data.queryString.reduce(this.reducer, {});
  }

  // construct headers objects
  if (data.headers && data.headers.length) {
    // loweCase header keys
    data.headersObj = data.headers.reduceRight(function (headers, header) {
      headers[header.name] = header.value;
      return headers
    }, {});
  }

  // construct Cookie header
  if (data.cookies && data.cookies.length) {
    var cookies = data.cookies.map(function (cookie) {
      return cookie.name + '=' + cookie.value
    });

    if (cookies.length) {
      data.headersObj.cookie = cookies.join('; ');
    }
  }

  // prep body
  function some (arr) {
    return arr.some(function (type) {
      return data.postData.mimeType.indexOf(type) === 0
    })
  }

  if (some([
    'multipart/mixed',
    'multipart/related',
    'multipart/form-data',
    'multipart/alternative'])) {
    // reset values
    data.postData.mimeType = 'multipart/form-data';
  } else if (some([
    'application/x-www-form-urlencoded'])) {
    if (!data.postData.params) {
      data.postData.text = '';
    } else {
      data.postData.paramsObj = data.postData.params.reduce(this.reducer, {});

      // always overwrite
      data.postData.text = querystring.stringify(data.postData.paramsObj);
    }
  } else if (some([
    'text/json',
    'text/x-json',
    'application/json',
    'application/x-json'])) {
    data.postData.mimeType = 'application/json';

    if (data.postData.text) {
      try {
        data.postData.jsonObj = JSON.parse(data.postData.text);
      } catch (e) {
        this.request.debug(e);

        // force back to text/plain
        data.postData.mimeType = 'text/plain';
      }
    }
  }

  return data
};

Har$1.prototype.options = function (options) {
  // skip if no har property defined
  if (!options.har) {
    return options
  }

  var har = {};
  extend(har, options.har);

  // only process the first entry
  if (har.log && har.log.entries) {
    har = har.log.entries[0];
  }

  // add optional properties to make validation successful
  har.url = har.url || options.url || options.uri || options.baseUrl || '/';
  har.httpVersion = har.httpVersion || 'HTTP/1.1';
  har.queryString = har.queryString || [];
  har.headers = har.headers || [];
  har.cookies = har.cookies || [];
  har.postData = har.postData || {};
  har.postData.mimeType = har.postData.mimeType || 'application/octet-stream';

  har.bodySize = 0;
  har.headersSize = 0;
  har.postData.size = 0;

  if (!promise.request(har)) {
    return options
  }

  // clean up and get some utility properties
  var req = this.prep(har);

  // construct new options
  if (req.url) {
    options.url = req.url;
  }

  if (req.method) {
    options.method = req.method;
  }

  if (Object.keys(req.queryObj).length) {
    options.qs = req.queryObj;
  }

  if (Object.keys(req.headersObj).length) {
    options.headers = req.headersObj;
  }

  function test (type) {
    return req.postData.mimeType.indexOf(type) === 0
  }
  if (test('application/x-www-form-urlencoded')) {
    options.form = req.postData.paramsObj;
  } else if (test('application/json')) {
    if (req.postData.jsonObj) {
      options.body = req.postData.jsonObj;
      options.json = true;
    }
  } else if (test('multipart/form-data')) {
    options.formData = {};

    req.postData.params.forEach(function (param) {
      var attachment = {};

      if (!param.fileName && !param.contentType) {
        options.formData[param.name] = param.value;
        return
      }

      // attempt to read from disk!
      if (param.fileName && !param.value) {
        attachment.value = fs.createReadStream(param.fileName);
      } else if (param.value) {
        attachment.value = param.value;
      }

      if (param.fileName) {
        attachment.options = {
          filename: param.fileName,
          contentType: param.contentType ? param.contentType : null
        };
      }

      options.formData[param.name] = attachment;
    });
  } else {
    if (req.postData.text) {
      options.body = req.postData.text;
    }
  }

  return options
};

var Har_1 = Har$1;

var har = {
	Har: Har_1
};

var rngBrowser = createCommonjsModule(function (module) {
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}
});

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

var bytesToUuid_1 = bytesToUuid;

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options === 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rngBrowser)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid_1(rnds);
}

var v4_1 = v4;

var md5 = helpers.md5;
var toBase64$1 = helpers.toBase64;

function Auth$1 (request) {
  // define all public properties here
  this.request = request;
  this.hasAuth = false;
  this.sentAuth = false;
  this.bearerToken = null;
  this.user = null;
  this.pass = null;
}

Auth$1.prototype.basic = function (user, pass, sendImmediately) {
  var self = this;
  if (typeof user !== 'string' || (pass !== undefined && typeof pass !== 'string')) {
    self.request.emit('error', new Error('auth() received invalid user or password'));
  }
  self.user = user;
  self.pass = pass;
  self.hasAuth = true;
  var header = user + ':' + (pass || '');
  if (sendImmediately || typeof sendImmediately === 'undefined') {
    var authHeader = 'Basic ' + toBase64$1(header);
    self.sentAuth = true;
    return authHeader
  }
};

Auth$1.prototype.bearer = function (bearer, sendImmediately) {
  var self = this;
  self.bearerToken = bearer;
  self.hasAuth = true;
  if (sendImmediately || typeof sendImmediately === 'undefined') {
    if (typeof bearer === 'function') {
      bearer = bearer();
    }
    var authHeader = 'Bearer ' + (bearer || '');
    self.sentAuth = true;
    return authHeader
  }
};

Auth$1.prototype.digest = function (method, path, authHeader) {
  // TODO: More complete implementation of RFC 2617.
  //   - handle challenge.domain
  //   - support qop="auth-int" only
  //   - handle Authentication-Info (not necessarily?)
  //   - check challenge.stale (not necessarily?)
  //   - increase nc (not necessarily?)
  // For reference:
  // http://tools.ietf.org/html/rfc2617#section-3
  // https://github.com/bagder/curl/blob/master/lib/http_digest.c

  var self = this;

  var challenge = {};
  var re = /([a-z0-9_-]+)=(?:"([^"]+)"|([a-z0-9_-]+))/gi;
  while (true) {
    var match = re.exec(authHeader);
    if (!match) {
      break
    }
    challenge[match[1]] = match[2] || match[3];
  }

  /**
   * RFC 2617: handle both MD5 and MD5-sess algorithms.
   *
   * If the algorithm directive's value is "MD5" or unspecified, then HA1 is
   *   HA1=MD5(username:realm:password)
   * If the algorithm directive's value is "MD5-sess", then HA1 is
   *   HA1=MD5(MD5(username:realm:password):nonce:cnonce)
   */
  var ha1Compute = function (algorithm, user, realm, pass, nonce, cnonce) {
    var ha1 = md5(user + ':' + realm + ':' + pass);
    if (algorithm && algorithm.toLowerCase() === 'md5-sess') {
      return md5(ha1 + ':' + nonce + ':' + cnonce)
    } else {
      return ha1
    }
  };

  var qop = /(^|,)\s*auth\s*($|,)/.test(challenge.qop) && 'auth';
  var nc = qop && '00000001';
  var cnonce = qop && v4_1().replace(/-/g, '');
  var ha1 = ha1Compute(challenge.algorithm, self.user, challenge.realm, self.pass, challenge.nonce, cnonce);
  var ha2 = md5(method + ':' + path);
  var digestResponse = qop
    ? md5(ha1 + ':' + challenge.nonce + ':' + nc + ':' + cnonce + ':' + qop + ':' + ha2)
    : md5(ha1 + ':' + challenge.nonce + ':' + ha2);
  var authValues = {
    username: self.user,
    realm: challenge.realm,
    nonce: challenge.nonce,
    uri: path,
    qop: qop,
    response: digestResponse,
    nc: nc,
    cnonce: cnonce,
    algorithm: challenge.algorithm,
    opaque: challenge.opaque
  };

  authHeader = [];
  for (var k in authValues) {
    if (authValues[k]) {
      if (k === 'qop' || k === 'nc' || k === 'algorithm') {
        authHeader.push(k + '=' + authValues[k]);
      } else {
        authHeader.push(k + '="' + authValues[k] + '"');
      }
    }
  }
  authHeader = 'Digest ' + authHeader.join(', ');
  self.sentAuth = true;
  return authHeader
};

Auth$1.prototype.onRequest = function (user, pass, sendImmediately, bearer) {
  var self = this;
  var request = self.request;

  var authHeader;
  if (bearer === undefined && user === undefined) {
    self.request.emit('error', new Error('no auth mechanism defined'));
  } else if (bearer !== undefined) {
    authHeader = self.bearer(bearer, sendImmediately);
  } else {
    authHeader = self.basic(user, pass, sendImmediately);
  }
  if (authHeader) {
    request.setHeader('authorization', authHeader);
  }
};

Auth$1.prototype.onResponse = function (response) {
  var self = this;
  var request = self.request;

  if (!self.hasAuth || self.sentAuth) { return null }

  var c = caseless(response.headers);

  var authHeader = c.get('www-authenticate');
  var authVerb = authHeader && authHeader.split(' ')[0].toLowerCase();
  request.debug('reauth', authVerb);

  switch (authVerb) {
    case 'basic':
      return self.basic(self.user, self.pass, true)

    case 'bearer':
      return self.bearer(self.bearerToken, true)

    case 'digest':
      return self.digest(request.method, request.path, authHeader)
  }
};

var Auth_1 = Auth$1;

var auth = {
	Auth: Auth_1
};

function sha (key, body, algorithm) {
  return crypto$1.createHmac(algorithm, key).update(body).digest('base64')
}

function rsa (key, body) {
  return crypto$1.createSign('RSA-SHA1').update(body).sign(key, 'base64')
}

function rfc3986 (str) {
  return encodeURIComponent(str)
    .replace(/!/g,'%21')
    .replace(/\*/g,'%2A')
    .replace(/\(/g,'%28')
    .replace(/\)/g,'%29')
    .replace(/'/g,'%27')
}

// Maps object to bi-dimensional array
// Converts { foo: 'A', bar: [ 'b', 'B' ]} to
// [ ['foo', 'A'], ['bar', 'b'], ['bar', 'B'] ]
function map (obj) {
  var key, val, arr = [];
  for (key in obj) {
    val = obj[key];
    if (Array.isArray(val))
      for (var i = 0; i < val.length; i++)
        arr.push([key, val[i]]);
    else if (typeof val === 'object')
      for (var prop in val)
        arr.push([key + '[' + prop + ']', val[prop]]);
    else
      arr.push([key, val]);
  }
  return arr
}

// Compare function for sort
function compare (a, b) {
  return a > b ? 1 : a < b ? -1 : 0
}

function generateBase (httpMethod, base_uri, params) {
  // adapted from https://dev.twitter.com/docs/auth/oauth and 
  // https://dev.twitter.com/docs/auth/creating-signature

  // Parameter normalization
  // http://tools.ietf.org/html/rfc5849#section-3.4.1.3.2
  var normalized = map(params)
  // 1.  First, the name and value of each parameter are encoded
  .map(function (p) {
    return [ rfc3986(p[0]), rfc3986(p[1] || '') ]
  })
  // 2.  The parameters are sorted by name, using ascending byte value
  //     ordering.  If two or more parameters share the same name, they
  //     are sorted by their value.
  .sort(function (a, b) {
    return compare(a[0], b[0]) || compare(a[1], b[1])
  })
  // 3.  The name of each parameter is concatenated to its corresponding
  //     value using an "=" character (ASCII code 61) as a separator, even
  //     if the value is empty.
  .map(function (p) { return p.join('=') })
   // 4.  The sorted name/value pairs are concatenated together into a
   //     single string by using an "&" character (ASCII code 38) as
   //     separator.
  .join('&');

  var base = [
    rfc3986(httpMethod ? httpMethod.toUpperCase() : 'GET'),
    rfc3986(base_uri),
    rfc3986(normalized)
  ].join('&');

  return base
}

function hmacsign (httpMethod, base_uri, params, consumer_secret, token_secret) {
  var base = generateBase(httpMethod, base_uri, params);
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&');

  return sha(key, base, 'sha1')
}

function hmacsign256 (httpMethod, base_uri, params, consumer_secret, token_secret) {
  var base = generateBase(httpMethod, base_uri, params);
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&');

  return sha(key, base, 'sha256')
}

function rsasign (httpMethod, base_uri, params, private_key, token_secret) {
  var base = generateBase(httpMethod, base_uri, params);
  var key = private_key || '';

  return rsa(key, base)
}

function plaintext (consumer_secret, token_secret) {
  var key = [
    consumer_secret || '',
    token_secret || ''
  ].map(rfc3986).join('&');

  return key
}

function sign (signMethod, httpMethod, base_uri, params, consumer_secret, token_secret) {
  var method;
  var skipArgs = 1;

  switch (signMethod) {
    case 'RSA-SHA1':
      method = rsasign;
      break
    case 'HMAC-SHA1':
      method = hmacsign;
      break
    case 'HMAC-SHA256':
      method = hmacsign256;
      break
    case 'PLAINTEXT':
      method = plaintext;
      skipArgs = 4;
      break
    default:
     throw new Error('Signature method not supported: ' + signMethod)
  }

  return method.apply(null, [].slice.call(arguments, skipArgs))
}

var hmacsign_1 = hmacsign;
var hmacsign256_1 = hmacsign256;
var rsasign_1 = rsasign;
var plaintext_1 = plaintext;
var sign_1 = sign;
var rfc3986_1 = rfc3986;
var generateBase_1 = generateBase;

var oauthSign = {
	hmacsign: hmacsign_1,
	hmacsign256: hmacsign256_1,
	rsasign: rsasign_1,
	plaintext: plaintext_1,
	sign: sign_1,
	rfc3986: rfc3986_1,
	generateBase: generateBase_1
};

var Buffer$4 = safeBuffer.Buffer;

function OAuth$1 (request) {
  this.request = request;
  this.params = null;
}

OAuth$1.prototype.buildParams = function (_oauth, uri, method, query, form, qsLib) {
  var oa = {};
  for (var i in _oauth) {
    oa['oauth_' + i] = _oauth[i];
  }
  if (!oa.oauth_version) {
    oa.oauth_version = '1.0';
  }
  if (!oa.oauth_timestamp) {
    oa.oauth_timestamp = Math.floor(Date.now() / 1000).toString();
  }
  if (!oa.oauth_nonce) {
    oa.oauth_nonce = v4_1().replace(/-/g, '');
  }
  if (!oa.oauth_signature_method) {
    oa.oauth_signature_method = 'HMAC-SHA1';
  }

  var consumer_secret_or_private_key = oa.oauth_consumer_secret || oa.oauth_private_key; // eslint-disable-line camelcase
  delete oa.oauth_consumer_secret;
  delete oa.oauth_private_key;

  var token_secret = oa.oauth_token_secret; // eslint-disable-line camelcase
  delete oa.oauth_token_secret;

  var realm = oa.oauth_realm;
  delete oa.oauth_realm;
  delete oa.oauth_transport_method;

  var baseurl = uri.protocol + '//' + uri.host + uri.pathname;
  var params = qsLib.parse([].concat(query, form, qsLib.stringify(oa)).join('&'));

  oa.oauth_signature = oauthSign.sign(
    oa.oauth_signature_method,
    method,
    baseurl,
    params,
    consumer_secret_or_private_key, // eslint-disable-line camelcase
    token_secret // eslint-disable-line camelcase
  );

  if (realm) {
    oa.realm = realm;
  }

  return oa
};

OAuth$1.prototype.buildBodyHash = function (_oauth, body) {
  if (['HMAC-SHA1', 'RSA-SHA1'].indexOf(_oauth.signature_method || 'HMAC-SHA1') < 0) {
    this.request.emit('error', new Error('oauth: ' + _oauth.signature_method +
      ' signature_method not supported with body_hash signing.'));
  }

  var shasum = crypto$1.createHash('sha1');
  shasum.update(body || '');
  var sha1 = shasum.digest('hex');

  return Buffer$4.from(sha1, 'hex').toString('base64')
};

OAuth$1.prototype.concatParams = function (oa, sep, wrap) {
  wrap = wrap || '';

  var params = Object.keys(oa).filter(function (i) {
    return i !== 'realm' && i !== 'oauth_signature'
  }).sort();

  if (oa.realm) {
    params.splice(0, 0, 'realm');
  }
  params.push('oauth_signature');

  return params.map(function (i) {
    return i + '=' + wrap + oauthSign.rfc3986(oa[i]) + wrap
  }).join(sep)
};

OAuth$1.prototype.onRequest = function (_oauth) {
  var self = this;
  self.params = _oauth;

  var uri = self.request.uri || {};
  var method = self.request.method || '';
  var headers = caseless(self.request.headers);
  var body = self.request.body || '';
  var qsLib = self.request.qsLib || lib$c;

  var form;
  var query;
  var contentType = headers.get('content-type') || '';
  var formContentType = 'application/x-www-form-urlencoded';
  var transport = _oauth.transport_method || 'header';

  if (contentType.slice(0, formContentType.length) === formContentType) {
    contentType = formContentType;
    form = body;
  }
  if (uri.query) {
    query = uri.query;
  }
  if (transport === 'body' && (method !== 'POST' || contentType !== formContentType)) {
    self.request.emit('error', new Error('oauth: transport_method of body requires POST ' +
      'and content-type ' + formContentType));
  }

  if (!form && typeof _oauth.body_hash === 'boolean') {
    _oauth.body_hash = self.buildBodyHash(_oauth, self.request.body.toString());
  }

  var oa = self.buildParams(_oauth, uri, method, query, form, qsLib);

  switch (transport) {
    case 'header':
      self.request.setHeader('Authorization', 'OAuth ' + self.concatParams(oa, ',', '"'));
      break

    case 'query':
      var href = self.request.uri.href += (query ? '&' : '?') + self.concatParams(oa, '&');
      self.request.uri = url.parse(href);
      self.request.path = self.request.uri.path;
      break

    case 'body':
      self.request.body = (form ? form + '&' : '') + self.concatParams(oa, '&');
      break

    default:
      self.request.emit('error', new Error('oauth: transport_method invalid'));
  }
};

var OAuth_1 = OAuth$1;

var oauth_1 = {
	OAuth: OAuth_1
};

var hawk = createCommonjsModule(function (module, exports) {



function randomString (size) {
  var bits = (size + 1) * 6;
  var buffer = crypto$1.randomBytes(Math.ceil(bits / 8));
  var string = buffer.toString('base64').replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
  return string.slice(0, size)
}

function calculatePayloadHash (payload, algorithm, contentType) {
  var hash = crypto$1.createHash(algorithm);
  hash.update('hawk.1.payload\n');
  hash.update((contentType ? contentType.split(';')[0].trim().toLowerCase() : '') + '\n');
  hash.update(payload || '');
  hash.update('\n');
  return hash.digest('base64')
}

exports.calculateMac = function (credentials, opts) {
  var normalized = 'hawk.1.header\n' +
    opts.ts + '\n' +
    opts.nonce + '\n' +
    (opts.method || '').toUpperCase() + '\n' +
    opts.resource + '\n' +
    opts.host.toLowerCase() + '\n' +
    opts.port + '\n' +
    (opts.hash || '') + '\n';

  if (opts.ext) {
    normalized = normalized + opts.ext.replace('\\', '\\\\').replace('\n', '\\n');
  }

  normalized = normalized + '\n';

  if (opts.app) {
    normalized = normalized + opts.app + '\n' + (opts.dlg || '') + '\n';
  }

  var hmac = crypto$1.createHmac(credentials.algorithm, credentials.key).update(normalized);
  var digest = hmac.digest('base64');
  return digest
};

exports.header = function (uri, method, opts) {
  var timestamp = opts.timestamp || Math.floor((Date.now() + (opts.localtimeOffsetMsec || 0)) / 1000);
  var credentials = opts.credentials;
  if (!credentials || !credentials.id || !credentials.key || !credentials.algorithm) {
    return ''
  }

  if (['sha1', 'sha256'].indexOf(credentials.algorithm) === -1) {
    return ''
  }

  var artifacts = {
    ts: timestamp,
    nonce: opts.nonce || randomString(6),
    method: method,
    resource: uri.pathname + (uri.search || ''),
    host: uri.hostname,
    port: uri.port || (uri.protocol === 'http:' ? 80 : 443),
    hash: opts.hash,
    ext: opts.ext,
    app: opts.app,
    dlg: opts.dlg
  };

  if (!artifacts.hash && (opts.payload || opts.payload === '')) {
    artifacts.hash = calculatePayloadHash(opts.payload, credentials.algorithm, opts.contentType);
  }

  var mac = exports.calculateMac(credentials, artifacts);

  var hasExt = artifacts.ext !== null && artifacts.ext !== undefined && artifacts.ext !== '';
  var header = 'Hawk id="' + credentials.id +
    '", ts="' + artifacts.ts +
    '", nonce="' + artifacts.nonce +
    (artifacts.hash ? '", hash="' + artifacts.hash : '') +
    (hasExt ? '", ext="' + artifacts.ext.replace(/\\/g, '\\\\').replace(/"/g, '\\"') : '') +
    '", mac="' + mac + '"';

  if (artifacts.app) {
    header = header + ', app="' + artifacts.app + (artifacts.dlg ? '", dlg="' + artifacts.dlg : '') + '"';
  }

  return header
};
});

var Stream$1 = stream.Stream;


var delayed_stream = DelayedStream;
function DelayedStream() {
  this.source = null;
  this.dataSize = 0;
  this.maxDataSize = 1024 * 1024;
  this.pauseStream = true;

  this._maxDataSizeExceeded = false;
  this._released = false;
  this._bufferedEvents = [];
}
util$2.inherits(DelayedStream, Stream$1);

DelayedStream.create = function(source, options) {
  var delayedStream = new this();

  options = options || {};
  for (var option in options) {
    delayedStream[option] = options[option];
  }

  delayedStream.source = source;

  var realEmit = source.emit;
  source.emit = function() {
    delayedStream._handleEmit(arguments);
    return realEmit.apply(source, arguments);
  };

  source.on('error', function() {});
  if (delayedStream.pauseStream) {
    source.pause();
  }

  return delayedStream;
};

Object.defineProperty(DelayedStream.prototype, 'readable', {
  configurable: true,
  enumerable: true,
  get: function() {
    return this.source.readable;
  }
});

DelayedStream.prototype.setEncoding = function() {
  return this.source.setEncoding.apply(this.source, arguments);
};

DelayedStream.prototype.resume = function() {
  if (!this._released) {
    this.release();
  }

  this.source.resume();
};

DelayedStream.prototype.pause = function() {
  this.source.pause();
};

DelayedStream.prototype.release = function() {
  this._released = true;

  this._bufferedEvents.forEach(function(args) {
    this.emit.apply(this, args);
  }.bind(this));
  this._bufferedEvents = [];
};

DelayedStream.prototype.pipe = function() {
  var r = Stream$1.prototype.pipe.apply(this, arguments);
  this.resume();
  return r;
};

DelayedStream.prototype._handleEmit = function(args) {
  if (this._released) {
    this.emit.apply(this, args);
    return;
  }

  if (args[0] === 'data') {
    this.dataSize += args[1].length;
    this._checkIfMaxDataSizeExceeded();
  }

  this._bufferedEvents.push(args);
};

DelayedStream.prototype._checkIfMaxDataSizeExceeded = function() {
  if (this._maxDataSizeExceeded) {
    return;
  }

  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  this._maxDataSizeExceeded = true;
  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this.emit('error', new Error(message));
};

var Stream = stream.Stream;


var combined_stream = CombinedStream;
function CombinedStream() {
  this.writable = false;
  this.readable = true;
  this.dataSize = 0;
  this.maxDataSize = 2 * 1024 * 1024;
  this.pauseStreams = true;

  this._released = false;
  this._streams = [];
  this._currentStream = null;
  this._insideLoop = false;
  this._pendingNext = false;
}
util$2.inherits(CombinedStream, Stream);

CombinedStream.create = function(options) {
  var combinedStream = new this();

  options = options || {};
  for (var option in options) {
    combinedStream[option] = options[option];
  }

  return combinedStream;
};

CombinedStream.isStreamLike = function(stream) {
  return (typeof stream !== 'function')
    && (typeof stream !== 'string')
    && (typeof stream !== 'boolean')
    && (typeof stream !== 'number')
    && (!Buffer.isBuffer(stream));
};

CombinedStream.prototype.append = function(stream) {
  var isStreamLike = CombinedStream.isStreamLike(stream);

  if (isStreamLike) {
    if (!(stream instanceof delayed_stream)) {
      var newStream = delayed_stream.create(stream, {
        maxDataSize: Infinity,
        pauseStream: this.pauseStreams,
      });
      stream.on('data', this._checkDataSize.bind(this));
      stream = newStream;
    }

    this._handleErrors(stream);

    if (this.pauseStreams) {
      stream.pause();
    }
  }

  this._streams.push(stream);
  return this;
};

CombinedStream.prototype.pipe = function(dest, options) {
  Stream.prototype.pipe.call(this, dest, options);
  this.resume();
  return dest;
};

CombinedStream.prototype._getNext = function() {
  this._currentStream = null;

  if (this._insideLoop) {
    this._pendingNext = true;
    return; // defer call
  }

  this._insideLoop = true;
  try {
    do {
      this._pendingNext = false;
      this._realGetNext();
    } while (this._pendingNext);
  } finally {
    this._insideLoop = false;
  }
};

CombinedStream.prototype._realGetNext = function() {
  var stream = this._streams.shift();


  if (typeof stream == 'undefined') {
    this.end();
    return;
  }

  if (typeof stream !== 'function') {
    this._pipeNext(stream);
    return;
  }

  var getStream = stream;
  getStream(function(stream) {
    var isStreamLike = CombinedStream.isStreamLike(stream);
    if (isStreamLike) {
      stream.on('data', this._checkDataSize.bind(this));
      this._handleErrors(stream);
    }

    this._pipeNext(stream);
  }.bind(this));
};

CombinedStream.prototype._pipeNext = function(stream) {
  this._currentStream = stream;

  var isStreamLike = CombinedStream.isStreamLike(stream);
  if (isStreamLike) {
    stream.on('end', this._getNext.bind(this));
    stream.pipe(this, {end: false});
    return;
  }

  var value = stream;
  this.write(value);
  this._getNext();
};

CombinedStream.prototype._handleErrors = function(stream) {
  var self = this;
  stream.on('error', function(err) {
    self._emitError(err);
  });
};

CombinedStream.prototype.write = function(data) {
  this.emit('data', data);
};

CombinedStream.prototype.pause = function() {
  if (!this.pauseStreams) {
    return;
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.pause) == 'function') this._currentStream.pause();
  this.emit('pause');
};

CombinedStream.prototype.resume = function() {
  if (!this._released) {
    this._released = true;
    this.writable = true;
    this._getNext();
  }

  if(this.pauseStreams && this._currentStream && typeof(this._currentStream.resume) == 'function') this._currentStream.resume();
  this.emit('resume');
};

CombinedStream.prototype.end = function() {
  this._reset();
  this.emit('end');
};

CombinedStream.prototype.destroy = function() {
  this._reset();
  this.emit('close');
};

CombinedStream.prototype._reset = function() {
  this.writable = false;
  this._streams = [];
  this._currentStream = null;
};

CombinedStream.prototype._checkDataSize = function() {
  this._updateDataSize();
  if (this.dataSize <= this.maxDataSize) {
    return;
  }

  var message =
    'DelayedStream#maxDataSize of ' + this.maxDataSize + ' bytes exceeded.';
  this._emitError(new Error(message));
};

CombinedStream.prototype._updateDataSize = function() {
  this.dataSize = 0;

  var self = this;
  this._streams.forEach(function(stream) {
    if (!stream.dataSize) {
      return;
    }

    self.dataSize += stream.dataSize;
  });

  if (this._currentStream && this._currentStream.dataSize) {
    this.dataSize += this._currentStream.dataSize;
  }
};

CombinedStream.prototype._emitError = function(err) {
  this._reset();
  this.emit('error', err);
};

var Buffer$3 = safeBuffer.Buffer;

function Multipart$1 (request) {
  this.request = request;
  this.boundary = v4_1();
  this.chunked = false;
  this.body = null;
}

Multipart$1.prototype.isChunked = function (options) {
  var self = this;
  var chunked = false;
  var parts = options.data || options;

  if (!parts.forEach) {
    self.request.emit('error', new Error('Argument error, options.multipart.'));
  }

  if (options.chunked !== undefined) {
    chunked = options.chunked;
  }

  if (self.request.getHeader('transfer-encoding') === 'chunked') {
    chunked = true;
  }

  if (!chunked) {
    parts.forEach(function (part) {
      if (typeof part.body === 'undefined') {
        self.request.emit('error', new Error('Body attribute missing in multipart.'));
      }
      if (isstream(part.body)) {
        chunked = true;
      }
    });
  }

  return chunked
};

Multipart$1.prototype.setHeaders = function (chunked) {
  var self = this;

  if (chunked && !self.request.hasHeader('transfer-encoding')) {
    self.request.setHeader('transfer-encoding', 'chunked');
  }

  var header = self.request.getHeader('content-type');

  if (!header || header.indexOf('multipart') === -1) {
    self.request.setHeader('content-type', 'multipart/related; boundary=' + self.boundary);
  } else {
    if (header.indexOf('boundary') !== -1) {
      self.boundary = header.replace(/.*boundary=([^\s;]+).*/, '$1');
    } else {
      self.request.setHeader('content-type', header + '; boundary=' + self.boundary);
    }
  }
};

Multipart$1.prototype.build = function (parts, chunked) {
  var self = this;
  var body = chunked ? new combined_stream() : [];

  function add (part) {
    if (typeof part === 'number') {
      part = part.toString();
    }
    return chunked ? body.append(part) : body.push(Buffer$3.from(part))
  }

  if (self.request.preambleCRLF) {
    add('\r\n');
  }

  parts.forEach(function (part) {
    var preamble = '--' + self.boundary + '\r\n';
    Object.keys(part).forEach(function (key) {
      if (key === 'body') { return }
      preamble += key + ': ' + part[key] + '\r\n';
    });
    preamble += '\r\n';
    add(preamble);
    add(part.body);
    add('\r\n');
  });
  add('--' + self.boundary + '--');

  if (self.request.postambleCRLF) {
    add('\r\n');
  }

  return body
};

Multipart$1.prototype.onRequest = function (options) {
  var self = this;

  var chunked = self.isChunked(options);
  var parts = options.data || options;

  self.setHeaders(chunked);
  self.chunked = chunked;
  self.body = self.build(parts, chunked);
};

var Multipart_1 = Multipart$1;

var multipart = {
	Multipart: Multipart_1
};

var isUrl = /^https?:/;

function Redirect$1 (request) {
  this.request = request;
  this.followRedirect = true;
  this.followRedirects = true;
  this.followAllRedirects = false;
  this.followOriginalHttpMethod = false;
  this.allowRedirect = function () { return true };
  this.maxRedirects = 10;
  this.redirects = [];
  this.redirectsFollowed = 0;
  this.removeRefererHeader = false;
}

Redirect$1.prototype.onRequest = function (options) {
  var self = this;

  if (options.maxRedirects !== undefined) {
    self.maxRedirects = options.maxRedirects;
  }
  if (typeof options.followRedirect === 'function') {
    self.allowRedirect = options.followRedirect;
  }
  if (options.followRedirect !== undefined) {
    self.followRedirects = !!options.followRedirect;
  }
  if (options.followAllRedirects !== undefined) {
    self.followAllRedirects = options.followAllRedirects;
  }
  if (self.followRedirects || self.followAllRedirects) {
    self.redirects = self.redirects || [];
  }
  if (options.removeRefererHeader !== undefined) {
    self.removeRefererHeader = options.removeRefererHeader;
  }
  if (options.followOriginalHttpMethod !== undefined) {
    self.followOriginalHttpMethod = options.followOriginalHttpMethod;
  }
};

Redirect$1.prototype.redirectTo = function (response) {
  var self = this;
  var request = self.request;

  var redirectTo = null;
  if (response.statusCode >= 300 && response.statusCode < 400 && response.caseless.has('location')) {
    var location = response.caseless.get('location');
    request.debug('redirect', location);

    if (self.followAllRedirects) {
      redirectTo = location;
    } else if (self.followRedirects) {
      switch (request.method) {
        case 'PATCH':
        case 'PUT':
        case 'POST':
        case 'DELETE':
          // Do not follow redirects
          break
        default:
          redirectTo = location;
          break
      }
    }
  } else if (response.statusCode === 401) {
    var authHeader = request._auth.onResponse(response);
    if (authHeader) {
      request.setHeader('authorization', authHeader);
      redirectTo = request.uri;
    }
  }
  return redirectTo
};

Redirect$1.prototype.onResponse = function (response) {
  var self = this;
  var request = self.request;

  var redirectTo = self.redirectTo(response);
  if (!redirectTo || !self.allowRedirect.call(request, response)) {
    return false
  }

  request.debug('redirect to', redirectTo);

  // ignore any potential response body.  it cannot possibly be useful
  // to us at this point.
  // response.resume should be defined, but check anyway before calling. Workaround for browserify.
  if (response.resume) {
    response.resume();
  }

  if (self.redirectsFollowed >= self.maxRedirects) {
    request.emit('error', new Error('Exceeded maxRedirects. Probably stuck in a redirect loop ' + request.uri.href));
    return false
  }
  self.redirectsFollowed += 1;

  if (!isUrl.test(redirectTo)) {
    redirectTo = url.resolve(request.uri.href, redirectTo);
  }

  var uriPrev = request.uri;
  request.uri = url.parse(redirectTo);

  // handle the case where we change protocol from https to http or vice versa
  if (request.uri.protocol !== uriPrev.protocol) {
    delete request.agent;
  }

  self.redirects.push({ statusCode: response.statusCode, redirectUri: redirectTo });

  if (self.followAllRedirects && request.method !== 'HEAD' &&
    response.statusCode !== 401 && response.statusCode !== 307) {
    request.method = self.followOriginalHttpMethod ? request.method : 'GET';
  }
  // request.method = 'GET' // Force all redirects to use GET || commented out fixes #215
  delete request.src;
  delete request.req;
  delete request._started;
  if (response.statusCode !== 401 && response.statusCode !== 307) {
    // Remove parameters from the previous response, unless this is the second request
    // for a server that requires digest authentication.
    delete request.body;
    delete request._form;
    if (request.headers) {
      request.removeHeader('host');
      request.removeHeader('content-type');
      request.removeHeader('content-length');
      if (request.uri.hostname !== request.originalHost.split(':')[0]) {
        // Remove authorization if changing hostnames (but not if just
        // changing ports or protocols).  This matches the behavior of curl:
        // https://github.com/bagder/curl/blob/6beb0eee/lib/http.c#L710
        request.removeHeader('authorization');
      }
    }
  }

  if (!self.removeRefererHeader) {
    request.setHeader('referer', uriPrev.href);
  }

  request.emit('redirect');

  request.init();

  return true
};

var Redirect_1 = Redirect$1;

var redirect = {
	Redirect: Redirect_1
};

var Buffer$2 = safeBuffer.Buffer
  ;

var httpOverHttp_1 = httpOverHttp;
var httpsOverHttp_1 = httpsOverHttp;
var httpOverHttps_1 = httpOverHttps;
var httpsOverHttps_1 = httpsOverHttps;


function httpOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  return agent
}

function httpsOverHttp(options) {
  var agent = new TunnelingAgent(options);
  agent.request = http.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent
}

function httpOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  return agent
}

function httpsOverHttps(options) {
  var agent = new TunnelingAgent(options);
  agent.request = https.request;
  agent.createSocket = createSecureSocket;
  agent.defaultPort = 443;
  return agent
}


function TunnelingAgent(options) {
  var self = this;
  self.options = options || {};
  self.proxyOptions = self.options.proxy || {};
  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;
  self.requests = [];
  self.sockets = [];

  self.on('free', function onFree(socket, host, port) {
    for (var i = 0, len = self.requests.length; i < len; ++i) {
      var pending = self.requests[i];
      if (pending.host === host && pending.port === port) {
        // Detect the request to connect same origin server,
        // reuse the connection.
        self.requests.splice(i, 1);
        pending.request.onSocket(socket);
        return
      }
    }
    socket.destroy();
    self.removeSocket(socket);
  });
}
util$2.inherits(TunnelingAgent, events.EventEmitter);

TunnelingAgent.prototype.addRequest = function addRequest(req, options) {
  var self = this;

   // Legacy API: addRequest(req, host, port, path)
  if (typeof options === 'string') {
    options = {
      host: options,
      port: arguments[2],
      path: arguments[3]
    };
  }

  if (self.sockets.length >= this.maxSockets) {
    // We are over limit so we'll add it to the queue.
    self.requests.push({host: options.host, port: options.port, request: req});
    return
  }

  // If we are under maxSockets create a new one.
  self.createConnection({host: options.host, port: options.port, request: req});
};

TunnelingAgent.prototype.createConnection = function createConnection(pending) {
  var self = this;

  self.createSocket(pending, function(socket) {
    socket.on('free', onFree);
    socket.on('close', onCloseOrRemove);
    socket.on('agentRemove', onCloseOrRemove);
    pending.request.onSocket(socket);

    function onFree() {
      self.emit('free', socket, pending.host, pending.port);
    }

    function onCloseOrRemove(err) {
      self.removeSocket(socket);
      socket.removeListener('free', onFree);
      socket.removeListener('close', onCloseOrRemove);
      socket.removeListener('agentRemove', onCloseOrRemove);
    }
  });
};

TunnelingAgent.prototype.createSocket = function createSocket(options, cb) {
  var self = this;
  var placeholder = {};
  self.sockets.push(placeholder);

  var connectOptions = mergeOptions({}, self.proxyOptions,
    { method: 'CONNECT'
    , path: options.host + ':' + options.port
    , agent: false
    }
  );
  if (connectOptions.proxyAuth) {
    connectOptions.headers = connectOptions.headers || {};
    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +
        Buffer$2.from(connectOptions.proxyAuth).toString('base64');
  }

  debug$3('making CONNECT request');
  var connectReq = self.request(connectOptions);
  connectReq.useChunkedEncodingByDefault = false; // for v0.6
  connectReq.once('response', onResponse); // for v0.6
  connectReq.once('upgrade', onUpgrade);   // for v0.6
  connectReq.once('connect', onConnect);   // for v0.7 or later
  connectReq.once('error', onError);
  connectReq.end();

  function onResponse(res) {
    // Very hacky. This is necessary to avoid http-parser leaks.
    res.upgrade = true;
  }

  function onUpgrade(res, socket, head) {
    // Hacky.
    process.nextTick(function() {
      onConnect(res, socket, head);
    });
  }

  function onConnect(res, socket, head) {
    connectReq.removeAllListeners();
    socket.removeAllListeners();

    if (res.statusCode === 200) {
      assert.equal(head.length, 0);
      debug$3('tunneling connection has established');
      self.sockets[self.sockets.indexOf(placeholder)] = socket;
      cb(socket);
    } else {
      debug$3('tunneling socket could not be established, statusCode=%d', res.statusCode);
      var error = new Error('tunneling socket could not be established, ' + 'statusCode=' + res.statusCode);
      error.code = 'ECONNRESET';
      options.request.emit('error', error);
      self.removeSocket(placeholder);
    }
  }

  function onError(cause) {
    connectReq.removeAllListeners();

    debug$3('tunneling socket could not be established, cause=%s\n', cause.message, cause.stack);
    var error = new Error('tunneling socket could not be established, ' + 'cause=' + cause.message);
    error.code = 'ECONNRESET';
    options.request.emit('error', error);
    self.removeSocket(placeholder);
  }
};

TunnelingAgent.prototype.removeSocket = function removeSocket(socket) {
  var pos = this.sockets.indexOf(socket);
  if (pos === -1) return

  this.sockets.splice(pos, 1);

  var pending = this.requests.shift();
  if (pending) {
    // If we have pending requests and a socket gets closed a new one
    // needs to be created to take over in the pool for the one that closed.
    this.createConnection(pending);
  }
};

function createSecureSocket(options, cb) {
  var self = this;
  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {
    // 0 is dummy port for v0.6
    var secureSocket = tls.connect(0, mergeOptions({}, self.options,
      { servername: options.host
      , socket: socket
      }
    ));
    self.sockets[self.sockets.indexOf(socket)] = secureSocket;
    cb(secureSocket);
  });
}


function mergeOptions(target) {
  for (var i = 1, len = arguments.length; i < len; ++i) {
    var overrides = arguments[i];
    if (typeof overrides === 'object') {
      var keys = Object.keys(overrides);
      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {
        var k = keys[j];
        if (overrides[k] !== undefined) {
          target[k] = overrides[k];
        }
      }
    }
  }
  return target
}


var debug$3;
if (process.env.NODE_DEBUG && /\btunnel\b/.test(process.env.NODE_DEBUG)) {
  debug$3 = function() {
    var args = Array.prototype.slice.call(arguments);
    if (typeof args[0] === 'string') {
      args[0] = 'TUNNEL: ' + args[0];
    } else {
      args.unshift('TUNNEL:');
    }
    console.error.apply(console, args);
  };
} else {
  debug$3 = function() {};
}
var debug_1 = debug$3; // for test

var tunnelAgent = {
	httpOverHttp: httpOverHttp_1,
	httpsOverHttp: httpsOverHttp_1,
	httpOverHttps: httpOverHttps_1,
	httpsOverHttps: httpsOverHttps_1,
	debug: debug_1
};

var defaultProxyHeaderWhiteList = [
  'accept',
  'accept-charset',
  'accept-encoding',
  'accept-language',
  'accept-ranges',
  'cache-control',
  'content-encoding',
  'content-language',
  'content-location',
  'content-md5',
  'content-range',
  'content-type',
  'connection',
  'date',
  'expect',
  'max-forwards',
  'pragma',
  'referer',
  'te',
  'user-agent',
  'via'
];

var defaultProxyHeaderExclusiveList = [
  'proxy-authorization'
];

function constructProxyHost (uriObject) {
  var port = uriObject.port;
  var protocol = uriObject.protocol;
  var proxyHost = uriObject.hostname + ':';

  if (port) {
    proxyHost += port;
  } else if (protocol === 'https:') {
    proxyHost += '443';
  } else {
    proxyHost += '80';
  }

  return proxyHost
}

function constructProxyHeaderWhiteList (headers, proxyHeaderWhiteList) {
  var whiteList = proxyHeaderWhiteList
    .reduce(function (set, header) {
      set[header.toLowerCase()] = true;
      return set
    }, {});

  return Object.keys(headers)
    .filter(function (header) {
      return whiteList[header.toLowerCase()]
    })
    .reduce(function (set, header) {
      set[header] = headers[header];
      return set
    }, {})
}

function constructTunnelOptions (request, proxyHeaders) {
  var proxy = request.proxy;

  var tunnelOptions = {
    proxy: {
      host: proxy.hostname,
      port: +proxy.port,
      proxyAuth: proxy.auth,
      headers: proxyHeaders
    },
    headers: request.headers,
    ca: request.ca,
    cert: request.cert,
    key: request.key,
    passphrase: request.passphrase,
    pfx: request.pfx,
    ciphers: request.ciphers,
    rejectUnauthorized: request.rejectUnauthorized,
    secureOptions: request.secureOptions,
    secureProtocol: request.secureProtocol
  };

  return tunnelOptions
}

function constructTunnelFnName (uri, proxy) {
  var uriProtocol = (uri.protocol === 'https:' ? 'https' : 'http');
  var proxyProtocol = (proxy.protocol === 'https:' ? 'Https' : 'Http');
  return [uriProtocol, proxyProtocol].join('Over')
}

function getTunnelFn (request) {
  var uri = request.uri;
  var proxy = request.proxy;
  var tunnelFnName = constructTunnelFnName(uri, proxy);
  return tunnelAgent[tunnelFnName]
}

function Tunnel$1 (request) {
  this.request = request;
  this.proxyHeaderWhiteList = defaultProxyHeaderWhiteList;
  this.proxyHeaderExclusiveList = [];
  if (typeof request.tunnel !== 'undefined') {
    this.tunnelOverride = request.tunnel;
  }
}

Tunnel$1.prototype.isEnabled = function () {
  var self = this;
  var request = self.request;
    // Tunnel HTTPS by default. Allow the user to override this setting.

  // If self.tunnelOverride is set (the user specified a value), use it.
  if (typeof self.tunnelOverride !== 'undefined') {
    return self.tunnelOverride
  }

  // If the destination is HTTPS, tunnel.
  if (request.uri.protocol === 'https:') {
    return true
  }

  // Otherwise, do not use tunnel.
  return false
};

Tunnel$1.prototype.setup = function (options) {
  var self = this;
  var request = self.request;

  options = options || {};

  if (typeof request.proxy === 'string') {
    request.proxy = url.parse(request.proxy);
  }

  if (!request.proxy || !request.tunnel) {
    return false
  }

  // Setup Proxy Header Exclusive List and White List
  if (options.proxyHeaderWhiteList) {
    self.proxyHeaderWhiteList = options.proxyHeaderWhiteList;
  }
  if (options.proxyHeaderExclusiveList) {
    self.proxyHeaderExclusiveList = options.proxyHeaderExclusiveList;
  }

  var proxyHeaderExclusiveList = self.proxyHeaderExclusiveList.concat(defaultProxyHeaderExclusiveList);
  var proxyHeaderWhiteList = self.proxyHeaderWhiteList.concat(proxyHeaderExclusiveList);

  // Setup Proxy Headers and Proxy Headers Host
  // Only send the Proxy White Listed Header names
  var proxyHeaders = constructProxyHeaderWhiteList(request.headers, proxyHeaderWhiteList);
  proxyHeaders.host = constructProxyHost(request.uri);

  proxyHeaderExclusiveList.forEach(request.removeHeader, request);

  // Set Agent from Tunnel Data
  var tunnelFn = getTunnelFn(request);
  var tunnelOptions = constructTunnelOptions(request, proxyHeaders);
  request.agent = tunnelFn(tunnelOptions);

  return true
};

Tunnel$1.defaultProxyHeaderWhiteList = defaultProxyHeaderWhiteList;
Tunnel$1.defaultProxyHeaderExclusiveList = defaultProxyHeaderExclusiveList;
var Tunnel_1 = Tunnel$1;

var tunnel_1 = {
	Tunnel: Tunnel_1
};

var performanceNow = createCommonjsModule(function (module) {
// Generated by CoffeeScript 1.12.2
(function() {
  var getNanoSeconds, hrtime, loadTime, moduleLoadTime, nodeLoadTime, upTime;

  if ((typeof performance !== "undefined" && performance !== null) && performance.now) {
    module.exports = function() {
      return performance.now();
    };
  } else if ((typeof process !== "undefined" && process !== null) && process.hrtime) {
    module.exports = function() {
      return (getNanoSeconds() - nodeLoadTime) / 1e6;
    };
    hrtime = process.hrtime;
    getNanoSeconds = function() {
      var hr;
      hr = hrtime();
      return hr[0] * 1e9 + hr[1];
    };
    moduleLoadTime = getNanoSeconds();
    upTime = process.uptime() * 1e9;
    nodeLoadTime = moduleLoadTime - upTime;
  } else if (Date.now) {
    module.exports = function() {
      return Date.now() - loadTime;
    };
    loadTime = Date.now();
  } else {
    module.exports = function() {
      return new Date().getTime() - loadTime;
    };
    loadTime = new Date().getTime();
  }

}).call(commonjsGlobal);


});

var isTypedArray = isTypedarray.strict;

var cookies = cookies$1;

var Querystring = querystring_1.Querystring;
var Har = har.Har;
var Auth = auth.Auth;
var OAuth = oauth_1.OAuth;

var Multipart = multipart.Multipart;
var Redirect = redirect.Redirect;
var Tunnel = tunnel_1.Tunnel;

var Buffer$1 = safeBuffer.Buffer;

var safeStringify = helpers.safeStringify;
var isReadStream = helpers.isReadStream;
var toBase64 = helpers.toBase64;
var defer = helpers.defer;
var copy = helpers.copy;
var version = helpers.version;
var globalCookieJar = cookies.jar();

var globalPool = {};

function filterForNonReserved (reserved, options) {
  // Filter out properties that are not reserved.
  // Reserved values are passed in at call site.

  var object = {};
  for (var i in options) {
    var notReserved = (reserved.indexOf(i) === -1);
    if (notReserved) {
      object[i] = options[i];
    }
  }
  return object
}

function filterOutReservedFunctions (reserved, options) {
  // Filter out properties that are functions and are reserved.
  // Reserved values are passed in at call site.

  var object = {};
  for (var i in options) {
    var isReserved = !(reserved.indexOf(i) === -1);
    var isFunction = (typeof options[i] === 'function');
    if (!(isReserved && isFunction)) {
      object[i] = options[i];
    }
  }
  return object
}

// Return a simpler request object to allow serialization
function requestToJSON () {
  var self = this;
  return {
    uri: self.uri,
    method: self.method,
    headers: self.headers
  }
}

// Return a simpler response object to allow serialization
function responseToJSON () {
  var self = this;
  return {
    statusCode: self.statusCode,
    body: self.body,
    headers: self.headers,
    request: requestToJSON.call(self.request)
  }
}

function Request (options) {
  // if given the method property in options, set property explicitMethod to true

  // extend the Request instance with any non-reserved properties
  // remove any reserved functions from the options object
  // set Request instance to be readable and writable
  // call init

  var self = this;

  // start with HAR, then override with additional options
  if (options.har) {
    self._har = new Har(self);
    options = self._har.options(options);
  }

  stream.Stream.call(self);
  var reserved = Object.keys(Request.prototype);
  var nonReserved = filterForNonReserved(reserved, options);

  extend(self, nonReserved);
  options = filterOutReservedFunctions(reserved, options);

  self.readable = true;
  self.writable = true;
  if (options.method) {
    self.explicitMethod = true;
  }
  self._qs = new Querystring(self);
  self._auth = new Auth(self);
  self._oauth = new OAuth(self);
  self._multipart = new Multipart(self);
  self._redirect = new Redirect(self);
  self._tunnel = new Tunnel(self);
  self.init(options);
}

util$2.inherits(Request, stream.Stream);

// Debugging
Request.debug = process.env.NODE_DEBUG && /\brequest\b/.test(process.env.NODE_DEBUG);
function debug$2 () {
  if (Request.debug) {
    console.error('REQUEST %s', util$2.format.apply(util$2, arguments));
  }
}
Request.prototype.debug = debug$2;

Request.prototype.init = function (options) {
  // init() contains all the code to setup the request object.
  // the actual outgoing request is not started until start() is called
  // this function is called from both the constructor and on redirect.
  var self = this;
  if (!options) {
    options = {};
  }
  self.headers = self.headers ? copy(self.headers) : {};

  // Delete headers with value undefined since they break
  // ClientRequest.OutgoingMessage.setHeader in node 0.12
  for (var headerName in self.headers) {
    if (typeof self.headers[headerName] === 'undefined') {
      delete self.headers[headerName];
    }
  }

  caseless.httpify(self, self.headers);

  if (!self.method) {
    self.method = options.method || 'GET';
  }
  if (!self.localAddress) {
    self.localAddress = options.localAddress;
  }

  self._qs.init(options);

  debug$2(options);
  if (!self.pool && self.pool !== false) {
    self.pool = globalPool;
  }
  self.dests = self.dests || [];
  self.__isRequestRequest = true;

  // Protect against double callback
  if (!self._callback && self.callback) {
    self._callback = self.callback;
    self.callback = function () {
      if (self._callbackCalled) {
        return // Print a warning maybe?
      }
      self._callbackCalled = true;
      self._callback.apply(self, arguments);
    };
    self.on('error', self.callback.bind());
    self.on('complete', self.callback.bind(self, null));
  }

  // People use this property instead all the time, so support it
  if (!self.uri && self.url) {
    self.uri = self.url;
    delete self.url;
  }

  // If there's a baseUrl, then use it as the base URL (i.e. uri must be
  // specified as a relative path and is appended to baseUrl).
  if (self.baseUrl) {
    if (typeof self.baseUrl !== 'string') {
      return self.emit('error', new Error('options.baseUrl must be a string'))
    }

    if (typeof self.uri !== 'string') {
      return self.emit('error', new Error('options.uri must be a string when using options.baseUrl'))
    }

    if (self.uri.indexOf('//') === 0 || self.uri.indexOf('://') !== -1) {
      return self.emit('error', new Error('options.uri must be a path when using options.baseUrl'))
    }

    // Handle all cases to make sure that there's only one slash between
    // baseUrl and uri.
    var baseUrlEndsWithSlash = self.baseUrl.lastIndexOf('/') === self.baseUrl.length - 1;
    var uriStartsWithSlash = self.uri.indexOf('/') === 0;

    if (baseUrlEndsWithSlash && uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri.slice(1);
    } else if (baseUrlEndsWithSlash || uriStartsWithSlash) {
      self.uri = self.baseUrl + self.uri;
    } else if (self.uri === '') {
      self.uri = self.baseUrl;
    } else {
      self.uri = self.baseUrl + '/' + self.uri;
    }
    delete self.baseUrl;
  }

  // A URI is needed by this point, emit error if we haven't been able to get one
  if (!self.uri) {
    return self.emit('error', new Error('options.uri is a required argument'))
  }

  // If a string URI/URL was given, parse it into a URL object
  if (typeof self.uri === 'string') {
    self.uri = url.parse(self.uri);
  }

  // Some URL objects are not from a URL parsed string and need href added
  if (!self.uri.href) {
    self.uri.href = url.format(self.uri);
  }

  // DEPRECATED: Warning for users of the old Unix Sockets URL Scheme
  if (self.uri.protocol === 'unix:') {
    return self.emit('error', new Error('`unix://` URL scheme is no longer supported. Please use the format `http://unix:SOCKET:PATH`'))
  }

  // Support Unix Sockets
  if (self.uri.host === 'unix') {
    self.enableUnixSocket();
  }

  if (self.strictSSL === false) {
    self.rejectUnauthorized = false;
  }

  if (!self.uri.pathname) { self.uri.pathname = '/'; }

  if (!(self.uri.host || (self.uri.hostname && self.uri.port)) && !self.uri.isUnix) {
    // Invalid URI: it may generate lot of bad errors, like 'TypeError: Cannot call method `indexOf` of undefined' in CookieJar
    // Detect and reject it as soon as possible
    var faultyUri = url.format(self.uri);
    var message = 'Invalid URI "' + faultyUri + '"';
    if (Object.keys(options).length === 0) {
      // No option ? This can be the sign of a redirect
      // As this is a case where the user cannot do anything (they didn't call request directly with this URL)
      // they should be warned that it can be caused by a redirection (can save some hair)
      message += '. This can be caused by a crappy redirection.';
    }
    // This error was fatal
    self.abort();
    return self.emit('error', new Error(message))
  }

  if (!self.hasOwnProperty('proxy')) {
    self.proxy = getProxyFromURI_1(self.uri);
  }

  self.tunnel = self._tunnel.isEnabled();
  if (self.proxy) {
    self._tunnel.setup(options);
  }

  self._redirect.onRequest(options);

  self.setHost = false;
  if (!self.hasHeader('host')) {
    var hostHeaderName = self.originalHostHeaderName || 'host';
    self.setHeader(hostHeaderName, self.uri.host);
    // Drop :port suffix from Host header if known protocol.
    if (self.uri.port) {
      if ((self.uri.port === '80' && self.uri.protocol === 'http:') ||
          (self.uri.port === '443' && self.uri.protocol === 'https:')) {
        self.setHeader(hostHeaderName, self.uri.hostname);
      }
    }
    self.setHost = true;
  }

  self.jar(self._jar || options.jar);

  if (!self.uri.port) {
    if (self.uri.protocol === 'http:') { self.uri.port = 80; } else if (self.uri.protocol === 'https:') { self.uri.port = 443; }
  }

  if (self.proxy && !self.tunnel) {
    self.port = self.proxy.port;
    self.host = self.proxy.hostname;
  } else {
    self.port = self.uri.port;
    self.host = self.uri.hostname;
  }

  if (options.form) {
    self.form(options.form);
  }

  if (options.formData) {
    var formData = options.formData;
    var requestForm = self.form();
    var appendFormValue = function (key, value) {
      if (value && value.hasOwnProperty('value') && value.hasOwnProperty('options')) {
        requestForm.append(key, value.value, value.options);
      } else {
        requestForm.append(key, value);
      }
    };
    for (var formKey in formData) {
      if (formData.hasOwnProperty(formKey)) {
        var formValue = formData[formKey];
        if (formValue instanceof Array) {
          for (var j = 0; j < formValue.length; j++) {
            appendFormValue(formKey, formValue[j]);
          }
        } else {
          appendFormValue(formKey, formValue);
        }
      }
    }
  }

  if (options.qs) {
    self.qs(options.qs);
  }

  if (self.uri.path) {
    self.path = self.uri.path;
  } else {
    self.path = self.uri.pathname + (self.uri.search || '');
  }

  if (self.path.length === 0) {
    self.path = '/';
  }

  // Auth must happen last in case signing is dependent on other headers
  if (options.aws) {
    self.aws(options.aws);
  }

  if (options.hawk) {
    self.hawk(options.hawk);
  }

  if (options.httpSignature) {
    self.httpSignature(options.httpSignature);
  }

  if (options.auth) {
    if (Object.prototype.hasOwnProperty.call(options.auth, 'username')) {
      options.auth.user = options.auth.username;
    }
    if (Object.prototype.hasOwnProperty.call(options.auth, 'password')) {
      options.auth.pass = options.auth.password;
    }

    self.auth(
      options.auth.user,
      options.auth.pass,
      options.auth.sendImmediately,
      options.auth.bearer
    );
  }

  if (self.gzip && !self.hasHeader('accept-encoding')) {
    self.setHeader('accept-encoding', 'gzip, deflate');
  }

  if (self.uri.auth && !self.hasHeader('authorization')) {
    var uriAuthPieces = self.uri.auth.split(':').map(function (item) { return self._qs.unescape(item) });
    self.auth(uriAuthPieces[0], uriAuthPieces.slice(1).join(':'), true);
  }

  if (!self.tunnel && self.proxy && self.proxy.auth && !self.hasHeader('proxy-authorization')) {
    var proxyAuthPieces = self.proxy.auth.split(':').map(function (item) { return self._qs.unescape(item) });
    var authHeader = 'Basic ' + toBase64(proxyAuthPieces.join(':'));
    self.setHeader('proxy-authorization', authHeader);
  }

  if (self.proxy && !self.tunnel) {
    self.path = (self.uri.protocol + '//' + self.uri.host + self.path);
  }

  if (options.json) {
    self.json(options.json);
  }
  if (options.multipart) {
    self.multipart(options.multipart);
  }

  if (options.time) {
    self.timing = true;

    // NOTE: elapsedTime is deprecated in favor of .timings
    self.elapsedTime = self.elapsedTime || 0;
  }

  function setContentLength () {
    if (isTypedArray(self.body)) {
      self.body = Buffer$1.from(self.body);
    }

    if (!self.hasHeader('content-length')) {
      var length;
      if (typeof self.body === 'string') {
        length = Buffer$1.byteLength(self.body);
      } else if (Array.isArray(self.body)) {
        length = self.body.reduce(function (a, b) { return a + b.length }, 0);
      } else {
        length = self.body.length;
      }

      if (length) {
        self.setHeader('content-length', length);
      } else {
        self.emit('error', new Error('Argument error, options.body.'));
      }
    }
  }
  if (self.body && !isstream(self.body)) {
    setContentLength();
  }

  if (options.oauth) {
    self.oauth(options.oauth);
  } else if (self._oauth.params && self.hasHeader('authorization')) {
    self.oauth(self._oauth.params);
  }

  var protocol = self.proxy && !self.tunnel ? self.proxy.protocol : self.uri.protocol;
  var defaultModules = {'http:': http, 'https:': https};
  var httpModules = self.httpModules || {};

  self.httpModule = httpModules[protocol] || defaultModules[protocol];

  if (!self.httpModule) {
    return self.emit('error', new Error('Invalid protocol: ' + protocol))
  }

  if (options.ca) {
    self.ca = options.ca;
  }

  if (!self.agent) {
    if (options.agentOptions) {
      self.agentOptions = options.agentOptions;
    }

    if (options.agentClass) {
      self.agentClass = options.agentClass;
    } else if (options.forever) {
      var v = version();
      // use ForeverAgent in node 0.10- only
      if (v.major === 0 && v.minor <= 10) {
        self.agentClass = protocol === 'http:' ? foreverAgent : foreverAgent.SSL;
      } else {
        self.agentClass = self.httpModule.Agent;
        self.agentOptions = self.agentOptions || {};
        self.agentOptions.keepAlive = true;
      }
    } else {
      self.agentClass = self.httpModule.Agent;
    }
  }

  if (self.pool === false) {
    self.agent = false;
  } else {
    self.agent = self.agent || self.getNewAgent();
  }

  self.on('pipe', function (src) {
    if (self.ntick && self._started) {
      self.emit('error', new Error('You cannot pipe to this stream after the outbound request has started.'));
    }
    self.src = src;
    if (isReadStream(src)) {
      if (!self.hasHeader('content-type')) {
        self.setHeader('content-type', mimeTypes.lookup(src.path));
      }
    } else {
      if (src.headers) {
        for (var i in src.headers) {
          if (!self.hasHeader(i)) {
            self.setHeader(i, src.headers[i]);
          }
        }
      }
      if (self._json && !self.hasHeader('content-type')) {
        self.setHeader('content-type', 'application/json');
      }
      if (src.method && !self.explicitMethod) {
        self.method = src.method;
      }
    }

  // self.on('pipe', function () {
  //   console.error('You have already piped to this stream. Pipeing twice is likely to break the request.')
  // })
  });

  defer(function () {
    if (self._aborted) {
      return
    }

    var end = function () {
      if (self._form) {
        if (!self._auth.hasAuth) {
          self._form.pipe(self);
        } else if (self._auth.hasAuth && self._auth.sentAuth) {
          self._form.pipe(self);
        }
      }
      if (self._multipart && self._multipart.chunked) {
        self._multipart.body.pipe(self);
      }
      if (self.body) {
        if (isstream(self.body)) {
          self.body.pipe(self);
        } else {
          setContentLength();
          if (Array.isArray(self.body)) {
            self.body.forEach(function (part) {
              self.write(part);
            });
          } else {
            self.write(self.body);
          }
          self.end();
        }
      } else if (self.requestBodyStream) {
        console.warn('options.requestBodyStream is deprecated, please pass the request object to stream.pipe.');
        self.requestBodyStream.pipe(self);
      } else if (!self.src) {
        if (self._auth.hasAuth && !self._auth.sentAuth) {
          self.end();
          return
        }
        if (self.method !== 'GET' && typeof self.method !== 'undefined') {
          self.setHeader('content-length', 0);
        }
        self.end();
      }
    };

    if (self._form && !self.hasHeader('content-length')) {
      // Before ending the request, we had to compute the length of the whole form, asyncly
      self.setHeader(self._form.getHeaders(), true);
      self._form.getLength(function (err, length) {
        if (!err && !isNaN(length)) {
          self.setHeader('content-length', length);
        }
        end();
      });
    } else {
      end();
    }

    self.ntick = true;
  });
};

Request.prototype.getNewAgent = function () {
  var self = this;
  var Agent = self.agentClass;
  var options = {};
  if (self.agentOptions) {
    for (var i in self.agentOptions) {
      options[i] = self.agentOptions[i];
    }
  }
  if (self.ca) {
    options.ca = self.ca;
  }
  if (self.ciphers) {
    options.ciphers = self.ciphers;
  }
  if (self.secureProtocol) {
    options.secureProtocol = self.secureProtocol;
  }
  if (self.secureOptions) {
    options.secureOptions = self.secureOptions;
  }
  if (typeof self.rejectUnauthorized !== 'undefined') {
    options.rejectUnauthorized = self.rejectUnauthorized;
  }

  if (self.cert && self.key) {
    options.key = self.key;
    options.cert = self.cert;
  }

  if (self.pfx) {
    options.pfx = self.pfx;
  }

  if (self.passphrase) {
    options.passphrase = self.passphrase;
  }

  var poolKey = '';

  // different types of agents are in different pools
  if (Agent !== self.httpModule.Agent) {
    poolKey += Agent.name;
  }

  // ca option is only relevant if proxy or destination are https
  var proxy = self.proxy;
  if (typeof proxy === 'string') {
    proxy = url.parse(proxy);
  }
  var isHttps = (proxy && proxy.protocol === 'https:') || this.uri.protocol === 'https:';

  if (isHttps) {
    if (options.ca) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.ca;
    }

    if (typeof options.rejectUnauthorized !== 'undefined') {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.rejectUnauthorized;
    }

    if (options.cert) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.cert.toString('ascii') + options.key.toString('ascii');
    }

    if (options.pfx) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.pfx.toString('ascii');
    }

    if (options.ciphers) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.ciphers;
    }

    if (options.secureProtocol) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.secureProtocol;
    }

    if (options.secureOptions) {
      if (poolKey) {
        poolKey += ':';
      }
      poolKey += options.secureOptions;
    }
  }

  if (self.pool === globalPool && !poolKey && Object.keys(options).length === 0 && self.httpModule.globalAgent) {
    // not doing anything special.  Use the globalAgent
    return self.httpModule.globalAgent
  }

  // we're using a stored agent.  Make sure it's protocol-specific
  poolKey = self.uri.protocol + poolKey;

  // generate a new agent for this setting if none yet exists
  if (!self.pool[poolKey]) {
    self.pool[poolKey] = new Agent(options);
    // properly set maxSockets on new agents
    if (self.pool.maxSockets) {
      self.pool[poolKey].maxSockets = self.pool.maxSockets;
    }
  }

  return self.pool[poolKey]
};

Request.prototype.start = function () {
  // start() is called once we are ready to send the outgoing HTTP request.
  // this is usually called on the first write(), end() or on nextTick()
  var self = this;

  if (self.timing) {
    // All timings will be relative to this request's startTime.  In order to do this,
    // we need to capture the wall-clock start time (via Date), immediately followed
    // by the high-resolution timer (via now()).  While these two won't be set
    // at the _exact_ same time, they should be close enough to be able to calculate
    // high-resolution, monotonically non-decreasing timestamps relative to startTime.
    var startTime = new Date().getTime();
    var startTimeNow = performanceNow();
  }

  if (self._aborted) {
    return
  }

  self._started = true;
  self.method = self.method || 'GET';
  self.href = self.uri.href;

  if (self.src && self.src.stat && self.src.stat.size && !self.hasHeader('content-length')) {
    self.setHeader('content-length', self.src.stat.size);
  }
  if (self._aws) {
    self.aws(self._aws, true);
  }

  // We have a method named auth, which is completely different from the http.request
  // auth option.  If we don't remove it, we're gonna have a bad time.
  var reqOptions = copy(self);
  delete reqOptions.auth;

  debug$2('make request', self.uri.href);

  // node v6.8.0 now supports a `timeout` value in `http.request()`, but we
  // should delete it for now since we handle timeouts manually for better
  // consistency with node versions before v6.8.0
  delete reqOptions.timeout;

  try {
    self.req = self.httpModule.request(reqOptions);
  } catch (err) {
    self.emit('error', err);
    return
  }

  if (self.timing) {
    self.startTime = startTime;
    self.startTimeNow = startTimeNow;

    // Timing values will all be relative to startTime (by comparing to startTimeNow
    // so we have an accurate clock)
    self.timings = {};
  }

  var timeout;
  if (self.timeout && !self.timeoutTimer) {
    if (self.timeout < 0) {
      timeout = 0;
    } else if (typeof self.timeout === 'number' && isFinite(self.timeout)) {
      timeout = self.timeout;
    }
  }

  self.req.on('response', self.onRequestResponse.bind(self));
  self.req.on('error', self.onRequestError.bind(self));
  self.req.on('drain', function () {
    self.emit('drain');
  });

  self.req.on('socket', function (socket) {
    // `._connecting` was the old property which was made public in node v6.1.0
    var isConnecting = socket._connecting || socket.connecting;
    if (self.timing) {
      self.timings.socket = performanceNow() - self.startTimeNow;

      if (isConnecting) {
        var onLookupTiming = function () {
          self.timings.lookup = performanceNow() - self.startTimeNow;
        };

        var onConnectTiming = function () {
          self.timings.connect = performanceNow() - self.startTimeNow;
        };

        socket.once('lookup', onLookupTiming);
        socket.once('connect', onConnectTiming);

        // clean up timing event listeners if needed on error
        self.req.once('error', function () {
          socket.removeListener('lookup', onLookupTiming);
          socket.removeListener('connect', onConnectTiming);
        });
      }
    }

    var setReqTimeout = function () {
      // This timeout sets the amount of time to wait *between* bytes sent
      // from the server once connected.
      //
      // In particular, it's useful for erroring if the server fails to send
      // data halfway through streaming a response.
      self.req.setTimeout(timeout, function () {
        if (self.req) {
          self.abort();
          var e = new Error('ESOCKETTIMEDOUT');
          e.code = 'ESOCKETTIMEDOUT';
          e.connect = false;
          self.emit('error', e);
        }
      });
    };
    if (timeout !== undefined) {
      // Only start the connection timer if we're actually connecting a new
      // socket, otherwise if we're already connected (because this is a
      // keep-alive connection) do not bother. This is important since we won't
      // get a 'connect' event for an already connected socket.
      if (isConnecting) {
        var onReqSockConnect = function () {
          socket.removeListener('connect', onReqSockConnect);
          self.clearTimeout();
          setReqTimeout();
        };

        socket.on('connect', onReqSockConnect);

        self.req.on('error', function (err) { // eslint-disable-line handle-callback-err
          socket.removeListener('connect', onReqSockConnect);
        });

        // Set a timeout in memory - this block will throw if the server takes more
        // than `timeout` to write the HTTP status and headers (corresponding to
        // the on('response') event on the client). NB: this measures wall-clock
        // time, not the time between bytes sent by the server.
        self.timeoutTimer = setTimeout(function () {
          socket.removeListener('connect', onReqSockConnect);
          self.abort();
          var e = new Error('ETIMEDOUT');
          e.code = 'ETIMEDOUT';
          e.connect = true;
          self.emit('error', e);
        }, timeout);
      } else {
        // We're already connected
        setReqTimeout();
      }
    }
    self.emit('socket', socket);
  });

  self.emit('request', self.req);
};

Request.prototype.onRequestError = function (error) {
  var self = this;
  if (self._aborted) {
    return
  }
  if (self.req && self.req._reusedSocket && error.code === 'ECONNRESET' &&
    self.agent.addRequestNoreuse) {
    self.agent = { addRequest: self.agent.addRequestNoreuse.bind(self.agent) };
    self.start();
    self.req.end();
    return
  }
  self.clearTimeout();
  self.emit('error', error);
};

Request.prototype.onRequestResponse = function (response) {
  var self = this;

  if (self.timing) {
    self.timings.response = performanceNow() - self.startTimeNow;
  }

  debug$2('onRequestResponse', self.uri.href, response.statusCode, response.headers);
  response.on('end', function () {
    if (self.timing) {
      self.timings.end = performanceNow() - self.startTimeNow;
      response.timingStart = self.startTime;

      // fill in the blanks for any periods that didn't trigger, such as
      // no lookup or connect due to keep alive
      if (!self.timings.socket) {
        self.timings.socket = 0;
      }
      if (!self.timings.lookup) {
        self.timings.lookup = self.timings.socket;
      }
      if (!self.timings.connect) {
        self.timings.connect = self.timings.lookup;
      }
      if (!self.timings.response) {
        self.timings.response = self.timings.connect;
      }

      debug$2('elapsed time', self.timings.end);

      // elapsedTime includes all redirects
      self.elapsedTime += Math.round(self.timings.end);

      // NOTE: elapsedTime is deprecated in favor of .timings
      response.elapsedTime = self.elapsedTime;

      // timings is just for the final fetch
      response.timings = self.timings;

      // pre-calculate phase timings as well
      response.timingPhases = {
        wait: self.timings.socket,
        dns: self.timings.lookup - self.timings.socket,
        tcp: self.timings.connect - self.timings.lookup,
        firstByte: self.timings.response - self.timings.connect,
        download: self.timings.end - self.timings.response,
        total: self.timings.end
      };
    }
    debug$2('response end', self.uri.href, response.statusCode, response.headers);
  });

  if (self._aborted) {
    debug$2('aborted', self.uri.href);
    response.resume();
    return
  }

  self.response = response;
  response.request = self;
  response.toJSON = responseToJSON;

  // XXX This is different on 0.10, because SSL is strict by default
  if (self.httpModule === https &&
    self.strictSSL && (!response.hasOwnProperty('socket') ||
    !response.socket.authorized)) {
    debug$2('strict ssl error', self.uri.href);
    var sslErr = response.hasOwnProperty('socket') ? response.socket.authorizationError : self.uri.href + ' does not support SSL';
    self.emit('error', new Error('SSL Error: ' + sslErr));
    return
  }

  // Save the original host before any redirect (if it changes, we need to
  // remove any authorization headers).  Also remember the case of the header
  // name because lots of broken servers expect Host instead of host and we
  // want the caller to be able to specify this.
  self.originalHost = self.getHeader('host');
  if (!self.originalHostHeaderName) {
    self.originalHostHeaderName = self.hasHeader('host');
  }
  if (self.setHost) {
    self.removeHeader('host');
  }
  self.clearTimeout();

  var targetCookieJar = (self._jar && self._jar.setCookie) ? self._jar : globalCookieJar;
  var addCookie = function (cookie) {
    // set the cookie if it's domain in the href's domain.
    try {
      targetCookieJar.setCookie(cookie, self.uri.href, {ignoreError: true});
    } catch (e) {
      self.emit('error', e);
    }
  };

  response.caseless = caseless(response.headers);

  if (response.caseless.has('set-cookie') && (!self._disableCookies)) {
    var headerName = response.caseless.has('set-cookie');
    if (Array.isArray(response.headers[headerName])) {
      response.headers[headerName].forEach(addCookie);
    } else {
      addCookie(response.headers[headerName]);
    }
  }

  if (self._redirect.onResponse(response)) {
    return // Ignore the rest of the response
  } else {
    // Be a good stream and emit end when the response is finished.
    // Hack to emit end on close because of a core bug that never fires end
    response.on('close', function () {
      if (!self._ended) {
        self.response.emit('end');
      }
    });

    response.once('end', function () {
      self._ended = true;
    });

    var noBody = function (code) {
      return (
        self.method === 'HEAD' ||
        // Informational
        (code >= 100 && code < 200) ||
        // No Content
        code === 204 ||
        // Not Modified
        code === 304
      )
    };

    var responseContent;
    if (self.gzip && !noBody(response.statusCode)) {
      var contentEncoding = response.headers['content-encoding'] || 'identity';
      contentEncoding = contentEncoding.trim().toLowerCase();

      // Be more lenient with decoding compressed responses, since (very rarely)
      // servers send slightly invalid gzip responses that are still accepted
      // by common browsers.
      // Always using Z_SYNC_FLUSH is what cURL does.
      var zlibOptions = {
        flush: zlib.Z_SYNC_FLUSH,
        finishFlush: zlib.Z_SYNC_FLUSH
      };

      if (contentEncoding === 'gzip') {
        responseContent = zlib.createGunzip(zlibOptions);
        response.pipe(responseContent);
      } else if (contentEncoding === 'deflate') {
        responseContent = zlib.createInflate(zlibOptions);
        response.pipe(responseContent);
      } else {
        // Since previous versions didn't check for Content-Encoding header,
        // ignore any invalid values to preserve backwards-compatibility
        if (contentEncoding !== 'identity') {
          debug$2('ignoring unrecognized Content-Encoding ' + contentEncoding);
        }
        responseContent = response;
      }
    } else {
      responseContent = response;
    }

    if (self.encoding) {
      if (self.dests.length !== 0) {
        console.error('Ignoring encoding parameter as this stream is being piped to another stream which makes the encoding option invalid.');
      } else {
        responseContent.setEncoding(self.encoding);
      }
    }

    if (self._paused) {
      responseContent.pause();
    }

    self.responseContent = responseContent;

    self.emit('response', response);

    self.dests.forEach(function (dest) {
      self.pipeDest(dest);
    });

    responseContent.on('data', function (chunk) {
      if (self.timing && !self.responseStarted) {
        self.responseStartTime = (new Date()).getTime();

        // NOTE: responseStartTime is deprecated in favor of .timings
        response.responseStartTime = self.responseStartTime;
      }
      self._destdata = true;
      self.emit('data', chunk);
    });
    responseContent.once('end', function (chunk) {
      self.emit('end', chunk);
    });
    responseContent.on('error', function (error) {
      self.emit('error', error);
    });
    responseContent.on('close', function () { self.emit('close'); });

    if (self.callback) {
      self.readResponseBody(response);
    } else { // if no callback
      self.on('end', function () {
        if (self._aborted) {
          debug$2('aborted', self.uri.href);
          return
        }
        self.emit('complete', response);
      });
    }
  }
  debug$2('finish init function', self.uri.href);
};

Request.prototype.readResponseBody = function (response) {
  var self = this;
  debug$2("reading response's body");
  var buffers = [];
  var bufferLength = 0;
  var strings = [];

  self.on('data', function (chunk) {
    if (!Buffer$1.isBuffer(chunk)) {
      strings.push(chunk);
    } else if (chunk.length) {
      bufferLength += chunk.length;
      buffers.push(chunk);
    }
  });
  self.on('end', function () {
    debug$2('end event', self.uri.href);
    if (self._aborted) {
      debug$2('aborted', self.uri.href);
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = [];
      bufferLength = 0;
      return
    }

    if (bufferLength) {
      debug$2('has body', self.uri.href, bufferLength);
      response.body = Buffer$1.concat(buffers, bufferLength);
      if (self.encoding !== null) {
        response.body = response.body.toString(self.encoding);
      }
      // `buffer` is defined in the parent scope and used in a closure it exists for the life of the Request.
      // This can lead to leaky behavior if the user retains a reference to the request object.
      buffers = [];
      bufferLength = 0;
    } else if (strings.length) {
      // The UTF8 BOM [0xEF,0xBB,0xBF] is converted to [0xFE,0xFF] in the JS UTC16/UCS2 representation.
      // Strip this value out when the encoding is set to 'utf8', as upstream consumers won't expect it and it breaks JSON.parse().
      if (self.encoding === 'utf8' && strings[0].length > 0 && strings[0][0] === '\uFEFF') {
        strings[0] = strings[0].substring(1);
      }
      response.body = strings.join('');
    }

    if (self._json) {
      try {
        response.body = JSON.parse(response.body, self._jsonReviver);
      } catch (e) {
        debug$2('invalid JSON received', self.uri.href);
      }
    }
    debug$2('emitting complete', self.uri.href);
    if (typeof response.body === 'undefined' && !self._json) {
      response.body = self.encoding === null ? Buffer$1.alloc(0) : '';
    }
    self.emit('complete', response, response.body);
  });
};

Request.prototype.abort = function () {
  var self = this;
  self._aborted = true;

  if (self.req) {
    self.req.abort();
  } else if (self.response) {
    self.response.destroy();
  }

  self.clearTimeout();
  self.emit('abort');
};

Request.prototype.pipeDest = function (dest) {
  var self = this;
  var response = self.response;
  // Called after the response is received
  if (dest.headers && !dest.headersSent) {
    if (response.caseless.has('content-type')) {
      var ctname = response.caseless.has('content-type');
      if (dest.setHeader) {
        dest.setHeader(ctname, response.headers[ctname]);
      } else {
        dest.headers[ctname] = response.headers[ctname];
      }
    }

    if (response.caseless.has('content-length')) {
      var clname = response.caseless.has('content-length');
      if (dest.setHeader) {
        dest.setHeader(clname, response.headers[clname]);
      } else {
        dest.headers[clname] = response.headers[clname];
      }
    }
  }
  if (dest.setHeader && !dest.headersSent) {
    for (var i in response.headers) {
      // If the response content is being decoded, the Content-Encoding header
      // of the response doesn't represent the piped content, so don't pass it.
      if (!self.gzip || i !== 'content-encoding') {
        dest.setHeader(i, response.headers[i]);
      }
    }
    dest.statusCode = response.statusCode;
  }
  if (self.pipefilter) {
    self.pipefilter(response, dest);
  }
};

Request.prototype.qs = function (q, clobber) {
  var self = this;
  var base;
  if (!clobber && self.uri.query) {
    base = self._qs.parse(self.uri.query);
  } else {
    base = {};
  }

  for (var i in q) {
    base[i] = q[i];
  }

  var qs = self._qs.stringify(base);

  if (qs === '') {
    return self
  }

  self.uri = url.parse(self.uri.href.split('?')[0] + '?' + qs);
  self.url = self.uri;
  self.path = self.uri.path;

  if (self.uri.host === 'unix') {
    self.enableUnixSocket();
  }

  return self
};
Request.prototype.form = function (form) {
  var self = this;
  if (form) {
    if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
      self.setHeader('content-type', 'application/x-www-form-urlencoded');
    }
    self.body = (typeof form === 'string')
      ? self._qs.rfc3986(form.toString('utf8'))
      : self._qs.stringify(form).toString('utf8');
    return self
  }
  // create form-data object
  self._form = new browser$2();
  self._form.on('error', function (err) {
    err.message = 'form-data: ' + err.message;
    self.emit('error', err);
    self.abort();
  });
  return self._form
};
Request.prototype.multipart = function (multipart) {
  var self = this;

  self._multipart.onRequest(multipart);

  if (!self._multipart.chunked) {
    self.body = self._multipart.body;
  }

  return self
};
Request.prototype.json = function (val) {
  var self = this;

  if (!self.hasHeader('accept')) {
    self.setHeader('accept', 'application/json');
  }

  if (typeof self.jsonReplacer === 'function') {
    self._jsonReplacer = self.jsonReplacer;
  }

  self._json = true;
  if (typeof val === 'boolean') {
    if (self.body !== undefined) {
      if (!/^application\/x-www-form-urlencoded\b/.test(self.getHeader('content-type'))) {
        self.body = safeStringify(self.body, self._jsonReplacer);
      } else {
        self.body = self._qs.rfc3986(self.body);
      }
      if (!self.hasHeader('content-type')) {
        self.setHeader('content-type', 'application/json');
      }
    }
  } else {
    self.body = safeStringify(val, self._jsonReplacer);
    if (!self.hasHeader('content-type')) {
      self.setHeader('content-type', 'application/json');
    }
  }

  if (typeof self.jsonReviver === 'function') {
    self._jsonReviver = self.jsonReviver;
  }

  return self
};
Request.prototype.getHeader = function (name, headers) {
  var self = this;
  var result, re, match;
  if (!headers) {
    headers = self.headers;
  }
  Object.keys(headers).forEach(function (key) {
    if (key.length !== name.length) {
      return
    }
    re = new RegExp(name, 'i');
    match = key.match(re);
    if (match) {
      result = headers[key];
    }
  });
  return result
};
Request.prototype.enableUnixSocket = function () {
  // Get the socket & request paths from the URL
  var unixParts = this.uri.path.split(':');
  var host = unixParts[0];
  var path = unixParts[1];
  // Apply unix properties to request
  this.socketPath = host;
  this.uri.pathname = path;
  this.uri.path = path;
  this.uri.host = host;
  this.uri.hostname = host;
  this.uri.isUnix = true;
};

Request.prototype.auth = function (user, pass, sendImmediately, bearer) {
  var self = this;

  self._auth.onRequest(user, pass, sendImmediately, bearer);

  return self
};
Request.prototype.aws = function (opts, now) {
  var self = this;

  if (!now) {
    self._aws = opts;
    return self
  }

  if (opts.sign_version === 4 || opts.sign_version === '4') {
    // use aws4
    var options = {
      host: self.uri.host,
      path: self.uri.path,
      method: self.method,
      headers: self.headers,
      body: self.body
    };
    if (opts.service) {
      options.service = opts.service;
    }
    var signRes = aws4_1.sign(options, {
      accessKeyId: opts.key,
      secretAccessKey: opts.secret,
      sessionToken: opts.session
    });
    self.setHeader('authorization', signRes.headers.Authorization);
    self.setHeader('x-amz-date', signRes.headers['X-Amz-Date']);
    if (signRes.headers['X-Amz-Security-Token']) {
      self.setHeader('x-amz-security-token', signRes.headers['X-Amz-Security-Token']);
    }
  } else {
    // default: use aws-sign2
    var date = new Date();
    self.setHeader('date', date.toUTCString());
    var auth = {
      key: opts.key,
      secret: opts.secret,
      verb: self.method.toUpperCase(),
      date: date,
      contentType: self.getHeader('content-type') || '',
      md5: self.getHeader('content-md5') || '',
      amazonHeaders: awsSign2.canonicalizeHeaders(self.headers)
    };
    var path = self.uri.path;
    if (opts.bucket && path) {
      auth.resource = '/' + opts.bucket + path;
    } else if (opts.bucket && !path) {
      auth.resource = '/' + opts.bucket;
    } else if (!opts.bucket && path) {
      auth.resource = path;
    } else if (!opts.bucket && !path) {
      auth.resource = '/';
    }
    auth.resource = awsSign2.canonicalizeResource(auth.resource);
    self.setHeader('authorization', awsSign2.authorization(auth));
  }

  return self
};
Request.prototype.httpSignature = function (opts) {
  var self = this;
  lib$d.signRequest({
    getHeader: function (header) {
      return self.getHeader(header, self.headers)
    },
    setHeader: function (header, value) {
      self.setHeader(header, value);
    },
    method: self.method,
    path: self.path
  }, opts);
  debug$2('httpSignature authorization', self.getHeader('authorization'));

  return self
};
Request.prototype.hawk = function (opts) {
  var self = this;
  self.setHeader('Authorization', hawk.header(self.uri, self.method, opts));
};
Request.prototype.oauth = function (_oauth) {
  var self = this;

  self._oauth.onRequest(_oauth);

  return self
};

Request.prototype.jar = function (jar) {
  var self = this;
  var cookies;

  if (self._redirect.redirectsFollowed === 0) {
    self.originalCookieHeader = self.getHeader('cookie');
  }

  if (!jar) {
    // disable cookies
    cookies = false;
    self._disableCookies = true;
  } else {
    var targetCookieJar = jar.getCookieString ? jar : globalCookieJar;
    var urihref = self.uri.href;
    // fetch cookie in the Specified host
    if (targetCookieJar) {
      cookies = targetCookieJar.getCookieString(urihref);
    }
  }

  // if need cookie and cookie is not empty
  if (cookies && cookies.length) {
    if (self.originalCookieHeader) {
      // Don't overwrite existing Cookie header
      self.setHeader('cookie', self.originalCookieHeader + '; ' + cookies);
    } else {
      self.setHeader('cookie', cookies);
    }
  }
  self._jar = jar;
  return self
};

// Stream API
Request.prototype.pipe = function (dest, opts) {
  var self = this;

  if (self.response) {
    if (self._destdata) {
      self.emit('error', new Error('You cannot pipe after data has been emitted from the response.'));
    } else if (self._ended) {
      self.emit('error', new Error('You cannot pipe after the response has been ended.'));
    } else {
      stream.Stream.prototype.pipe.call(self, dest, opts);
      self.pipeDest(dest);
      return dest
    }
  } else {
    self.dests.push(dest);
    stream.Stream.prototype.pipe.call(self, dest, opts);
    return dest
  }
};
Request.prototype.write = function () {
  var self = this;
  if (self._aborted) { return }

  if (!self._started) {
    self.start();
  }
  if (self.req) {
    return self.req.write.apply(self.req, arguments)
  }
};
Request.prototype.end = function (chunk) {
  var self = this;
  if (self._aborted) { return }

  if (chunk) {
    self.write(chunk);
  }
  if (!self._started) {
    self.start();
  }
  if (self.req) {
    self.req.end();
  }
};
Request.prototype.pause = function () {
  var self = this;
  if (!self.responseContent) {
    self._paused = true;
  } else {
    self.responseContent.pause.apply(self.responseContent, arguments);
  }
};
Request.prototype.resume = function () {
  var self = this;
  if (!self.responseContent) {
    self._paused = false;
  } else {
    self.responseContent.resume.apply(self.responseContent, arguments);
  }
};
Request.prototype.destroy = function () {
  var self = this;
  this.clearTimeout();
  if (!self._ended) {
    self.end();
  } else if (self.response) {
    self.response.destroy();
  }
};

Request.prototype.clearTimeout = function () {
  if (this.timeoutTimer) {
    clearTimeout(this.timeoutTimer);
    this.timeoutTimer = null;
  }
};

Request.defaultProxyHeaderWhiteList =
  Tunnel.defaultProxyHeaderWhiteList.slice();

Request.defaultProxyHeaderExclusiveList =
  Tunnel.defaultProxyHeaderExclusiveList.slice();

// Exports

Request.prototype.toJSON = requestToJSON;
var request$1 = Request;

var paramsHaveRequestBody = helpers.paramsHaveRequestBody;

// organize params for patch, post, put, head, del
function initParams (uri, options, callback) {
  if (typeof options === 'function') {
    callback = options;
  }

  var params = {};
  if (options !== null && typeof options === 'object') {
    extend(params, options, {uri: uri});
  } else if (typeof uri === 'string') {
    extend(params, {uri: uri});
  } else {
    extend(params, uri);
  }

  params.callback = callback || params.callback;
  return params
}

function request (uri, options, callback) {
  if (typeof uri === 'undefined') {
    throw new Error('undefined is not a valid uri or options object.')
  }

  var params = initParams(uri, options, callback);

  if (params.method === 'HEAD' && paramsHaveRequestBody(params)) {
    throw new Error('HTTP HEAD requests MUST NOT include a request body.')
  }

  return new request.Request(params)
}

function verbFunc (verb) {
  var method = verb.toUpperCase();
  return function (uri, options, callback) {
    var params = initParams(uri, options, callback);
    params.method = method;
    return request(params, params.callback)
  }
}

// define like this to please codeintel/intellisense IDEs
request.get = verbFunc('get');
request.head = verbFunc('head');
request.options = verbFunc('options');
request.post = verbFunc('post');
request.put = verbFunc('put');
request.patch = verbFunc('patch');
request.del = verbFunc('delete');
request['delete'] = verbFunc('delete');

request.jar = function (store) {
  return cookies$1.jar(store)
};

request.cookie = function (str) {
  return cookies$1.parse(str)
};

function wrapRequestMethod (method, options, requester, verb) {
  return function (uri, opts, callback) {
    var params = initParams(uri, opts, callback);

    var target = {};
    extend(true, target, options, params);

    target.pool = params.pool || options.pool;

    if (verb) {
      target.method = verb.toUpperCase();
    }

    if (typeof requester === 'function') {
      method = requester;
    }

    return method(target, target.callback)
  }
}

request.defaults = function (options, requester) {
  var self = this;

  options = options || {};

  if (typeof options === 'function') {
    requester = options;
    options = {};
  }

  var defaults = wrapRequestMethod(self, options, requester);

  var verbs = ['get', 'head', 'post', 'put', 'patch', 'del', 'delete'];
  verbs.forEach(function (verb) {
    defaults[verb] = wrapRequestMethod(self[verb], options, requester, verb);
  });

  defaults.cookie = wrapRequestMethod(self.cookie, options, requester);
  defaults.jar = self.jar;
  defaults.defaults = self.defaults;
  return defaults
};

request.forever = function (agentOptions, optionsArg) {
  var options = {};
  if (optionsArg) {
    extend(options, optionsArg);
  }
  if (agentOptions) {
    options.agentOptions = agentOptions;
  }

  options.forever = true;
  return request.defaults(options)
};
request.Request = request$1;
request.initParams = initParams;

// Backwards compatibility for request.debug
Object.defineProperty(request, 'debug', {
  enumerable: true,
  get: function () {
    return request.Request.debug
  },
  set: function (debug) {
    request.Request.debug = debug;
  }
});

/*!
 * async
 * https://github.com/caolan/async
 *
 * Copyright 2010-2014 Caolan McMahon
 * Released under the MIT license
 */

var async = createCommonjsModule(function (module) {
/*jshint onevar: false, indent:4 */
/*global setImmediate: false, setTimeout: false, console: false */
(function () {

    var async = {};

    // global on the server, window in the browser
    var root, previous_async;

    root = this;
    if (root != null) {
      previous_async = root.async;
    }

    async.noConflict = function () {
        root.async = previous_async;
        return async;
    };

    function only_once(fn) {
        var called = false;
        return function() {
            if (called) throw new Error("Callback was already called.");
            called = true;
            fn.apply(root, arguments);
        }
    }

    //// cross-browser compatiblity functions ////

    var _toString = Object.prototype.toString;

    var _isArray = Array.isArray || function (obj) {
        return _toString.call(obj) === '[object Array]';
    };

    var _each = function (arr, iterator) {
        for (var i = 0; i < arr.length; i += 1) {
            iterator(arr[i], i, arr);
        }
    };

    var _map = function (arr, iterator) {
        if (arr.map) {
            return arr.map(iterator);
        }
        var results = [];
        _each(arr, function (x, i, a) {
            results.push(iterator(x, i, a));
        });
        return results;
    };

    var _reduce = function (arr, iterator, memo) {
        if (arr.reduce) {
            return arr.reduce(iterator, memo);
        }
        _each(arr, function (x, i, a) {
            memo = iterator(memo, x, i, a);
        });
        return memo;
    };

    var _keys = function (obj) {
        if (Object.keys) {
            return Object.keys(obj);
        }
        var keys = [];
        for (var k in obj) {
            if (obj.hasOwnProperty(k)) {
                keys.push(k);
            }
        }
        return keys;
    };

    //// exported async module functions ////

    //// nextTick implementation with browser-compatible fallback ////
    if (typeof process === 'undefined' || !(process.nextTick)) {
        if (typeof setImmediate === 'function') {
            async.nextTick = function (fn) {
                // not a direct alias for IE10 compatibility
                setImmediate(fn);
            };
            async.setImmediate = async.nextTick;
        }
        else {
            async.nextTick = function (fn) {
                setTimeout(fn, 0);
            };
            async.setImmediate = async.nextTick;
        }
    }
    else {
        async.nextTick = process.nextTick;
        if (typeof setImmediate !== 'undefined') {
            async.setImmediate = function (fn) {
              // not a direct alias for IE10 compatibility
              setImmediate(fn);
            };
        }
        else {
            async.setImmediate = async.nextTick;
        }
    }

    async.each = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        _each(arr, function (x) {
            iterator(x, only_once(done) );
        });
        function done(err) {
          if (err) {
              callback(err);
              callback = function () {};
          }
          else {
              completed += 1;
              if (completed >= arr.length) {
                  callback();
              }
          }
        }
    };
    async.forEach = async.each;

    async.eachSeries = function (arr, iterator, callback) {
        callback = callback || function () {};
        if (!arr.length) {
            return callback();
        }
        var completed = 0;
        var iterate = function () {
            iterator(arr[completed], function (err) {
                if (err) {
                    callback(err);
                    callback = function () {};
                }
                else {
                    completed += 1;
                    if (completed >= arr.length) {
                        callback();
                    }
                    else {
                        iterate();
                    }
                }
            });
        };
        iterate();
    };
    async.forEachSeries = async.eachSeries;

    async.eachLimit = function (arr, limit, iterator, callback) {
        var fn = _eachLimit(limit);
        fn.apply(null, [arr, iterator, callback]);
    };
    async.forEachLimit = async.eachLimit;

    var _eachLimit = function (limit) {

        return function (arr, iterator, callback) {
            callback = callback || function () {};
            if (!arr.length || limit <= 0) {
                return callback();
            }
            var completed = 0;
            var started = 0;
            var running = 0;

            (function replenish () {
                if (completed >= arr.length) {
                    return callback();
                }

                while (running < limit && started < arr.length) {
                    started += 1;
                    running += 1;
                    iterator(arr[started - 1], function (err) {
                        if (err) {
                            callback(err);
                            callback = function () {};
                        }
                        else {
                            completed += 1;
                            running -= 1;
                            if (completed >= arr.length) {
                                callback();
                            }
                            else {
                                replenish();
                            }
                        }
                    });
                }
            })();
        };
    };


    var doParallel = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.each].concat(args));
        };
    };
    var doParallelLimit = function(limit, fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [_eachLimit(limit)].concat(args));
        };
    };
    var doSeries = function (fn) {
        return function () {
            var args = Array.prototype.slice.call(arguments);
            return fn.apply(null, [async.eachSeries].concat(args));
        };
    };


    var _asyncMap = function (eachfn, arr, iterator, callback) {
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        if (!callback) {
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err) {
                    callback(err);
                });
            });
        } else {
            var results = [];
            eachfn(arr, function (x, callback) {
                iterator(x.value, function (err, v) {
                    results[x.index] = v;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };
    async.map = doParallel(_asyncMap);
    async.mapSeries = doSeries(_asyncMap);
    async.mapLimit = function (arr, limit, iterator, callback) {
        return _mapLimit(limit)(arr, iterator, callback);
    };

    var _mapLimit = function(limit) {
        return doParallelLimit(limit, _asyncMap);
    };

    // reduce only has a series version, as doing reduce in parallel won't
    // work in many situations.
    async.reduce = function (arr, memo, iterator, callback) {
        async.eachSeries(arr, function (x, callback) {
            iterator(memo, x, function (err, v) {
                memo = v;
                callback(err);
            });
        }, function (err) {
            callback(err, memo);
        });
    };
    // inject alias
    async.inject = async.reduce;
    // foldl alias
    async.foldl = async.reduce;

    async.reduceRight = function (arr, memo, iterator, callback) {
        var reversed = _map(arr, function (x) {
            return x;
        }).reverse();
        async.reduce(reversed, memo, iterator, callback);
    };
    // foldr alias
    async.foldr = async.reduceRight;

    var _filter = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.filter = doParallel(_filter);
    async.filterSeries = doSeries(_filter);
    // select alias
    async.select = async.filter;
    async.selectSeries = async.filterSeries;

    var _reject = function (eachfn, arr, iterator, callback) {
        var results = [];
        arr = _map(arr, function (x, i) {
            return {index: i, value: x};
        });
        eachfn(arr, function (x, callback) {
            iterator(x.value, function (v) {
                if (!v) {
                    results.push(x);
                }
                callback();
            });
        }, function (err) {
            callback(_map(results.sort(function (a, b) {
                return a.index - b.index;
            }), function (x) {
                return x.value;
            }));
        });
    };
    async.reject = doParallel(_reject);
    async.rejectSeries = doSeries(_reject);

    var _detect = function (eachfn, arr, iterator, main_callback) {
        eachfn(arr, function (x, callback) {
            iterator(x, function (result) {
                if (result) {
                    main_callback(x);
                    main_callback = function () {};
                }
                else {
                    callback();
                }
            });
        }, function (err) {
            main_callback();
        });
    };
    async.detect = doParallel(_detect);
    async.detectSeries = doSeries(_detect);

    async.some = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (v) {
                    main_callback(true);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(false);
        });
    };
    // any alias
    async.any = async.some;

    async.every = function (arr, iterator, main_callback) {
        async.each(arr, function (x, callback) {
            iterator(x, function (v) {
                if (!v) {
                    main_callback(false);
                    main_callback = function () {};
                }
                callback();
            });
        }, function (err) {
            main_callback(true);
        });
    };
    // all alias
    async.all = async.every;

    async.sortBy = function (arr, iterator, callback) {
        async.map(arr, function (x, callback) {
            iterator(x, function (err, criteria) {
                if (err) {
                    callback(err);
                }
                else {
                    callback(null, {value: x, criteria: criteria});
                }
            });
        }, function (err, results) {
            if (err) {
                return callback(err);
            }
            else {
                var fn = function (left, right) {
                    var a = left.criteria, b = right.criteria;
                    return a < b ? -1 : a > b ? 1 : 0;
                };
                callback(null, _map(results.sort(fn), function (x) {
                    return x.value;
                }));
            }
        });
    };

    async.auto = function (tasks, callback) {
        callback = callback || function () {};
        var keys = _keys(tasks);
        var remainingTasks = keys.length;
        if (!remainingTasks) {
            return callback();
        }

        var results = {};

        var listeners = [];
        var addListener = function (fn) {
            listeners.unshift(fn);
        };
        var removeListener = function (fn) {
            for (var i = 0; i < listeners.length; i += 1) {
                if (listeners[i] === fn) {
                    listeners.splice(i, 1);
                    return;
                }
            }
        };
        var taskComplete = function () {
            remainingTasks--;
            _each(listeners.slice(0), function (fn) {
                fn();
            });
        };

        addListener(function () {
            if (!remainingTasks) {
                var theCallback = callback;
                // prevent final callback from calling itself if it errors
                callback = function () {};

                theCallback(null, results);
            }
        });

        _each(keys, function (k) {
            var task = _isArray(tasks[k]) ? tasks[k]: [tasks[k]];
            var taskCallback = function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (args.length <= 1) {
                    args = args[0];
                }
                if (err) {
                    var safeResults = {};
                    _each(_keys(results), function(rkey) {
                        safeResults[rkey] = results[rkey];
                    });
                    safeResults[k] = args;
                    callback(err, safeResults);
                    // stop subsequent errors hitting callback multiple times
                    callback = function () {};
                }
                else {
                    results[k] = args;
                    async.setImmediate(taskComplete);
                }
            };
            var requires = task.slice(0, Math.abs(task.length - 1)) || [];
            var ready = function () {
                return _reduce(requires, function (a, x) {
                    return (a && results.hasOwnProperty(x));
                }, true) && !results.hasOwnProperty(k);
            };
            if (ready()) {
                task[task.length - 1](taskCallback, results);
            }
            else {
                var listener = function () {
                    if (ready()) {
                        removeListener(listener);
                        task[task.length - 1](taskCallback, results);
                    }
                };
                addListener(listener);
            }
        });
    };

    async.retry = function(times, task, callback) {
        var DEFAULT_TIMES = 5;
        var attempts = [];
        // Use defaults if times not passed
        if (typeof times === 'function') {
            callback = task;
            task = times;
            times = DEFAULT_TIMES;
        }
        // Make sure times is a number
        times = parseInt(times, 10) || DEFAULT_TIMES;
        var wrappedTask = function(wrappedCallback, wrappedResults) {
            var retryAttempt = function(task, finalAttempt) {
                return function(seriesCallback) {
                    task(function(err, result){
                        seriesCallback(!err || finalAttempt, {err: err, result: result});
                    }, wrappedResults);
                };
            };
            while (times) {
                attempts.push(retryAttempt(task, !(times-=1)));
            }
            async.series(attempts, function(done, data){
                data = data[data.length - 1];
                (wrappedCallback || callback)(data.err, data.result);
            });
        };
        // If a callback is passed, run this as a controll flow
        return callback ? wrappedTask() : wrappedTask
    };

    async.waterfall = function (tasks, callback) {
        callback = callback || function () {};
        if (!_isArray(tasks)) {
          var err = new Error('First argument to waterfall must be an array of functions');
          return callback(err);
        }
        if (!tasks.length) {
            return callback();
        }
        var wrapIterator = function (iterator) {
            return function (err) {
                if (err) {
                    callback.apply(null, arguments);
                    callback = function () {};
                }
                else {
                    var args = Array.prototype.slice.call(arguments, 1);
                    var next = iterator.next();
                    if (next) {
                        args.push(wrapIterator(next));
                    }
                    else {
                        args.push(callback);
                    }
                    async.setImmediate(function () {
                        iterator.apply(null, args);
                    });
                }
            };
        };
        wrapIterator(async.iterator(tasks))();
    };

    var _parallel = function(eachfn, tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            eachfn.map(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            eachfn.each(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.parallel = function (tasks, callback) {
        _parallel({ map: async.map, each: async.each }, tasks, callback);
    };

    async.parallelLimit = function(tasks, limit, callback) {
        _parallel({ map: _mapLimit(limit), each: _eachLimit(limit) }, tasks, callback);
    };

    async.series = function (tasks, callback) {
        callback = callback || function () {};
        if (_isArray(tasks)) {
            async.mapSeries(tasks, function (fn, callback) {
                if (fn) {
                    fn(function (err) {
                        var args = Array.prototype.slice.call(arguments, 1);
                        if (args.length <= 1) {
                            args = args[0];
                        }
                        callback.call(null, err, args);
                    });
                }
            }, callback);
        }
        else {
            var results = {};
            async.eachSeries(_keys(tasks), function (k, callback) {
                tasks[k](function (err) {
                    var args = Array.prototype.slice.call(arguments, 1);
                    if (args.length <= 1) {
                        args = args[0];
                    }
                    results[k] = args;
                    callback(err);
                });
            }, function (err) {
                callback(err, results);
            });
        }
    };

    async.iterator = function (tasks) {
        var makeCallback = function (index) {
            var fn = function () {
                if (tasks.length) {
                    tasks[index].apply(null, arguments);
                }
                return fn.next();
            };
            fn.next = function () {
                return (index < tasks.length - 1) ? makeCallback(index + 1): null;
            };
            return fn;
        };
        return makeCallback(0);
    };

    async.apply = function (fn) {
        var args = Array.prototype.slice.call(arguments, 1);
        return function () {
            return fn.apply(
                null, args.concat(Array.prototype.slice.call(arguments))
            );
        };
    };

    var _concat = function (eachfn, arr, fn, callback) {
        var r = [];
        eachfn(arr, function (x, cb) {
            fn(x, function (err, y) {
                r = r.concat(y || []);
                cb(err);
            });
        }, function (err) {
            callback(err, r);
        });
    };
    async.concat = doParallel(_concat);
    async.concatSeries = doSeries(_concat);

    async.whilst = function (test, iterator, callback) {
        if (test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.whilst(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doWhilst = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (test.apply(null, args)) {
                async.doWhilst(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.until = function (test, iterator, callback) {
        if (!test()) {
            iterator(function (err) {
                if (err) {
                    return callback(err);
                }
                async.until(test, iterator, callback);
            });
        }
        else {
            callback();
        }
    };

    async.doUntil = function (iterator, test, callback) {
        iterator(function (err) {
            if (err) {
                return callback(err);
            }
            var args = Array.prototype.slice.call(arguments, 1);
            if (!test.apply(null, args)) {
                async.doUntil(iterator, test, callback);
            }
            else {
                callback();
            }
        });
    };

    async.queue = function (worker, concurrency) {
        if (concurrency === undefined) {
            concurrency = 1;
        }
        function _insert(q, data, pos, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  callback: typeof callback === 'function' ? callback : null
              };

              if (pos) {
                q.tasks.unshift(item);
              } else {
                q.tasks.push(item);
              }

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        var workers = 0;
        var q = {
            tasks: [],
            concurrency: concurrency,
            saturated: null,
            empty: null,
            drain: null,
            started: false,
            paused: false,
            push: function (data, callback) {
              _insert(q, data, false, callback);
            },
            kill: function () {
              q.drain = null;
              q.tasks = [];
            },
            unshift: function (data, callback) {
              _insert(q, data, true, callback);
            },
            process: function () {
                if (!q.paused && workers < q.concurrency && q.tasks.length) {
                    var task = q.tasks.shift();
                    if (q.empty && q.tasks.length === 0) {
                        q.empty();
                    }
                    workers += 1;
                    var next = function () {
                        workers -= 1;
                        if (task.callback) {
                            task.callback.apply(task, arguments);
                        }
                        if (q.drain && q.tasks.length + workers === 0) {
                            q.drain();
                        }
                        q.process();
                    };
                    var cb = only_once(next);
                    worker(task.data, cb);
                }
            },
            length: function () {
                return q.tasks.length;
            },
            running: function () {
                return workers;
            },
            idle: function() {
                return q.tasks.length + workers === 0;
            },
            pause: function () {
                if (q.paused === true) { return; }
                q.paused = true;
            },
            resume: function () {
                if (q.paused === false) { return; }
                q.paused = false;
                // Need to call q.process once per concurrent
                // worker to preserve full concurrency after pause
                for (var w = 1; w <= q.concurrency; w++) {
                    async.setImmediate(q.process);
                }
            }
        };
        return q;
    };

    async.priorityQueue = function (worker, concurrency) {

        function _compareTasks(a, b){
          return a.priority - b.priority;
        }
        function _binarySearch(sequence, item, compare) {
          var beg = -1,
              end = sequence.length - 1;
          while (beg < end) {
            var mid = beg + ((end - beg + 1) >>> 1);
            if (compare(item, sequence[mid]) >= 0) {
              beg = mid;
            } else {
              end = mid - 1;
            }
          }
          return beg;
        }

        function _insert(q, data, priority, callback) {
          if (!q.started){
            q.started = true;
          }
          if (!_isArray(data)) {
              data = [data];
          }
          if(data.length == 0) {
             // call drain immediately if there are no tasks
             return async.setImmediate(function() {
                 if (q.drain) {
                     q.drain();
                 }
             });
          }
          _each(data, function(task) {
              var item = {
                  data: task,
                  priority: priority,
                  callback: typeof callback === 'function' ? callback : null
              };

              q.tasks.splice(_binarySearch(q.tasks, item, _compareTasks) + 1, 0, item);

              if (q.saturated && q.tasks.length === q.concurrency) {
                  q.saturated();
              }
              async.setImmediate(q.process);
          });
        }

        // Start with a normal queue
        var q = async.queue(worker, concurrency);

        // Override push to accept second parameter representing priority
        q.push = function (data, priority, callback) {
          _insert(q, data, priority, callback);
        };

        // Remove unshift function
        delete q.unshift;

        return q;
    };

    async.cargo = function (worker, payload) {
        var working     = false,
            tasks       = [];

        var cargo = {
            tasks: tasks,
            payload: payload,
            saturated: null,
            empty: null,
            drain: null,
            drained: true,
            push: function (data, callback) {
                if (!_isArray(data)) {
                    data = [data];
                }
                _each(data, function(task) {
                    tasks.push({
                        data: task,
                        callback: typeof callback === 'function' ? callback : null
                    });
                    cargo.drained = false;
                    if (cargo.saturated && tasks.length === payload) {
                        cargo.saturated();
                    }
                });
                async.setImmediate(cargo.process);
            },
            process: function process() {
                if (working) return;
                if (tasks.length === 0) {
                    if(cargo.drain && !cargo.drained) cargo.drain();
                    cargo.drained = true;
                    return;
                }

                var ts = typeof payload === 'number'
                            ? tasks.splice(0, payload)
                            : tasks.splice(0, tasks.length);

                var ds = _map(ts, function (task) {
                    return task.data;
                });

                if(cargo.empty) cargo.empty();
                working = true;
                worker(ds, function () {
                    working = false;

                    var args = arguments;
                    _each(ts, function (data) {
                        if (data.callback) {
                            data.callback.apply(null, args);
                        }
                    });

                    process();
                });
            },
            length: function () {
                return tasks.length;
            },
            running: function () {
                return working;
            }
        };
        return cargo;
    };

    var _console_fn = function (name) {
        return function (fn) {
            var args = Array.prototype.slice.call(arguments, 1);
            fn.apply(null, args.concat([function (err) {
                var args = Array.prototype.slice.call(arguments, 1);
                if (typeof console !== 'undefined') {
                    if (err) {
                        if (console.error) {
                            console.error(err);
                        }
                    }
                    else if (console[name]) {
                        _each(args, function (x) {
                            console[name](x);
                        });
                    }
                }
            }]));
        };
    };
    async.log = _console_fn('log');
    async.dir = _console_fn('dir');
    /*async.info = _console_fn('info');
    async.warn = _console_fn('warn');
    async.error = _console_fn('error');*/

    async.memoize = function (fn, hasher) {
        var memo = {};
        var queues = {};
        hasher = hasher || function (x) {
            return x;
        };
        var memoized = function () {
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            var key = hasher.apply(null, args);
            if (key in memo) {
                async.nextTick(function () {
                    callback.apply(null, memo[key]);
                });
            }
            else if (key in queues) {
                queues[key].push(callback);
            }
            else {
                queues[key] = [callback];
                fn.apply(null, args.concat([function () {
                    memo[key] = arguments;
                    var q = queues[key];
                    delete queues[key];
                    for (var i = 0, l = q.length; i < l; i++) {
                      q[i].apply(null, arguments);
                    }
                }]));
            }
        };
        memoized.memo = memo;
        memoized.unmemoized = fn;
        return memoized;
    };

    async.unmemoize = function (fn) {
      return function () {
        return (fn.unmemoized || fn).apply(null, arguments);
      };
    };

    async.times = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.map(counter, iterator, callback);
    };

    async.timesSeries = function (count, iterator, callback) {
        var counter = [];
        for (var i = 0; i < count; i++) {
            counter.push(i);
        }
        return async.mapSeries(counter, iterator, callback);
    };

    async.seq = function (/* functions... */) {
        var fns = arguments;
        return function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            async.reduce(fns, args, function (newargs, fn, cb) {
                fn.apply(that, newargs.concat([function () {
                    var err = arguments[0];
                    var nextargs = Array.prototype.slice.call(arguments, 1);
                    cb(err, nextargs);
                }]));
            },
            function (err, results) {
                callback.apply(that, [err].concat(results));
            });
        };
    };

    async.compose = function (/* functions... */) {
      return async.seq.apply(null, Array.prototype.reverse.call(arguments));
    };

    var _applyEach = function (eachfn, fns /*args...*/) {
        var go = function () {
            var that = this;
            var args = Array.prototype.slice.call(arguments);
            var callback = args.pop();
            return eachfn(fns, function (fn, cb) {
                fn.apply(that, args.concat([cb]));
            },
            callback);
        };
        if (arguments.length > 2) {
            var args = Array.prototype.slice.call(arguments, 2);
            return go.apply(this, args);
        }
        else {
            return go;
        }
    };
    async.applyEach = doParallel(_applyEach);
    async.applyEachSeries = doSeries(_applyEach);

    async.forever = function (fn, callback) {
        function next(err) {
            if (err) {
                if (callback) {
                    return callback(err);
                }
                throw err;
            }
            fn(next);
        }
        next();
    };

    // Node.js
    if (module.exports) {
        module.exports = async;
    }
    // AMD / RequireJS
    else {
        root.async = async;
    }

}());
});

var shellEscape = shellescape;

// return a shell compatible format
function shellescape(a) {
  var ret = [];

  a.forEach(function(s) {
    if (!/^[A-Za-z0-9_\/-]+$/.test(s)) {
      s = "'"+s.replace(/'/g,"'\\''")+"'";
      s = s.replace(/^(?:'')+/g, '') // unduplicate single-quote at the beginning
        .replace(/\\'''/g, "\\'" ); // remove non-escaped single-quote if there are enclosed between 2 escaped
    }
    ret.push(s);
  });

  return ret.join(' ');
}

var fsPath = {
  _win32: process.platform === 'win32',
  _supportExecSync: function () {
    if (!child_process.execSync) {
      throw new Error('your node.js version is to low(<0.11.12).')
    }
    return this;
  },
  mkdir: function (dist, callback) {
    var dirs = [];
    dist = path.resolve(dist);
    dist.split(/[\\\/]/).reduce(function (first, second) {
      var _path = path.join(first || '/', second);
      dirs.push(_path);
      return _path;
    });
    async.eachSeries(dirs, function (_path, callback) {
      fs.exists(_path, function (exists) {
        if (exists) {
          callback(null);
        } else {
          fs.mkdir(_path, function (err) {
            callback(!err || err.code === 'EEXIST' ? null : err);
          });
        }
      });
    }, function (err) {
      callback && callback(err);
    });
  },
  mkdirSync: function (dist) {
    dist = path.resolve(dist);
    if (!fs.existsSync(dist)) {
      fsPath.mkdirSync(path.dirname(dist));
      fs.mkdirSync(dist);
    }
  },
  copy: function (from, dist, callback) {
    var that = this,
      cmd = '';
    dist = path.resolve(dist);
    fs.lstat(from, function (err, stats) {
      if (err) {
        callback(err);
      } else {
        if (stats.isDirectory()) {
          that.mkdir(dist, function (err) {
            if (err) {
              callback(err);
            } else {
              if (that._win32) {
                cmd = 'echo d|xcopy /s /e /y ' + shellEscape([path.join(from, '*')]) + ' ' + shellEscape([dist]);
              } else {
                cmd = 'cp -f -R -p ' + shellEscape([path.join(from, '*')]) + ' ' + shellEscape([dist]);
              }
              var command = cmd.split(' ');
              child_process.execFile(command[0], command.slice(1), function (error, stdout, stderr) {
                callback && callback(error);
              });
            }
          });
        } else if (stats.isFile()) {
          if (that._win32) {
            cmd = 'echo f|xcopy /y ' + shellEscape([from]) + ' ' + shellEscape([dist]);
          } else {
            cmd = 'cp -f -p ' + shellEscape([from]) + ' ' + shellEscape([dist]);
          }
          var command = cmd.split(' ');
          child_process.execFile(command[0], command.slice(1), function (error, stdout, stderr) {
            callback && callback(error);
          });
        } else {
          callback && callback(null);
        }
      }
    });
  },
  copySync: function (from, dist) {
    this._supportExecSync();
    try {
      var cmd = '';
      var stats = fs.lstatSync(from);
      dist = path.resolve(dist);
      if (stats.isDirectory()) {
        if (this._win32) {
          // windows
          cmd = 'echo da|xcopy /s /e ' + shellEscape([path.join(from, '*')]) + ' ' + shellEscape([dist]);
        } else {
          // linux or mac
          cmd = 'cp -f -R -p ' + shellEscape([path.join(from, '*')]) + ' ' + shellEscape([dist]);
        }
      } else if (stats.isFile()) {
        if (this._win32) {
          // windows
          cmd = 'echo fa|xcopy ' + shellEscape([from]) + ' ' + shellEscape([dist]);
        } else {
          // linux or mac
          cmd = 'cp -f -p ' + shellEscape([from]) + ' ' + shellEscape([dist]);
        }
      }
      var command = cmd.split(' ');
      cmd && child_process.execFileSync(command[0], command.slice(1));
    } catch (e) {}
  },
  remove: function (from, callback) {
    var that = this,
      cmd = '';
    fs.lstat(from, function (err, stats) {
      if (err) {
        callback(err);
      } else {
        if (that._win32) {
          // windows
          if (stats.isDirectory()) {
            cmd = 'rd /s /q ' + shellEscape([from]);
          } else if (stats.isFile()) {
            cmd = 'del /f ' + shellEscape([from]);
          }
        } else {
          // linux or mac
          cmd = 'rm -rf ' + shellEscape([from]);
        }
        if (cmd) {
          var command = cmd.split(' ');
          child_process.execFile(command[0], command.slice(1), function (error, stdout, stderr) {
            callback && callback(error);
          });
        } else {
          callback && callback(null);
        }
      }
    });
  },
  removeSync: function (from) {
    this._supportExecSync();
    try {
      var cmd = '';
      var stats = fs.lstatSync(from);
      if (this._win32) {
        // windows
        if (stats.isDirectory()) {
          cmd = 'rd /s /q ' + shellEscape([from]);
        } else if (stats.isFile()) {
          cmd = 'del /f ' + shellEscape([from]);
        }
      } else {
        // linux or mac
        cmd = 'rm -rf ' + shellEscape([from]);
      }
      var command = cmd.split(' ');
      cmd && child_process.execFileSync(command[0], command.slice(1));
    } catch (e) {}
  },
  find: function (from, filter, callback) {
    var filelist = {
      dirs: [],
      files: []
    };
    if (arguments.length < 3) {
      callback = filter;
      filter = null;
    }
    fs.readdir(from, function (err, files) {
      if (err) {
        callback && callback(err);
      } else {
        async.each(files, function (file, callback) {
          var filepath = path.join(from, file);
          fs.lstat(filepath, function (err, stats) {
            if (err) {
              callback(err);
            } else {
              if (stats.isDirectory()) {
                if (!filter || filter(filepath, 'directory', file)) {
                  filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);
                  fsPath.find(filepath, filter, function (err, files) {
                    if (err) {
                      callback && callback(err);
                    } else {
                      files.dirs.forEach(function (_dir) {
                        filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);
                      });
                      filelist.files = filelist.files.concat(files.files);
                      callback && callback(null);
                    }
                  });
                } else {
                  callback && callback(null);
                }
              } else if (stats.isFile()) {
                if (!filter || filter(filepath, 'file', file)) {
                  filelist.files.push(filepath);
                }
                callback && callback(null);
              } else {
                callback && callback(null);
              }
            }
          });
        }, function (err) {
          if (err) {
            callback && callback(err);
          } else {
            callback && callback(null, filelist);
          }
        });
      }
    });
  },
  findSync: function (from, filter) {
    var filelist = {
      dirs: [],
      files: []
    };
    fs.readdirSync(from).forEach(function (file) {
      var filepath = path.join(from, file);
      var stats = fs.lstatSync(filepath);
      if (stats.isDirectory()) {
        if (!filter || filter(filepath, 'directory', file)) {
          filelist.dirs.indexOf(filepath) === -1 && filelist.dirs.push(filepath);
          var files = fsPath.findSync(filepath, filter);
          files.dirs.forEach(function (_dir) {
            filelist.dirs.indexOf(_dir) === -1 && filelist.dirs.push(_dir);
          });
          filelist.files = filelist.files.concat(files.files);
        }
      } else if (stats.isFile()) {
        if (!filter || filter(filepath, 'file', file)) {
          filelist.files.push(filepath);
        }
      }
    });
    return filelist;
  },
  writeFile: function (dist, content, encoding, callback) {
    dist = path.resolve(dist);
    if (typeof encoding === 'function') {
      callback = encoding;
      encoding = 'utf-8';
    }
    fsPath.mkdir(path.dirname(dist), function (err) {
      if (err) {
        callback(err);
      } else {
        fs.writeFile(dist, content, {
          encoding: encoding
        }, callback);
      }
    });
  },
  writeFileSync: function (dist, content, encoding) {
    dist = path.resolve(dist);
    if (typeof encoding === 'function') {
      callback = encoding;
      encoding = 'utf-8';
    }
    fsPath.mkdirSync(path.dirname(dist));
    fs.writeFileSync(dist, content, {
      encoding: encoding
    });
  }
};

//Robot Status Class (as distinguished from the robot_status 1D array of 60 elts.

var RobotStatus$1 = class RobotStatus{
    //below work for g0 and g1
    constructor({robot_status="required"}){
        this.robot_status = robot_status; //for g0, the array has degrees, etc.
                                         //for g1+ the array has low level numbers, ie arcseconds,
                                         //unchanged from what Dexter sends to DDE.
                                         //But methods like measured_angle return degrees.
    }
    job_id()                        { return this.robot_status[Dexter$1.JOB_ID]}
    instruction_id()                { return this.robot_status[Dexter$1.INSTRUCTION_ID]}
    start_time()                    { return this.robot_status[Dexter$1.START_TIME]}
    stop_time()                     { return this.robot_status[Dexter$1.STOP_TIME]}
    instruction_type()              { return this.robot_status[Dexter$1.INSTRUCTION_TYPE]}
    error_code()                    { return this.robot_status[Dexter$1.ERROR_CODE]}
    dma_read_data()                 { return this.robot_status[Dexter$1.DMA_READ_INSTRUCTION]}
    read_block_count()              { return this.robot_status[Dexter$1.READ_BLOCK_COUNT]}
    end_effector_io_in()            { return this.robot_status[Dexter$1.END_EFFECTOR_IO_IN]} //was end_effector_io_in

    status_mode(){
        return RobotStatus.array_status_mode(this.robot_status)
    }

    static array_status_mode(robot_status_array){
        let raw = robot_status_array[Dexter$1.STATUS_MODE];
        if      (typeof(raw) === "string") { return parseInt(raw) }
        else if (typeof(raw === "number")) { return raw }
    }

    static is_other_status_mode(sm){ //such status_modes will use generic table display.
        return ![0, 1, 2].includes(sm)
    }

    supports_measured_angles(){
        return (this.status_mode() < 3)
    }

    value_at_index(index){
        if((index < 0) || (index > 59)) {
            return this.robot_status(index)
        }
        else {
            dde_error("RobotStatus.value_at_index called with index that's not between 0 and 59 iclusive: " + index);
        }
    }

    //below for g0 only
    angle(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_ANGLE";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else {
                  dde_error("RobotStatus.angle passed joint_number: " + joint_number +
                             "<br/> but the value of that is: " + result +
                             "<br/> when it should be a number." +
                             "<br/>The whole robot status is: " + this.robot_status);

                 }
        }
        else {
            dde_error("RobotStatus.angle is invalid for status_mode: " + sm);
        }
    }

    angles(joint_count=5){
        let sm = this.status_mode();
        if(sm === 0) {
            let result = [];
            for(let j_number = 1; j_number <= joint_count;  j_number++){
                result.push(this.angle(j_number));
            }
            return result
        }
        else {
            dde_error("RobotStatus.angles is invalid for status_mode: " + sm);
        }
    }

    delta(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_DELTA";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.delta passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else {
            dde_error("RobotStatus.delta is invalid for status_mode: " + sm);
        }
    }

    deltas(joint_count=5){
        let sm = this.status_mode();
        if(sm === 0) {
            let result = [];
            for(let j_number = 1; j_number <= joint_count;  j_number++){
                result.push(this.delta(j_number));
            }
            return result
        }
        else {
            dde_error("RobotStatus.deltas is invalid for status_mode: " + sm);
        }
    }

    pid_delta(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_PID_DELTA";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.pid_delta passed joint_number: " + joint_number + " which isn't valid."); }
        }
        if(sm === 2) {
            let label = "Dexter.J" + joint_number + "_PID_DELTA_G2";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.pid_delta passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else {
            dde_error("RobotStatus.pid_delta is invalid for status_mode: " + sm);
        }
    }

    pid_deltas(joint_count=5){
        let sm = this.status_mode();
        if(sm === 0) {
            let result = [];
            for(let j_number = 1; j_number <= joint_count;  j_number++){
                result.push(this.pid_delta(j_number));
            }
            return result
        }
        else {
            dde_error("RobotStatus.pid_deltas is invalid for status_mode: " + sm);
        }
    }

    /*force_calc_angle(joint_number){
        let result = this.robot_status["J" + joint_number + "_FORCE_CALC_ANGLE"]
        if(typeof(result) == "number") { return result}
        else { dde_error("RobotStatus.force_calc_angle passed joint_number: " + joint_number + " which isn't valid.") }
    }

    force_calc_angles(joint_count=5){
        let result = []
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.force_calc_angle(j_number))
        }
        return result
    }*/

    a2d_sin(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_A2D_SIN";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.a2d_sin passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else if(sm === 2) {
            let label = "Dexter.J" + joint_number + "_A2D_SIN_G2";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.a2d_sin passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else {
            dde_error("RobotStatus.a2d_sin is invalid for status_mode: " + sm);
        }
    }

    a2d_sins(joint_count=5){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.a2d_sin(j_number));
        }
        return result
    }

    a2d_cos(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_A2D_COS";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.a2d_cos passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else if(sm === 2) {
            let label = "Dexter.J" + joint_number + "_A2D_COS_G2";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) == "number") { return result}
            else { dde_error("RobotStatus.a2d_cos passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else {
            dde_error("RobotStatus.a2d_cos is invalid for status_mode: " + sm);
        }
    }

    a2d_coses(joint_count=5){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.a2d_cos(j_number));
        }
        return result

    }

    sent(joint_number){
        let sm = this.status_mode();
        if(sm === 0) {
            let label = "Dexter.J" + joint_number + "_SENT";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) === "number") { return result}
            else { dde_error("RobotStatus.sent passed joint_number: " + joint_number + " which isn't valid."); }
        }
        if(sm === 2) {
            let label = "Dexter.J" + joint_number + "_SENT";
            let index = value_of_path(label);
            let result = this.robot_status[index];
            if(typeof(result) === "number") { return result}
            else { dde_error("RobotStatus.sent passed joint_number: " + joint_number + " which isn't valid."); }
        }
        else {
            dde_error("RobotStatus.sent is invalid for status_mode: " + sm);
        }
    }

    sents(joint_count=5){
        let sm = this.status_mode();
        if((sm === 0) || (sm === 2)) {
            let result = [];
            for(let j_number = 1; j_number <= joint_count;  j_number++){
                result.push(this.sent(j_number));
            }
            return result
        }
        else {
            dde_error("RobotStatus.sents is invalid for status_mode: " + sm);
        }
    }

    //works for g0 & g1  returns angle in degrees except
    //if raw=true, then return the number in the array without converting
    //used in
    measured_angle(joint_number, raw=false) {
        let sm = this.status_mode();
        if(sm === 0) {
            if      (joint_number == 1) { return this.robot_status[Dexter$1.J1_MEASURED_ANGLE] }
            else if (joint_number == 2) { return this.robot_status[Dexter$1.J2_MEASURED_ANGLE] }
            else if (joint_number == 3) { return this.robot_status[Dexter$1.J3_MEASURED_ANGLE] }
            else if (joint_number == 4) { return this.robot_status[Dexter$1.J4_MEASURED_ANGLE] }
            else if (joint_number == 5) { return this.robot_status[Dexter$1.J5_MEASURED_ANGLE] }
            else if (joint_number == 6) { return this.robot_status[Dexter$1.J6_MEASURED_ANGLE] }
            else if (joint_number == 7) { return this.robot_status[Dexter$1.J7_MEASURED_ANGLE] }
            else {
                dde_error("RobotStatus.measured_angle passed invalid joint_number of: " + joint_number +
                          "<br/>Valid numbers are 1 through 7.");
            }
        }
        else if (sm === 1) {
            if((joint_number >= 0) && (joint_number <= 10)){
                let index = 9 + joint_number;
                let result = this.robot_status[index];
                if(!raw) { result = result / 3600; } //the usual case
                return result
            }
            else {
                dde_error("RobotStatus.measured_angle passed invalid joint_number of: " + joint_number +
                          "<br/>Valid numbers are 1 through 7.");
            }
        }
        if(sm === 2) {
            if((joint_number >= 0) && (joint_number <= 7)) {
                if      (joint_number == 1) { return this.robot_status[Dexter$1.J1_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 2) { return this.robot_status[Dexter$1.J2_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 3) { return this.robot_status[Dexter$1.J3_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 4) { return this.robot_status[Dexter$1.J4_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 5) { return this.robot_status[Dexter$1.J5_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 6) { return this.robot_status[Dexter$1.J6_MEASURED_ANGLE_G2] / 3600 }
                else if (joint_number == 7) { return this.robot_status[Dexter$1.J7_MEASURED_ANGLE_G2] / 3600 }
            }
            else {
                dde_error("RobotStatus.measured_angle passed invalid joint_number of: " + joint_number +
                    "<br/>Valid numbers are 1 through 7.");
            }
        }
        else {
            dde_error("RobotStatus.measured_angle isn't supported for status_mode of " + sm);
        }
    }

    //works for g0 & g1 returns angle in degrees
    measured_angles(joint_count=7, raw=false){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.measured_angle(j_number, raw));
        }
        return result
    }

    //array_of_measured_angles is in degrees
    //if raw is true, don't modify array_of_measured_angles when shoving them into the array
    //array_of_measured_angles expected to be in degrees, but if raw = true, it doesn't matter.
    set_measured_angles(array_of_measured_angles, raw=false){
        let rs_array = this.robot_status;
        let sm = this.status_mode();
        if(sm === 0) { //angles in rs_array are in degrees
            rs_array[Dexter$1.J1_MEASURED_ANGLE] = array_of_measured_angles[0];
            rs_array[Dexter$1.J2_MEASURED_ANGLE] = array_of_measured_angles[1];
            rs_array[Dexter$1.J3_MEASURED_ANGLE] = array_of_measured_angles[2];
            rs_array[Dexter$1.J4_MEASURED_ANGLE] = array_of_measured_angles[3];
            rs_array[Dexter$1.J5_MEASURED_ANGLE] = array_of_measured_angles[4];
            rs_array[Dexter$1.J6_MEASURED_ANGLE] = array_of_measured_angles[5];
            rs_array[Dexter$1.J7_MEASURED_ANGLE] = array_of_measured_angles[6];
        }
        else if (sm === 1) { //angles in rs_array are in arcseconds
            for(let i = 0; i < 7; i++){
                let new_val = array_of_measured_angles[i];
                if(!raw) { new_val = new_val * 3600; } //usual
                rs_array[10 + i] = new_val;
            }
        }
        else if(sm === 2) { //angles in rs_array are in degrees
            rs_array[Dexter$1.J1_MEASURED_ANGLE_G2] = array_of_measured_angles[0];
            rs_array[Dexter$1.J2_MEASURED_ANGLE_G2] = array_of_measured_angles[1];
            rs_array[Dexter$1.J3_MEASURED_ANGLE_G2] = array_of_measured_angles[2];
            rs_array[Dexter$1.J4_MEASURED_ANGLE_G2] = array_of_measured_angles[3];
            rs_array[Dexter$1.J5_MEASURED_ANGLE_G2] = array_of_measured_angles[4];
            rs_array[Dexter$1.J6_MEASURED_ANGLE_G2] = array_of_measured_angles[5];
            rs_array[Dexter$1.J7_MEASURED_ANGLE_G2] = array_of_measured_angles[6];
        }
        else {
            dde_error("RobotStatus.set_measured_angles can't handle status_mode: " + sm);
        }
    }

    //works only for g1
    torque(joint_number) {
        if(this.status_mode() === 1) {
            if((joint_number >= 0) && (joint_number <= 7)) {
                let index = 19 + joint_number;
                return this.robot_status[index] / 1000000
            }
            else {
                dde_error("RobotStatus.torque passed invalid joint_number of: " + joint_number +
                    "<br/>Valid numbers are 1 through 7.");
            }
        }
        else {
            dde_error("RobotStatus.torque called using status_mode " + sm + ", but it only works for 1.");
        }
    }

    //works only for g1
    torques(joint_count=7){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.torque(j_number));
        }
        return result
    }

    //works only for g1 returned value is in degrees per second
    velocity(joint_number) {
        if(this.status_mode() === 1) {
            if((joint_number >= 0) && (joint_number <= 7)) {
                let index = 29 + joint_number;
                return this.robot_status[index] / 3600
            }
            else {
                dde_error("RobotStatus.velocity passed invalid joint_number of: " + joint_number +
                    "<br/>Valid numbers are 1 through 7.");
            }
        }
        else {
            dde_error("RobotStatus.velocity called using status_mode " + sm + ", but it only works for 1.");
        }
    }

    //works only for g1  returned values are in degrees per second
    velocities(joint_count=7){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.velocity(j_number));
        }
        return result
    }

    raw_encoder_angle(joint_number) {
        let sm = this.status_mode();
        if(sm === 2) {
            if      (joint_number == 1) { return this.robot_status[Dexter$1.J1_RAW_ENCODER_ANGLE_FXP_G2] }
            else if (joint_number == 2) { return this.robot_status[Dexter$1.J2_RAW_ENCODER_ANGLE_FXP_G2] }
            else if (joint_number == 3) { return this.robot_status[Dexter$1.J3_RAW_ENCODER_ANGLE_FXP_G2] }
            else if (joint_number == 4) { return this.robot_status[Dexter$1.J4_RAW_ENCODER_ANGLE_FXP_G2] }
            else if (joint_number == 5) { return this.robot_status[Dexter$1.J5_RAW_ENCODER_ANGLE_FXP_G2] }
            else {
                dde_error("RobotStatus.measured_angle passed invalid joint_number of: " + joint_number +
                    "<br/>Valid numbers are 1 through 5.");
            }
        }
        else {
            dde_error("RobotStatus.raw_encoder_angle called using status_mode: " + sm + ", but it only works for 2.");
        }
    }

    raw_encoder_angles(joint_count=5){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.raw_encoder_angle(j_number));
        }
        return result
    }

    eye_number(joint_number) {
        let sm = this.status_mode();
        if(sm === 2) {
            if      (joint_number == 1) { return this.robot_status[Dexter$1.J1_EYE_NUMBER_G2] }
            else if (joint_number == 2) { return this.robot_status[Dexter$1.J2_EYE_NUMBER_G2] }
            else if (joint_number == 3) { return this.robot_status[Dexter$1.J3_EYE_NUMBER_G2] }
            else if (joint_number == 4) { return this.robot_status[Dexter$1.J4_EYE_NUMBER_G2] }
            else if (joint_number == 5) { return this.robot_status[Dexter$1.J5_EYE_NUMBER_G2] }
            else {
                dde_error("RobotStatus.measured_angle passed invalid joint_number of: " + joint_number +
                    "<br/>Valid numbers are 1 through 5.");
            }
        }
        else {
            dde_error("RobotStatus.raw_encoder_angle called using status_mode: " + sm + ", but it only works for 2.");
        }
    }

    eye_numbers(joint_count=5){
        let result = [];
        for(let j_number = 1; j_number <= joint_count;  j_number++){
            result.push(this.eye_number(j_number));
        }
        return result
    }


    //returns array. First elt is an array of x,y,z
    xyz(){
        let joint_angles = this.measured_angles(5);
        return Kin.J_angles_to_xyz(joint_angles)
    }

    static fill_robot_status_array_with_another(rs_array_to_modify, source_of_values_rs_array, raw=false){
       for(let i = 0; i < 10; i++){
           if(i !== Dexter$1.STATUS_MODE) { //don't change the status_mode of rs_array_to_modify, as that's the real reason we're calling this whole method
                rs_array_to_modify[i] = source_of_values_rs_array[i];
           }
       }
       let arr_mod_RS = new RobotStatus({robot_status: rs_array_to_modify});
       let arr_src_RS = new RobotStatus({robot_status: source_of_values_rs_array});
       let arr_src_mes_angs = arr_src_RS.measured_angles(7, raw);
       arr_mod_RS.set_measured_angles(arr_src_mes_angs, raw);
    }

};

var esprima = createCommonjsModule(function (module, exports) {
(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	module.exports = factory();
})(commonjsGlobal, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements ⊆ AssignmentTargets ⊆ AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
});

var esprima$1 = /*@__PURE__*/getDefaultExportFromCjs(esprima);

// Use the fastest means possible to execute a task in its own turn, with
// priority over other events including IO, animation, reflow, and redraw
// events in browsers.
//
// An exception thrown by a task will permanently interrupt the processing of
// subsequent tasks. The higher level `asap` function ensures that if an
// exception is thrown by a task, that the task queue will continue flushing as
// soon as possible, but if you use `rawAsap` directly, you are responsible to
// either ensure that no exceptions are thrown from your task, or to manually
// call `rawAsap.requestFlush` if an exception is thrown.
var browserRaw = rawAsap;
function rawAsap(task) {
    if (!queue.length) {
        requestFlush();
    }
    // Equivalent to push, but avoids a function call.
    queue[queue.length] = task;
}

var queue = [];
// `requestFlush` is an implementation-specific method that attempts to kick
// off a `flush` event as quickly as possible. `flush` will attempt to exhaust
// the event queue before yielding to the browser's own event loop.
var requestFlush;
// The position of the next task to execute in the task queue. This is
// preserved between calls to `flush` so that it can be resumed if
// a task throws an exception.
var index = 0;
// If a task schedules additional tasks recursively, the task queue can grow
// unbounded. To prevent memory exhaustion, the task queue will periodically
// truncate already-completed tasks.
var capacity = 1024;

// The flush function processes all tasks that have been scheduled with
// `rawAsap` unless and until one of those tasks throws an exception.
// If a task throws an exception, `flush` ensures that its state will remain
// consistent and will resume where it left off when called again.
// However, `flush` does not make any arrangements to be called again if an
// exception is thrown.
function flush() {
    while (index < queue.length) {
        var currentIndex = index;
        // Advance the index before calling the task. This ensures that we will
        // begin flushing on the next task the task throws an error.
        index = index + 1;
        queue[currentIndex].call();
        // Prevent leaking memory for long chains of recursive calls to `asap`.
        // If we call `asap` within tasks scheduled by `asap`, the queue will
        // grow, but to avoid an O(n) walk for every task we execute, we don't
        // shift tasks off the queue after they have been executed.
        // Instead, we periodically shift 1024 tasks off the queue.
        if (index > capacity) {
            // Manually shift all values starting at the index back to the
            // beginning of the queue.
            for (var scan = 0, newLength = queue.length - index; scan < newLength; scan++) {
                queue[scan] = queue[scan + index];
            }
            queue.length -= index;
            index = 0;
        }
    }
    queue.length = 0;
    index = 0;
}

// `requestFlush` is implemented using a strategy based on data collected from
// every available SauceLabs Selenium web driver worker at time of writing.
// https://docs.google.com/spreadsheets/d/1mG-5UYGup5qxGdEMWkhP6BWCz053NUb2E1QoUTU16uA/edit#gid=783724593

// Safari 6 and 6.1 for desktop, iPad, and iPhone are the only browsers that
// have WebKitMutationObserver but not un-prefixed MutationObserver.
// Must use `global` or `self` instead of `window` to work in both frames and web
// workers. `global` is a provision of Browserify, Mr, Mrs, or Mop.

/* globals self */
var scope = typeof commonjsGlobal !== "undefined" ? commonjsGlobal : self;
var BrowserMutationObserver = scope.MutationObserver || scope.WebKitMutationObserver;

// MutationObservers are desirable because they have high priority and work
// reliably everywhere they are implemented.
// They are implemented in all modern browsers.
//
// - Android 4-4.3
// - Chrome 26-34
// - Firefox 14-29
// - Internet Explorer 11
// - iPad Safari 6-7.1
// - iPhone Safari 7-7.1
// - Safari 6-7
if (typeof BrowserMutationObserver === "function") {
    requestFlush = makeRequestCallFromMutationObserver(flush);

// MessageChannels are desirable because they give direct access to the HTML
// task queue, are implemented in Internet Explorer 10, Safari 5.0-1, and Opera
// 11-12, and in web workers in many engines.
// Although message channels yield to any queued rendering and IO tasks, they
// would be better than imposing the 4ms delay of timers.
// However, they do not work reliably in Internet Explorer or Safari.

// Internet Explorer 10 is the only browser that has setImmediate but does
// not have MutationObservers.
// Although setImmediate yields to the browser's renderer, it would be
// preferrable to falling back to setTimeout since it does not have
// the minimum 4ms penalty.
// Unfortunately there appears to be a bug in Internet Explorer 10 Mobile (and
// Desktop to a lesser extent) that renders both setImmediate and
// MessageChannel useless for the purposes of ASAP.
// https://github.com/kriskowal/q/issues/396

// Timers are implemented universally.
// We fall back to timers in workers in most engines, and in foreground
// contexts in the following browsers.
// However, note that even this simple case requires nuances to operate in a
// broad spectrum of browsers.
//
// - Firefox 3-13
// - Internet Explorer 6-9
// - iPad Safari 4.3
// - Lynx 2.8.7
} else {
    requestFlush = makeRequestCallFromTimer(flush);
}

// `requestFlush` requests that the high priority event queue be flushed as
// soon as possible.
// This is useful to prevent an error thrown in a task from stalling the event
// queue if the exception handled by Node.js’s
// `process.on("uncaughtException")` or by a domain.
rawAsap.requestFlush = requestFlush;

// To request a high priority event, we induce a mutation observer by toggling
// the text of a text node between "1" and "-1".
function makeRequestCallFromMutationObserver(callback) {
    var toggle = 1;
    var observer = new BrowserMutationObserver(callback);
    var node = document.createTextNode("");
    observer.observe(node, {characterData: true});
    return function requestCall() {
        toggle = -toggle;
        node.data = toggle;
    };
}

// The message channel technique was discovered by Malte Ubl and was the
// original foundation for this library.
// http://www.nonblocking.io/2011/06/windownexttick.html

// Safari 6.0.5 (at least) intermittently fails to create message ports on a
// page's first load. Thankfully, this version of Safari supports
// MutationObservers, so we don't need to fall back in that case.

// function makeRequestCallFromMessageChannel(callback) {
//     var channel = new MessageChannel();
//     channel.port1.onmessage = callback;
//     return function requestCall() {
//         channel.port2.postMessage(0);
//     };
// }

// For reasons explained above, we are also unable to use `setImmediate`
// under any circumstances.
// Even if we were, there is another bug in Internet Explorer 10.
// It is not sufficient to assign `setImmediate` to `requestFlush` because
// `setImmediate` must be called *by name* and therefore must be wrapped in a
// closure.
// Never forget.

// function makeRequestCallFromSetImmediate(callback) {
//     return function requestCall() {
//         setImmediate(callback);
//     };
// }

// Safari 6.0 has a problem where timers will get lost while the user is
// scrolling. This problem does not impact ASAP because Safari 6.0 supports
// mutation observers, so that implementation is used instead.
// However, if we ever elect to use timers in Safari, the prevalent work-around
// is to add a scroll event listener that calls for a flush.

// `setTimeout` does not call the passed callback if the delay is less than
// approximately 7 in web workers in Firefox 8 through 18, and sometimes not
// even then.

function makeRequestCallFromTimer(callback) {
    return function requestCall() {
        // We dispatch a timeout with a specified delay of 0 for engines that
        // can reliably accommodate that request. This will usually be snapped
        // to a 4 milisecond delay, but once we're flushing, there's no delay
        // between events.
        var timeoutHandle = setTimeout(handleTimer, 0);
        // However, since this timer gets frequently dropped in Firefox
        // workers, we enlist an interval handle that will try to fire
        // an event 20 times per second until it succeeds.
        var intervalHandle = setInterval(handleTimer, 50);

        function handleTimer() {
            // Whichever timer succeeds will cancel both timers and
            // execute the callback.
            clearTimeout(timeoutHandle);
            clearInterval(intervalHandle);
            callback();
        }
    };
}

// This is for `asap.js` only.
// Its name will be periodically randomized to break any code that depends on
// its existence.
rawAsap.makeRequestCallFromTimer = makeRequestCallFromTimer;

// rawAsap provides everything we need except exception management.

// RawTasks are recycled to reduce GC churn.
var freeTasks = [];
// We queue errors to ensure they are thrown in right order (FIFO).
// Array-as-queue is good enough here, since we are just dealing with exceptions.
var pendingErrors = [];
var requestErrorThrow = browserRaw.makeRequestCallFromTimer(throwFirstError);

function throwFirstError() {
    if (pendingErrors.length) {
        throw pendingErrors.shift();
    }
}

/**
 * Calls a task as soon as possible after returning, in its own event, with priority
 * over other events like animation, reflow, and repaint. An error thrown from an
 * event will not interrupt, nor even substantially slow down the processing of
 * other events, but will be rather postponed to a lower priority event.
 * @param {{call}} task A callable object, typically a function that takes no
 * arguments.
 */
var browserAsap = asap;
function asap(task) {
    var rawTask;
    if (freeTasks.length) {
        rawTask = freeTasks.pop();
    } else {
        rawTask = new RawTask();
    }
    rawTask.task = task;
    browserRaw(rawTask);
}

// We wrap tasks with recyclable task objects.  A task object implements
// `call`, just like a function.
function RawTask() {
    this.task = null;
}

// The sole purpose of wrapping the task is to catch the exception and recycle
// the task object after its single use.
RawTask.prototype.call = function () {
    try {
        this.task.call();
    } catch (error) {
        if (asap.onerror) {
            // This hook exists purely for testing purposes.
            // Its name will be periodically randomized to break any code that
            // depends on its existence.
            asap.onerror(error);
        } else {
            // In a web browser, exceptions are not fatal. However, to avoid
            // slowing down the queue of pending tasks, we rethrow the error in a
            // lower priority turn.
            pendingErrors.push(error);
            requestErrorThrow();
        }
    } finally {
        this.task = null;
        freeTasks[freeTasks.length] = this;
    }
};

createCommonjsModule(function (module, exports) {
(function(root) {

  function isBase64(v, opts) {
    if (v instanceof Boolean || typeof v === 'boolean') {
      return false
    }

    if (!(opts instanceof Object)) {
      opts = {};
    }

    if (opts.allowEmpty === false && v === '') {
      return false
    }

    var regex = '(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}==|[A-Za-z0-9+\/]{3}=)?';
    var mimeRegex = '(data:\\w+\\/[a-zA-Z\\+\\-\\.]+;base64,)';

    if (opts.mimeRequired === true) {
      regex =  mimeRegex + regex;
    } else if (opts.allowMime === true) {
      regex = mimeRegex + '?' + regex;
    }

    if (opts.paddingRequired === false) {
      regex = '(?:[A-Za-z0-9+\\/]{4})*(?:[A-Za-z0-9+\\/]{2}(==)?|[A-Za-z0-9+\\/]{3}=?)?';
    }

    return (new RegExp('^' + regex + '$', 'gi')).test(v)
  }

  {
    if (module.exports) {
      exports = module.exports = isBase64;
    }
    exports.isBase64 = isBase64;
  }
})();
});

var BigInteger = createCommonjsModule(function (module) {
var bigInt = (function (undefined$1) {

    var BASE = 1e7,
        LOG_BASE = 7,
        MAX_INT = 9007199254740992,
        MAX_INT_ARR = smallToArray(MAX_INT),
        DEFAULT_ALPHABET = "0123456789abcdefghijklmnopqrstuvwxyz";

    var supportsNativeBigInt = typeof BigInt === "function";

    function Integer(v, radix, alphabet, caseSensitive) {
        if (typeof v === "undefined") return Integer[0];
        if (typeof radix !== "undefined") return +radix === 10 && !alphabet ? parseValue(v) : parseBase(v, radix, alphabet, caseSensitive);
        return parseValue(v);
    }

    function BigInteger(value, sign) {
        this.value = value;
        this.sign = sign;
        this.isSmall = false;
    }
    BigInteger.prototype = Object.create(Integer.prototype);

    function SmallInteger(value) {
        this.value = value;
        this.sign = value < 0;
        this.isSmall = true;
    }
    SmallInteger.prototype = Object.create(Integer.prototype);

    function NativeBigInt(value) {
        this.value = value;
    }
    NativeBigInt.prototype = Object.create(Integer.prototype);

    function isPrecise(n) {
        return -MAX_INT < n && n < MAX_INT;
    }

    function smallToArray(n) { // For performance reasons doesn't reference BASE, need to change this function if BASE changes
        if (n < 1e7)
            return [n];
        if (n < 1e14)
            return [n % 1e7, Math.floor(n / 1e7)];
        return [n % 1e7, Math.floor(n / 1e7) % 1e7, Math.floor(n / 1e14)];
    }

    function arrayToSmall(arr) { // If BASE changes this function may need to change
        trim(arr);
        var length = arr.length;
        if (length < 4 && compareAbs(arr, MAX_INT_ARR) < 0) {
            switch (length) {
                case 0: return 0;
                case 1: return arr[0];
                case 2: return arr[0] + arr[1] * BASE;
                default: return arr[0] + (arr[1] + arr[2] * BASE) * BASE;
            }
        }
        return arr;
    }

    function trim(v) {
        var i = v.length;
        while (v[--i] === 0);
        v.length = i + 1;
    }

    function createArray(length) { // function shamelessly stolen from Yaffle's library https://github.com/Yaffle/BigInteger
        var x = new Array(length);
        var i = -1;
        while (++i < length) {
            x[i] = 0;
        }
        return x;
    }

    function truncate(n) {
        if (n > 0) return Math.floor(n);
        return Math.ceil(n);
    }

    function add(a, b) { // assumes a and b are arrays with a.length >= b.length
        var l_a = a.length,
            l_b = b.length,
            r = new Array(l_a),
            carry = 0,
            base = BASE,
            sum, i;
        for (i = 0; i < l_b; i++) {
            sum = a[i] + b[i] + carry;
            carry = sum >= base ? 1 : 0;
            r[i] = sum - carry * base;
        }
        while (i < l_a) {
            sum = a[i] + carry;
            carry = sum === base ? 1 : 0;
            r[i++] = sum - carry * base;
        }
        if (carry > 0) r.push(carry);
        return r;
    }

    function addAny(a, b) {
        if (a.length >= b.length) return add(a, b);
        return add(b, a);
    }

    function addSmall(a, carry) { // assumes a is array, carry is number with 0 <= carry < MAX_INT
        var l = a.length,
            r = new Array(l),
            base = BASE,
            sum, i;
        for (i = 0; i < l; i++) {
            sum = a[i] - base + carry;
            carry = Math.floor(sum / base);
            r[i] = sum - carry * base;
            carry += 1;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    BigInteger.prototype.add = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.subtract(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall) {
            return new BigInteger(addSmall(a, Math.abs(b)), this.sign);
        }
        return new BigInteger(addAny(a, b), this.sign);
    };
    BigInteger.prototype.plus = BigInteger.prototype.add;

    SmallInteger.prototype.add = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.subtract(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            if (isPrecise(a + b)) return new SmallInteger(a + b);
            b = smallToArray(Math.abs(b));
        }
        return new BigInteger(addSmall(b, Math.abs(a)), a < 0);
    };
    SmallInteger.prototype.plus = SmallInteger.prototype.add;

    NativeBigInt.prototype.add = function (v) {
        return new NativeBigInt(this.value + parseValue(v).value);
    };
    NativeBigInt.prototype.plus = NativeBigInt.prototype.add;

    function subtract(a, b) { // assumes a and b are arrays with a >= b
        var a_l = a.length,
            b_l = b.length,
            r = new Array(a_l),
            borrow = 0,
            base = BASE,
            i, difference;
        for (i = 0; i < b_l; i++) {
            difference = a[i] - borrow - b[i];
            if (difference < 0) {
                difference += base;
                borrow = 1;
            } else borrow = 0;
            r[i] = difference;
        }
        for (i = b_l; i < a_l; i++) {
            difference = a[i] - borrow;
            if (difference < 0) difference += base;
            else {
                r[i++] = difference;
                break;
            }
            r[i] = difference;
        }
        for (; i < a_l; i++) {
            r[i] = a[i];
        }
        trim(r);
        return r;
    }

    function subtractAny(a, b, sign) {
        var value;
        if (compareAbs(a, b) >= 0) {
            value = subtract(a, b);
        } else {
            value = subtract(b, a);
            sign = !sign;
        }
        value = arrayToSmall(value);
        if (typeof value === "number") {
            if (sign) value = -value;
            return new SmallInteger(value);
        }
        return new BigInteger(value, sign);
    }

    function subtractSmall(a, b, sign) { // assumes a is array, b is number with 0 <= b < MAX_INT
        var l = a.length,
            r = new Array(l),
            carry = -b,
            base = BASE,
            i, difference;
        for (i = 0; i < l; i++) {
            difference = a[i] + carry;
            carry = Math.floor(difference / base);
            difference %= base;
            r[i] = difference < 0 ? difference + base : difference;
        }
        r = arrayToSmall(r);
        if (typeof r === "number") {
            if (sign) r = -r;
            return new SmallInteger(r);
        } return new BigInteger(r, sign);
    }

    BigInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        if (this.sign !== n.sign) {
            return this.add(n.negate());
        }
        var a = this.value, b = n.value;
        if (n.isSmall)
            return subtractSmall(a, Math.abs(b), this.sign);
        return subtractAny(a, b, this.sign);
    };
    BigInteger.prototype.minus = BigInteger.prototype.subtract;

    SmallInteger.prototype.subtract = function (v) {
        var n = parseValue(v);
        var a = this.value;
        if (a < 0 !== n.sign) {
            return this.add(n.negate());
        }
        var b = n.value;
        if (n.isSmall) {
            return new SmallInteger(a - b);
        }
        return subtractSmall(b, Math.abs(a), a >= 0);
    };
    SmallInteger.prototype.minus = SmallInteger.prototype.subtract;

    NativeBigInt.prototype.subtract = function (v) {
        return new NativeBigInt(this.value - parseValue(v).value);
    };
    NativeBigInt.prototype.minus = NativeBigInt.prototype.subtract;

    BigInteger.prototype.negate = function () {
        return new BigInteger(this.value, !this.sign);
    };
    SmallInteger.prototype.negate = function () {
        var sign = this.sign;
        var small = new SmallInteger(-this.value);
        small.sign = !sign;
        return small;
    };
    NativeBigInt.prototype.negate = function () {
        return new NativeBigInt(-this.value);
    };

    BigInteger.prototype.abs = function () {
        return new BigInteger(this.value, false);
    };
    SmallInteger.prototype.abs = function () {
        return new SmallInteger(Math.abs(this.value));
    };
    NativeBigInt.prototype.abs = function () {
        return new NativeBigInt(this.value >= 0 ? this.value : -this.value);
    };


    function multiplyLong(a, b) {
        var a_l = a.length,
            b_l = b.length,
            l = a_l + b_l,
            r = createArray(l),
            base = BASE,
            product, carry, i, a_i, b_j;
        for (i = 0; i < a_l; ++i) {
            a_i = a[i];
            for (var j = 0; j < b_l; ++j) {
                b_j = b[j];
                product = a_i * b_j + r[i + j];
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
                r[i + j + 1] += carry;
            }
        }
        trim(r);
        return r;
    }

    function multiplySmall(a, b) { // assumes a is array, b is number with |b| < BASE
        var l = a.length,
            r = new Array(l),
            base = BASE,
            carry = 0,
            product, i;
        for (i = 0; i < l; i++) {
            product = a[i] * b + carry;
            carry = Math.floor(product / base);
            r[i] = product - carry * base;
        }
        while (carry > 0) {
            r[i++] = carry % base;
            carry = Math.floor(carry / base);
        }
        return r;
    }

    function shiftLeft(x, n) {
        var r = [];
        while (n-- > 0) r.push(0);
        return r.concat(x);
    }

    function multiplyKaratsuba(x, y) {
        var n = Math.max(x.length, y.length);

        if (n <= 30) return multiplyLong(x, y);
        n = Math.ceil(n / 2);

        var b = x.slice(n),
            a = x.slice(0, n),
            d = y.slice(n),
            c = y.slice(0, n);

        var ac = multiplyKaratsuba(a, c),
            bd = multiplyKaratsuba(b, d),
            abcd = multiplyKaratsuba(addAny(a, b), addAny(c, d));

        var product = addAny(addAny(ac, shiftLeft(subtract(subtract(abcd, ac), bd), n)), shiftLeft(bd, 2 * n));
        trim(product);
        return product;
    }

    // The following function is derived from a surface fit of a graph plotting the performance difference
    // between long multiplication and karatsuba multiplication versus the lengths of the two arrays.
    function useKaratsuba(l1, l2) {
        return -0.012 * l1 - 0.012 * l2 + 0.000015 * l1 * l2 > 0;
    }

    BigInteger.prototype.multiply = function (v) {
        var n = parseValue(v),
            a = this.value, b = n.value,
            sign = this.sign !== n.sign,
            abs;
        if (n.isSmall) {
            if (b === 0) return Integer[0];
            if (b === 1) return this;
            if (b === -1) return this.negate();
            abs = Math.abs(b);
            if (abs < BASE) {
                return new BigInteger(multiplySmall(a, abs), sign);
            }
            b = smallToArray(abs);
        }
        if (useKaratsuba(a.length, b.length)) // Karatsuba is only faster for certain array sizes
            return new BigInteger(multiplyKaratsuba(a, b), sign);
        return new BigInteger(multiplyLong(a, b), sign);
    };

    BigInteger.prototype.times = BigInteger.prototype.multiply;

    function multiplySmallAndArray(a, b, sign) { // a >= 0
        if (a < BASE) {
            return new BigInteger(multiplySmall(b, a), sign);
        }
        return new BigInteger(multiplyLong(b, smallToArray(a)), sign);
    }
    SmallInteger.prototype._multiplyBySmall = function (a) {
        if (isPrecise(a.value * this.value)) {
            return new SmallInteger(a.value * this.value);
        }
        return multiplySmallAndArray(Math.abs(a.value), smallToArray(Math.abs(this.value)), this.sign !== a.sign);
    };
    BigInteger.prototype._multiplyBySmall = function (a) {
        if (a.value === 0) return Integer[0];
        if (a.value === 1) return this;
        if (a.value === -1) return this.negate();
        return multiplySmallAndArray(Math.abs(a.value), this.value, this.sign !== a.sign);
    };
    SmallInteger.prototype.multiply = function (v) {
        return parseValue(v)._multiplyBySmall(this);
    };
    SmallInteger.prototype.times = SmallInteger.prototype.multiply;

    NativeBigInt.prototype.multiply = function (v) {
        return new NativeBigInt(this.value * parseValue(v).value);
    };
    NativeBigInt.prototype.times = NativeBigInt.prototype.multiply;

    function square(a) {
        //console.assert(2 * BASE * BASE < MAX_INT);
        var l = a.length,
            r = createArray(l + l),
            base = BASE,
            product, carry, i, a_i, a_j;
        for (i = 0; i < l; i++) {
            a_i = a[i];
            carry = 0 - a_i * a_i;
            for (var j = i; j < l; j++) {
                a_j = a[j];
                product = 2 * (a_i * a_j) + r[i + j] + carry;
                carry = Math.floor(product / base);
                r[i + j] = product - carry * base;
            }
            r[i + l] = carry;
        }
        trim(r);
        return r;
    }

    BigInteger.prototype.square = function () {
        return new BigInteger(square(this.value), false);
    };

    SmallInteger.prototype.square = function () {
        var value = this.value * this.value;
        if (isPrecise(value)) return new SmallInteger(value);
        return new BigInteger(square(smallToArray(Math.abs(this.value))), false);
    };

    NativeBigInt.prototype.square = function (v) {
        return new NativeBigInt(this.value * this.value);
    };

    function divMod1(a, b) { // Left over from previous version. Performs faster than divMod2 on smaller input sizes.
        var a_l = a.length,
            b_l = b.length,
            base = BASE,
            result = createArray(b.length),
            divisorMostSignificantDigit = b[b_l - 1],
            // normalization
            lambda = Math.ceil(base / (2 * divisorMostSignificantDigit)),
            remainder = multiplySmall(a, lambda),
            divisor = multiplySmall(b, lambda),
            quotientDigit, shift, carry, borrow, i, l, q;
        if (remainder.length <= a_l) remainder.push(0);
        divisor.push(0);
        divisorMostSignificantDigit = divisor[b_l - 1];
        for (shift = a_l - b_l; shift >= 0; shift--) {
            quotientDigit = base - 1;
            if (remainder[shift + b_l] !== divisorMostSignificantDigit) {
                quotientDigit = Math.floor((remainder[shift + b_l] * base + remainder[shift + b_l - 1]) / divisorMostSignificantDigit);
            }
            // quotientDigit <= base - 1
            carry = 0;
            borrow = 0;
            l = divisor.length;
            for (i = 0; i < l; i++) {
                carry += quotientDigit * divisor[i];
                q = Math.floor(carry / base);
                borrow += remainder[shift + i] - (carry - q * base);
                carry = q;
                if (borrow < 0) {
                    remainder[shift + i] = borrow + base;
                    borrow = -1;
                } else {
                    remainder[shift + i] = borrow;
                    borrow = 0;
                }
            }
            while (borrow !== 0) {
                quotientDigit -= 1;
                carry = 0;
                for (i = 0; i < l; i++) {
                    carry += remainder[shift + i] - base + divisor[i];
                    if (carry < 0) {
                        remainder[shift + i] = carry + base;
                        carry = 0;
                    } else {
                        remainder[shift + i] = carry;
                        carry = 1;
                    }
                }
                borrow += carry;
            }
            result[shift] = quotientDigit;
        }
        // denormalization
        remainder = divModSmall(remainder, lambda)[0];
        return [arrayToSmall(result), arrayToSmall(remainder)];
    }

    function divMod2(a, b) { // Implementation idea shamelessly stolen from Silent Matt's library http://silentmatt.com/biginteger/
        // Performs faster than divMod1 on larger input sizes.
        var a_l = a.length,
            b_l = b.length,
            result = [],
            part = [],
            base = BASE,
            guess, xlen, highx, highy, check;
        while (a_l) {
            part.unshift(a[--a_l]);
            trim(part);
            if (compareAbs(part, b) < 0) {
                result.push(0);
                continue;
            }
            xlen = part.length;
            highx = part[xlen - 1] * base + part[xlen - 2];
            highy = b[b_l - 1] * base + b[b_l - 2];
            if (xlen > b_l) {
                highx = (highx + 1) * base;
            }
            guess = Math.ceil(highx / highy);
            do {
                check = multiplySmall(b, guess);
                if (compareAbs(check, part) <= 0) break;
                guess--;
            } while (guess);
            result.push(guess);
            part = subtract(part, check);
        }
        result.reverse();
        return [arrayToSmall(result), arrayToSmall(part)];
    }

    function divModSmall(value, lambda) {
        var length = value.length,
            quotient = createArray(length),
            base = BASE,
            i, q, remainder, divisor;
        remainder = 0;
        for (i = length - 1; i >= 0; --i) {
            divisor = remainder * base + value[i];
            q = truncate(divisor / lambda);
            remainder = divisor - q * lambda;
            quotient[i] = q | 0;
        }
        return [quotient, remainder | 0];
    }

    function divModAny(self, v) {
        var value, n = parseValue(v);
        if (supportsNativeBigInt) {
            return [new NativeBigInt(self.value / n.value), new NativeBigInt(self.value % n.value)];
        }
        var a = self.value, b = n.value;
        var quotient;
        if (b === 0) throw new Error("Cannot divide by zero");
        if (self.isSmall) {
            if (n.isSmall) {
                return [new SmallInteger(truncate(a / b)), new SmallInteger(a % b)];
            }
            return [Integer[0], self];
        }
        if (n.isSmall) {
            if (b === 1) return [self, Integer[0]];
            if (b == -1) return [self.negate(), Integer[0]];
            var abs = Math.abs(b);
            if (abs < BASE) {
                value = divModSmall(a, abs);
                quotient = arrayToSmall(value[0]);
                var remainder = value[1];
                if (self.sign) remainder = -remainder;
                if (typeof quotient === "number") {
                    if (self.sign !== n.sign) quotient = -quotient;
                    return [new SmallInteger(quotient), new SmallInteger(remainder)];
                }
                return [new BigInteger(quotient, self.sign !== n.sign), new SmallInteger(remainder)];
            }
            b = smallToArray(abs);
        }
        var comparison = compareAbs(a, b);
        if (comparison === -1) return [Integer[0], self];
        if (comparison === 0) return [Integer[self.sign === n.sign ? 1 : -1], Integer[0]];

        // divMod1 is faster on smaller input sizes
        if (a.length + b.length <= 200)
            value = divMod1(a, b);
        else value = divMod2(a, b);

        quotient = value[0];
        var qSign = self.sign !== n.sign,
            mod = value[1],
            mSign = self.sign;
        if (typeof quotient === "number") {
            if (qSign) quotient = -quotient;
            quotient = new SmallInteger(quotient);
        } else quotient = new BigInteger(quotient, qSign);
        if (typeof mod === "number") {
            if (mSign) mod = -mod;
            mod = new SmallInteger(mod);
        } else mod = new BigInteger(mod, mSign);
        return [quotient, mod];
    }

    BigInteger.prototype.divmod = function (v) {
        var result = divModAny(this, v);
        return {
            quotient: result[0],
            remainder: result[1]
        };
    };
    NativeBigInt.prototype.divmod = SmallInteger.prototype.divmod = BigInteger.prototype.divmod;


    BigInteger.prototype.divide = function (v) {
        return divModAny(this, v)[0];
    };
    NativeBigInt.prototype.over = NativeBigInt.prototype.divide = function (v) {
        return new NativeBigInt(this.value / parseValue(v).value);
    };
    SmallInteger.prototype.over = SmallInteger.prototype.divide = BigInteger.prototype.over = BigInteger.prototype.divide;

    BigInteger.prototype.mod = function (v) {
        return divModAny(this, v)[1];
    };
    NativeBigInt.prototype.mod = NativeBigInt.prototype.remainder = function (v) {
        return new NativeBigInt(this.value % parseValue(v).value);
    };
    SmallInteger.prototype.remainder = SmallInteger.prototype.mod = BigInteger.prototype.remainder = BigInteger.prototype.mod;

    BigInteger.prototype.pow = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value,
            value, x, y;
        if (b === 0) return Integer[1];
        if (a === 0) return Integer[0];
        if (a === 1) return Integer[1];
        if (a === -1) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.sign) {
            return Integer[0];
        }
        if (!n.isSmall) throw new Error("The exponent " + n.toString() + " is too large.");
        if (this.isSmall) {
            if (isPrecise(value = Math.pow(a, b)))
                return new SmallInteger(truncate(value));
        }
        x = this;
        y = Integer[1];
        while (true) {
            if (b & 1 === 1) {
                y = y.times(x);
                --b;
            }
            if (b === 0) break;
            b /= 2;
            x = x.square();
        }
        return y;
    };
    SmallInteger.prototype.pow = BigInteger.prototype.pow;

    NativeBigInt.prototype.pow = function (v) {
        var n = parseValue(v);
        var a = this.value, b = n.value;
        var _0 = BigInt(0), _1 = BigInt(1), _2 = BigInt(2);
        if (b === _0) return Integer[1];
        if (a === _0) return Integer[0];
        if (a === _1) return Integer[1];
        if (a === BigInt(-1)) return n.isEven() ? Integer[1] : Integer[-1];
        if (n.isNegative()) return new NativeBigInt(_0);
        var x = this;
        var y = Integer[1];
        while (true) {
            if ((b & _1) === _1) {
                y = y.times(x);
                --b;
            }
            if (b === _0) break;
            b /= _2;
            x = x.square();
        }
        return y;
    };

    BigInteger.prototype.modPow = function (exp, mod) {
        exp = parseValue(exp);
        mod = parseValue(mod);
        if (mod.isZero()) throw new Error("Cannot take modPow with modulus 0");
        var r = Integer[1],
            base = this.mod(mod);
        if (exp.isNegative()) {
            exp = exp.multiply(Integer[-1]);
            base = base.modInv(mod);
        }
        while (exp.isPositive()) {
            if (base.isZero()) return Integer[0];
            if (exp.isOdd()) r = r.multiply(base).mod(mod);
            exp = exp.divide(2);
            base = base.square().mod(mod);
        }
        return r;
    };
    NativeBigInt.prototype.modPow = SmallInteger.prototype.modPow = BigInteger.prototype.modPow;

    function compareAbs(a, b) {
        if (a.length !== b.length) {
            return a.length > b.length ? 1 : -1;
        }
        for (var i = a.length - 1; i >= 0; i--) {
            if (a[i] !== b[i]) return a[i] > b[i] ? 1 : -1;
        }
        return 0;
    }

    BigInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) return 1;
        return compareAbs(a, b);
    };
    SmallInteger.prototype.compareAbs = function (v) {
        var n = parseValue(v),
            a = Math.abs(this.value),
            b = n.value;
        if (n.isSmall) {
            b = Math.abs(b);
            return a === b ? 0 : a > b ? 1 : -1;
        }
        return -1;
    };
    NativeBigInt.prototype.compareAbs = function (v) {
        var a = this.value;
        var b = parseValue(v).value;
        a = a >= 0 ? a : -a;
        b = b >= 0 ? b : -b;
        return a === b ? 0 : a > b ? 1 : -1;
    };

    BigInteger.prototype.compare = function (v) {
        // See discussion about comparison with Infinity:
        // https://github.com/peterolson/BigInteger.js/issues/61
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (this.sign !== n.sign) {
            return n.sign ? 1 : -1;
        }
        if (n.isSmall) {
            return this.sign ? -1 : 1;
        }
        return compareAbs(a, b) * (this.sign ? -1 : 1);
    };
    BigInteger.prototype.compareTo = BigInteger.prototype.compare;

    SmallInteger.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }

        var n = parseValue(v),
            a = this.value,
            b = n.value;
        if (n.isSmall) {
            return a == b ? 0 : a > b ? 1 : -1;
        }
        if (a < 0 !== n.sign) {
            return a < 0 ? -1 : 1;
        }
        return a < 0 ? 1 : -1;
    };
    SmallInteger.prototype.compareTo = SmallInteger.prototype.compare;

    NativeBigInt.prototype.compare = function (v) {
        if (v === Infinity) {
            return -1;
        }
        if (v === -Infinity) {
            return 1;
        }
        var a = this.value;
        var b = parseValue(v).value;
        return a === b ? 0 : a > b ? 1 : -1;
    };
    NativeBigInt.prototype.compareTo = NativeBigInt.prototype.compare;

    BigInteger.prototype.equals = function (v) {
        return this.compare(v) === 0;
    };
    NativeBigInt.prototype.eq = NativeBigInt.prototype.equals = SmallInteger.prototype.eq = SmallInteger.prototype.equals = BigInteger.prototype.eq = BigInteger.prototype.equals;

    BigInteger.prototype.notEquals = function (v) {
        return this.compare(v) !== 0;
    };
    NativeBigInt.prototype.neq = NativeBigInt.prototype.notEquals = SmallInteger.prototype.neq = SmallInteger.prototype.notEquals = BigInteger.prototype.neq = BigInteger.prototype.notEquals;

    BigInteger.prototype.greater = function (v) {
        return this.compare(v) > 0;
    };
    NativeBigInt.prototype.gt = NativeBigInt.prototype.greater = SmallInteger.prototype.gt = SmallInteger.prototype.greater = BigInteger.prototype.gt = BigInteger.prototype.greater;

    BigInteger.prototype.lesser = function (v) {
        return this.compare(v) < 0;
    };
    NativeBigInt.prototype.lt = NativeBigInt.prototype.lesser = SmallInteger.prototype.lt = SmallInteger.prototype.lesser = BigInteger.prototype.lt = BigInteger.prototype.lesser;

    BigInteger.prototype.greaterOrEquals = function (v) {
        return this.compare(v) >= 0;
    };
    NativeBigInt.prototype.geq = NativeBigInt.prototype.greaterOrEquals = SmallInteger.prototype.geq = SmallInteger.prototype.greaterOrEquals = BigInteger.prototype.geq = BigInteger.prototype.greaterOrEquals;

    BigInteger.prototype.lesserOrEquals = function (v) {
        return this.compare(v) <= 0;
    };
    NativeBigInt.prototype.leq = NativeBigInt.prototype.lesserOrEquals = SmallInteger.prototype.leq = SmallInteger.prototype.lesserOrEquals = BigInteger.prototype.leq = BigInteger.prototype.lesserOrEquals;

    BigInteger.prototype.isEven = function () {
        return (this.value[0] & 1) === 0;
    };
    SmallInteger.prototype.isEven = function () {
        return (this.value & 1) === 0;
    };
    NativeBigInt.prototype.isEven = function () {
        return (this.value & BigInt(1)) === BigInt(0);
    };

    BigInteger.prototype.isOdd = function () {
        return (this.value[0] & 1) === 1;
    };
    SmallInteger.prototype.isOdd = function () {
        return (this.value & 1) === 1;
    };
    NativeBigInt.prototype.isOdd = function () {
        return (this.value & BigInt(1)) === BigInt(1);
    };

    BigInteger.prototype.isPositive = function () {
        return !this.sign;
    };
    SmallInteger.prototype.isPositive = function () {
        return this.value > 0;
    };
    NativeBigInt.prototype.isPositive = SmallInteger.prototype.isPositive;

    BigInteger.prototype.isNegative = function () {
        return this.sign;
    };
    SmallInteger.prototype.isNegative = function () {
        return this.value < 0;
    };
    NativeBigInt.prototype.isNegative = SmallInteger.prototype.isNegative;

    BigInteger.prototype.isUnit = function () {
        return false;
    };
    SmallInteger.prototype.isUnit = function () {
        return Math.abs(this.value) === 1;
    };
    NativeBigInt.prototype.isUnit = function () {
        return this.abs().value === BigInt(1);
    };

    BigInteger.prototype.isZero = function () {
        return false;
    };
    SmallInteger.prototype.isZero = function () {
        return this.value === 0;
    };
    NativeBigInt.prototype.isZero = function () {
        return this.value === BigInt(0);
    };

    BigInteger.prototype.isDivisibleBy = function (v) {
        var n = parseValue(v);
        if (n.isZero()) return false;
        if (n.isUnit()) return true;
        if (n.compareAbs(2) === 0) return this.isEven();
        return this.mod(n).isZero();
    };
    NativeBigInt.prototype.isDivisibleBy = SmallInteger.prototype.isDivisibleBy = BigInteger.prototype.isDivisibleBy;

    function isBasicPrime(v) {
        var n = v.abs();
        if (n.isUnit()) return false;
        if (n.equals(2) || n.equals(3) || n.equals(5)) return true;
        if (n.isEven() || n.isDivisibleBy(3) || n.isDivisibleBy(5)) return false;
        if (n.lesser(49)) return true;
        // we don't know if it's prime: let the other functions figure it out
    }

    function millerRabinTest(n, a) {
        var nPrev = n.prev(),
            b = nPrev,
            r = 0,
            d, i, x;
        while (b.isEven()) b = b.divide(2), r++;
        next: for (i = 0; i < a.length; i++) {
            if (n.lesser(a[i])) continue;
            x = bigInt(a[i]).modPow(b, n);
            if (x.isUnit() || x.equals(nPrev)) continue;
            for (d = r - 1; d != 0; d--) {
                x = x.square().mod(n);
                if (x.isUnit()) return false;
                if (x.equals(nPrev)) continue next;
            }
            return false;
        }
        return true;
    }

    // Set "strict" to true to force GRH-supported lower bound of 2*log(N)^2
    BigInteger.prototype.isPrime = function (strict) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var bits = n.bitLength();
        if (bits <= 64)
            return millerRabinTest(n, [2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37]);
        var logN = Math.log(2) * bits.toJSNumber();
        var t = Math.ceil((strict === true) ? (2 * Math.pow(logN, 2)) : logN);
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt(i + 2));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isPrime = SmallInteger.prototype.isPrime = BigInteger.prototype.isPrime;

    BigInteger.prototype.isProbablePrime = function (iterations, rng) {
        var isPrime = isBasicPrime(this);
        if (isPrime !== undefined$1) return isPrime;
        var n = this.abs();
        var t = iterations === undefined$1 ? 5 : iterations;
        for (var a = [], i = 0; i < t; i++) {
            a.push(bigInt.randBetween(2, n.minus(2), rng));
        }
        return millerRabinTest(n, a);
    };
    NativeBigInt.prototype.isProbablePrime = SmallInteger.prototype.isProbablePrime = BigInteger.prototype.isProbablePrime;

    BigInteger.prototype.modInv = function (n) {
        var t = bigInt.zero, newT = bigInt.one, r = parseValue(n), newR = this.abs(), q, lastT, lastR;
        while (!newR.isZero()) {
            q = r.divide(newR);
            lastT = t;
            lastR = r;
            t = newT;
            r = newR;
            newT = lastT.subtract(q.multiply(newT));
            newR = lastR.subtract(q.multiply(newR));
        }
        if (!r.isUnit()) throw new Error(this.toString() + " and " + n.toString() + " are not co-prime");
        if (t.compare(0) === -1) {
            t = t.add(n);
        }
        if (this.isNegative()) {
            return t.negate();
        }
        return t;
    };

    NativeBigInt.prototype.modInv = SmallInteger.prototype.modInv = BigInteger.prototype.modInv;

    BigInteger.prototype.next = function () {
        var value = this.value;
        if (this.sign) {
            return subtractSmall(value, 1, this.sign);
        }
        return new BigInteger(addSmall(value, 1), this.sign);
    };
    SmallInteger.prototype.next = function () {
        var value = this.value;
        if (value + 1 < MAX_INT) return new SmallInteger(value + 1);
        return new BigInteger(MAX_INT_ARR, false);
    };
    NativeBigInt.prototype.next = function () {
        return new NativeBigInt(this.value + BigInt(1));
    };

    BigInteger.prototype.prev = function () {
        var value = this.value;
        if (this.sign) {
            return new BigInteger(addSmall(value, 1), true);
        }
        return subtractSmall(value, 1, this.sign);
    };
    SmallInteger.prototype.prev = function () {
        var value = this.value;
        if (value - 1 > -MAX_INT) return new SmallInteger(value - 1);
        return new BigInteger(MAX_INT_ARR, true);
    };
    NativeBigInt.prototype.prev = function () {
        return new NativeBigInt(this.value - BigInt(1));
    };

    var powersOfTwo = [1];
    while (2 * powersOfTwo[powersOfTwo.length - 1] <= BASE) powersOfTwo.push(2 * powersOfTwo[powersOfTwo.length - 1]);
    var powers2Length = powersOfTwo.length, highestPower2 = powersOfTwo[powers2Length - 1];

    function shift_isSmall(n) {
        return Math.abs(n) <= BASE;
    }

    BigInteger.prototype.shiftLeft = function (v) {
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftRight(-n);
        var result = this;
        if (result.isZero()) return result;
        while (n >= powers2Length) {
            result = result.multiply(highestPower2);
            n -= powers2Length - 1;
        }
        return result.multiply(powersOfTwo[n]);
    };
    NativeBigInt.prototype.shiftLeft = SmallInteger.prototype.shiftLeft = BigInteger.prototype.shiftLeft;

    BigInteger.prototype.shiftRight = function (v) {
        var remQuo;
        var n = parseValue(v).toJSNumber();
        if (!shift_isSmall(n)) {
            throw new Error(String(n) + " is too large for shifting.");
        }
        if (n < 0) return this.shiftLeft(-n);
        var result = this;
        while (n >= powers2Length) {
            if (result.isZero() || (result.isNegative() && result.isUnit())) return result;
            remQuo = divModAny(result, highestPower2);
            result = remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
            n -= powers2Length - 1;
        }
        remQuo = divModAny(result, powersOfTwo[n]);
        return remQuo[1].isNegative() ? remQuo[0].prev() : remQuo[0];
    };
    NativeBigInt.prototype.shiftRight = SmallInteger.prototype.shiftRight = BigInteger.prototype.shiftRight;

    function bitwise(x, y, fn) {
        y = parseValue(y);
        var xSign = x.isNegative(), ySign = y.isNegative();
        var xRem = xSign ? x.not() : x,
            yRem = ySign ? y.not() : y;
        var xDigit = 0, yDigit = 0;
        var xDivMod = null, yDivMod = null;
        var result = [];
        while (!xRem.isZero() || !yRem.isZero()) {
            xDivMod = divModAny(xRem, highestPower2);
            xDigit = xDivMod[1].toJSNumber();
            if (xSign) {
                xDigit = highestPower2 - 1 - xDigit; // two's complement for negative numbers
            }

            yDivMod = divModAny(yRem, highestPower2);
            yDigit = yDivMod[1].toJSNumber();
            if (ySign) {
                yDigit = highestPower2 - 1 - yDigit; // two's complement for negative numbers
            }

            xRem = xDivMod[0];
            yRem = yDivMod[0];
            result.push(fn(xDigit, yDigit));
        }
        var sum = fn(xSign ? 1 : 0, ySign ? 1 : 0) !== 0 ? bigInt(-1) : bigInt(0);
        for (var i = result.length - 1; i >= 0; i -= 1) {
            sum = sum.multiply(highestPower2).add(bigInt(result[i]));
        }
        return sum;
    }

    BigInteger.prototype.not = function () {
        return this.negate().prev();
    };
    NativeBigInt.prototype.not = SmallInteger.prototype.not = BigInteger.prototype.not;

    BigInteger.prototype.and = function (n) {
        return bitwise(this, n, function (a, b) { return a & b; });
    };
    NativeBigInt.prototype.and = SmallInteger.prototype.and = BigInteger.prototype.and;

    BigInteger.prototype.or = function (n) {
        return bitwise(this, n, function (a, b) { return a | b; });
    };
    NativeBigInt.prototype.or = SmallInteger.prototype.or = BigInteger.prototype.or;

    BigInteger.prototype.xor = function (n) {
        return bitwise(this, n, function (a, b) { return a ^ b; });
    };
    NativeBigInt.prototype.xor = SmallInteger.prototype.xor = BigInteger.prototype.xor;

    var LOBMASK_I = 1 << 30, LOBMASK_BI = (BASE & -BASE) * (BASE & -BASE) | LOBMASK_I;
    function roughLOB(n) { // get lowestOneBit (rough)
        // SmallInteger: return Min(lowestOneBit(n), 1 << 30)
        // BigInteger: return Min(lowestOneBit(n), 1 << 14) [BASE=1e7]
        var v = n.value,
            x = typeof v === "number" ? v | LOBMASK_I :
                typeof v === "bigint" ? v | BigInt(LOBMASK_I) :
                    v[0] + v[1] * BASE | LOBMASK_BI;
        return x & -x;
    }

    function integerLogarithm(value, base) {
        if (base.compareTo(value) <= 0) {
            var tmp = integerLogarithm(value, base.square(base));
            var p = tmp.p;
            var e = tmp.e;
            var t = p.multiply(base);
            return t.compareTo(value) <= 0 ? { p: t, e: e * 2 + 1 } : { p: p, e: e * 2 };
        }
        return { p: bigInt(1), e: 0 };
    }

    BigInteger.prototype.bitLength = function () {
        var n = this;
        if (n.compareTo(bigInt(0)) < 0) {
            n = n.negate().subtract(bigInt(1));
        }
        if (n.compareTo(bigInt(0)) === 0) {
            return bigInt(0);
        }
        return bigInt(integerLogarithm(n, bigInt(2)).e).add(bigInt(1));
    };
    NativeBigInt.prototype.bitLength = SmallInteger.prototype.bitLength = BigInteger.prototype.bitLength;

    function max(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.greater(b) ? a : b;
    }
    function min(a, b) {
        a = parseValue(a);
        b = parseValue(b);
        return a.lesser(b) ? a : b;
    }
    function gcd(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        if (a.equals(b)) return a;
        if (a.isZero()) return b;
        if (b.isZero()) return a;
        var c = Integer[1], d, t;
        while (a.isEven() && b.isEven()) {
            d = min(roughLOB(a), roughLOB(b));
            a = a.divide(d);
            b = b.divide(d);
            c = c.multiply(d);
        }
        while (a.isEven()) {
            a = a.divide(roughLOB(a));
        }
        do {
            while (b.isEven()) {
                b = b.divide(roughLOB(b));
            }
            if (a.greater(b)) {
                t = b; b = a; a = t;
            }
            b = b.subtract(a);
        } while (!b.isZero());
        return c.isUnit() ? a : a.multiply(c);
    }
    function lcm(a, b) {
        a = parseValue(a).abs();
        b = parseValue(b).abs();
        return a.divide(gcd(a, b)).multiply(b);
    }
    function randBetween(a, b, rng) {
        a = parseValue(a);
        b = parseValue(b);
        var usedRNG = rng || Math.random;
        var low = min(a, b), high = max(a, b);
        var range = high.subtract(low).add(1);
        if (range.isSmall) return low.add(Math.floor(usedRNG() * range));
        var digits = toBase(range, BASE).value;
        var result = [], restricted = true;
        for (var i = 0; i < digits.length; i++) {
            var top = restricted ? digits[i] : BASE;
            var digit = truncate(usedRNG() * top);
            result.push(digit);
            if (digit < top) restricted = false;
        }
        return low.add(Integer.fromArray(result, BASE, false));
    }

    var parseBase = function (text, base, alphabet, caseSensitive) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        text = String(text);
        if (!caseSensitive) {
            text = text.toLowerCase();
            alphabet = alphabet.toLowerCase();
        }
        var length = text.length;
        var i;
        var absBase = Math.abs(base);
        var alphabetValues = {};
        for (i = 0; i < alphabet.length; i++) {
            alphabetValues[alphabet[i]] = i;
        }
        for (i = 0; i < length; i++) {
            var c = text[i];
            if (c === "-") continue;
            if (c in alphabetValues) {
                if (alphabetValues[c] >= absBase) {
                    if (c === "1" && absBase === 1) continue;
                    throw new Error(c + " is not a valid digit in base " + base + ".");
                }
            }
        }
        base = parseValue(base);
        var digits = [];
        var isNegative = text[0] === "-";
        for (i = isNegative ? 1 : 0; i < text.length; i++) {
            var c = text[i];
            if (c in alphabetValues) digits.push(parseValue(alphabetValues[c]));
            else if (c === "<") {
                var start = i;
                do { i++; } while (text[i] !== ">" && i < text.length);
                digits.push(parseValue(text.slice(start + 1, i)));
            }
            else throw new Error(c + " is not a valid character");
        }
        return parseBaseFromArray(digits, base, isNegative);
    };

    function parseBaseFromArray(digits, base, isNegative) {
        var val = Integer[0], pow = Integer[1], i;
        for (i = digits.length - 1; i >= 0; i--) {
            val = val.add(digits[i].times(pow));
            pow = pow.times(base);
        }
        return isNegative ? val.negate() : val;
    }

    function stringify(digit, alphabet) {
        alphabet = alphabet || DEFAULT_ALPHABET;
        if (digit < alphabet.length) {
            return alphabet[digit];
        }
        return "<" + digit + ">";
    }

    function toBase(n, base) {
        base = bigInt(base);
        if (base.isZero()) {
            if (n.isZero()) return { value: [0], isNegative: false };
            throw new Error("Cannot convert nonzero numbers to base 0.");
        }
        if (base.equals(-1)) {
            if (n.isZero()) return { value: [0], isNegative: false };
            if (n.isNegative())
                return {
                    value: [].concat.apply([], Array.apply(null, Array(-n.toJSNumber()))
                        .map(Array.prototype.valueOf, [1, 0])
                    ),
                    isNegative: false
                };

            var arr = Array.apply(null, Array(n.toJSNumber() - 1))
                .map(Array.prototype.valueOf, [0, 1]);
            arr.unshift([1]);
            return {
                value: [].concat.apply([], arr),
                isNegative: false
            };
        }

        var neg = false;
        if (n.isNegative() && base.isPositive()) {
            neg = true;
            n = n.abs();
        }
        if (base.isUnit()) {
            if (n.isZero()) return { value: [0], isNegative: false };

            return {
                value: Array.apply(null, Array(n.toJSNumber()))
                    .map(Number.prototype.valueOf, 1),
                isNegative: neg
            };
        }
        var out = [];
        var left = n, divmod;
        while (left.isNegative() || left.compareAbs(base) >= 0) {
            divmod = left.divmod(base);
            left = divmod.quotient;
            var digit = divmod.remainder;
            if (digit.isNegative()) {
                digit = base.minus(digit).abs();
                left = left.next();
            }
            out.push(digit.toJSNumber());
        }
        out.push(left.toJSNumber());
        return { value: out.reverse(), isNegative: neg };
    }

    function toBaseString(n, base, alphabet) {
        var arr = toBase(n, base);
        return (arr.isNegative ? "-" : "") + arr.value.map(function (x) {
            return stringify(x, alphabet);
        }).join('');
    }

    BigInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    SmallInteger.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    NativeBigInt.prototype.toArray = function (radix) {
        return toBase(this, radix);
    };

    BigInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix !== 10) return toBaseString(this, radix, alphabet);
        var v = this.value, l = v.length, str = String(v[--l]), zeros = "0000000", digit;
        while (--l >= 0) {
            digit = String(v[l]);
            str += zeros.slice(digit.length) + digit;
        }
        var sign = this.sign ? "-" : "";
        return sign + str;
    };

    SmallInteger.prototype.toString = function (radix, alphabet) {
        if (radix === undefined$1) radix = 10;
        if (radix != 10) return toBaseString(this, radix, alphabet);
        return String(this.value);
    };

    NativeBigInt.prototype.toString = SmallInteger.prototype.toString;

    NativeBigInt.prototype.toJSON = BigInteger.prototype.toJSON = SmallInteger.prototype.toJSON = function () { return this.toString(); };

    BigInteger.prototype.valueOf = function () {
        return parseInt(this.toString(), 10);
    };
    BigInteger.prototype.toJSNumber = BigInteger.prototype.valueOf;

    SmallInteger.prototype.valueOf = function () {
        return this.value;
    };
    SmallInteger.prototype.toJSNumber = SmallInteger.prototype.valueOf;
    NativeBigInt.prototype.valueOf = NativeBigInt.prototype.toJSNumber = function () {
        return parseInt(this.toString(), 10);
    };

    function parseStringValue(v) {
        if (isPrecise(+v)) {
            var x = +v;
            if (x === truncate(x))
                return supportsNativeBigInt ? new NativeBigInt(BigInt(x)) : new SmallInteger(x);
            throw new Error("Invalid integer: " + v);
        }
        var sign = v[0] === "-";
        if (sign) v = v.slice(1);
        var split = v.split(/e/i);
        if (split.length > 2) throw new Error("Invalid integer: " + split.join("e"));
        if (split.length === 2) {
            var exp = split[1];
            if (exp[0] === "+") exp = exp.slice(1);
            exp = +exp;
            if (exp !== truncate(exp) || !isPrecise(exp)) throw new Error("Invalid integer: " + exp + " is not a valid exponent.");
            var text = split[0];
            var decimalPlace = text.indexOf(".");
            if (decimalPlace >= 0) {
                exp -= text.length - decimalPlace - 1;
                text = text.slice(0, decimalPlace) + text.slice(decimalPlace + 1);
            }
            if (exp < 0) throw new Error("Cannot include negative exponent part for integers");
            text += (new Array(exp + 1)).join("0");
            v = text;
        }
        var isValid = /^([0-9][0-9]*)$/.test(v);
        if (!isValid) throw new Error("Invalid integer: " + v);
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(sign ? "-" + v : v));
        }
        var r = [], max = v.length, l = LOG_BASE, min = max - l;
        while (max > 0) {
            r.push(+v.slice(min, max));
            min -= l;
            if (min < 0) min = 0;
            max -= l;
        }
        trim(r);
        return new BigInteger(r, sign);
    }

    function parseNumberValue(v) {
        if (supportsNativeBigInt) {
            return new NativeBigInt(BigInt(v));
        }
        if (isPrecise(v)) {
            if (v !== truncate(v)) throw new Error(v + " is not an integer.");
            return new SmallInteger(v);
        }
        return parseStringValue(v.toString());
    }

    function parseValue(v) {
        if (typeof v === "number") {
            return parseNumberValue(v);
        }
        if (typeof v === "string") {
            return parseStringValue(v);
        }
        if (typeof v === "bigint") {
            return new NativeBigInt(v);
        }
        return v;
    }
    // Pre-define numbers in range [-999,999]
    for (var i = 0; i < 1000; i++) {
        Integer[i] = parseValue(i);
        if (i > 0) Integer[-i] = parseValue(-i);
    }
    // Backwards compatibility
    Integer.one = Integer[1];
    Integer.zero = Integer[0];
    Integer.minusOne = Integer[-1];
    Integer.max = max;
    Integer.min = min;
    Integer.gcd = gcd;
    Integer.lcm = lcm;
    Integer.isInstance = function (x) { return x instanceof BigInteger || x instanceof SmallInteger || x instanceof NativeBigInt; };
    Integer.randBetween = randBetween;

    Integer.fromArray = function (digits, base, isNegative) {
        return parseBaseFromArray(digits.map(parseValue), parseValue(base || 10), isNegative);
    };

    return Integer;
})();

// Node.js check
if (module.hasOwnProperty("exports")) {
    module.exports = bigInt;
}
});

createCommonjsModule(function (module) {



const loadNs = process.hrtime();
const loadMs = new Date().getTime();

function nanoseconds() {
  let diffNs = process.hrtime(loadNs);
  return BigInteger(loadMs).times(1e6).add(BigInteger(diffNs[0]).times(1e9).plus(diffNs[1])).toString();
}

function microseconds() {
  return BigInteger(nanoseconds()).divide(1e3).toString();
}

module.exports = nanoseconds;
module.exports.microseconds = module.exports.micro = microseconds;
});

createCommonjsModule(function (module, exports) {
exports = module.exports = SemVer;

var debug;
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0);
    args.unshift('SEMVER');
    console.log.apply(console, args);
  };
} else {
  debug = function () {};
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0';

var MAX_LENGTH = 256;
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991;

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16;

// The actual regexps go on exports.re
var re = exports.re = [];
var src = exports.src = [];
var R = 0;

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++;
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*';
var NUMERICIDENTIFIERLOOSE = R++;
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+';

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++;
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*';

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++;
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')';

var MAINVERSIONLOOSE = R++;
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')';

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++;
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')';

var PRERELEASEIDENTIFIERLOOSE = R++;
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')';

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++;
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))';

var PRERELEASELOOSE = R++;
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))';

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++;
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+';

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++;
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))';

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++;
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?';

src[FULL] = '^' + FULLPLAIN + '$';

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?';

var LOOSE = R++;
src[LOOSE] = '^' + LOOSEPLAIN + '$';

var GTLT = R++;
src[GTLT] = '((?:<|>)?=?)';

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++;
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
var XRANGEIDENTIFIER = R++;
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*';

var XRANGEPLAIN = R++;
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?';

var XRANGEPLAINLOOSE = R++;
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?';

var XRANGE = R++;
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$';
var XRANGELOOSE = R++;
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$';

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++;
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])';

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++;
src[LONETILDE] = '(?:~>?)';

var TILDETRIM = R++;
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+';
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g');
var tildeTrimReplace = '$1~';

var TILDE = R++;
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$';
var TILDELOOSE = R++;
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$';

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++;
src[LONECARET] = '(?:\\^)';

var CARETTRIM = R++;
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+';
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g');
var caretTrimReplace = '$1^';

var CARET = R++;
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$';
var CARETLOOSE = R++;
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$';

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++;
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$';
var COMPARATOR = R++;
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$';

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++;
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')';

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g');
var comparatorTrimReplace = '$1$2$3';

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++;
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$';

var HYPHENRANGELOOSE = R++;
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$';

// Star ranges basically just allow anything at all.
var STAR = R++;
src[STAR] = '(<|>)?=?\\s*\\*';

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i]);
  if (!re[i]) {
    re[i] = new RegExp(src[i]);
  }
}

exports.parse = parse;
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL];
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid;
function valid (version, options) {
  var v = parse(version, options);
  return v ? v.version : null
}

exports.clean = clean;
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options);
  return s ? s.version : null
}

exports.SemVer = SemVer;

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version;
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options);
  this.options = options;
  this.loose = !!options.loose;

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL]);

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version;

  // these are actually numbers
  this.major = +m[1];
  this.minor = +m[2];
  this.patch = +m[3];

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = [];
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id;
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    });
  }

  this.build = m[5] ? m[5].split('.') : [];
  this.format();
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch;
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.');
  }
  return this.version
};

SemVer.prototype.toString = function () {
  return this.version
};

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other);
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return this.compareMain(other) || this.comparePre(other)
};

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
};

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options);
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0;
  do {
    var a = this.prerelease[i];
    var b = other.prerelease[i];
    debug('prerelease compare', i, a, b);
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
};

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor = 0;
      this.major++;
      this.inc('pre', identifier);
      break
    case 'preminor':
      this.prerelease.length = 0;
      this.patch = 0;
      this.minor++;
      this.inc('pre', identifier);
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0;
      this.inc('patch', identifier);
      this.inc('pre', identifier);
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier);
      }
      this.inc('pre', identifier);
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++;
      }
      this.minor = 0;
      this.patch = 0;
      this.prerelease = [];
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++;
      }
      this.patch = 0;
      this.prerelease = [];
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++;
      }
      this.prerelease = [];
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0];
      } else {
        var i = this.prerelease.length;
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++;
            i = -2;
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0);
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0];
          }
        } else {
          this.prerelease = [identifier, 0];
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format();
  this.raw = this.version;
  return this
};

exports.inc = inc;
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose;
    loose = undefined;
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff;
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1);
    var v2 = parse(version2);
    var prefix = '';
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre';
      var defaultResult = 'prerelease';
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers;

var numeric = /^[0-9]+$/;
function compareIdentifiers (a, b) {
  var anum = numeric.test(a);
  var bnum = numeric.test(b);

  if (anum && bnum) {
    a = +a;
    b = +b;
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers;
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major;
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor;
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch;
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare;
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose;
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare;
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort;
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort;
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt;
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt;
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq;
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq;
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte;
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte;
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp;
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version;
      if (typeof b === 'object')
        b = b.version;
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator;
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value;
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options);
  this.options = options;
  this.loose = !!options.loose;
  this.parse(comp);

  if (this.semver === ANY) {
    this.value = '';
  } else {
    this.value = this.operator + this.semver.version;
  }

  debug('comp', this);
}

var ANY = {};
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var m = comp.match(r);

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1];
  if (this.operator === '=') {
    this.operator = '';
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY;
  } else {
    this.semver = new SemVer(m[2], this.options.loose);
  }
};

Comparator.prototype.toString = function () {
  return this.value
};

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose);

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  return cmp(version, this.operator, this.semver, this.options)
};

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  var rangeTmp;

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options);
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options);
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>');
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<');
  var sameSemVer = this.semver.version === comp.semver.version;
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=');
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'));
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'));

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
};

exports.Range = Range;
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    };
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options;
  this.loose = !!options.loose;
  this.includePrerelease = !!options.includePrerelease;

  // First, split based on boolean or ||
  this.raw = range;
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  });

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format();
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim();
  return this.range
};

Range.prototype.toString = function () {
  return this.range
};

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose;
  range = range.trim();
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE];
  range = range.replace(hr, hyphenReplace);
  debug('hyphen replace', range);
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace);
  debug('comparator trim', range, re[COMPARATORTRIM]);

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace);

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace);

  // normalize spaces
  range = range.split(/\s+/).join(' ');

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR];
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/);
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    });
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this);

  return set
};

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
};

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators;
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options);
  comp = replaceCarets(comp, options);
  debug('caret', comp);
  comp = replaceTildes(comp, options);
  debug('tildes', comp);
  comp = replaceXRanges(comp, options);
  debug('xrange', comp);
  comp = replaceStars(comp, options);
  debug('stars', comp);
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    } else if (pr) {
      debug('replaceTilde pr', pr);
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0';
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0';
    }

    debug('tilde return', ret);
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options);
  var r = options.loose ? re[CARETLOOSE] : re[CARET];
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr);
    var ret;

    if (isX(M)) {
      ret = '';
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
      }
    } else if (pr) {
      debug('replaceCaret pr', pr);
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0';
      }
    } else {
      debug('no pr');
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1);
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0';
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0';
      }
    }

    debug('caret return', ret);
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options);
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim();
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE];
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr);
    var xM = isX(M);
    var xm = xM || isX(m);
    var xp = xm || isX(p);
    var anyX = xp;

    if (gtlt === '=' && anyX) {
      gtlt = '';
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0';
      } else {
        // nothing is forbidden
        ret = '*';
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0;
      }
      p = 0;

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>=';
        if (xm) {
          M = +M + 1;
          m = 0;
          p = 0;
        } else {
          m = +m + 1;
          p = 0;
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<';
        if (xm) {
          M = +M + 1;
        } else {
          m = +m + 1;
        }
      }

      ret = gtlt + M + '.' + m + '.' + p;
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
    }

    debug('xRange return', ret);

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options);
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = '';
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0';
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0';
  } else {
    from = '>=' + from;
  }

  if (isX(tM)) {
    to = '';
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0';
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0';
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
  } else {
    to = '<=' + to;
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options);
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
};

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver);
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver;
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies;
function satisfies (version, range, options) {
  try {
    range = new Range(range, options);
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying;
function maxSatisfying (versions, range, options) {
  var max = null;
  var maxSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v;
        maxSV = new SemVer(max, options);
      }
    }
  });
  return max
}

exports.minSatisfying = minSatisfying;
function minSatisfying (versions, range, options) {
  var min = null;
  var minSV = null;
  try {
    var rangeObj = new Range(range, options);
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v;
        minSV = new SemVer(min, options);
      }
    }
  });
  return min
}

exports.minVersion = minVersion;
function minVersion (range, loose) {
  range = new Range(range, loose);

  var minver = new SemVer('0.0.0');
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0');
  if (range.test(minver)) {
    return minver
  }

  minver = null;
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version);
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++;
          } else {
            compver.prerelease.push(0);
          }
          compver.raw = compver.format();
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver;
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    });
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange;
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr;
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr;
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside;
function outside (version, range, hilo, options) {
  version = new SemVer(version, options);
  range = new Range(range, options);

  var gtfn, ltefn, ltfn, comp, ecomp;
  switch (hilo) {
    case '>':
      gtfn = gt;
      ltefn = lte;
      ltfn = lt;
      comp = '>';
      ecomp = '>=';
      break
    case '<':
      gtfn = lt;
      ltefn = gte;
      ltfn = gt;
      comp = '<';
      ecomp = '<=';
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i];

    var high = null;
    var low = null;

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0');
      }
      high = high || comparator;
      low = low || comparator;
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator;
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator;
      }
    });

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease;
function prerelease (version, options) {
  var parsed = parse(version, options);
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects;
function intersects (r1, r2, options) {
  r1 = new Range(r1, options);
  r2 = new Range(r2, options);
  return r1.intersects(r2)
}

exports.coerce = coerce;
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE]);

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}
});

Instruction$1.Dexter = class Dexter extends Instruction$1{};

//only used for Dexter.dexter0.get_robot_status() like calls, not for Dexter.get_robot_status() calls.
//this instance is needed because we need the instruction on the do_list to contain
//the robot so that Socket.on_receive and its aux fn, find_dexter_instance_from_robot_status
//know what robot that the on_received robot status belongs to.
Instruction$1.Dexter.get_robot_status = class get_robot_status extends Instruction$1.Dexter{
    constructor (status_mode, robot) {
        super();
        this.status_mode = status_mode; //keep for orig 5 angles so to_source_code can use them. May contain nulls
        this.robot = robot; //if this is undefined, we will use the default robot of the job.
    }
    do_item (job_instance){
        if(!this.robot) { //this.robot = job_instance.robot
            this.set_instruction_robot_from_job(job_instance); //might error which is good
        }
        if(this.status_mode === null){
            job_instance.send(make_ins("g"), this.robot);
        }
        else {
            job_instance.send(make_ins("g", this.status_mode), this.robot);
        }
    }
    toString(){
        return "{instanceof: get_robot_status " + this.status_mode + "}"
    }
    to_source_code(args){
        let arg_src;
        if(this.status_mode == null) { arg_src = ""; }
        else { arg_src = "" + this.status_mode; }
        args.indent = "";
        return args.indent + "Dexter." + this.robot.name + ".get_robot_status(" + arg_src + ")"
    }
};

Instruction$1.Dexter.move_all_joints = class move_all_joints extends Instruction$1.Dexter{
    constructor (array_of_angles, robot) {
        super();
        this.array_of_angles = array_of_angles; //keep for orig 5 angles so to_source_code can use them. May contain nulls
        this.robot = robot; //if this is undefined, we will use the default robot of the job.
    }
    do_item (job_instance){
        if(!this.robot) { //this.robot = job_instance.robot
            this.set_instruction_robot_from_job(job_instance); //might error which is good
        }
        let angles = [];
        for (let i = 0; i < 5; i++){
            let ang = this.array_of_angles[i];
            if ((ang === undefined) || //happens when array is less than 5 long
                Number.isNaN(ang)) {
                angles.push(this.robot.angles[i]); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {  //relative move by the first elt of the array
                angles.push(this.robot.angles[i] + ang[0]);
            }
            else { angles.push(ang); }
        }
        //angles is now 5 long
        for(let i = 5; i < this.array_of_angles.length; i++) {
            let ang = this.array_of_angles[i];
            if ((ang === undefined) ||
                Number.isNaN(ang) ||
                (Array.isArray(ang) && (ang.length == 1) && (ang[0] == 0))) { //ie [0] means move relative amount of 0. in which case, don't more at all, not even what we THINK is to the same place.
                angles.push(NaN); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {  //relative move by the first elt of the array
                angles.push(this.robot.angles[i] + ang[0]);
            }
            else { angles.push(ang); }
        }
        //angles is at least 5 long, could be 6 or 7
        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nin Robot.move_all_joints([" + angles + "])");
            job_instance.set_up_next_do(0);
        }
        else  {
            //this.robot.angles = angles
            for(let i = 0; i < angles.length; i++) { this.robot.angles[i] = angles[i]; }
            //job_instance.insert_single_instruction(make_ins("a", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(make_ins("a", ...angles), this.robot);
            //job_instance.set_up_next_do(1) //effectively done in robot_done_with_instruction
        }
    }
    toString(){
        return "{instanceof: move_all_joints " + this.array_of_angles + "}"
    }
    to_source_code(args){
        args = jQuery.extend({}, args);
        args.value = this.array_of_angles;
        args.indent = "";
        return args.indent + "Dexter.move_all_joints(" + to_source_code(args) + ")"
    }
};

Instruction$1.Dexter.pid_move_all_joints = class pid_move_all_joints extends Instruction$1.Dexter{
    constructor (array_of_angles, robot) {
        super();
        this.array_of_angles = array_of_angles; //keep for orig 5 angles so to_source_code can use them. May contain nulls
        this.robot = robot;
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        let angles = [];
        for (let i = 0; i < 5; i++){
            let ang = this.array_of_angles[i];
            if ((ang === undefined) || //happens when array is less than 5 long
                Number.isNaN(ang)) {
                angles.push(this.robot.pid_angles[i]); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {  //relative move by the first elt of the array
                angles.push(this.robot.pid_angles[i] + ang[0]);
            }
            else { angles.push(ang); }
        }
        //angles is now 5 long
        for(let i = 5; i < this.array_of_angles.length; i++) {
            let ang = this.array_of_angles[i];
            if ((ang === undefined) ||
                Number.isNaN(ang)) {
                angles.push(NaN); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {  //relative move by the first elt of the array
                angles.push(this.robot.pid_angles[i] + ang[0]);
            }
            else { angles.push(ang); }
        }
        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nin Robot.pid_move_all_joints([" + angles + "])");
            job_instance.set_up_next_do(0);
        }
        else  {
            for(let i = 0; i < angles.length; i++) { this.robot.pid_angles[i] = angles[i]; }
            //job_instance.insert_single_instruction(make_ins("P", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(make_ins("P", ...angles), this.robot);
            // job_instance.set_up_next_do(1) //called by robot_done_with_instruction
        }
    }
    toString(){
        return "{instanceof: pid_move_all_joints " + this.array_of_angles + "}"
    }
    to_source_code(args){
        args        = jQuery.extend({}, args);
        args.value  = this.array_of_angles;
        args.indent = "";
        return args.indent + "Dexter.pid_move_all_joints(" + to_source_code(args) + ")"
    }
};

Instruction$1.Dexter.move_all_joints_relative = class move_all_joints_relative extends Instruction$1.Dexter{
    constructor (delta_angles, robot) {
        super();
        this.delta_angles = delta_angles; //keep for orig 5 angles so to_source_code can use them. May contain nulls
        this.robot = robot;
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance);}
        let angles = []; //the absolute angles after the rel has been added in
        for (let i = 0; i < 5; i++){
            let ang = this.delta_angles[i];
            if ((ang === undefined) || //happens when array is less than 5 long
                Number.isNaN(ang)) {
                angles.push(this.robot.angles[i]); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {  //relative move by the first elt of the array
                //angles.push(this.robot.angles[i] + ang[0])
                dde_error("move_all_joints_relative passed an array: " + ang +
                    " but can only accept numbers as these are already relative.");
            }
            else { angles.push(this.robot.angles[i] + ang); }
        }
        //angles is now 5 long
        for(let i = 5; i < this.delta_angles.length; i++) {
            let ang = this.delta_angles[i];
            if ((ang === undefined) ||
                Number.isNaN(ang)) {
                angles.push(NaN); //this.robot_status[Dexter.ds_j0_angle_index + i] //ie don't change angle
            }
            else if (Array.isArray(ang)) {
                dde_error("move_all_joints_relative passed an array: " + ang +
                    " but can only accept numbers as these are already relative.");

            }
            else { angles.push(this.robot.angles[i] + ang); }
        }
        //angles is at least 5 long, could be 6 or 7
        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nin Robot.move_all_joints_relative([" + angles + "])");
            job_instance.set_up_next_do(0);
        }
        else  {
            //this.robot.angles = angles
            for(let i = 0; i < angles.length; i++) { this.robot.angles[i] = angles[i]; }
            //job_instance.insert_single_instruction(make_ins("a", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(make_ins("a", ...angles), this.robot);
            //job_instance.set_up_next_do(1) //effectively done in robot_done_with_instruction
        }
    }
    toString(){
        return "{instanceof: move_all_joints_relative " + this.delta_angles + "}"
    }
    to_source_code(args){
        args        = jQuery.extend({}, args);
        args.value  = this.delta_angles;
        args.indent = "";
        return args.indent + "Dexter.move_all_joints_relative(" + to_source_code(args) + ")"
    }
};

Instruction$1.Dexter.move_to = class move_to extends Instruction$1.Dexter{
    constructor (xyz           = [],
                 J5_direction  = [0, 0, -1], //pointing down
                 config        = Dexter.RIGHT_UP_OUT,
                 workspace_pose = null, //default's to the job's default_workspace_pose
                 j6_angle = [0], //default is to move relatively 0, ie don't change
                 j7_angle = [0],
                 robot
    ){
        super();
        this.xyz            = xyz;
        this.J5_direction   = J5_direction;
        this.config         = config;
        this.workspace_pose = ((workspace_pose === null) ? undefined : workspace_pose);
        this.j6_angle       = j6_angle;
        this.j7_angle       = j7_angle;
        this.robot          = robot;
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        let xyz          = this.xyz;
        let J5_direction = this.J5_direction;
        let config       = this.config;
        let pose         = this.workspace_pose;
        if(Dexter.is_position(this.xyz)){
            pose         = J5_direction;
            xyz          = this.xyz[0];
            J5_direction = this.xyz[1];
            config       = this.xyz[2];

        }
        let [existing_xyz, existing_direction, existing_config] = Kin.J_angles_to_xyz(this.robot.angles, this.robot.pose); //just to get defaults.
        if(J5_direction === null) { J5_direction = existing_direction; }
        if(config       === null) { config       = existing_config; }
        if(Array.isArray(J5_direction) &&
            (J5_direction.length == 2) &&
            (Math.abs(J5_direction[0]) == 90) &&
            (Math.abs(J5_direction[1]) == 90)){
            job_instance.stop_for_reason("errored",
                "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nDexter.move_to([" + xyz + "], [" + J5_direction + "])\n" +
                "was passed an invalid J5_direction." +
                "\n[90, 90], [-90, 90], [90, -90] and [-90, -90]\n are all invalid.");
        }
        let xyz_copy = xyz.slice(0);
        for(let i = 0; i < 3; i++){
            let new_x_y_or_z = xyz_copy[i];
            if (xyz_copy.length <= i)             { xyz_copy.push(existing_xyz[i]); }
            else if (new_x_y_or_z == null)        { xyz_copy[i] = existing_xyz[i];  } //does not hit if new_x_y_or_z is 0
            else if (Array.isArray(new_x_y_or_z)) { xyz_copy[i] = existing_xyz[i] + new_x_y_or_z[0]; } //relative "new val"
        }
        if(pose == null) { pose = job_instance.default_workspace_pose; }

        if (Object.isNewObject(pose)) { pose = pose.pose; }
        if (Object.isNewObject(J5_direction)) {
            J5_direction = J5_direction.pose;
            config       = undefined;
            pose         = undefined;
        }
        else if (Array.isArray(J5_direction)) {
            if (Array.isArray(J5_direction[0])) { //J5_direciton is a 2d array
                config = undefined;
                pose   = undefined;
            }
            //else its a 1D array, so use config and pose as they are
        }
        else {
            dde_error("Dexter.move_to passed invalid 5_direction of: " + J5_direction);
        }
        let angles;
        try {
            angles = Kin.xyz_to_J_angles(xyz_copy, J5_direction, config, pose); //was: job_instance.robot.pose
            //angles is now 5 long
        }
        catch(err){
            job_instance.stop_for_reason("errored",
                "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nDexter.move_to([" + xyz + "], [" + J5_direction + "])" +
                "\nwas passed invalid xyz.\n " +
                err.message);
            job_instance.set_up_next_do(0);
            return
        }
        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " +
                job_instance.program_counter +
                "\nin Dexter.move_to([" + xyz + "])" +
                "\nout of range xyz.");
            job_instance.set_up_next_do(0);
        }
        else {
            if(Array.isArray(this.j6_angle)) {
                angles.push(this.robot.angles[5] + this.j6_angle[0]);
            }
            else { angles.push(this.j6_angle); }
            if(Array.isArray(this.j7_angle)) {
                angles.push(this.robot.angles[6] + this.j7_angle[0]);
            }
            else { angles.push(this.j7_angle); }
            this.robot.angles       = angles;
            //Job.insert_instruction(make_ins("a", ...angles), {job: job_instance, offset: "after_program_counter"})
            //job_instance.insert_single_instruction(make_ins("a", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            this.computed_angles = angles; //for debugging purposes
            if(Array.isArray(this.j7_angle) &&
                (this.j7_angle.length === 1) &&
                (this.j7_angle[0] === 0)){
                if(Array.isArray(this.j6_angle) &&
                    (this.j6_angle.length === 1) &&
                    (this.j6_angle[0] === 0)){
                    angles = angles.slice(0, 5);
                }
                else { //only j7 is [0] so keep j6 in the array
                    angles = angles.slice(0, 6);
                }
            }
            //we're keeping j7, but maybe not j6
            else if (Array.isArray(this.j6_angle) &&
                    (this.j6_angle.length === 1) &&
                    (this.j6_angle[0] === 0)){
                    angles[5] = "N"; //means don't move J6.
            }
            job_instance.send(make_ins("a", ...angles), this.robot);
            //job_instance.set_up_next_do(1) //effectively done in robot_done_with_instruction
        }
    }

    toString(){ return "{instanceof: move_to " + this.xyz + "}" }

    to_source_code(args){
        args        = jQuery.extend({}, args);
        args.indent = "";

        args.value  = this.xyz;
        let xyx_src = to_source_code(args);

        args.value  = this.J5_direction;
        let J5_direction_src = to_source_code(args);

        args.value  = this.config;
        let config_src = to_source_code(args);

        return args.indent + "Dexter.move_to(" +
            xyx_src          + ", " +
            J5_direction_src + ", " +
            config_src       +
            ")"
    }
};

Instruction$1.Dexter.pid_move_to = class pid_move_to extends Instruction$1.Dexter{
    constructor (xyz           = [],
                 J5_direction  = [0, 0, -1],
                 config        = Dexter.RIGHT_UP_OUT,
                 workspace_pose = undefined, //default's to the job's default_workspace_pos
                 j6_angle = [0], //default is to move relatively 0, ie don't change
                 j7_angle = [0],
                 robot
    ){
        super();
        this.xyz            = xyz;
        this.J5_direction   = J5_direction;
        this.config         = config;
        this.workspace_pose = ((workspace_pose === null) ? undefined : workspace_pose);
        this.j6_angle       = j6_angle;
        this.j7_angle       = j7_angle;
        this.robot          = robot;
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        let xyz          = this.xyz;
        let J5_direction = this.J5_direction;
        let config       = this.config;
        let pose         = this.workspace_pose;
        if(Dexter.is_position(this.xyz)){
            pose         = J5_direction;
            xyz          = this.xyz[0];
            J5_direction = this.xyz[1];
            config       = this.xyz[2];
        }
        let [existing_xyz, existing_direction, existing_config] = Kin.J_angles_to_xyz(this.robot.pid_angles, this.robot.pose); //just to get defaults.
        if(J5_direction === null) { J5_direction = existing_direction; }
        if(config       === null) { config       = existing_config; }
        if(Array.isArray(J5_direction) &&
            (J5_direction.length == 2) &&
            (Math.abs(J5_direction[0]) == 90) &&
            (Math.abs(J5_direction[1]) == 90)){
            job_instance.stop_for_reason("errored",
                "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nDexter.pid_move_to([" + xyz + "], [" + J5_direction + "])\n" +
                "was passed an invalid J5_direction." +
                "\n[90, 90], [-90, 90], [90, -90] and [-90, -90]\n are all invalid.");
        }
        let xyz_copy = xyz.slice(0);
        for(let i = 0; i < 3; i++){
            let new_x_y_or_z = xyz_copy[i];
            if      (xyz_copy.length <= i)        { xyz_copy.push(existing_xyz[i]); }
            else if (xyz_copy[i] == null)         { xyz_copy[i] = existing_xyz[i];  }
            else if (Array.isArray(new_x_y_or_z)) { xyz_copy[i] = existing_xyz[i] + new_x_y_or_z[0]; } //relative "new val"
        }
        if(pose == null) { pose = job_instance.default_workspace_pose; }
        if (Object.isNewObject(pose)) { pose = pose.pose; }
        if (Object.isNewObject(J5_direction)) {
            J5_direction = J5_direction.pose;
            config       = undefined;
            pose         = undefined;
        }
        else if (Array.isArray(J5_direction)) {
            if (Array.isArray(J5_direction[0])) { //J5_direciton is a 2d array
                config = undefined;
                pose   = undefined;
            }
            //else its a 1D array, so use config and pose as they are
        }
        else {
            dde_error("Dexter.move_to passed invalid 5_direction of: " + J5_direction);
        }
        let angles;
        try {
            angles = Kin.xyz_to_J_angles(xyz_copy, J5_direction, config, pose); //job_instance.robot.pose
            //angles is now 5 long
        }
        catch(err){
            //job_instance.stop_for_reason("errored",
            //    "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
            //    "\nDexter.pid_move_to([" + xyz + "], [" + J5_direction + "])" +
            //    "\nwas passed invalid xyz.\n " +
            // err.message)
            //job_instance.set_up_next_do(0)
            //return
            throw new Error("in pid_move_to do_item method. Call to Kin.xyz_to_J_angles has errored")
        }
        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nin Dexter.pid_move_to([" + xyz + "])");
            job_instance.set_up_next_do(0);
        }
        else {
            if(Array.isArray(this.j6_angle)) {
                angles.push(this.robot.pid_angles[5] + this.j6_angle[0]);
            }
            else { angles.push(this.j6_angle); }
            if(Array.isArray(this.j7_angle)) {
                angles.push(this.robot.pid_angles[6] + this.j7_angle[0]);
            }
            else { angles.push(this.j7_angle); }
            this.robot.pid_angles       = angles;  //angles is 7 long
            //Job.insert_instruction(make_ins("P", ...angles), {job: job_instance, offset: "after_program_counter"})
            //job_instance.insert_single_instruction(make_ins("P", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(make_ins("P", ...angles), this.robot);
            //job_instance.set_up_next_do(1) //called by robot_done_with_instruction
        }
    }

    toString(){ return "{instanceof: pid_move_to " + this.xyz + "}" }

    to_source_code(args){
        args        = jQuery.extend({}, args);
        args.indent = "";

        args.value  = this.xyz;
        let xyx_src = to_source_code(args);

        args.value  = this.J5_direction;
        let J5_direction_src = to_source_code(args);

        args.value  = this.config;
        let config_src = to_source_code(args);

        return args.indent + "Dexter.pid_move_to(" +
            xyx_src          + ", " +
            J5_direction_src + ", " +
            config_src       +
            ")"
    }
};
Instruction$1.Dexter.move_to_relative = class move_to_relative extends Instruction$1.Dexter{
    constructor (delta_xyz = [0, 0, 0], workspace_pose=undefined, j6_delta_angle=0, j7_delta_angle=0, robot){
        super();
        if (delta_xyz.length == 1) {
            delta_xyz.push(0);
            delta_xyz.push(0);
        }
        else if (delta_xyz.length == 2) {  delta_xyz.push(0); }
        this.delta_xyz      = delta_xyz;
        this.workspace_pose = ((workspace_pose === null)? undefined : workspace_pose);
        this.j6_delta_angle = j6_delta_angle;
        this.j7_delta_angle = j7_delta_angle;
        this.robot          = robot;
    }
    do_item(job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        let [old_xyz, J5_direction, config] = Kin.J_angles_to_xyz(this.robot.angles, this.workspace_pose); //job_instance.robot.pose
        let new_xyz = Vector.add(old_xyz, this.delta_xyz); //makes a new array
        let angles;
        try {
            angles = Kin.xyz_to_J_angles(new_xyz, J5_direction, config, this.workspace_pose); //job_instance.robot.pose)
            //now of length 5
        }
        catch(err){
            job_instance.stop_for_reason("errored",
                "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nDexter.move_to_relative([" + this.delta_xyz + "])" +
                "\ncalled with out of range delta_xyz\n" +
                err.message);
            job_instance.set_up_next_do(0);
            return
        }
        angles.push(this.robot.angles[5] + this.j6_delta_angle);
        angles.push(this.robot.angles[6] + this.j7_delta_angle);

        let error_mess = Dexter.joints_out_of_range(angles, this.robot);
        if (error_mess){ // a string like "Joint 1 with angle: 0.01 is less than the minimum: 30
            job_instance.stop_for_reason("errored",
                error_mess + "\nin Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nin Dexter.move_to_relative([" + this.delta_xyz + "])");
            job_instance.set_up_next_do(0);
        }
        else {
            this.robot.angles = angles;
            //return make_ins("a", ...angles) // Dexter.move_all_joints(angles)
            //job_instance.insert_single_instruction(make_ins("a", ...angles))
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(make_ins("a", ...angles), this.robot);
            //job_instance.set_up_next_do(1) //called by robot_done_with_instruction
        }
    }
    toString(){
        return "{instanceof: move_to_relative " + this.delta_xyz + "}"
    }
    to_source_code(args){
        let prop_args        = jQuery.extend({}, args);
        prop_args.indent     = "";
        prop_args.value      = this.delta_xyz;
        return args.indent + "Dexter.move_to_relative(" + to_source_code(prop_args) + ")"
    }
};

Instruction$1.Dexter.move_to_straight = class move_to_straight extends Instruction$1.Dexter{
    constructor ({xyz           = [],
                  J5_direction   = [0, 0, -1],
                  config         = Dexter.RIGHT_UP_OUT,
                  workspace_pose = undefined,
                  tool_speed     = 5*_mm / _s,
                  resolution     = 0.5*_mm,
                  j6_angle       = [0],
                  j7_angle       = [0],
                  single_instruction = false, //false means make up all the make_ins for this here in DDE,
                                                 //true means create just 1 make_ins "T" instruction
                  robot}) {
        super();
        this.xyz            = xyz;
        this.J5_direction   = J5_direction;
        this.config         = config;
        this.workspace_pos  = ((workspace_pose === null) ? undefined : workspace_pose);
        this.tool_speed     = tool_speed;
        this.resolution     = resolution;
        this.j6_angle       = j6_angle;
        this.j7_angle       = j7_angle;
        this.single_instruction = single_instruction;
        this.robot          = robot;
        if(!single_instruction) { this.inserting_instruction = true; }
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        let [existing_xyz, existing_J5_direction, existing_config] =
            Kin.J_angles_to_xyz(this.robot.angles, this.robot.pose);
        let xyz_copy = this.xyz.slice(0);
        for(let i = 0; i < 3; i++){
            let new_x_y_or_z = xyz_copy[i];
            if (xyz_copy.length <= i)             { xyz_copy.push(existing_xyz[i]); }
            else if (new_x_y_or_z == null)        { xyz_copy[i] = existing_xyz[i];  } //does not hit if new_x_y_or_z is 0
            else if (Array.isArray(new_x_y_or_z)) { xyz_copy[i] = existing_xyz[i] + new_x_y_or_z[0]; } //relative "new val"
        }
        let angles;
        try { angles = Kin.xyz_to_J_angles(xyz_copy, this.J5_direction, this.config, this.robot.pose);} //job_instance.robot.pose ?
        catch(err){
            job_instance.stop_for_reason("errored",
                "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                "\nDexter.move_to_straight([" + this.xyz + "])" +
                "\ncalled with out of range xyz\n" +
                err.message);
            job_instance.set_up_next_do(0);
            return
        }
        let new_j6_angle;
        if(Array.isArray(this.j6_angle)) {
            new_j6_angle = this.robot.angles[5] + this.j6_angle[0];
        }
        else {  new_j6_angle = this.j6_angle; }
        angles.push(new_j6_angle);

        let new_j7_angle;
        if(Array.isArray(this.j7_angle)) {
            new_j7_angle =  this.robot.angles[6] + this.j7_angle[0];
        }
        else { new_j7_angle = this.j7_angle; }
        angles.push(new_j7_angle);

        this.robot.angles = angles;
        if(this.single_instruction) {
            let ins = make_ins("T",
                xyz_copy[0], xyz_copy[1], xyz_copy[2], //args 0, 1, 2
                this.J5_direction[0], this.J5_direction[1], this.J5_direction[2],
                this.config[0], this.config[1], this.config[2],
                this.tool_speed, this.resolution,
                new_j6_angle, new_j7_angle); //args 11, 12
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            job_instance.send(ins, this.robot);
            //job_instance.set_up_next_do(1) //will be called by robot_done_with_instruction
        }
        else {
            try {
                let instrs = this.move_to_straight_aux(existing_xyz,
                    xyz_copy,
                    this.J5_direction,
                    this.config,
                    this.robot.pose,
                    this.tool_speed,
                    this.resolution,
                    this.robot);
                //Job.insert_instruction(instrs, {job: job_instance, offset: "after_program_counter"})
                job_instance.insert_instructions(instrs);
                job_instance.set_up_next_do(1);
            }
            catch(err){
                job_instance.stop_for_reason("errored",
                    "In Job." + job_instance.name + " at PC: " + job_instance.program_counter +
                    "Dexter.move_to_straight({xyz: [" + this.xyz + "]})\n" +
                    "passed invalid xyz.\n" +
                    err.message);
            }
        }
    }
    move_to_straight_aux (xyz_1, xyz_2, J5_direction, config,  robot_pose, tool_speed = 5*_mm / _s, resolution = .5*_mm, robot){
        let movCMD = [];
        let U1 = xyz_1;
        let U2 = xyz_2;
        let U21 = Vector.subtract(U2, U1);
        let v21 = Vector.normalize(U21);
        let mag = Vector.magnitude(U21);
        let div = 1;
        let step = Infinity;
        while(resolution < step){
            div++;
            step = mag / div;
        }
        let angular_velocity;
        let Ui, new_J_angles;
        let old_J_angles = Kin.xyz_to_J_angles(U1, J5_direction, config, robot_pose);
        for(let i = 1; i < div+1; i++){
            Ui = Vector.add(U1, Vector.multiply(i*step, v21));
            new_J_angles = Kin.xyz_to_J_angles(Ui, J5_direction, config, robot_pose);
            angular_velocity = Kin.tip_speed_to_angle_speed(old_J_angles, new_J_angles, tool_speed);
            old_J_angles = new_J_angles;
            movCMD.push(robot.make_ins("S", "MaxSpeed", angular_velocity));
            movCMD.push(robot.make_ins("S", "StartSpeed", angular_velocity));
            movCMD.push(robot.move_to(Ui, J5_direction, config, robot_pose));
        }
        return movCMD
    }
    toString(){
        return "{instanceof: move_to_straignt " + this.xyz + "}"
    }
    to_source_code(args){
        args        = jQuery.extend({}, args);
        args.indent = "";

        args.value  = this.xyz;
        let xyx_src = to_source_code(args);

        args.value  = this.J5_direction;
        let J5_direction_src = to_source_code(args);

        args.value  = this.config;
        let config_src = to_source_code(args);

        args.value  = this.tool_speed;
        let tool_speed_src = to_source_code(args);

        args.value  = this.resolution;
        let resolution_src = to_source_code(args);

        return args.indent + "Dexter.move_to_straight(" +
            xyx_src          + ", " +
            J5_direction_src + ", " +
            config_src       + ", " +
            tool_speed_src   + ", " +
            resolution_src   +
            ")"
    }
};

Instruction$1.Dexter.read_file = class read_file extends Instruction$1.Dexter{
    constructor (source        , //a file name path string
                 destination   = "read_file_content", //user data variable
                 robot         = null //null means use the default robot of the job.
    ){
        if (typeof(source) != "string") {
            dde_error("Dexter.read_file passed non-string for 'source' of: " + source);
        }
        if (typeof(destination) != "string") {
            dde_error("Dexter.read_file passed non-string for 'destination' of: " + destination);
        }
        super();
        this.source = source; //Instruction.Dexter.read_file.add_default_file_prefix_maybe(source)
              //add_default no longer used. We pass teh users path straight thru.
              //if it starts with a letter (not slash or special char like *)
              //it gets file from /srv/samba/share
        this.destination = destination;
        this.first_do_item_call = true;
        this.is_done = false;
        this.processing_r_instruction = false;
        this.robot = robot;
        this.inserting_instruction = true;
    }
    do_item (job_instance){
        if(!this.robot) { this.set_instruction_robot_from_job(job_instance); }
        if (this.first_do_item_call) {
            const sim_actual = Robot.get_simulate_actual(this.robot.simulate);
            //have to check for dexter_file_systems or else the 2nd time I run the job, it will
            //have a double length path with 2 dexter_file_systems parts
            if (!this.source.startsWith("/") && (sim_actual === true) && !this.source.startsWith("dexter_file_systems")) {
                this.fuller_source = "dexter_file_systems/" + this.robot.name + "/" + this.source;
            }
            else { this.fuller_source = this.source; }
            job_instance.user_data[this.destination] = "";
            this.first_do_item_call = false;
            this.is_done = false;
            this.processing_r_instruction = false;
        }
        //the below can never happen
        //if (this.is_done) {
        //    this.processing_r_instruction = false
        //    return Control.break()
        //}
        let read_file_instance = this;
        let robot = this.robot; //closed over
        job_instance.insert_single_instruction(Control.loop(true, function(content_hunk_index){
                if (read_file_instance.is_done) {
                    //init this inst just in case it gets used again
                    read_file_instance.is_done = false;
                    read_file_instance.first_do_item_call = true;
                    read_file_instance.processing_r_instruction = false;
                    return Control.break()
                }
                else {
                    read_file_instance.processing_r_instruction = true;
                    return [make_ins("r", content_hunk_index, read_file_instance.fuller_source, robot),
                            Control.wait_until(function(){
                                return !read_file_instance.processing_r_instruction
                             })
                           ]
                }
            })
        );
        job_instance.set_up_next_do(1);
    }

    //back up over dolist and return the first Instruction.Dexter.read_file found
    //called from got_content_hunk AND Dexter.done_with_instruction
    static find_read_file_instance_on_do_list(job_instance, starting_ins_id){
        for (let i = starting_ins_id; i >= 0; i--){
            let an_instruction = job_instance.do_list[i];
            if(an_instruction instanceof Instruction$1.Dexter.read_file){
                    return an_instruction
            }
        }
        shouldnt("find_read_file_instance_on_do_list failed to find<br/>" +
            "an instance of Dexter.read_file on Job." + job_instance.name + ".do_list<br/>" +
            "at or before instruction: " + starting_ins_id);
    }

    //called from socket.js
    //payload_string_maybe is a string or an error code (an int > 0)
    static got_content_hunk(job_id, ins_id, payload_string_maybe){
        let job_instance = Job.job_id_to_job_instance(job_id);
        if (job_instance == null){
            throw new Error("Dexter.robot_done_with_instruction passed job_id: " + job_id +
                " but couldn't find a Job instance with that job_id.")
        }
        let read_file_instance = this.find_read_file_instance_on_do_list(job_instance, ins_id);
        read_file_instance.processing_r_instruction = false;
        if(typeof(payload_string_maybe) == "string"){ //do the usual
            job_instance.user_data[read_file_instance.destination] += payload_string_maybe;
            if(payload_string_maybe.length < Instruction$1.Dexter.read_file.payload_max_chars){
                read_file_instance.is_done = true;
            }
        }
        else if(typeof(payload_string_maybe) == "number"){ //an error number.
            job_instance.user_data[read_file_instance.destination] = payload_string_maybe; //set, don't append
            read_file_instance.is_done = true;
        }
    }

    //used by Dexter.write_file to prepare path for passing it to make_ins("W" ...)
    //because the path used for write_file defaults to "srv/samba/share/dde_apps",
    //whereas the path for make_ins("W" ...) defaults to srv/samba/share
    //see Dexter.srv_samba_share_default_to_absolute_path to do the opposite
    //no longer used.
    /*static add_default_file_prefix_maybe(path){
        if      (path.startsWith("/"))   { return path }
        else if (path.startsWith("#"))   { return path }
        else if (path.startsWith("./"))  { return "dde_apps/" + path.substring(2) }
        else if (path.startsWith("../")) { return path.substring(3) } //will go to dexrun's default folder, ie /srv/samba/share/
        else                             { return "dde_apps/" + path }
    }*/

    to_source_code(args){
        let result = "Dexter.";
        if(this.robot) { result += this.robot.name + "."; }
        result += args.indent +
                  "read_file(" +
                  to_source_code({value: this.source}) + ", " +
                  to_source_code({value: this.destination}) +
                  ")";
        return result
    }
};
Instruction$1.Dexter.read_file.payload_max_chars = 62;

//James Wigglesworth
//Started: 6_23_17
//Updated: 6_29_17

function sind(theta){
	if(theta%180 == 0){
    	return 0
    }
	return Math.sin(theta*Math.PI/180)
}

function cosd(theta){
	if((theta+90)%180 == 0){
    	return 0
    }
	return Math.cos(theta*Math.PI/180)
}


function acosd(ratio){
	return Math.acos(ratio)*180/Math.PI
}

function atan2d(num1, num2){
	return Math.atan2(num1, num2)*180/Math.PI
}

//Convert Class

class Convert{
	//Private
    //This is used to prevent functions from altering outside arrays
    static deep_copy(arg){
        //return JSON.parse(JSON.stringify(arg))
    	if (typeof(arg) == "number"){
        	return arg
        }else {
        	let result = [];
        	for(var i = 0; i < arg.length; i++){
            	let elt = arg[i];
                if (typeof(elt) !== "number"){
                    elt = elt.slice(0);
                }
                result.push(elt);
            }
            return result
        }
    }


    //*******************************************
    //Rotation representation conversions:

    static angles_to_DCM(angles = [0, 0, 0], sequence = "XYZ"){
    	//default could be ZX'Z'
        
        var result = [];
        let elt = "";
        for(let char of sequence){
        	if(elt.length == 1){
            	if(char == "'"){
                	elt += char;
                    result.push(elt);
                    elt = "";
                }else {
                	result.push(elt);
                    elt = char;
                }
            }else {
            	elt = char;
            } 
        }
        if((elt != "'") && (elt.length == 1)){
        	result.push(elt);
        }

    	let DCM = Vector$1.identity_matrix(3);
        if(result.length == 3){
        	for(var i = 0; i < 3; i++){
        		DCM = Vector$1.rotate_DCM(DCM, result[i], angles[i]); 
            }
        }
        return Vector$1.transpose(DCM)
    }
    //Convert.angles_to_DCM([Convert.degrees_to_arcseconds(45), Convert.degrees_to_arcseconds(45), 0])

    static DCM_to_angles(DCM, sequence = "XYZ"){
    	
    }

    static quat_to_DCM(quaternion = [1, 0, 0, 0]){
    	//Algorithm was found here:
        //http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/
    	let w = quaternion[0];
        let x = quaternion[1];
        let y = quaternion[2];
        let z = quaternion[3];
        
        let DCM = Vector$1.make_matrix(3,3);
        DCM[0][0] = 1-2*y*y-2*z*z;
        DCM[1][0] = 2*x*y+2*z*w;
        DCM[2][0] = 2*x*z-2*y*w;
        DCM[0][1] = 2*x*y-2*z*w;
        DCM[1][1] = 1-2*x*x-2*z*z;
        DCM[2][1] = 2*y*z+2*x*w;
        DCM[0][2] = 2*x*z+2*y*w;
        DCM[1][2] = 2*y*z-2*x*w;
        DCM[2][2] = 1-2*x*x-2*y*y;
        return DCM
    }


    static DCM_to_quat(DCM){
    	//Algorithm was found here:
        //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
    	let trace = DCM[0][0] + DCM[1][1] + DCM[2][2];
        let S, w, x, y, z, quaternion;
        if(trace > 0){
        	S = Math.sqrt(1.0 + trace) * 2;
			w = .25 * S;
            x = (DCM[2][1] - DCM[1][2]) / S;
            y = (DCM[2][1] - DCM[1][2]) / S;
            z = (DCM[2][1] - DCM[1][2]) / S;
        }else if(DCM[0][0] > DCM[1][1] && DCM[0][0] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[0][0] - DCM[1][1] - DCM[2][2]);
            w = (DCM[2][1] - DCM[1][2]) / S;
            x = .25 * S;
            y = (DCM[0][1] + DCM[1][0]) / S;
            z = (DCM[0][2] + DCM[2][0]) / S;
        }else if(DCM[1][1] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[1][1] - DCM[0][0] - DCM[2][2]);
            w = (DCM[0][2] - DCM[2][0]) / S;
            x = (DCM[0][1] + DCM[1][0]) / S;
            y = .25 * S;
            z = (DCM[1][2] + DCM[2][1]) / S;
        }else if(DCM[1][1] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[2][2] - DCM[0][0] - DCM[1][1]);
            w = (DCM[1][0] - DCM[0][1]) / S;
            x = (DCM[0][2] + DCM[2][0]) / S;
            y = (DCM[1][2] + DCM[2][1]) / S;
            z = .25 * S;
        }
    	quaternion = [w, x, y, z];
        return quaternion
    }
    
}

//Vector Class

var dde_github_issues = "https://github.com/cfry/dde/issues";

class Vector$1{
//The Vector Class contains functions for manipulating the following:
/*

 Name        |    Variable    |    Syntax    |       Example        |     Description
 point               U           [x, y, z]          [1, 2, 3]           Defines a 3D position. Default units are microns.
 vector              Uab         [x, y, z]          [1, 2, 3]           Defines a 3D direction and magnitude. Uab = Ua-Ub.
 unit vector         V           [x, y, z]        [0, .707, .707]       Defines a 3D direction. Magnitude is scaled to be 1.
 plane               P           [x, y, z, d]    [0, .707, .707, 5]     Unit vector perpendicular to plane and distance from the origin.
 
*/

    static size (a){
    	
    	if (a === undefined){
        	dde_error("input to function 'size()' is undefined", "red");
            return
        }
        if (a === null){
        	dde_error("input to function 'size()' is null:");
            return
        }
        
        if (typeof(a) == "number"){
        	return 1
        }
		//debugger
    	let temp_size = a.length;
        
        
        if (temp_size === undefined){
        	return 1
        }else {
        /*
        	let a_temp = a
        	let result = []
        	let i = 0
        	while (a_temp !== undefined){
        		i++
        		result.push(a_temp.length)
            	a_temp = a[i]
        	}*/
        	return temp_size
        }
    }
    
    static max (array){
    	let dim = Vector$1.matrix_dimensions(array);
        let max = -Infinity;
        for(let i = 0; i < dim[0]; i++){
        	for(let j = 0; j < dim[0]; j++){
        		if(array[i][j] > max){
                	max = array[i][j];
                }
        	}
        }
        return max
    }

    static min (array){
    	let dim = Vector$1.matrix_dimensions(array);
        let min = Infinity;
        for(let i = 0; i < dim[0]; i++){
        	for(let j = 0; j < dim[0]; j++){
        		if(array[i][j] < max){
                	min = array[i][j];
                }
        	}
        }
        return min
    }
    
    
    //Vector.size([0, 0, 1])

    //Public
    //Returns the unit vector of the input
    //Works for both 2D and 3D vectors
    static normalize(vector){
    	let magnitude = Vector$1.magnitude(vector);
        return Vector$1.divide(vector, magnitude)
    }
    
    
    //Public
    //Returns the dot product of two arrays
    //Will work for arrays of any equal length
    static dot (vector_A, vector_B){
    	var A_size = Vector$1.size(vector_A);
        var B_size = Vector$1.size(vector_B);
        var point, plane;
        var product = 0;
        if (A_size === B_size){
        	if(A_size == 1){
            	return vector_A*vector_B
            }
        	for(var i = 0; i < Math.min(A_size, B_size); i++){
        		product += vector_A[i] * vector_B[i];
        	}
        	
        }else {
        	if (A_size === 3 && B_size === 4){
            	point = [vector_A[0], vector_A[1], vector_A[2], 1];
                plane = vector_B;
            }else {
            	if (A_size === 4 && B_size === 3){
                	point = [vector_B[0], vector_B[1], vector_B[2], 1];
                	plane = vector_A;
                }else {
                	if (A_size === 3 && B_size === 4){
                		point = [vector_A[0], vector_A[1], vector_A[2], 1];
                		plane = vector_B;
                    }else {
                    	if(vector_A[0].length == vector_B.length){
                        	for(var i = 0; i < vector_A[0].length; i++){
        						product += vector_A[0][i] * vector_B[i];
        					}
                            return product
                        }else {
                        	if(vector_B[0].length == vector_A.length){
                            	for(var i = 0; i < vector_B[0].length; i++){
        							product += vector_A[i] * vector_B[0][i];
        						}
                            }else {
                				dde_error("Reconsider the input size in the function 'Vector.dot()'", "red");
                    			return null
                            }
                        }
                	}
                }
            }
            
        	for(var i = 0; i < 4; i++){
        		product += point[i] * plane[i];
        	}
        }
        return product
    }
    
    //Public
    //Returns the cross product of two vectors
    //Vectors must be equal lengths
    static cross (vector_A, vector_B){
		var A_size = vector_A.length;
    	var B_size = vector_B.length;
    	var mat_size = Math.min(A_size, B_size);
    	var vector_C = new Array(mat_size);
    	for(var i = 0; i < mat_size; i++){
      		vector_C[i] = (vector_A[(i + 1) % mat_size] * vector_B[(i + 2) % mat_size]) - (vector_A[(i + 2) % mat_size] * vector_B[(i + 1) % mat_size]);
    	}
      	return vector_C
	}
    
    //*************************************************
    
    
	//Public
    //This is used to add vectors of equal length
    //Can also add scalars to each element in vector
    //unlimited number of inputs args
    static add(...args){
        let temp_args = Convert.deep_copy(args);
        var sum = temp_args[0];
        
    	for(let i = 1; i < Vector$1.size(args); i++){
        	if (Vector$1.size(args[i]) === Vector$1.size(sum)){
				if (Vector$1.size(sum) === 1){
                	sum += args[i];
                }else {
                	for(let j = 0; j < Vector$1.size(sum); j++){
                		sum[j] += args[i][j];
                	}
                }
            	
            }else {
            	if (Vector$1.size(args[i]) === 1){
                	for(let j = 0; j < Vector$1.size(sum); j++){
                		sum[j] += args[i];
                	}
                }else {
                	if (Vector$1.size(sum) === 1){
                    var temp = sum;
                    sum = args[i];
                		for(var j = 0; j < Vector$1.size(sum); j++){
                			sum[j] += temp;
                        }
                	}else {
                    	let dim_1 = Vector$1.matrix_dimensions(sum);
                        let dim_2 = Vector$1.matrix_dimensions(args[i]);
                        if(dim_1[0] == 1 && dim_1[1] == dim_2[1]){
                        	let shift_vector = sum;
                            sum = args[i];
                            for(let m = 0; m < dim_2[0]; m++){
                            	sum[m] = Vector$1.add(sum[m], shift_vector);
                            }
                        }else if(dim_2[0] == 1 && dim_2[1] == dim_1[1]){
                        	let shift_vector = args[i];
                            for(let m = 0; m < dim_1[0]; m++){
                            	sum[m] = Vector$1.add(sum[m], shift_vector);
                            }
                        }else {
                    		dde_error("Error: inputs to function 'add()' are not correct sizes:<br/>" + JSON.stringify(args), "red");
                        }
                    }
                }
            }
        }
        return sum
        
    }
    
    
    
    //Public
    //This is used to subtract vectors of equal length
    //Can also add scalars to each element in vector
    //unlimited number of inputs args
    static subtract (...args){
        let temp_args = Convert.deep_copy(args);
        var sum = temp_args[0];
        
    	for(var i = 1; i < Vector$1.size(temp_args); i++){
        	if (Vector$1.size(temp_args[i]) === Vector$1.size(sum)){
				if (Vector$1.size(sum) === 1){
                	sum -= temp_args[i];
                }else {
                	for(var j = 0; j < Vector$1.size(sum); j++){
                		sum[j] -= temp_args[i][j];
                	}
                }
            	
            }else {
            	if (Vector$1.size(temp_args[i]) === 1){
                	for(var j = 0; j < Vector$1.size(sum); j++){
                		sum[j] -= temp_args[i];
                	}
                }else {
                	if (Vector$1.size(sum) === 1){
                    var temp = sum;
                    sum = temp_args[i];
                		for(var j = 0; j < Vector$1.size(sum); j++){
                			sum[j] -= temp;
                        }
                	}else {
                    	dde_error("inputs to function 'subtract()' are not correct sizes:<br/>" + JSON.stringify(args), "red");
                    }
                }
            }
        }
        return sum
    }
        
    //Public
    //This should be re-written in a more clever way....
    static multiply(...args){
        if (args === undefined){
        	dde_error("Error: the function 'Vector.multiply' has undefined inputs");
        }
        
        let temp_args = Convert.deep_copy(args);
        var product = temp_args[0];

    	for(var i = 1; i < Vector$1.size(args); i++){
        	let temp_arg = args[i];
            if(temp_arg === undefined) {
                dde_error("Vector.multiply passed an arg that was undefined in: " + args);
			}
        	var temp_arg_size = Vector$1.size(temp_arg);
        	var product_size = Vector$1.size(product);
        	if (product_size === 1 && temp_arg_size === 1){
        		product *= temp_arg;
        	}else {
        		if (temp_arg_size === product_size){
					for(var j = 0; j < temp_arg_size; j++){
            			var arg_element_length = Vector$1.size(temp_arg[j]);
                    	var product_element_length = Vector$1.size(product[j]);
            			if (arg_element_length === 1 && arg_element_length === 1){
							product[j] *= temp_arg[j];
						}else {
                    		if (arg_element_length === product_element_length){
								for(var k = 0; k < arg_element_length; k++){
									product[j][k] *= temp_arg[j][k];
								}
                        	}else {
                        		if (arg_element_length === 1){
                            		for(var k = 0; k < product_element_length; k++){
                                		product[j][k] *= temp_arg[j];
                                	}
                            	}
                            	if (product_element_length === 1){
                            		var product_element_val = product[j];
                            		for(var k = 0; k < arg_element_length; k++){
                                		product[j][k] = temp_arg[j][k] * product_element_val;
                                	}
                            	}
                        	}
            			}
          			}
        		}else {
                	if (Vector$1.size(temp_arg) === 1){
                		for(var j = 0; j < Vector$1.size(product); j++){ 
                        	if (Vector$1.size(product[j]) === 1){
                        		product[j] *= temp_arg;
                        	}else {
                        		for(var k = 0; k < product[j].length; k++){
                            		product[j][k] *= temp_arg;
                            	}
                        	}
                        }
                	}else {
                		if (Vector$1.size(product) === 1){
                    		var temp = product;
                    		product = temp_arg.slice(0);
                			for(var j = 0; j < Vector$1.size(product); j++){
                				if (Vector$1.size(product[j]) === 1){
                        			product[j] *= temp;
                        		}else {
                        			for(var k = 0; k < product[j].length; k++){
                            			product[j][k] *= temp;
                            		}
                        		}
                    		}
                		}else {
                    		dde_error("inputs to function 'multiply()' are not correct sizes:<br/>" + JSON.stringify(args), "red");
                    	}
                	}
            	}
        	}
    	}
        return product
    }
    /*
    var pose_1 = [[1, 0, 0, 10], 
			     [0, 1, 0, 20],
			     [0, 0, 1, 30],
			     [0, 0, 0,  1]]
		var pose_2 = [[1, 0, 0, 100], 
			     [0, 1, 0, 200],
			     [0, 0, 1, 300],
			     [0, 0, 0,  1]]
		var result_1 = Vector.matrix_multiply(pose_1, pose_2)
        var result_2 = Vector.matrix_multiply(pose_2, pose_1)
    */
    
    //Public
    static divide (...args){
        if (args === undefined){
        	dde_error("the function 'Vector.divide' has undefined inputs");
        }
        
        let temp_args = Convert.deep_copy(args);
        var quotient = temp_args[0];

    	for(var i = 1; i < Vector$1.size(args); i++){
        	let temp_arg = args[i];
        	var temp_arg_size = Vector$1.size(temp_arg);
        	var quotient_size = Vector$1.size(quotient);
        	if (quotient_size === 1 && temp_arg_size === 1){
        		quotient /= temp_arg;
        	}else {
        		if (temp_arg_size === quotient_size){
					for(var j = 0; j < temp_arg_size; j++){
            			var arg_element_length = Vector$1.size(temp_arg[j]);
                    	var quotient_element_length = Vector$1.size(quotient[j]);
            			if (arg_element_length === 1 && arg_element_length === 1){
							quotient[j] /= temp_arg[j];
						}else {
                    		if (arg_element_length === quotient_element_length){
								for(var k = 0; k < arg_element_length; k++){
									quotient[j][k] /= temp_arg[j][k];
								}
                        	}else {
                        		if (arg_element_length === 1){
                            		for(var k = 0; k < quotient_element_length; k++){
                                		quotient[j][k] /= temp_arg[j];
                                	}
                            	}
                            	if (quotient_element_length === 1){
                            		var quotient_element_val = product[j];
                            		for(var k = 0; k < arg_element_length; k++){
                                		quotient[j][k] = quotient_element_val / temp_arg[j][k];
                                	}
                            	}
                        	}
            			}
          			}
        		}else {
                	if (Vector$1.size(temp_arg) === 1){
                		for(var j = 0; j < Vector$1.size(quotient); j++){ 
                        	if (Vector$1.size(quotient[j]) === 1){
                        		quotient[j] /= temp_arg;
                        	}else {
                        		for(var k = 0; k < quotient[j].length; k++){
                            		quotient[j][k] /= temp_arg;
                            	}
                        	}
                        }
                	}else {
                		if (Vector$1.size(quotient) === 1){
                    		var temp = quotient;
                    		quotient = temp_arg.slice(0);
                			for(var j = 0; j < Vector$1.size(quotient); j++){
                				if (Vector$1.size(quotient[j]) === 1){
                        			quotient[j] = temp / quotient[j];
                        		}else {
                        			for(var k = 0; k < quotient[j].length; k++){
                            			quotient[j][k] = temp / quotient[j][k];
                            		}
                        		}
                    		}
                		}else {
                    		dde_error("inputs to function 'divide()' are not correct sizes:<br/>" + JSON.stringify(args), "red");
                    	}
                	}
            	}
        	}
    	}
        return quotient
    }
    /*
    var pose_1 = [[1, 0, 0, 10], 
			     [0, 1, 0, 20],
			     [0, 0, 1, 30],
			     [0, 0, 0,  1]]
		var pose_2 = [[1, 0, 0, 100], 
			     [0, 1, 0, 200],
			     [0, 0, 1, 300],
			     [0, 0, 0,  1]]
		var result_1 = Vector.matrix_divide(pose_1, pose_2)
        var result_2 = Vector.matrix_divide(pose_2, pose_1)
    */
    
    /*
    debugger
    Vector.average([1, 2, 3])
    */


    static average(...args){
    	let temp_args = Convert.deep_copy(args);
        let sum;
        if(temp_args.length == 1){
        	sum = temp_args[0][0];
        	for(let i = 1; i < temp_args[0].length; i++){
            	sum += temp_args[0][i];
            }
            return sum/temp_args[0].length
        }
        
        sum = temp_args[0];
    	for(var i = 1; i < Vector$1.size(args); i++){
        	if (Vector$1.size(args[i]) === Vector$1.size(sum)){
				if (Vector$1.size(sum) === 1){
                	sum += args[i];
                }else {
                	for(var j = 0; j < Vector$1.size(sum); j++){
                		sum[j] += args[i][j];
                	}
                }
            	
            }else {
            	if (Vector$1.size(args[i]) === 1){
                	for(var j = 0; j < Vector$1.size(sum); j++){
                		sum[j] += args[i];
                	}
                }else {
                	if (Vector$1.size(sum) === 1){
                    var temp = sum;
                    sum = args[i];
                		for(var j = 0; j < Vector$1.size(sum); j++){
                			sum[j] += temp;
                        }
                	}
                }
            }
        }
        return Vector$1.divide(sum, args.length)
    }
    //Vector.average([2, 2], [4, 4])
    
   //private fns here
    
	
    
    //Public
	static distance(...args) {
    	/*SYNTAX:
        	Kin.distance(POINT)        -> distance between point and origin / magnitude of VECTOR
            Kin.distance(POINT, POINT) -> distance between points
            Kin.distance(PLANE, POINT) -> distance between plane and point
            Kin.distance(POINT, PLANE) -> distance between point and point
        */
        var temp_args = Convert.deep_copy(args);
        
        
        switch(Vector$1.size(args)){
            
        	case 1:
            	var a = temp_args[0];
            	switch(Vector$1.size(a)){
					case 2:
                    	//magnitude of 2D vector
                    	return Math.hypot(a[0], a[1])
                 	case 3:
						//magnitude of 3D vector
						return Math.hypot(a[0], a[1], a[2])
					case 4:
						//distance between plane and origin
						return a[4]
					default:
						dde_error("single vector input to function 'distance()' must have a size of 2, 3, or 4", "red");
						return null
             	}
                
                
            case 2:
            	var a = args[0].slice(0);
                var b = args[1].slice(0);
            	var aL = Vector$1.size(a);
                var bL = Vector$1.size(b);
                var point;
                var plane;
            	if (aL === 2 && bL === 2){
                	return Math.hypot(a[0] - b[0], a[1] - b[1])
                }
            	if (aL === 3 && bL === 3){
                	return Math.hypot(a[0] - b[0], a[1] - b[1], a[2] - b[2])
                }else {
                	if (aL === 3 && bL === 4){
                    	point = a;
                        plane = b;
                    }else {
                    	if (aL === 4 && bL === 3){
                        	plane = a;
                            point = b;
                        }else {
                        	dde_error("inputs for function 'distance()' must be a point, plane, or vector", "red");
                            return null
                        }
                    }
					return dist_point_to_plane(point, plane)
                }
                
            case 3:
                point = args[0].slice(0);
                var line_point_A = args[1].slice(0);
                var line_point_B = args[2].slice(0);
                if (Vector$1.size(point) === 3 && Vector$1.size(line_point_A) === 3 && Vector$1.size(line_point_B) === 3){
            		return dist_point_to_line(point, line_point_A, line_point_B)
                }
            	break
            
            default:
            	let sum = 0;
            	for(var i = 0; i < temp_args.length; i++){
                	sum += temp_args[i] * temp_args[i];
                }
            	return Math.sqrt(sum)
        }

    }
    
    static magnitude(vector){
    	if(vector.length == undefined){
        	return vector
        }
    	let sum = 0;
        for(var i = 0; i < vector.length; i++){
          sum += vector[i] * vector[i];
        }
      	return Math.sqrt(sum)
    }
    
    //Public
    static complete_plane(plane, point){
    	if (Vector$1.size(plane) === 3){
        	var vector = Vector$1.normalize(plane);
        	var d = Vector$1.dot(vector, point);
            vector.push(d);
            return vector
    	}else {
        	return plane
        }
    }
    
    //Public
    static project_vector_onto_plane(vector, plane){
		var short_plane = [plane[0], plane[1], plane[2]];
		var term1 = Vector$1.dot(vector, short_plane);
    	var term2 = Math.pow(Vector$1.distance(short_plane), 2);
		return Vector$1.subtract(vector, Vector$1.multiply(term1 / term2, short_plane))
	}

    static project_point_onto_line(point, line_point_1, line_point_2){
    	let U1a = line_point_1;
        let U1b = point;
        let U2a = line_point_1;
        let U2b = line_point_2;
        let U1ba = Vector$1.subtract(U1b, U1a);
        let U2ba = Vector$1.subtract(U2b, U2a);
        let proj = Vector$1.add(Vector$1.multiply(Vector$1.dot(U2ba, U1ba) /
                                 Math.pow(Vector$1.magnitude(U2ba), 2),
                                 U2ba), U2a);
        return proj
    }
    
    /*
    debugger
    Vector.sign(0)
    */
    static sign(array){
		let dim = Vector$1.matrix_dimensions(array);
        let sign_array;
        if(dim[1] == 0){
        	if(array >= 0){
            	return 1
            }else {
            	return -1
            }
        }else if(dim[0] == 1){
        	sign_array = Vector$1.make_matrix(dim)[0];
        	for(let i = 0; i < dim[1]; i++){
            	if(array[i] >= 0){
            		sign_array[i] = 1;
            	}else {
            		sign_array[i] = -1;
            	}
            }
        }else {
        	sign_array = Vector$1.make_matrix(dim);
        	for(let i = 0; i < dim[0]; i++){
            	for(let j = 0; j < dim[1]; i++){
            		if(array[i][j] >= 0){
            			sign_array[i][j] = 1;
            		}else {
            			sign_array[i][j] = -1;
            		}
                }
            }
        }
        return sign_array
	}
    
    //Public
    static points_to_plane(Ua, Ub, Uc){
    	var Uba = Vector$1.subtract(Ub, Ua);
        var Uca = Vector$1.subtract(Uc, Ua);
        Vector$1.round(Vector$1.normalize(Uba),10);
        Vector$1.round(Vector$1.normalize(Uca),10);
        /*if (Vector.is_equal(Uba_norm, Uca_norm, 10) || Vector.is_equal(Vector.multiply(-1, Uba_norm), Uca_norm, 10)){
        	return Kin.base_rotation_to_plane(0, Vector.normalize(Uba))
        }*/
        var vector = Vector$1.normalize(Vector$1.cross(Uba, Uca));
        
        
        return Vector$1.complete_plane(vector, Ua)
    }
	
    
    //Public 
    static round(number_or_array, digits = 1){
    	if(number_or_array == null) {return null}
    	let mulitplier = Math.pow(10, digits);
        if(typeof(number_or_array) == "number"){
        	return Math.round(mulitplier * number_or_array) / mulitplier
        }else {
        	let temp_array = Convert.deep_copy(number_or_array);
            let dim = Vector$1.matrix_dimensions(number_or_array);
            if(dim[0] == 1){
            	for(var i = 0; i < number_or_array.length; i++){
                    let elt = temp_array[i];
                    if(elt != null) {
                		temp_array[i] = Math.round(mulitplier * elt) / mulitplier;
					}
                }
            }else {
        		for(var i = 0; i < dim[0]; i++){
            		for(var j = 0; j < dim[1]; j++){
                        let elt = temp_array[i][j];
                        if(elt != null) {
            				temp_array[i][j] = Math.round(mulitplier * elt) / mulitplier;
						}
            		}
            	}
            }
            return temp_array
        }
    }

    
    
    //Public
    static is_equal(array1, array2, tolerance = 14, tolerance_type = "decimal_places"){
        let result = true;
        if(array1 == null) {
            if(array2 == null) { return true }
            else { return false }
        }
        else if (array2 == null) { return false }
        else if (array1.length !== array2.length){
        	return false
        }else {
        	let array1_temp = Convert.deep_copy(array1);
            let array2_temp = Convert.deep_copy(array2);
        	switch(tolerance_type){
            	case "decimal_places":
        			array1_temp = Vector$1.round(array1_temp, tolerance);
                	array2_temp = Vector$1.round(array2_temp, tolerance);
					if(array1_temp.length == undefined){
						if(array1_temp == array2_temp){
							return true
						}else {
							return false
						}
					}
					for(var i = 0; i < array1_temp.length; i++){
						if (JSON.stringify(array1_temp[i]) != JSON.stringify(array2_temp[i])){
							return false
						}
					}
					break
                case "absolute":
					if (Vector$1.max(Vector$1.abs(Vector$1.subtract(array1_temp, array2_temp))) > tolerance){
						return false
					}
					break
                
                case "percent_difference":
					if(tolerance > 1){

						warning("Percent difference tolerance should be within 0 and 1.</br>Input of "
						+ tolerance + " changed to " + (tolerance/100) + ".");
						tolerance = tolerance/100;
					}

					let avg = Vector$1.average(array1_temp, array2_temp);
					if (Vector$1.max(Vector$1.divide(Vector$1.abs(Vector$1.subtract(array1_temp, array2_temp)), avg)) > tolerance){
						return false
					}
					break
                
                case "magnitude":
					if (Vector$1.max(Vector$1.magnitude(Vector$1.subtract(array1_temp, array2_temp))) > tolerance){
						return false
					}
					break
                
                default:
					dde_error("Vector.is_equal does not support input of \"" + tolerance_type
					+ "\".</br>Supported tolerance types: \"decimal_places\", \"absolute\", \"percent_difference\", and \"magnitude\"");
                
            }
                
        }
        return result
    }
    
    
    
    //Public
    static shorten(matrix){
    	return [matrix[0], matrix[1], matrix[2]]
    }
    
    //Public
    //Returns the smallest angle between two vectors with range 0-180 degrees
    static angle(vector_A, vector_B){
    	//in case one of the vectors is a complete plane
    	var short_A = Vector$1.shorten(vector_A);
        var short_B = Vector$1.shorten(vector_B);
        var result;
    	if (Vector$1.is_equal(short_A, short_B)){
        	result =  0;
        }else {
        	if (Vector$1.distance(Vector$1.add(short_A, short_B)) === 0){
            	result = 180;
            }else {
            	var result = atan2d(Vector$1.distance(Vector$1.cross(short_A, short_B)), Vector$1.dot(short_A, short_B));
        	}
        }
        return result
    }
    
    //Public
    //Returns angle between two vectors with range -180 to 180
    static signed_angle(vector_A, vector_B, plane){
    	let epsilon = 1e-14;
    	//checks if vectors lie in plane
        var cross_product = Vector$1.normalize(Vector$1.cross(Vector$1.shorten(vector_A), Vector$1.shorten(vector_B)));
        var short_plane = Vector$1.shorten(plane);
        
        if (!(Vector$1.is_equal(cross_product, short_plane) ||
             Vector$1.is_equal(
                             Vector$1.multiply(-1, cross_product),
                             short_plane))
			&&
			(cross_product[0] === NaN)){
            dde_error("input vectors do not lie in plane");
        }
    	
    	var guess_angle = Vector$1.angle(vector_A, vector_B);
        var guess_vector = Vector$1.round(Vector$1.rotate(vector_A, plane, guess_angle), 3);
        var test_vector = Vector$1.round([vector_B[0], vector_B[1], vector_B[2]], 3);
        
        if (Vector$1.magnitude(Vector$1.subtract(guess_vector, test_vector)) < epsilon){
        //if (Vector.magnitude(Vector.subtract(guess_vector, test_vector)) < Vector.magnitude(Vector.subtract(guess_vector, Vector.multiply(-1, test_vector)))){
        	return guess_angle
        }else {
        	return -guess_angle
        }
    }
    
   
    
    
    //Public
    //returns intersection of two planes, a plane and a line, and two lines
    static intersection(...args){
    	switch (Vector$1.size(args)){
        	case 2:
        		//Assumes intersection between two planes
                return Vector$1.normalize(Vector$1.cross(args[1], args[2]))
        	case 3:
            	//Assumes intersection between plane and line
            	var line_vector, complete_point, alpha, intersection_point;
            	
            	for(var i = 0; i < 3; i++){
                	if (Vector$1.size(args[i]) === 4){
                    	var plane = args[i].slice(0);
                        var point_A = args[(i + 1) % 3].slice(0);
                        var point_B = args[(i + 2) % 3].slice(0);
                    }
                    
                }
                if (plane === undefined){
                    dde_error("inputs to the function 'Vector.intersection' must be a plane and two points or two planes");
                }
                if (Vector$1.size(point_A) !== 3 || Vector$1.size(point_B) !== 3){
                	dde_error("inputs to the function 'Vector.intersection' must be a plane and two points or two planes");
                }
                
                //Assumes plane is passed in along with a line defined by a point and unit vector
                if (Vector$1.distance(point_A) === 1 && Vector$1.distance(point_B) !== 1){
                	line_vector = point_A;
                    complete_point = [point_B[0], point_B[1], point_B[2], 1];
                    alpha = -Vector$1.dot(plane, complete_point) / (Math.pow(line_vector[0], 2), Math.pow(line_vector[1], 2), Math.pow(line_vector[2], 2));
                    intersection_point = Vector$1.add(Vector$1.multiply(alpha, line_vector), point_B);
                    return intersection_point
                }
                
                //Assumes plane is passed in along with a line defined by a point and unit vector
                if (Vector$1.distance(point_A) !== 1 && Vector$1.distance(point_B) === 1){
                	line_vector = point_B;
                    complete_point = [point_A[0], point_A[1], point_A[2], 1];
                    alpha = -Vector$1.dot(plane, complete_point) / (Math.pow(line_vector[0], 2), Math.pow(line_vector[1], 2), Math.pow(line_vector[2], 2));
                    intersection_point = Vector$1.add(Vector$1.multiply(alpha, line_vector), point_A);
                    return intersection_point
                }
                
                //Assumes plane is passed in along with a line defined by two points
                line_vector = Vector$1.subtract(point_B, point_A);
                complete_point = [point_A[0], point_A[1], point_A[2], 1];
                alpha = -Vector$1.dot(plane, complete_point) / (Math.pow(line_vector[0], 2), Math.pow(line_vector[1], 2), Math.pow(line_vector[2], 2));
                intersection_point = Vector$1.add(Vector$1.multiply(alpha, line_vector), point_A);
                return [intersection_point, alpha]
            
            	
        }
    }

    //Public
    //rotates a vector in 3D space on a plane by angle theta
    //will also rotate a point about a line by substituting the line's vector in plane and its point in point
    static rotate(vector, plane, theta, point = [0, 0, 0]){
    	plane =  Vector$1.normalize(Vector$1.shorten(plane));
        let dim = Vector$1.matrix_dimensions(vector);
        let result, short_vector, term_1, term_2;
        if (dim[1] == 3 && dim[0] != 1){
        	result = Vector$1.make_matrix(dim[0], 1);
            for(var i = 0; i < vector.length; i++){
            	short_vector = Vector$1.subtract(vector[i], point);
                if(Vector$1.is_equal(short_vector, point)){
            		result[i] = short_vector;
            	}else {
                	term_1 = Vector$1.multiply(cosd(theta), short_vector);
            		term_2 = Vector$1.multiply(sind(theta), Vector$1.cross(Vector$1.shorten(plane), short_vector));
                	result[i] = Vector$1.add(Vector$1.multiply(Vector$1.magnitude(short_vector),  Vector$1.normalize(Vector$1.add(term_1, term_2))), point);
                }
            }
        }else {
        	short_vector = Vector$1.subtract(Vector$1.shorten(vector), point);
            if(Vector$1.magnitude(Vector$1.cross(short_vector, plane)) < 1e-10){
            	return short_vector
            }
            term_1 = Vector$1.multiply(cosd(theta), short_vector);
            term_2 = Vector$1.multiply(sind(theta), Vector$1.cross(Vector$1.shorten(plane), short_vector));
            result = Vector$1.add(Vector$1.multiply(Vector$1.magnitude(short_vector),  Vector$1.normalize(Vector$1.add(term_1, term_2))), point);
        }
        return result
    }


    static three_points_to_transformation(point_list, pointA = [0, 0, 0], pointB = [1, 0, 0], pointC = [0, 1, 0], U4){
		
        let points_plane = Vector$1.points_to_plane(pointA, pointB, pointC);
        let dist = Vector$1.distance(U4, points_plane);
        out("input plane and dist:");
        out(points_plane);
        out(dist);
        if(dist < 0){
        	points_plane = Vector$1.multiply(-1, points_plane);
        }
        if(!Vector$1.is_equal(points_plane, [0, 0, 1], 4)){
        	let intersection_axis = Vector$1.cross(points_plane, [0, 0, 1]);
            let phi = Vector$1.signed_angle([1, 0, 0], points_plane, intersection_axis);
            for(var i = 0; i < point_list.length; i++){
				point_list[i] = Vector$1.rotate(point_list[i], [0, 0, 1], phi);
			}
        }
        
    	let rot_plane = Vector$1.cross(points_plane, [0, 0, 1]);
    	let theta = Vector$1.signed_angle([0, 0, 1], points_plane, rot_plane);
        
        let new_point_list = [];

        let sum = [0, 0, 0];
        if (point_list[0].length === 2){
        	for(var i = 0; i < point_list.length; i++){
				new_point_list[i] = Vector$1.rotate([point_list[i][0], point_list[i][1], 0], rot_plane, theta);
        		drawing_centroid = Vector$1.add(sum, new_point_list[i]);
			}
        }
        if (point_list[0].length === 3){
        	for(var i = 0; i < point_list.length; i++){
				point_list[i] = [-point_list[i][0], point_list[i][1], point_list[i][2]]; 
			}
        	for(var i = 0; i < point_list.length; i++){
				new_point_list.push(Vector$1.rotate([point_list[i][0], point_list[i][1], point_list[i][2]], rot_plane, theta));
        		drawing_centroid = Vector$1.add(sum, new_point_list[i]);
			}
        }
        drawing_centroid = Vector$1.multiply(drawing_centroid, 1 / point_list.length);
        let plane_centroid = Vector$1.multiply(Vector$1.add(pointA, pointB, pointC), 1 / 3);
        let distance_vector = Vector$1.subtract(plane_centroid, drawing_centroid);
        for(var i = 0; i < point_list.length; i++){
			new_point_list[i] = Vector$1.add(new_point_list[i], distance_vector);
		}
    
    	return [new_point_list, Vector$1.shorten(points_plane)]
    	//[x*cos(theta)+dx, y*cos(theta)+dy, (Py*y + Pz*x)*sin(theta)+dz]
	}

    static max(vector){
    	let dim = Vector$1.matrix_dimensions(vector);
        let temp_max;
        
        if(dim[0] == 1){
        	if(dim[1] == 0){
            	return vector
            }
        	temp_max = -Infinity;
        	for(let i = 0; i < dim[1]; i++){
            	if(vector[i] > temp_max){
                	temp_max = vector[i];
                }
            }
        }else {
        	temp_max = Vector$1.make_matrix(1, dim[1], -Infinity)[0];
        	for(let j = 0; j < dim[1]; j++){
            	for(let i = 0; i < dim[0]; i++){
            		if(vector[i][j] > temp_max[j]){
                		temp_max[j] = vector[i][j];
                	}
            	}
        	}
    	}
    	return temp_max
    }
    /*
    debugger
    var result = Vector.max([[1, 2, 10], [4, 5, 6]])
    var result = Vector.max([1, 2, 10])
    */

    static min(vector){
    	let dim = Vector$1.matrix_dimensions(vector);
        let temp_min;
        if(dim[0] == 1){
        	if(dim[1] == 0){
            	return vector
            }
        	temp_min = Infinity;
        	for(let i = 0; i < dim[1]; i++){
            	if(vector[i] < temp_min){
                	temp_min = vector[i];
                }
            }
        }else {
        	temp_min = Vector$1.make_matrix(1, dim[1], Infinity)[0];
        	for(let j = 0; j < dim[1]; j++){
            	for(let i = 0; i < dim[0]; i++){
            		if(vector[i][j] < temp_min[j]){
                		temp_min[j] = vector[i][j];
                	}
            	}
        	}
    	}
    	return temp_min
    }
    /*
    var result = Vector.min([[1, 2, 10], [4, 5, 6]])
    var result = Vector.min([1, 2, 10])
    */

    static is_NaN(vector){
    	let dim = Vector$1.matrix_dimensions(vector);
        if(dim[0] == 1 && dim[1] == 0){return isNaN(vector)}
        if(dim[0] == 1){
        	for(let i = 0; i < dim[1]; i++){
        		if(isNaN(vector[i])){return true}
        	}
        }else {
        	for(let i = 0; i < dim[0]; i++){
            	for(let j = 0; j < dim[1]; j++){
        			if(isNaN(vector[i][j])){return true}
                }
        	}
        }
        return false
    }

    static is_NaN_null_or_undefined(vector){
        let dim = Vector$1.matrix_dimensions(vector);
        if(dim[0] == 1 && dim[1] == 0){return is_NaN_null_or_undefined(vector)}
        if(dim[0] == 1){
            for(let i = 0; i < dim[1]; i++){
                if(is_NaN_null_or_undefined(vector[i])){return true}
            }
        }else {
            for(let i = 0; i < dim[0]; i++){
                for(let j = 0; j < dim[1]; j++){
                    if(is_NaN_null_or_undefined(vector[i][j])){return true}
                }
            }
        }
        return false
    }

    static sum (array){
    	let dim = Vector$1.matrix_dimensions(array);
        let sum = 0;
        if(dim[0] == 1){
        	for(let i = 0; i < dim[1]; i++){
            	sum += array[i];
            }
        }
        return sum
    }
    
    /*
    debugger
    Vector.abs([[-10, 9], [-8, -6],[-1, -5]])
    Vector.abs([[-10, 9], [-8, -6]])
    */
    static abs(array){
    	let dim = Vector$1.matrix_dimensions(array);
        let array_copy = Convert.deep_copy(array);
        
        if(dim[1] == 0){
        	return Math.abs(array)
        }else if(dim[0] == 1){
        	array_copy = Vector$1.make_matrix(dim)[0];
        	for(let i = 0; i < dim[1]; i++){
            	array_copy[i] = Math.abs(array[i]);
            }
        }else {
        	array_copy = Vector$1.make_matrix(dim);
        	for(let i = 0; i < dim[0]; i++){
            	for(let j = 0; j < dim[1]; j++){
            		array_copy[i][j] = Math.abs(array[i][j]);
                }
            }
        }
        return array_copy
    }
    /*
    var myvec = [1, -4, 5, -4]
    Vector.abs(myvec)
    out(myvec)
    */

    static pow(array, power){
    	let dim = Vector$1.matrix_dimensions(array);
        let array_copy = Convert.deep_copy(array);
        
        if(dim[1] == 0){
        	return Math.pow(array, power)
        }else if(dim[0] == 1){
        	array_copy = Vector$1.make_matrix(dim)[0];
        	for(let i = 0; i < dim[1]; i++){
            	array_copy[i] = Math.pow(array[i], power);
            }
        }else {
        	array_copy = Vector$1.make_matrix(dim);
        	for(let i = 0; i < dim[0]; i++){
            	for(let j = 0; j < dim[1]; j++){
            		array_copy[i][j] = Math.pow(array[i][j], power);
                }
            }
        }
        return array_copy
    }
    
    
    
    /*
    Vector.is_greater([4, 4, 5], [4, 3, 5])
    */
    static is_greater(vector_1, vector_2){
        let state = false;
        for(let i = 0; i < vector_1.length; i++){
        	if(vector_1[i] > vector_2[i]){
            	state = true;
                break
            }
        }
        return state
    }

    static is_less(vector_1, vector_2){
        let state = false;
        for(let i = 0; i < vector_1.length; i++){
        	if(vector_1[i] < vector_2[i]){
            	state = true;
                break
            }
        }
        return state
    }

    static quadratic_formula(a, b, c){
    	let det = Math.sqrt(Math.pow(b, 2) -4*a*c);
        if(isNaN(det)){
        	dde_error("Vector.quadratic_formula does not support imaginery roots yet");
        }
        return [(-b+det)/(2*a), (-b-det)/(2*a)]
    }

    static root_mean_square(vector){
    	if(vector.length){
        	let sum = 0;
        	for(let i = 0; i < vector.length; i++){
            	sum += vector[i] * vector[i];
        	}
            return Math.sqrt(sum / vector.length)
        }else {
        	return vector
        }
    }
    
    
    
	//Cubic Formula by Alexander Shtuchkin
	//https://stackoverflow.com/questions/27176423/function-to-solve-cubic-equation-analytically
    static cuberoot(x){
    	let y = Math.pow(Math.abs(x), 1/3);
    	return x < 0 ? -y : y;
	}

    static solveCubic(a, b, c, d) {
    	if (Math.abs(a) < 1e-8) { // Quadratic case, ax^2+bx+c=0
        	a = b; b = c; c = d;
        	if (Math.abs(a) < 1e-8) { // Linear case, ax+b=0
            	a = b; b = c;
            	if (Math.abs(a) < 1e-8) // Degenerate case
                	return [];
            	return [-b/a];
        	}

        	var D = b*b - 4*a*c;
        	if (Math.abs(D) < 1e-8)
            	return [-b/(2*a)];
        	else if (D > 0)
            	return [(-b+Math.sqrt(D))/(2*a), (-b-Math.sqrt(D))/(2*a)];
        	return [];
    	}

    	// Convert to depressed cubic t^3+pt+q = 0 (subst x = t - b/3a)
    	var p = (3*a*c - b*b)/(3*a*a);
    	var q = (2*b*b*b - 9*a*b*c + 27*a*a*d)/(27*a*a*a);
    	var roots;

    	if (Math.abs(p) < 1e-8) { // p = 0 -> t^3 = -q -> t = -q^1/3
        	roots = [cuberoot(-q)];
    	} else if (Math.abs(q) < 1e-8) { // q = 0 -> t^3 + pt = 0 -> t(t^2+p)=0
        	roots = [0].concat(p < 0 ? [Math.sqrt(-p), -Math.sqrt(-p)] : []);
    	} else {
        	var D = q*q/4 + p*p*p/27;
        	if (Math.abs(D) < 1e-8) {       // D = 0 -> two roots
            	roots = [-1.5*q/p, 3*q/p];
        	} else if (D > 0) {             // Only one real root
            	var u = cuberoot(-q/2 - Math.sqrt(D));
            	roots = [u - p/(3*u)];
        	} else {                        // D < 0, three roots, but needs to use complex numbers/trigonometric solution
            	var u = 2*Math.sqrt(-p/3);
            	var t = Math.acos(3*q/p/u)/3;  // D < 0 implies p < 0 and acos argument in [-1..1]
            	var k = 2*Math.PI/3;
            	roots = [u*Math.cos(t), u*Math.cos(t-k), u*Math.cos(t-2*k)];
        	}
    	}

    	// Convert back from depressed cubic
    	for (var i = 0; i < roots.length; i++)
        	roots[i] -= b/(3*a);

    	return roots;
	}

    static linspace(start, end, n){
		let result = Vector$1.make_matrix(1, n);
    	let step = (end-start)/(n-1);
    	for(let i = 0; i < n; i++){
    		result[i] = start+i*step;
    	}
    	return result
	}
    
    

	//Private
    //This is used to prevent functions from altering outside arrays
    static deep_copy(arg){
        return JSON.parse(JSON.stringify(arg))
    	/*if (typeof(arg) == "number"){
        	return arg
        }else{
        	let result = []
        	for(var i = 0; i < arg.length; i++){
            	let elt = arg[i]
                if (typeof(elt) !== "number"){
                    elt = elt.slice(0)
                }
                result.push(elt)
            }
            return result
        }*/
    }


    //*******************************************
    //Orientation representation conversions:

    static euler_angles_to_DCM(euler_angles = [0, 0, 0], euler_sequence = "ZYX"){
    	//default could be ZX'Z'
        let dim = Vector$1.matrix_dimensions(euler_angles);
        if(dim[0] == 2 && dim[1] == 3){
        	euler_sequence = euler_angles[1];
            euler_angles = euler_angles[0];
        }
        
        var result = [];
        let elt = "";
        for(let char of euler_sequence){
        	if(elt.length == 1){
            	if(char == "'"){
                	elt += char;
                    result.push(elt);
                    elt = "";
                }else {
                	result.push(elt);
                    elt = char;
                }
            }else {
            	elt = char;
            } 
        }
        if((elt != "'") && (elt.length == 1)){
        	result.push(elt);
        }
          
        
    	let DCM = Vector$1.identity_matrix(3);
        if(result.length == 3){
        	for(var i = 0; i < 3; i++){
        		DCM = Vector$1.rotate_DCM(DCM, result[i], euler_angles[i]); 
            }
        }
        //return Vector.transpose(DCM)
        return DCM
    }
    //Convert.angles_to_DCM([Convert.degrees_to_arcseconds(45), Convert.degrees_to_arcseconds(45), 0])
    /* 
    debugger
    Vector.DCM_to_euler_angles(Vector.transpose(Vector.euler_angles_to_DCM([30, 0, 0])))
    */

    static DCM_to_euler_angles(DCM, euler_sequence = "ZYX"){
    	let euler_angles = [0, 0, 0];
        switch(euler_sequence){
        	
        	case "ZYZ":
            	//euler_angles[0] = atan2d(DCM[0][1], DCM[0][0])
                //euler_angles[1] = asind(DCM[0][2])
                //euler_angles[2] = atan2d(DCM[1][2], DCM[2][2])
            	if(DCM[2][2] == 0){
                	dde_error("Singularity in DCM_to_Euler_Angles for euler_sequence: " + euler_sequence + " and DCM:");
                    out(Vector$1.round(DCM,3));
                }
            	euler_angles[0] = atan2d(DCM[2][0], DCM[2][1]);
                euler_angles[1] = acosd(DCM[2][2]);
                euler_angles[2] = atan2d(DCM[0][2], DCM[1][2]);
            
            case "XYZ":
            	let x_prime, y_prime;
                
            	let DCM_0 = DCM.slice();
                out("DCM_0:");
                out(Vector$1.round(DCM_0, 3));
                x_prime = Vector$1.transpose(Vector$1.pull(DCM_0, [0, 2], [0, 0]));
                let x_prime_proj = Vector$1.project_vector_onto_plane(x_prime, [0, 0, 1]);
                euler_angles[2] = Vector$1.signed_angle(x_prime_proj, [1, 0, 0], [0, 0, 1]);
                
                let DCM_1 = Vector$1.rotate_DCM(DCM_0, [0, 0, 1], -euler_angles[2]);
                out("DCM_1:");
                out(Vector$1.round(DCM_1, 3));
                x_prime = Vector$1.transpose(Vector$1.pull(DCM_1, [0, 2], [0, 0]));
                euler_angles[1] = Vector$1.signed_angle(x_prime, [1, 0, 0], [0, 1, 0]);
                
                //debugger
                let DCM_2 = Vector$1.rotate_DCM(DCM_1, [0, 1, 0], -euler_angles[1]);
                out("DCM_2:");
                out(Vector$1.round(DCM_2, 3));
                x_prime = Vector$1.transpose(Vector$1.pull(DCM_2, [0, 2], [0, 0]));
                Vector$1.transpose(Vector$1.pull(DCM_2, [0, 2], [2, 2]));
                y_prime = Vector$1.transpose(Vector$1.pull(DCM_2, [0, 2], [1, 1]));
                euler_angles[0] = Vector$1.signed_angle(y_prime, [0, 1, 0], [1, 0, 0]);
                
            break
            
            
            default:
           		dde_error("The euler sequence of " + euler_sequence + " is not supported.</br>If you wish to have this specific sequence implimented post an Issue on the DDE Github:</br>" + dde_github_issues);
        }
        
        return euler_angles
    }

    static quaternion_to_DCM(quaternion = [1, 0, 0, 0]){
    	//Algorithm was found here:
        //http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToMatrix/
    	let w = quaternion[0];
        let x = quaternion[1];
        let y = quaternion[2];
        let z = quaternion[3];
        
        let DCM = Vector$1.make_matrix(3,3);
        DCM[0][0] = 1-2*y*y-2*z*z;
        DCM[1][0] = 2*x*y+2*z*w;
        DCM[2][0] = 2*x*z-2*y*w;
        DCM[0][1] = 2*x*y-2*z*w;
        DCM[1][1] = 1-2*x*x-2*z*z;
        DCM[2][1] = 2*y*z+2*x*w;
        DCM[0][2] = 2*x*z+2*y*w;
        DCM[1][2] = 2*y*z-2*x*w;
        DCM[2][2] = 1-2*x*x-2*y*y;
        return DCM
    }


    static DCM_to_quaternion(DCM = Vector$1.make_DCM()){
    	//Algorithm was found here:
        //http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/
    	let trace = DCM[0][0] + DCM[1][1] + DCM[2][2];
        let S, w, x, y, z, quaternion;
        if(trace > 0){
        	S = Math.sqrt(1.0 + trace) * 2;
			w = .25 * S;
            x = (DCM[2][1] - DCM[1][2]) / S;
            y = (DCM[2][1] - DCM[1][2]) / S;
            z = (DCM[2][1] - DCM[1][2]) / S;
        }else if(DCM[0][0] > DCM[1][1] && DCM[0][0] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[0][0] - DCM[1][1] - DCM[2][2]);
            w = (DCM[2][1] - DCM[1][2]) / S;
            x = .25 * S;
            y = (DCM[0][1] + DCM[1][0]) / S;
            z = (DCM[0][2] + DCM[2][0]) / S;
        }else if(DCM[1][1] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[1][1] - DCM[0][0] - DCM[2][2]);
            w = (DCM[0][2] - DCM[2][0]) / S;
            x = (DCM[0][1] + DCM[1][0]) / S;
            y = .25 * S;
            z = (DCM[1][2] + DCM[2][1]) / S;
        }else if(DCM[1][1] > DCM[2][2]){
        	S = 2 * Math.sqrt(1 + DCM[2][2] - DCM[0][0] - DCM[1][1]);
            w = (DCM[1][0] - DCM[0][1]) / S;
            x = (DCM[0][2] + DCM[2][0]) / S;
            y = (DCM[1][2] + DCM[2][1]) / S;
            z = .25 * S;
        }
    	quaternion = [w, x, y, z];
        return quaternion
    }

    static euler_angles_to_quaternion(euler_angles = [0, 0, 0], euler_sequence = "XYZ"){
        return Vector$1.DCM_to_quaternion(Vector$1.euler_angles_to_DCM(euler_angles, euler_sequence))
    }

    static quaternion_to_euler_angles(quaternion = [1, 0, 0, 0], euler_sequence = "XYZ"){
        return Vector$1.DCM_to_euler_angles(Vector$1.quaternion_to_DCM(quaternion), euler_sequence)
    }

    static get_orientation_format(orientation){
    	let result;
        let dim = Vector$1.matrix_dimensions(orientation);
        if(dim[0] == 1 && dim[1] == 3){
            result = "euler_angles";
        }else if(dim[0] == 2 && dim[1] == 3){
            result = "euler_angles";
        }else if(dim[0] == 1 && dim[1] == 4){
            result = "quaternion";
        }else if(dim[0] == 3 && dim[1] == 3){
        	result = "DCM";
        }else {
        	dde_error("orientation is improperly formatted");
        }
        return result
    }
    
    //Euler_angles Utilities:
    static make_euler_angles(orientation = [0, 0, 0], euler_sequence = "XYZ"){
    	let format = Vector$1.get_orientation_format(orientation);
        let angles;
        switch(format){
        	case "euler_angles":
            	angles = [orientation, euler_sequence];
            break
            case "quaternion":
            	angles = Vector$1.quaternion_to_euler_angles(orientation, euler_sequence);
            break
            case "DCM":
            	angles = Vector$1.DCM_to_euler_angles(orientation, euler_sequence);
            break
        }
        return angles
    }

    static make_quaternion(orientation = [1, 0, 0, 0]){
    	let format = Vector$1.get_orientation_format(orientation);
        let quat;
        switch(format){
        	case "euler_angles":
            	quat = Vector$1.euler_angles_to_quaternion(orientation);
            break
            case "quaternion":
            	quat = orientation;
            break
            case "DCM":
            	quat = Vector$1.DCM_to_quaternion(orientation);
            break
        }
        return quat
    }
    
    //DCM Utilities:
    static make_DCM (orientation = [0, 0, 0]){
    	let type = Vector$1.get_orientation_format(orientation);
        let DCM;
        switch(type){
        	case "euler_angles":
            	DCM = Vector$1.euler_angles_to_DCM(orientation);
            break
            case "quaternion":
            	DCM = Vector$1.quaternion_to_DCM(orientation);
            break
            case "DCM":
            	DCM = orientation;
            break
        }
        return DCM
    }
    
    static get_x_vector_from_DCM(DCM = Vector$1.make_DCM()){
    	return Vector$1.transpose(Vector$1.pull(DCM, [0, 2], [0, 0]))
    }

    static get_y_vector_from_DCM(DCM = Vector$1.make_DCM()){
    	return Vector$1.transpose(Vector$1.pull(DCM, [0, 2], [1, 1]))
    }

    static get_z_vector_from_DCM(DCM = Vector$1.make_DCM()){
    	return Vector$1.transpose(Vector$1.pull(DCM, [0, 2], [2, 2]))
    }
    
    //Pose Utilities:
    static get_x_vector_from_pose(pose = Vector$1.make_pose()){
    	return Vector$1.transpose(Vector$1.pull(pose, [0, 2], [0, 0]))
    }

    static get_y_vector_from_pose(pose = Vector$1.make_pose()){
    	return Vector$1.transpose(Vector$1.pull(pose, [0, 2], [1, 1]))
    }

    static get_z_vector_from_pose(pose = Vector$1.make_pose()){
    	return Vector$1.transpose(Vector$1.pull(pose, [0, 2], [2, 2]))
    }

    static get_xyz_from_pose(pose = Vector$1.make_pose()){
    	return Vector$1.transpose(Vector$1.pull(pose, [0, 2], [3, 3]))
    }

    static get_DCM_from_pose(pose = Vector$1.make_pose()){
    	return Vector$1.transpose(Vector$1.pull(pose, [0, 2], [0, 2]))
    }
    
    /**********************************************************
    //Matrix Math
    ***********************************************************/
    /*
    Vector.make_matrix(3,"tilt")
    debugger
    Vector.make_matrix(1,0)
    */

    static make_matrix(nRows, nColumns, value = 0){
    	let result = [];
        if(nColumns === undefined){
        	if(Vector$1.matrix_dimensions(nRows)[1] == 2){
            	nColumns = nRows[1];
                nRows = nRows[0];
            }else {
        		nColumns = nRows;
            }
        }
        if(nColumns === "tilt"){
        	result = Vector$1.make_matrix(nRows);
            for(let i = 0; i < nRows; i++){
            	for(let j = 0; j < nRows; j++){
            		result[i][j] = 2*nRows-i-j-2;
            	}
            }
            return result
        }
        if(nRows < 1 || nColumns < 1){
        	dde_error("matrix dimensions must be greater than 1");
        }
        
    	for(var i = 0; i < nRows; i++){
    		result.push([]);
    		for(var j = 0; j < nColumns; j++){
    			result[i].push(value);
    		}
    	}
    	return result
	}
    //Vector.make_matrix(10, 7)
    //Vector.make_matrix(3)
    //Vector.make_matrix(3, 2, 1)
    //Vector.make_matrix([2,3])
    


	static transpose(matrix){
    	let height = matrix.length;
        let width  = matrix[0].length;
        if(width == undefined){
        	width = height;
        	height = 1;
            matrix = [matrix];
        }
        let result = Vector$1.make_matrix(width, height);
        for(var i = 0; i < width; i++){
        	for(var j = 0; j < height; j++){
        		result[i][j] = matrix[j][i];
        	}
        }
        if(result.length == 1){
        	return result[0]
        }else {
        	return result
        }
    }
    /*
    var v = [1, 2, 3]
    v = Vector.transpose(v)
    var v2 = Vector.transpose(v)
    */
    
    static matrix_multiply(...args){
    	if (args === undefined){
        	dde_error("the function 'Vector.matrix_multiply' has undefined inputs");
        }
        let temp_args = Convert.deep_copy(args);
        let matrix_A = temp_args[0];
        for(let i = 1; i < temp_args.length; i++){
            let matrix_B = temp_args[i];
            matrix_A = multiply_two_matrices(matrix_A, matrix_B);
    	}
        return matrix_A
    }
    
    static matrix_divide(...args){
    	if (args === undefined){
        	dde_error("the function 'Vector.matrix_multiply' has undefined inputs");
        }
        let temp_args = Convert.deep_copy(args);
        let matrix_A = temp_args[0];
        for(var i = 1; i < temp_args.length; i++){
            let matrix_B = temp_args[i];
            matrix_A = divide_two_matrices(matrix_A, matrix_B);
    	}
        return matrix_A
    }
    
    
    static determinant(matrix){
    	let result;
    	let dim = Vector$1.matrix_dimensions(matrix);
        if (dim[0] == 2 && dim[1] == 2){
        	result = matrix[0][0]*matrix[1][1] - matrix[0][1]*matrix[1][0];
        }else if(dim[0] == 3 && dim[1] == 3){
        	//Source: https://en.wikipedia.org/wiki/Determinant#n_.C3.97_n_matrices
        	let a, b, c, d, e, f, g, h, i;
            a = matrix[0][0];
            b = matrix[0][1];
            c = matrix[0][2];
            d = matrix[1][0];
            e = matrix[1][1];
            f = matrix[1][2];
            g = matrix[2][0];
            h = matrix[2][1];
            i = matrix[2][2];
        	result = a*(e*i-f*h)-b*(d*i-f*g)+c*(d*h-e*g);
        }else if(dim[0] == 4 && dim[1] == 4){
        	// Source: http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
            let a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44;
            a11 = matrix[0][0];
            a12 = matrix[0][1];
            a13 = matrix[0][2];
            a14 = matrix[0][3];
            a21 = matrix[1][0];
            a22 = matrix[1][1];
            a23 = matrix[1][2];
            a24 = matrix[1][3];
            a31 = matrix[2][0];
            a32 = matrix[2][1];
            a33 = matrix[2][2];
            a34 = matrix[2][3];
            a41 = matrix[3][0];
            a42 = matrix[3][1];
            a43 = matrix[3][2];
            a44 = matrix[3][3];
            
            result = a11*a22*a33*a44 + a11*a23*a34*a42 + a11*a24*a32*a43
            		+a12*a21*a34*a43 + a12*a23*a31*a44 + a12*a24*a33*a41
                    +a13*a21*a32*a44 + a13*a22*a34*a41 + a13*a24*a31*a42
                    +a14*a21*a33*a42 + a14*a22*a31*a43 + a14*a23*a32*a41
                    -a11*a22*a34*a43 - a11*a23*a32*a44 - a11*a24*a33*a42
                    -a12*a21*a33*a44 - a12*a23*a34*a41 - a12*a24*a31*a43
                    -a13*a21*a34*a42 - a13*a22*a31*a44 - a13*a24*a32*a41
                    -a14*a21*a32*a43 - a14*a22*a33*a41 - a14*a23*a31*a42;
        }else {
        	dde_error("determinants of matricies with these dimensions are not supported yet");
        }
        return result
    }
    /*
    var my_matrix = [[1, 0, 0], [0, 1, 0], [0, 0, 1]]
    Vector.determinant(my_matrix)
    
    var mat = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12], [13, 14, 15, 16]]
    var det = Vector.determinant(mat)
    
    var mat = [[3, 2, 1.7, 1.5],[4.5, 5, 4.1, 1.9], [1.1, 8.5, 9, 8], [3, 9, 9, 10]]
    var det = Vector.determinant(mat)
    */
    
    /////////////////////////////////////////////////////////////////////////////////////

    
    static inverse(matrix){
    	let result;
    	let dim = Vector$1.matrix_dimensions(matrix);
        if (dim[0] == 2 && dim[1] == 2){
        	result = [[matrix[1][1], -matrix[1][0]], [-matrix[0][1], matrix[0][0]]];
            result = Vector$1.multiply(1/Vector$1.determinant(matrix), result);
        }else if(dim[0] == 3 && dim[1] == 3){
        	//Source: University of Massachusetts Lowell - MECH 5960 Mechanics of Composite Materials
        	let a, b, c, d, e, f, g, h, i, A, B, C, D, E, F, G, H, I;
            a = matrix[0][0];
            b = matrix[0][1];
            c = matrix[0][2];
            d = matrix[1][0];
            e = matrix[1][1];
            f = matrix[1][2];
            g = matrix[2][0];
            h = matrix[2][1];
            i = matrix[2][2];
            
            A =  Vector$1.determinant([[e, f], [h, i]]);
            B = -Vector$1.determinant([[d, f], [g, i]]);
            C =  Vector$1.determinant([[d, e], [g, h]]);
            D = -Vector$1.determinant([[b, c], [h, i]]);
            E =  Vector$1.determinant([[a, c], [g, i]]);
            F = -Vector$1.determinant([[a, b], [g, h]]);
            G =  Vector$1.determinant([[b, c], [e, f]]);
            H = -Vector$1.determinant([[a, c], [d, f]]);
            I =  Vector$1.determinant([[a, b], [d, e]]);
            
            result = [[A, B, C], [D, E, F], [G, H, I]];
            result = Vector$1.multiply(1/Vector$1.determinant(matrix), result);
        }else if(dim[0] == 4 && dim[1] == 4){
        	// Source: http://www.cg.info.hiroshima-cu.ac.jp/~miyazaki/knowledge/teche23.html
            let a11, a12, a13, a14, a21, a22, a23, a24, a31, a32, a33, a34, a41, a42, a43, a44;
            let b11, b12, b13, b14, b21, b22, b23, b24, b31, b32, b33, b34, b41, b42, b43, b44;
            a11 = matrix[0][0];
            a12 = matrix[0][1];
            a13 = matrix[0][2];
            a14 = matrix[0][3];
            a21 = matrix[1][0];
            a22 = matrix[1][1];
            a23 = matrix[1][2];
            a24 = matrix[1][3];
            a31 = matrix[2][0];
            a32 = matrix[2][1];
            a33 = matrix[2][2];
            a34 = matrix[2][3];
            a41 = matrix[3][0];
            a42 = matrix[3][1];
            a43 = matrix[3][2];
            a44 = matrix[3][3];
        	
            b11 = a22*a33*a44 + a23*a34*a42 + a24*a32*a43 - a22*a34*a43 - a23*a32*a44 - a24*a33*a42;
            b12 = a12*a34*a43 + a13*a32*a44 + a14*a33*a42 - a12*a33*a44 - a13*a34*a42 - a14*a32*a43;
            b13 = a12*a23*a44 + a13*a24*a42 + a14*a22*a43 - a12*a24*a43 - a13*a22*a44 - a14*a23*a42;
            b14 = a12*a24*a33 + a13*a22*a34 + a14*a23*a32 - a12*a23*a34 - a13*a24*a32 - a14*a22*a33;
            
            b21 = a21*a34*a43 + a23*a31*a44 + a24*a33*a41 - a21*a33*a44 - a23*a34*a41 - a24*a31*a43;
            b22 = a11*a33*a44 + a13*a34*a41 + a14*a31*a43 - a11*a34*a43 - a13*a31*a44 - a14*a33*a41;
            b23 = a11*a24*a43 + a13*a21*a44 + a14*a23*a41 - a11*a23*a44 - a13*a24*a41 - a14*a21*a43;
            b24 = a11*a23*a34 + a13*a24*a31 + a14*a21*a33 - a11*a24*a33 - a13*a21*a34 - a14*a23*a31;
            
            b31 = a21*a32*a44 + a22*a34*a41 + a24*a31*a42 - a21*a34*a42 - a22*a31*a44 - a24*a32*a41;
            b32 = a11*a34*a42 + a12*a31*a44 + a14*a32*a41 - a11*a32*a44 - a12*a34*a41 - a14*a31*a42;
            b33 = a11*a22*a44 + a12*a24*a41 + a14*a21*a42 - a11*a24*a42 - a12*a21*a44 - a14*a22*a41;
            b34 = a11*a24*a32 + a12*a21*a34 + a14*a22*a31 - a11*a22*a34 - a12*a24*a31 - a14*a21*a32;
            
            b41 = a21*a33*a42 + a22*a31*a43 + a23*a32*a41 - a21*a32*a43 - a22*a33*a41 - a23*a31*a42;
            b42 = a11*a32*a43 + a12*a33*a41 + a13*a31*a42 - a11*a33*a42 - a12*a31*a43 - a13*a32*a41;
            b43 = a11*a23*a42 + a12*a21*a43 + a13*a22*a41 - a11*a22*a43 - a12*a23*a41 - a13*a21*a42;
            b44 = a11*a22*a33 + a12*a23*a31 + a13*a21*a32 - a11*a23*a32 - a12*a21*a33 - a13*a22*a31;
            
            result = [[b11, b12, b13, b14], [b21, b22, b23, b24], [b31, b32, b33, b34], [b41, b42, b43, b44]];
            result = Vector$1.multiply(1/Vector$1.determinant(matrix),result);
        }else {
        	result = matrix_invert(matrix);
        }
        return result
   }
   
   /*
   var mat = Vector.identity_matrix(3)
   var mat = [[3, 2, 1.7, 1.5],[4.5, 5, 4.1, 1.9], [1.1, 8.5, 9, 8], [3, 9, 9, 10]]
   var det = Vector.determinant(mat)
   var imat = Vector.inverse(mat)
   
   var my_DCM = 
   
   var det = Vector.determinant(imat)
   var mat2 = Vector.inverse(imat)
   */
    
    /*
    var mat = []
    Vector.matrix_dimensions(mat)
    debugger
    Vector.matrix_dimensions(3)
    */
    
    static matrix_dimensions(matrix){
        let width;
        let height;
        if(matrix != null) {
            height = matrix.length;
        }
        if(height == undefined){
        	return [1, 0]
        }
        if(height == 0){
        	width = 0;
        	height = 0;
            return [height, width]
        }
        let mat0 = matrix[0];
        if(mat0 != null) {
        	width  = mat0.length;
		}
		if(width == undefined){
			width = height;
			height = 1;
		}
        return [height, width]
    }
    //Vector.matrix_dimensions([10, 20, 30])
    //Vector.matrix_dimensions([[10], [20], [30]])
    
    static properly_define_point(points){
    	//a proper point takes the following form: [[x], [y], [z], [1]]
        //for points: [[x1, x2, ..., xn], [y1, y2, ..., yn], [z1, z2, ..., zm=n] [1, 1, ..., 1]]
    	let dim = Vector$1.matrix_dimensions(points);
        let proper_points = Convert.deep_copy(points);
        if(dim[0] == 1){
        	proper_points = Vector$1.transpose(proper_points);
            proper_points.push([1]);
            return proper_points
        }else {
        	if(dim[1] == 3){
            	for(var i = 0; i < dim[0]; i++){
                	proper_points[i].push(1);
                }
                proper_points = Vector$1.transpose(proper_points);
            	return proper_points
            }else {
            	if(dim[0] == 3){
                	//let ones = Vector.add(Vector.make_matrix(1, dim[0])[0], 1)
                    proper_points.push([1]);
                    return proper_points
                }
            }
        }
    }
    /*
    Vector.properly_define_point([10, 20, 30])
    Vector.properly_define_point([[10], [20], [30]])
    debugger
    Vector.properly_define_point([[10, 20, 30], [10, 20, 30], [10, 20, 30]])
    */
	
    static properly_define_vector(vectors){
    	//a proper point takes the following form: [[x], [y], [z], [1]]
        //for points: [[x1, x2, ..., xn], [y1, y2, ..., yn], [z1, z2, ..., zm=n] [1, 1, ..., 1]]
    	let dim = Vector$1.matrix_dimensions(vectors);
        let proper_vectors = Convert.deep_copy(vectors);
        if(dim[0] == 1){
        	proper_vectors = Vector$1.transpose(proper_vectors);
            if(dim[1] == 3){
            	proper_vectors.push([0]);
            }
            return proper_vectors
        }else {
        	if(dim[1] == 3){
            	for(var i = 0; i < dim[0]; i++){
                	proper_vectors[i].push(0);
                }
                proper_vectors = Vector$1.transpose(proper_vectors);
            	return proper_vectors
            }else {
            	if(dim[0] == 3){
                	//let ones = Vector.add(Vector.make_matrix(1, dim[0])[0], 1)
                    proper_vectors.push([0]);
                    return proper_vectors
                }
            }
        }
    }
    
    static make_dcm(x_vector, y_vector, z_vector){
    	warning("This function is being depricated.</br>Please replace with Vector.make_dcm_from_3_vectors, Vector.euler_angles_to_DCM, or Vector.quaternion_to_DCM");
        let dcm = Vector$1.identity_matrix(3);
        
        if(x_vector == undefined && y_vector == undefined && z_vector == undefined){
        	return dcm
        }else if(x_vector == undefined && y_vector != undefined && z_vector != undefined){
        	x_vector = Vector$1.cross(y_vector, z_vector);
        }else if(x_vector != undefined && y_vector == undefined && z_vector != undefined){
        	y_vector = Vector$1.cross(z_vector, x_vector);
        }else if(x_vector != undefined && y_vector != undefined && z_vector == undefined){
        	z_vector = Vector$1.cross(x_vector, y_vector);
        }
        
        x_vector = Vector$1.normalize(x_vector);
        y_vector = Vector$1.normalize(y_vector);
        z_vector = Vector$1.normalize(z_vector);
        
        dcm = Vector$1.insert(dcm, Vector$1.transpose(x_vector), [0, 0]);
        dcm = Vector$1.insert(dcm, Vector$1.transpose(y_vector), [0, 1]);
        dcm = Vector$1.insert(dcm, Vector$1.transpose(z_vector), [0, 2]);
        
        return dcm
    }
    
    
    static make_DCM_from_3_vectors(x_vector, y_vector, z_vector){
        let dcm = Vector$1.identity_matrix(3);
        
        if(x_vector == undefined && y_vector == undefined && z_vector == undefined){
        	return dcm
        }else if(x_vector == undefined && y_vector != undefined && z_vector != undefined){
        	x_vector = Vector$1.cross(y_vector, z_vector);
        }else if(x_vector != undefined && y_vector == undefined && z_vector != undefined){
        	y_vector = Vector$1.cross(z_vector, x_vector);
        }else if(x_vector != undefined && y_vector != undefined && z_vector == undefined){
        	z_vector = Vector$1.cross(x_vector, y_vector);
        }
        
        x_vector = Vector$1.normalize(x_vector);
        y_vector = Vector$1.normalize(y_vector);
        z_vector = Vector$1.normalize(z_vector);
        
        dcm = Vector$1.insert(dcm, Vector$1.transpose(x_vector), [0, 0]);
        dcm = Vector$1.insert(dcm, Vector$1.transpose(y_vector), [0, 1]);
        dcm = Vector$1.insert(dcm, Vector$1.transpose(z_vector), [0, 2]);
        
        return dcm
    }

    /* obsolete because it uses Convert.
	static make_pose(position = [0, 0, 0], orientation = [0, 0, 0], scale_factor = 1, sequence = "ZYX"){
		let dim = Vector.matrix_dimensions(orientation)
        let DCM
        let s = scale_factor
        if(dim[0] == 1 && dim[1] == 3){
        	//Euler Angle
            DCM = Convert.angles_to_DCM(orientation, sequence)
        }else if(dim[0] == 1 && dim[1] == 4){
            //Quaternion
            DCM = Convert.quat_to_DCM(orientation)
        }else if(dim[0] == 3 && dim[1] == 3){
        	//DCM
            DCM = orientation
        }else{
        	dde_error("orientation is improperly formatted")
        }
        
        //Please tell me there's a better way to do this:
        let pose = [[s*DCM[0][0], s*DCM[0][1], s*DCM[0][2], position[0]],
        			[s*DCM[1][0], s*DCM[1][1], s*DCM[1][2], position[1]],
                    [s*DCM[2][0], s*DCM[2][1], s*DCM[2][2], position[2]],
                    [0, 0, 0, 1]]
        return pose
	}*/

    static make_pose(position = [0, 0, 0], orientation = [0, 0, 0], scale_factor = 1, sequence = "ZYX"){
        let dim = Vector$1.matrix_dimensions(orientation);
        let DCM;
        let s = scale_factor;
        if(dim[0] == 1 && dim[1] == 3){
            //Euler Angle
            DCM = Vector$1.euler_angles_to_DCM(orientation, sequence);
        }else if(dim[0] == 1 && dim[1] == 4){
            //Quaternion
            DCM = Vector$1.quaternion_to_DCM(orientation);
        }else if(dim[0] == 3 && dim[1] == 3){
            //DCM
            DCM = orientation;
        }else {
            dde_error("orientation is improperly formatted");
        }

        //Please tell me there's a better way to do this:
        let pose = [[s*DCM[0][0], s*DCM[0][1], s*DCM[0][2], position[0]],
            [s*DCM[1][0], s*DCM[1][1], s*DCM[1][2], position[1]],
            [s*DCM[2][0], s*DCM[2][1], s*DCM[2][2], position[2]],
            [0, 0, 0, 1]];
        return pose
    }

    
    static identity_matrix(size){
    	let result = Vector$1.make_matrix(size, size);
        for(var i = 0; i < size; i++){
        	result[i][i] = 1;
        }
        return result
    }
    //var im = Vector.identity_matrix(4)
    //var det = Vector.determinant(im)
    
    static rotate_DCM(DCM = [[1, 0, 0],[0, 1, 0],[0, 0, 1]], axis_of_rotation, angle){
    	let trans_matrix = Vector$1.identity_matrix(3);
        let x_vector, y_vector, z_vector;
    	switch(axis_of_rotation){
        	case "X":
            	trans_matrix[1][1] = cosd(angle);
                trans_matrix[2][2] = cosd(angle);
                trans_matrix[2][1] = sind(angle);
                trans_matrix[1][2] = -sind(angle);
                break
            case "Y":
            	trans_matrix[0][0] = cosd(angle);
                trans_matrix[2][2] = cosd(angle);
                trans_matrix[0][2] = sind(angle);
                trans_matrix[2][0] = -sind(angle);
            	break
            case "Z":
            	trans_matrix[0][0] = cosd(angle);
                trans_matrix[1][1] = cosd(angle);
                trans_matrix[1][0] = sind(angle);
                trans_matrix[0][1] = -sind(angle);
            	break
            case "X'":
            	x_vector = [DCM[0][0], DCM[1][0], DCM[2][0]];
            	DCM = Vector$1.rotate_DCM(DCM, x_vector, angle);
            	break
           	case "Y'":
            	y_vector = [DCM[0][1], DCM[1][1], DCM[2][1]];
            	DCM = Vector$1.rotate_DCM(DCM, y_vector, angle);
            	break
            case "Z'":
            	z_vector = [DCM[0][2], DCM[1][2], DCM[2][2]];
            	DCM = Vector$1.rotate_DCM(DCM, z_vector, angle);
            	break
            default:
            	x_vector = [DCM[0][0], DCM[1][0], DCM[2][0]];
                y_vector = [DCM[0][1], DCM[1][1], DCM[2][1]];
                z_vector = [DCM[0][2], DCM[1][2], DCM[2][2]];
                x_vector = Vector$1.rotate(x_vector, axis_of_rotation, angle);
                y_vector = Vector$1.rotate(y_vector, axis_of_rotation, angle);
                z_vector = Vector$1.rotate(z_vector, axis_of_rotation, angle);
                DCM = Vector$1.transpose([x_vector, y_vector, z_vector]);
                return DCM
        }
        return Vector$1.matrix_multiply(DCM, trans_matrix)
    }
    /*
    var mat = Vector.rotate_DCM(Vector.identity_matrix(3), [1, 0, 0], Convert.degrees_to_arcseconds(90))
    var det = Vector.determinant(mat)
    */
    static rotate_pose(pose, axis_of_rotation, angle, point_of_rotation = [0, 0, 0]){
    	if(Vector$1.is_pose(pose) == false){
        	dde_error("pose is not properly formatted");
        }
    	let DCM = Vector$1.pull(pose, [0, 2], [0, 2]);
        DCM = Vector$1.rotate_DCM(DCM, axis_of_rotation, angle);
        let axis;
        switch(axis_of_rotation){
        	case "X":
            	axis = [1, 0, 0];
                break
            case "Y":
            	axis = [0, 1, 0];
            	break
            case "Z":
            	axis = [0, 0, 1];
            	break
            case "X'":
            	axis = [DCM[0][0], DCM[1][0], DCM[2][0]];
            	break
           	case "Y'":
            	axis = [DCM[0][1], DCM[1][1], DCM[2][1]];
            	break
            case "Z'":
            	axis = [DCM[0][2], DCM[1][2], DCM[2][2]];
            	break
            default:
            	axis = axis_of_rotation;
            }
        let position = Vector$1.transpose(Vector$1.pull(pose, [0, 2], 3));
        position = Vector$1.rotate(position, axis, angle, point_of_rotation);
        return Vector$1.make_pose(position, DCM)
    }

	/*
	static quaternion_interpolation(quaternion){
    	THREE.QuaternionLinearInterpolant()
        THREE.Quaternion
    }
    */

    static is_pose(pose){
    	let dim = Vector$1.matrix_dimensions(pose);
        if (!(dim[0] == 4 && dim[1] == 4)){
        	return false
        }
        
        let short, short_mag;
        short = [pose[0][0], pose[1][0], pose[2][0]];
        short_mag = Vector$1.magnitude(short);
        if (Vector$1.round(short_mag, 10) != 1){
        	return false
        }
        short = [pose[0][1], pose[1][1], pose[2][1]];
        short_mag = Vector$1.magnitude(short);
        if (Vector$1.round(short_mag, 10) != 1){
        	return false
        }
        short = [pose[0][2], pose[1][2], pose[2][2]];
        short_mag = Vector$1.magnitude(short);
        if (Vector$1.round(short_mag, 10) != 1){
        	return false
        }
        
        let DCM = Vector$1.pull(pose, [0, 2], [0, 2]);
        if (!Vector$1.is_equal(Vector$1.determinant(DCM), 1, 10)){
        	return false
        }
        
        if (pose[3][3] != 1){
        	return false
        }
        
        if (!((pose[3][0] == 0) && (pose[3][1] == 0) && (pose[3][2] == 0))){
        	return false
        }
        
        return true
    }
    /*
    var my_pose = Vector.make_pose()
    var state = Vector.is_pose(my_pose)
    
    var my_pose = Vector.make_pose([10, 20, 30], [Convert.degrees_to_arcseconds(45), 0, 0], "ZX'Z'")
    var state = Vector.is_pose(my_pose)
    */
    
    
    /*
    static place(matrix, row, column){
    	let dim = Vector.matrix_dimensions(matrix)
        let row_lower, row_upper, col_lower, col_upper
        if (Vector.size(row) == 1){
        	row_lower = row
            row_upper = row
        }else if (Vector.size(row) == 2){
        	row_lower = row[0]
            row_upper = row[1]
        }else{
        	dde_error("row has invalid dimensions")
        }
        if (Vector.size(column) == 1){
        	col_lower = column
            col_upper = column
        }else if (Vector.size(column) == 2){
        	col_lower = column[0]
            col_upper = column[1]
        }else{
        	dde_error("column has invalid dimensions")
        }
        if ((row_lower < 0) || (row_upper > dim[0]) || (col_lower < 0) || (col_upper > dim[1])){
        	dde_error("indeces exceed matrix dimensions")
        }
        
        let result = Vector.make_matrix(row_upper-row_lower+1, col_upper-col_lower+1)
        for(var i = row_lower; i < row_upper+1; i++){
        	for(var j = col_lower; j < col_upper+1; j++){
        		result[i-row_lower][j-col_lower] = matrix[i][j]
        	}
        }
        return result
    }
    */
    
    
    static pull(matrix, row, column){
    	let dim = Vector$1.matrix_dimensions(matrix);
        if(dim[0] == 1){
        	matrix = [matrix];
        }
        let row_lower, row_upper, col_lower, col_upper;
        if (Vector$1.size(row) == 1){
        	row_lower = row;
            row_upper = row;
        }else if (Vector$1.size(row) == 2){
        	row_lower = row[0];
            row_upper = row[1];
        }else {
        	dde_error("row has invalid dimensions");
        }
        if (Vector$1.size(column) == 1){
        	col_lower = column;
            col_upper = column;
        }else if (Vector$1.size(column) == 2){
        	col_lower = column[0];
            col_upper = column[1];
        }else {
        	dde_error("column has invalid dimensions");
        }
        if ((row_lower < 0) || (row_upper > dim[0]) || (col_lower < 0) || (col_upper > dim[1])){
        	dde_error("indeces exceed matrix dimensions");
        }
        
        let result = Vector$1.make_matrix(row_upper-row_lower+1, col_upper-col_lower+1);
        for(var i = row_lower; i < row_upper+1; i++){
        	for(var j = col_lower; j < col_upper+1; j++){
        		result[i-row_lower][j-col_lower] = matrix[i][j];
        	}
        }
        if(Vector$1.matrix_dimensions(result)[0] == 1){
        	return result[0]
        }
        return result
    }
    //Vector.pull([[1, 2, 3], [4, 5, 6], [7, 8, 9]], [1, 2], [1, 2])
    
    
    static insert(big_matrix, small_matrix, location = [0, 0]){
    	let big_dim = Vector$1.matrix_dimensions(big_matrix);
        let small_dim = Vector$1.matrix_dimensions(small_matrix);
        let result = big_matrix;
        let small_i, small_j;
        
        for(let i = location[0]; (i < location[0]+small_dim[0]) && (i < big_dim[0]); i++){
        	for(let j = location[1]; (j < location[1]+small_dim[1]) && (j < big_dim[1]); j++){
        		small_i = i-location[0];
                small_j = j-location[1];
                result[i][j] = small_matrix[small_i][small_j];
        	}
        }
        return result
    }
    /*
    var my_big = Vector.make_matrix(10)
    var my_small = Vector.make_matrix(3, 2, 6)
    debugger
    var result = Vector.insert(my_big, my_small, [3, 4])
    */
    
    static concatinate(direction = 0, matrix_1, matrix_2, ...args){

        let result, dim_1, dim_2;
        if(matrix_1.length == 0){
        	return matrix_2
        }
        if(matrix_2.length == 0){
        	return matrix_1
        }
        
    	switch(direction){
        	//Vertical concatination
            case 0:
            dim_1 = Vector$1.matrix_dimensions(matrix_1);
            dim_2 = Vector$1.matrix_dimensions(matrix_2);
            if(dim_1[1] != dim_2[1]){
            	dde_error("Vector.concatinate, matrix widths must match");
            }
            if(dim_1[0] == 1){
            	result = [matrix_1];
            }else {
            	result = matrix_1;
            }
            if(dim_2[0] == 1){
            	for(let i = 0; i < dim_2[0]; i++){
            		result.push(matrix_2);
            	}
            }else {
            	for(let i = 0; i < dim_2[0]; i++){
            		result.push(matrix_2[i]);
            	}
            }
            break
            
            //Horizontal concatination
            case 1:
            dim_1 = Vector$1.matrix_dimensions(matrix_1);
            dim_2 = Vector$1.matrix_dimensions(matrix_2);
            if(dim_1[0] != dim_2[0]){
            	dde_error("Vector.concatinate: matrix heights must match");
            }
            if(dim_1[0] == 1){
            	result = Vector$1.make_matrix(dim_1[0], dim_1[1]+dim_2[1])[0];
                for(let j = 0; j < dim_1[1]; j++){
                	result[j] = matrix_1[j];
                }
                for(let j = 0; j < dim_2[1]; j++){
                	result[j+dim_1[1]] = matrix_2[j];
                }
            }else {
            	result = Vector$1.make_matrix(dim_1[0], dim_1[1]+dim_2[1]);
                for(let i = 0; i < dim_1[0]; i++){
            		for(let j = 0; j < dim_1[1]; j++){
                		result[i][j] = matrix_1[i][j];
                	}
                	for(let j = 0; j < dim_2[1]; j++){
                		result[i][j+dim_1[1]] = matrix_2[i][j];
                	}
            	}
           	}
            
            break
            default:
            dde_error("In Vector.concatinate, direction must 0 or 1");
        }
        
        let n_matrices = args.length + 2;
        if(n_matrices > 2){
        	for(let i = 0; i < n_matrices-2; i++){
            	result = Vector$1.concatinate(direction, result, args[i]);
            }
        }
        
        return result
    }
    /*
    var matrix_1 = [1, 2, 3]
    var matrix_2 = [4, 5, 6]
    //debugger
    var ans = Vector.concatinate(0, matrix_1, matrix_2)
	Vector.concatinate(0, [1, 2, 3], [4, 5, 6])  
    Vector.concatinate(1, [1, 2, 3], [4, 5, 6])
    Vector.concatinate(1, [[1, 1], [2, 2], [3, 2]], [[4], [5], [6]])

    var matrix_1 = [1, 2, 3]
    var matrix_2 = [4, 5, 6]
    debugger
    var ans = Vector.concatinate(1, matrix_1, matrix_2)
    
    var matrix_1 = [[1, 1], [2, 2], [3, 2]]
    var matrix_2 = [[4], [5], [6]]
    //debugger
    var ans = Vector.concatinate(1, matrix_1, matrix_2)
    */
    
    static data_to_file(...args){
    //debugger
    
    	let temp_args = Convert.deep_copy(args);
        let file_name, elt, file_string, data_array, table_titles;
        let data = [];
        for(let i = 0; i < temp_args.length; i++){
        	elt = temp_args[i];
            if($.type(elt) === "string"){
            	//if contains 
            	if (elt.indexOf(" ") > -1){
                	table_titles = elt;
                }else if(file_name == undefined){
                	file_name = elt;
                }else {
                	dde_error("Vector.data_to_file can only take in one string");
                }
            }else {
            	data.push(elt);
            }
        }
        if(file_name == undefined){
        	dde_error("Vector.data_to_file needs a filename input arg");
        }
        
        let dim = Vector$1.matrix_dimensions(data[0]);
        dim[1];
        data_array = [];
        for(var i = 0; i < data.length; i++){
        	elt = data[i];
            dim = Vector$1.matrix_dimensions(elt);
            if(dim[0] == 1){
            	elt = Vector$1.transpose(elt);
            }
            data_array = Vector$1.concatinate(1, data_array, elt);
        }
        
        dim = Vector$1.matrix_dimensions(data_array);
        if(table_titles == undefined){
        	file_string = "";
        }else {
        	file_string = table_titles + "\r\n";
        }
        for(let i = 0; i < dim[0]; i++){
        	file_string += data_array[i][0];
        	for(let j = 1; j < dim[1]; j++){
        		file_string += " " + data_array[i][j];
            }
            file_string += "\r\n";
        }
        write_file(file_name, file_string);
        return file_string
    }
    /*
    var data_1 = [1, 2, 3, 4]
    var data_2 = [100, 200, 300, 400]
    var filename = "2017/Main_Work_Version_Control/_Test_Files/torque_data.txt"
    var table_titles = "x y"
    //debugger
    var sol = Vector.data_to_file(table_titles, filename, Vector.transpose(data_1), Vector.transpose(data_2))
    
    //write_file("2017/Main_Work_Version_Control/_Test_Files/torque_data.txt", "lol")
    
    var my_string = "hello"
    _.isString(my_string)
    $.type(my_string) === "string"
    
    */
    /*
    var x_data = [361.1, 433.95, 474.3, 534.61, 966.06]
	var y_data = [0, 63500.24892, 158750.6223, 317501.2446, 1587506.223]
	
	var solution = Vector.poly_fit(x_data, y_data, 1)
    //debugger
	var solution = Vector.poly_fit(x_data, y_data, 4)
*/
    
    static poly_fit(x_data, y_data, order = 1){
		let dim_x = Vector$1.matrix_dimensions(x_data);
    	let dim_y = Vector$1.matrix_dimensions(y_data);
    	if((dim_x[0]!=1) || (dim_y[0]!=1) || (dim_x[1]!=dim_y[1])){
    		dde_error(" Input data has incorrect dimensions for function Vector.poly_fit()");
    	}
        
		let sol = Vector$1.make_matrix(1, order)[0];
    	let A, B, B1=0, B2=0, A11=0, A12=0, A21=0, A22=0, xi, yi;
    	switch(order){
    		case 0:
        		result = [Vector$1.average(y_data)];
        		break
        	case 1:
        		for(let i = 0; i < dim_x[1]; i++){
            		xi = x_data[i];
                	yi = y_data[i];
                
            		B1  += 2*xi*yi;
                	B2  += 2*yi;
                	A11 += 2*xi*xi;
                	A12 += 2*xi;
                	A21 += 2*xi;
                	A22 += 2;
            	}
            	A = [[A11, A12], [A21, A22]];
            	B = [[B1], [B2]];
            	sol = Vector$1.matrix_multiply(Vector$1.inverse(A), B);
        		break
        	default:
            	let size = order+1;
                A = Vector$1.make_matrix(size);
                B = Vector$1.make_matrix(size,1);
                let powers = Vector$1.make_matrix(size, "tilt");
                for(let i = 0; i < dim_x[1]; i++){
            		xi = x_data[i];
                	yi = y_data[i];
                	for(let i = 0; i < size; i++){
                    	for(let j = 0; j < size; j++){
            				A[i][j] += 2*Math.pow(xi, powers[i][j]);
                        }
                        B[i][0] += 2*Math.pow(xi, size-i-1)*yi;
                    }
            	}
                sol = Vector$1.matrix_multiply(Vector$1.inverse(A), B);
    	}
    	return sol
	}
    /*
    var data_x = [2,1.80901699437495,1.30901699437495,0.690983005625053,0.190983005625053,0,0.190983005625053,0.690983005625053,1.30901699437495,1.80901699437495,2]
    var data_y = [0,0.293892626146237,0.475528258147577,0.475528258147577,0.293892626146237,0,-0.293892626146237,-0.475528258147577,-0.475528258147577,-0.293892626146237,0]
    debugger
                  0  1  2  3  4  5
    var data_x = [0, 1, 2, 3, 2, 1]
    var data_y = [0, 1.5, 2.5, 3, 1.5, 0.5]
  
    var e = Vector.ellipse_fit(data_x, data_y)
    */
    
    static ellipse_fit(x, y){
		//Code adapted from Nikolai Chernov
    	//https://www.mathworks.com/matlabcentral/fileexchange/22684-ellipse-fit-direct-method
    	if(x.length < 5 || y.length < 5){
        	dde_error("A minumum of 5 datapoints are required to fit an ellipse.<br>Only " + x.length + " were supplied to Vector.ellipse_fit().");
        }
        
    	let results = {};
    	let x_dim = Vector$1.matrix_dimensions(x);
    	let y_dim = Vector$1.matrix_dimensions(y);
        if(1 == x_dim[0]){
        	x = Vector$1.transpose(x);
        }
        if(1 == y_dim[0]){
        	y = Vector$1.transpose(y);
        }
    
    	let n_points = Math.max(x_dim[0], x_dim[1]);
    
    	let orientation_tolerance = 1e-3;

    	let sum_x = 0;
        let sum_y = 0;
        for(let i = 0; i < n_points; i++){
        	sum_x += x[i][0];
            sum_y += y[i][0];
        }
        let mean_x = sum_x / n_points;
        let mean_y = sum_y / n_points;
        
		x = Vector$1.subtract(x, mean_x);
		y = Vector$1.subtract(y, mean_y);

		//X = [x.^2, x.*y, y.^2, x, y ]; //look how elegant this is in MATLAB
    	//solution = sum(X)/(X'*X);      //it's two lines!
    	
        let X_prime = Vector$1.concatinate(0, Vector$1.pow(x, 2), Vector$1.multiply(x, y), Vector$1.pow(y, 2), x, y);
		let X = Vector$1.transpose(X_prime);
        let row_sum = [0, 0, 0, 0, 0];
    	for(let i = 0; i < n_points; i++){
    		row_sum = Vector$1.add(row_sum, X[i]);
    	}
        
    	let coeffs = Vector$1.matrix_multiply(row_sum, Vector$1.inverse(Vector$1.matrix_multiply(X_prime, X)))[0];
		results.coeffs = coeffs;
        let a = coeffs[0];
        let b = coeffs[1];
        let c = coeffs[2];
        let d = coeffs[3];
        let e = coeffs[4];
        coeffs[5];
        
        //debugger
        
        let cos_phi, sin_phi;
        let orientation_rad;
        if(Math.min(Math.abs(b/a), Math.abs(b/c)) > orientation_tolerance ){
    		orientation_rad = 1/2 * Math.atan(b/(c-a));
    		cos_phi = Math.cos( orientation_rad );
    		sin_phi = Math.sin( orientation_rad );
        	a = a*cos_phi*cos_phi - b*cos_phi*sin_phi + c*sin_phi*sin_phi;
        	b = 0;
        	c = a*sin_phi*sin_phi + b*cos_phi*sin_phi + c*cos_phi*cos_phi;
        	d = d*cos_phi - e*sin_phi;
        	e = d*sin_phi + e*cos_phi;
        	mean_x = cos_phi*mean_x - sin_phi*mean_y;
        	mean_y = sin_phi*mean_x + cos_phi*mean_y;
		}else {
    		orientation_rad = 0;
    		cos_phi = Math.cos( orientation_rad );
    		sin_phi = Math.sin( orientation_rad );
		}
		
        
        let test = a*c;
        /*
        switch(test){
        	case (test > 0):
            	results.shape = "Ellipse"	
            break
            case (test == 0):
            	results.shape = "Paraboloa"	
            break
            case (test < 0):
            	results.shape = "Hyperbola"
            break
        }
        */
        if(test > 0){
        	results.shape = "Ellipse";	
        }else if(test == 0){
        	results.shape = "Paraboloa";	
        }else if(test < 0){
        	results.shape = "Hyperbola";
        }else {
        	out("x_data:", "red");
            out(x_data, "red");
            out("y_data:", "red");
            out(y_data, "red");
        	dde_error("Vector.ellipse_fit() received bad data. ^ Data printed above ^");
        }
        
        


		if (test>0){
    		if(a<0){
    			a = -a;
        		c = -c;
        		d = -d;
        		e = -e;
            }
    	}

    	let x_center = mean_x - d/2/a;
    	let y_center = mean_y - e/2/c;
    	let F = 1 + Math.pow(d, 2)/(4*a) + Math.pow(e, 2)/(4*c);
    	let radius_a = Math.sqrt( F/a );
    	let radius_b = Math.sqrt( F/c );
    	results.major_radius = Math.max(radius_a, radius_b);
    	results.minor_radius = Math.min(radius_a, radius_b);
		
        let R = [
        	[cos_phi, sin_phi], 
            [-sin_phi, cos_phi]
        ];
		let P_in = Vector$1.matrix_multiply(R, [[x_center], [y_center]]);
    	P_in[0];
    	P_in[1];
    	
    	//results.x0_in_center = X0_in[0]
        //results.y0_in_center = Y0_in[0]
        results.coeffs = coeffs;
        results.eccentricity = results.minor_radius / results.major_radius;
 		results.rotation_angle = orientation_rad * 180 / Math.PI;
    	results.center_point = [x_center, y_center];
        let phi = orientation_rad;
        results.quad_points_major = [
        	[x_center + results.major_radius*Math.cos(phi), y_center + results.major_radius*Math.sin(phi)],
            [x_center + results.major_radius*Math.cos(phi + Math.PI), y_center + results.major_radius*Math.sin(phi + Math.PI)]
        ];
        results.quad_points_minor = [
        	[x_center + results.minor_radius*Math.cos(phi + Math.PI/2), y_center + results.minor_radius*Math.sin(phi + Math.PI/2)],
            [x_center + results.minor_radius*Math.cos(phi - Math.PI/2), y_center + results.minor_radius*Math.sin(phi - Math.PI/2)]
        ];
        
    	return results
	}
} //end class


//Private
function dist_point_to_plane(point, plane){
    if (Vector$1.size(plane) !== 4){
        dde_error("Complete the plane by using the function 'Vector.complete_plane(vector, point)'");
        return null
    }
    return -Vector$1.dot(point, plane)
}

//Private
function dist_point_to_line(point, line_point_A, line_point_B){
    var term1 = Vector$1.subtract(point, line_point_A);
    var term2 = Vector$1.subtract(point, line_point_B);
    var term3 = Vector$1.subtract(line_point_B, line_point_A);
    var d = Vector$1.distance(Vector$1.cross(term1, term2)) / Vector$1.distance(term3);
    return d
}

function multiply_two_matrices(matrix_A, matrix_B){
    let A_height, B_height, A_width, B_width, A_dim, B_dim;
    A_dim = Vector$1.matrix_dimensions(matrix_A);
    B_dim = Vector$1.matrix_dimensions(matrix_B);
    A_height = A_dim[0];
    A_width = A_dim[1];
    B_height = B_dim[0];
    B_width = B_dim[1];

    /*
    let A_height = matrix_A.length
    let B_height = matrix_B.length
    let A_width  = matrix_A[0].length
    let B_width  = matrix_B[0].length
    */
    if(A_width == undefined){
        A_width = A_height;
        A_height = 1;
    }
    if(B_width == undefined){
        B_width = B_height;
        B_height = 1;
    }
    if(A_width != B_height){
        dde_error("Inner matrix dimension must match");
    }
    let result = Vector$1.make_matrix(A_height, B_width);
    for(var i = 0; i < A_height; i++){
        for(var j = 0; j < B_width; j++){
            let verticle = Vector$1.make_matrix(1, B_height)[0];
            if(B_height == 1){
                verticle = matrix_B[j];
            }else {
                for(var k = 0; k < B_height; k++){
                    verticle[k] = matrix_B[k][j];
                }
            }
            if(A_height == 1){
                result[i][j] = Vector$1.dot(matrix_A, verticle);
            }else {
                result[i][j] = Vector$1.dot(matrix_A[i], verticle);
            }
        }
    }
    return result
}

function divide_two_matrices(matrix_numerator, matrix_denominator){
    let dim_num = Vector$1.matrix_dimensions(matrix_numerator);
    let dim_den = Vector$1.matrix_dimensions(matrix_denominator);
    if (!((dim_num[0] == dim_den[0]) && (dim_num[1] == dim_den[1]))){
        dde_error("matrix dimensions must match in Vector.matrix_divide");
    }
    return Vector$1.matrix_multiply(matrix_numerator, Vector$1.inverse(matrix_denominator))
}

//16 Nov 2013 by Andrew Ippoliti
//http://blog.acipo.com/matrix-inversion-in-javascript/
// Returns the inverse of matrix `M`.
function matrix_invert(M){
    // I use Guassian Elimination to calculate the inverse:
    // (1) 'augment' the matrix (left) by the identity (on the right)
    // (2) Turn the matrix on the left into the identity by elemetry row ops
    // (3) The matrix on the right is the inverse (was the identity matrix)
    // There are 3 elemtary row ops: (I combine b and c in my code)
    // (a) Swap 2 rows
    // (b) Multiply a row by a scalar
    // (c) Add 2 rows

    //if the matrix isn't square: exit (error)
    if(M.length !== M[0].length){return;}

    //create the identity matrix (I), and a copy (C) of the original
    var ii=0, j=0, dim=M.length, e=0;
    var I = [], C = [];
    for(let i=0; i<dim; i+=1){
        // Create the row
        I[I.length]=[];
        C[C.length]=[];
        for(j=0; j<dim; j+=1){
            //if we're on the diagonal, put a 1 (for identity)
            if(i==j){ I[i][j] = 1; }
            else { I[i][j] = 0; }
            // Also, make the copy of the original
            C[i][j] = M[i][j];
        }
    }

    // Perform elementary row operations
    for(let i=0; i<dim; i+=1){
        // get the element e on the diagonal
        e = C[i][i];

        // if we have a 0 on the diagonal (we'll need to swap with a lower row)
        if(e==0){
            //look through every row below the i'th row
            for(ii=i+1; ii<dim; ii+=1){
                //if the ii'th row has a non-0 in the i'th col
                if(C[ii][i] != 0){
                    //it would make the diagonal have a non-0 so swap it
                    for(j=0; j<dim; j++){
                        e = C[i][j];       //temp store i'th row
                        C[i][j] = C[ii][j];//replace i'th row by ii'th
                        C[ii][j] = e;      //repace ii'th by temp
                        e = I[i][j];       //temp store i'th row
                        I[i][j] = I[ii][j];//replace i'th row by ii'th
                        I[ii][j] = e;      //repace ii'th by temp
                    }
                    //don't bother checking other rows since we've swapped
                    break;
                }
            }
            //get the new diagonal
            e = C[i][i];
            //if it's still 0, not invertable (error)
            if(e==0){return}
        }

        // Scale this row down by e (so we have a 1 on the diagonal)
        for(j=0; j<dim; j++){
            C[i][j] = C[i][j]/e; //apply to original matrix
            I[i][j] = I[i][j]/e; //apply to identity
        }

        // Subtract this row (scaled appropriately for each row) from ALL of
        // the other rows so that there will be 0's in this column in the
        // rows above and below this one
        for(ii=0; ii<dim; ii++){
            // Only apply to other rows (we want a 1 on the diagonal)
            if(ii==i){continue;}

            // We want to change this element to 0
            e = C[ii][i];

            // Subtract (the row above(or below) scaled by e) from (the
            // current row) but start at the i'th column and assume all the
            // stuff left of diagonal is 0 (which it should be if we made this
            // algorithm correctly)
            for(j=0; j<dim; j++){
                C[ii][j] -= e*C[i][j]; //apply to original matrix
                I[ii][j] -= e*I[i][j]; //apply to identity
            }
        }
    }

    //we've done all operations, C should be the identity
    //matrix I should be the inverse:
    return I;
}

//Kinematics Class

class Kin$1{
    static inverse_kinematics(xyz, direction = [0, 0, -1], config = [1, 1, 1], dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        if(xyz == undefined){
        	dde_error("xyz must be defined. To prevent unpredictable movement a default is not used.");
        }
        let dexter_inst, workspace_pose;
        if(Array.isArray(dexter_inst_or_workspace_pose)) { workspace_pose = dexter_inst_or_workspace_pose;}
        else { dexter_inst = dexter_inst_or_workspace_pose; workspace_pose = dexter_inst_or_workspace_pose.pose;}
        let xyz_dim = Vector$1.matrix_dimensions(xyz);
        if(xyz_dim[0] == 3 && xyz_dim[1] == 3){
        	workspace_pose = direction;
            config = xyz[2];
            direction = xyz[1];
            xyz = xyz[0];
        }
        
        
    
        let J = Vector$1.make_matrix(1, 5)[0]; // Joint Angles
        let U = Vector$1.make_matrix(5, 3);
        let P = [0, 0, 0, 0];
        let L;
        if(dexter_inst) { L = [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5]; } //Link Lengths
		else            { L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5]; }
		let normal = direction;
    	let right_arm = config[0];
    	let elbow_up = config[1];
    	let wrist_out = config[2];
        
        if(direction.length == 2){
        	normal = Kin$1.angles_to_dir_xyz(direction[0], direction[1]);
        }else if(direction.length == 3){
        	if(Vector$1.magnitude(direction) == 0){
            	dde_error("Direction must have a magnitude. Try [0, 0, -1] or [0, 0] for the [x_angle, y_angle] form");
            }
        }else {dde_error("Direction must be in the form [x, y, z] or [x_angle, y_angle]");}
        
        
        let xyz_trans, normal_trans;
        if(workspace_pose == undefined || Vector$1.is_equal(workspace_pose, [0, 0, -1])){
        	workspace_pose = Vector$1.identity_matrix(4);
            xyz_trans = xyz.slice();
            normal_trans = normal.slice();
        }else if(Vector$1.is_equal([4,4], Vector$1.matrix_dimensions(workspace_pose))){
        	xyz_trans = Vector$1.transpose(Vector$1.matrix_multiply(workspace_pose, Vector$1.properly_define_point(xyz))).slice(0,3);
        	normal_trans = Vector$1.transpose(Vector$1.matrix_multiply(workspace_pose, Vector$1.properly_define_vector(normal))).slice(0,3);
        }else {
        	dde_error("Unsupported workspace_pose datatype: " + workspace_pose);
        }
        
        
    	//Knowns:
        P[0] = [1, 0, 0, 0];
    	let V54 = Vector$1.multiply(-1, Vector$1.normalize(normal_trans)); //Direction of EE
        U[0] = [0, 0, 0];
        let V10 = [0, 0, 1];
    	U[1] = Vector$1.multiply(L[0], V10);
        U[4] = Vector$1.add(xyz_trans, Vector$1.multiply(L[4], V54));
        U[5] = xyz_trans;
        
    	
    	//Solving for P1
    	P[1] = Vector$1.points_to_plane(U[1], U[0], U[4]);
        if(Vector$1.is_NaN_null_or_undefined(P[1])){
        	P[1] = Vector$1.points_to_plane(U[1], U[0], U[3]);
            if(Vector$1.is_NaN_null_or_undefined(P[1])){
        		dde_error(`Singularity: Toolpoint xyz is on Base axis. [0, 0, z] divides by 0.
            	Try [0, 1e-10, z] if it works use the ouputted joint angles for a move_all_joints() instead.
            	The first joint angle can be changed to any value without affecting the tool point`);
            }
        }

		//Solving for U3
    	var U54_Proj = Vector$1.project_vector_onto_plane(V54, P[1]);
    	var U3_a = Vector$1.add(U[4], Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(U54_Proj), P[1], 90)));
        var U3_b = Vector$1.add(U[4], Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(U54_Proj), P[1], -90)));
        
        
        //This is proven to work for directions of approx. [0, 1, 0] but has potentially not been tested enough
        var dist_a = Vector$1.distance(U3_a, [0, 0, 0]);
    	var dist_b = Vector$1.distance(U3_b, [0, 0, 0]);
        if (wrist_out){
    		if (dist_a < dist_b){
        		U[3] = U3_a;
        	}else {
        		U[3] = U3_b;
        	}
    	}else {
    		if (dist_a > dist_b){
        		U[3] = U3_a;
        	}else {
        		U[3] = U3_b;
        	}
    	}
    	
        
        
        /*
        //This is proven to work for directions of approx. [0, 0, -1] but not for [x, y, 0]
        var dist_a = Vector.distance(U3_a, U[1], U[0])
    	var dist_b = Vector.distance(U3_b, U[1], U[0])
        if (wrist_out){
    		if (dist_a < dist_b){
        		U[3] = U3_a
        	}else{
        		U[3] = U3_b
        	}
    	}else{
    		if (dist_a > dist_b){
        		U[3] = U3_a
        	}else{
        		U[3] = U3_b
        	}
    	}
        */
        
        
    	//Solving for P2
    	P[2] = Vector$1.points_to_plane(U[5], U[4], U[3]);
        if(Vector$1.is_NaN_null_or_undefined(P[2])){
        	dde_error("Unknown plane singularity at: " + xyz + ", " + direction + ", " + config + ". Please copy this message and report it as a bug.");
        }
		
    	//Solving for U2
    	var D3 = Vector$1.distance(U[3], U[1]);
        if(Vector$1.is_equal(D3, L[1] + L[3], 9)){
        	D3 = L[1] + L[2];
        }
        
        //Checking if in reach
        if (D3 > L[1] + L[2]){
        	let out_of_reach_dist = Vector$1.round(D3 - (L[1] + L[2]), 4);
        	dde_error("Point [" + Vector$1.round(xyz, 3)+"], [" + Vector$1.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach');
        }
        
        
    	//let Beta = acosd((-Math.pow(L[2], 2) + Math.pow(L[1], 2) + Math.pow(D3, 2)) / (2 * D3 * L[1])) // Law of Cosines
        let Beta = acosd((-Math.pow(L[2], 2) + Math.pow(L[1], 2) + Math.pow(D3, 2)) / (2 * D3 * L[1])); // Law of Cosines
        let V31 = Vector$1.normalize(Vector$1.subtract(U[3], U[1]));
    	
    	let U2_a = Vector$1.add(U[1], Vector$1.multiply(L[1], Vector$1.rotate(V31, P[1], Beta)));
    	let U2_b = Vector$1.add(U[1], Vector$1.multiply(L[1], Vector$1.rotate(V31, P[1], -Beta)));
    	//let U2_a_dist = Vector.distance(U2_a, P[0])
    	//let U2_b_dist = Vector.distance(U2_b, P[0])
        let V2a1 = Vector$1.subtract(U2_a, U[1]);
        let V32a = Vector$1.subtract(U[3], U2_a);
        //let V2b1 = Vector.subtract(U2_b, U[1])
        //let V32b = Vector.subtract(U[3], U2_b)
    	
    	if (elbow_up){
    		if(Vector$1.dot(Vector$1.cross(V2a1, V32a), P[1]) < 0){
        		U[2] = U2_a;
        	}else {
        		U[2] = U2_b;
        	}
    	}else {
      		if(Vector$1.dot(Vector$1.cross(V2a1, V32a), P[1]) > 0){
        		U[2] = U2_a;
        	}else {
        		U[2] = U2_b;
        	}
    	}


    	//Solving for joint angles
    
		//var V10 = minus(U[1], U[0])
    	var V21 = Vector$1.normalize(Vector$1.subtract(U[2], U[1]));
    	var V32 = Vector$1.normalize(Vector$1.subtract(U[3], U[2]));
    	var V43 = Vector$1.normalize(Vector$1.subtract(U[4], U[3]));
    	//var V54 = minus(U[5], U[3])

		if(right_arm == 1){
    		J[0] = Vector$1.signed_angle(P[1], P[0], V10); 
    		J[1] = Vector$1.signed_angle(V21, V10, P[1]);
    		J[2] = Vector$1.signed_angle(V32, V21, P[1]);
    		J[3] = Vector$1.signed_angle(V43, V32, P[1]);
    		J[4] = Vector$1.signed_angle(P[2], P[1], V43);
    	}else {
    		J[0] = Vector$1.signed_angle(P[1], P[0], V10) + 180;
    		J[1] = -Vector$1.signed_angle(V21, V10, P[1]);
    		J[2] = -Vector$1.signed_angle(V32, V21, P[1]);
    		J[3] = -Vector$1.signed_angle(V43, V32, P[1]);
    		J[4] = Vector$1.signed_angle(P[2], P[1], V43) + 180;
    	}
    
    	if(Vector$1.is_NaN_null_or_undefined(J[2])){
        	let thres = 100;
        	if(L[0] > thres || L[1] > thres || L[2] > thres || L[3] > thres || L[4] > thres){
            	dde_error("Link lengths are non properly defined: "  
                + "</br>LINK1: " + L[0] + " (meters)"
                + "</br>LINK2: " + L[1] + " (meters)"
                + "</br>LINK3: " + L[2] + " (meters)"
                + "</br>LINK4: " + L[3] + " (meters)"
                + "</br>LINK5: " + L[4] + " (meters)");
            }
        	dde_error("Singularity at: " + xyz + ", " + direction + ", " + config + ".</br>Please copy this message and report it as a bug.");
    	}
    
    	return [J, U, P]
    } 
    
    static forward_kinematics (joint_angles, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        let J = Vector$1.deep_copy(joint_angles); //Joint Angles
        let U = new Array(5).fill(new Array(3)); //Point Locations

        let dexter_inst, workspace_pose;
        if(Array.isArray(dexter_inst_or_workspace_pose))  { workspace_pose = dexter_inst_or_workspace_pose;}
        else { dexter_inst = dexter_inst_or_workspace_pose; workspace_pose = dexter_inst_or_workspace_pose.pose;}
        let L;
        if(dexter_inst) { L = [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5]; } //Link Lengths
        else            { L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5]; }

        let P = new Array(3).fill(new Array(4)); //Planes
        
        let V21, V32, V43, V54;
        //Knowns:
        let U0 = [0, 0, 0];
        let V10 = [0, 0, 1];
        let P0 = [1, 0, 0];
        
        //Calculates all vectors first
        P[0] = P0;
		P[1] = Vector$1.rotate(P[0], V10, -(J[0]-180));
        V21 = Vector$1.rotate(V10, P[1], J[1]);
        V32 = Vector$1.rotate(V21, P[1], J[2]);
        V43 = Vector$1.rotate(V32, P[1], J[3]);
        P[2] = Vector$1.rotate(P[1], V43, -(J[4]-180));
        V54 = Vector$1.rotate(V43, P[2], -90);
		let V = [V10, V21, V32, V43, V54];
        
        //Dimensionalizes vectors by multiplying by link lengths
        U[0] = U0;
		U[1] = Vector$1.add(U[0], Vector$1.multiply(L[0], V10));
        U[2] = Vector$1.add(U[1], Vector$1.multiply(L[1], V21));
        U[3] = Vector$1.add(U[2], Vector$1.multiply(L[2], V32));
        U[4] = Vector$1.add(U[3], Vector$1.multiply(L[3], V43));
        U[5] = Vector$1.add(U[4], Vector$1.multiply(L[4], V54));
		
        P[1] = Vector$1.round(P[1], 15);
        P[2] = Vector$1.round(P[2], 15);
        
        
        let trans_mat = Vector$1.inverse(workspace_pose);
        if(Vector$1.is_equal([4,4], Vector$1.matrix_dimensions(workspace_pose))){
        	for(let i = 0; i < U.length; i++){
            	U[i] = Vector$1.transpose(Vector$1.matrix_multiply(trans_mat, Vector$1.properly_define_point(U[i]))).slice(0,3);
            }
            //debugger
            for(let i = 0; i < P.length; i++){
            	P[i] = Vector$1.transpose(Vector$1.matrix_multiply(trans_mat, Vector$1.properly_define_vector(P[i]))).slice(0,3);
            }
            for(let i = 0; i < V.length; i++){
            	V[i] = Vector$1.transpose(Vector$1.matrix_multiply(trans_mat, Vector$1.properly_define_vector(V[i]))).slice(0,3);
            }
        }else {
        	dde_error("Unsupported workspace_pose datatype");
        }
        
        return [U, V, P]
    }

    /*static is_in_reach(xyz, J5_direction = [0, 0, -1], config = [1, 1, 1], dexter_inst){
    	let base_xyz = [0, 0, 0] // Come back to this and pull it from robot_pose
        let base_plane = [0, 0, 1]
        let U3
        let L
        if(dexter_inst) { L = [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5] } //Link Lengths
        else            { L = [Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5] }

        let U1 = Vector.add(base_xyz, Vector.multiply(base_plane, L[0]))
    	let U4 = Vector.add(xyz, Vector.multiply(-L[4], Vector.normalize(J5_direction)))

		//Solving for P1
    	let P1 = Vector.points_to_plane(U1, base_xyz, U4)
        if(Vector.is_NaN(P1)){
        	P1 = Vector.points_to_plane(U1, base_xyz, U3)
            if(Vector.is_NaN(P1)){
        		return false
            }
        }
    }*/



    static is_in_reach (xyz, J5_direction = [0, 0, -1], config = [1, 1, 1], dexter_inst_or_workspace_pose){
            let base_xyz = [0, 0, 0]; // Come back to this and pull it from robot_pose
            let base_plane = [0, 0, 1];
            let U3;
            let U1 = Vector$1.add(base_xyz, Vector$1.multiply(base_plane, Dexter$1.LINK1));
            let dexter_inst, workspace_pose;
            if(Array.isArray(dexter_inst_or_workspace_pose)) { workspace_pose = dexter_inst_or_workspace_pose;}
            else if (dexter_inst_or_workspace_pose) { dexter_inst = dexter_inst_or_workspace_pose; workspace_pose = dexter_inst_or_workspace_pose.pose;}
            let L;
            if(dexter_inst) { L = [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5]; } //Link Lengths
            else            { L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5]; }

            let xyz_trans;
            let normal_trans;
            if(workspace_pose == undefined){
                workspace_pose = Vector$1.identity_matrix(4);
                xyz_trans = xyz.slice();
                normal_trans = J5_direction.slice();
            }else if(Vector$1.is_equal([4,4], Vector$1.matrix_dimensions(workspace_pose))){
                xyz_trans = Vector$1.transpose(Vector$1.matrix_multiply(workspace_pose, Vector$1.properly_define_point(xyz))).slice(0,3);
                normal_trans = Vector$1.transpose(Vector$1.matrix_multiply(workspace_pose, Vector$1.properly_define_vector(J5_direction))).slice(0,3);
            }else {
                dde_error("Unsupported workspace_pose datatype: " + workspace_pose);
            }
            let U5 = xyz_trans;
            let U4 = Vector$1.add(U5, Vector$1.multiply(-L[4], Vector$1.normalize(normal_trans)));


            //Solving for P1
            let P1 = Vector$1.points_to_plane(U1, base_xyz, U4);
            if(Vector$1.is_NaN_null_or_undefined(P1)){
                P1 = Vector$1.points_to_plane(U1, base_xyz, U3);
                if(Vector$1.is_NaN_null_or_undefined(P1)){
                    return false
                }
            }


            //Solving for U3
            let V54 = Vector$1.subtract(U5, U4);
            var U54_Proj = Vector$1.project_vector_onto_plane(V54, P1);
            var U3_a = Vector$1.add(U4, Vector$1.multiply(L[2], Vector$1.rotate(Vector$1.normalize(U54_Proj), P1, 90)));
            var U3_b = Vector$1.add(U4, Vector$1.multiply(L[2], Vector$1.rotate(Vector$1.normalize(U54_Proj), P1, -90)));
            var dist_a = Vector$1.distance(U3_a, U1, base_xyz);
            var dist_b = Vector$1.distance(U3_b, U1, base_xyz);
            if (config[2] == 1){
                if (dist_a < dist_b){
                    U3 = U3_a;
                }else {
                    U3 = U3_b;
                }
            }else {
                if (dist_a > dist_b){
                    U3 = U3_a;
                }else {
                    U3 = U3_b;
                }
            }


            if (Vector$1.distance(U1, U3) <= L[1] + L[2]){
                return true
            }else {
                return false
            }
    }
    
    //Public
    static J_angles_to_config (joint_angles, dexter_inst_or_workspace_pose){
    	let U54_Proj, U3_a, U3_b, dist_a, dist_b;
    	let J = Vector$1.deep_copy(joint_angles);
        let fk = Kin$1.forward_kinematics(J, dexter_inst_or_workspace_pose);
        let U = fk[0];
        let V = fk[1];
        let dexter_inst;
        if(Array.isArray(dexter_inst_or_workspace_pose)) ;
        else if (dexter_inst_or_workspace_pose) { dexter_inst = dexter_inst_or_workspace_pose;}
        //note that dexter_inst_or_workspace_pose might be undefined.
        //we don't actually need workspace_pose in this method, but I'm following a pattern here.
        let L;
        if(dexter_inst) { L = [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5]; } //Link Lengths
        else            { L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5]; }

        let right_arm, elbow_up, wrist_out;
        let P = fk[2];
        
        P[1] = Vector$1.points_to_plane(U[1], U[0], U[4]);
        U54_Proj = Vector$1.project_vector_onto_plane(V[4], P[1]);
    	U3_a = Vector$1.add(U[4], Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(U54_Proj), P[1], 90)));
        U3_b = Vector$1.add(U[4], Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(U54_Proj), P[1], -90)));
        
        
        dist_a = Vector$1.distance(U3_a, U[2]);
    	dist_b = Vector$1.distance(U3_b, U[2]);
        if (Vector$1.is_equal(U[3], U3_a)){
    		if (dist_a < dist_b){
        		wrist_out = 0;
        	}else {
        		wrist_out = 1;
        	}
    	}else {
    		if (dist_a > dist_b){
        		wrist_out = 1;
        	}else {
        		wrist_out = 0;
        	}
    	}
        /*
        //Old code:
        dist_a = Vector.distance(U3_a, U[1], U[0])
    	dist_b = Vector.distance(U3_b, U[1], U[0])
    		
        if(U[3] == U3_a){
        	if (dist_a < dist_b){
            	wrist_out = 1
            }else{
            	wrist_out = 0
            }
        }else{
        	if (dist_a < dist_b){
            	wrist_out = 0
            }else{
            	wrist_out = 1
            }
        }
        */
        
        
        let U50 = Vector$1.subtract(U[5], U[0]);
        if(Vector$1.dot(Vector$1.cross(U50, P[1]), V[0]) > 0){
        	right_arm = 0;
            
            if(wrist_out == 0){
            	wrist_out = 1;
            }else {
            	wrist_out = 0;
            }
        }else {
        	right_arm = 1;
        }
        
        if(right_arm == 1){
        	if(Vector$1.dot(Vector$1.cross(V[1], V[2]), P[1]) > 0){
        		elbow_up = 0;
        	}else {
        		elbow_up = 1;
        	}
        }else {
        	if(Vector$1.dot(Vector$1.cross(V[1], V[2]), P[1]) < 0){
        		elbow_up = 0;
        	}else {
        		elbow_up = 1;
        	}
        }
        
        
        return [right_arm, elbow_up, wrist_out]
    }

	/*
	this.point_at_xyz = function(xyz, current_J5_xyz, current_config, base_xyz = [0, 0, 0], base_plane = [0, 0, 1], base_rotation = 0){
    	let pointing_direction = Vector.subtract(xyz, current_J5_xyz)
        Kin.xyz_to_J_angles(current_J5_xyz, pointing_direction, current_config, base_xyz, base_plane, base_rotation)
    }
    */
    
    
    
    //Torque:
    
    
    /*
    I've run a mile in 4:24 what is that in MPH?
    var meter_per_sec = _mile / (4*_min+24*_s)
    var MPH = meter_per_sec / (_mile/_hour)
    
    
    
    this.gravity_torques = function(J_angles, base_xyz = [0, 0, 0], base_plane = [0, 0, 1], base_rotation = 0){
    	//This will return the torques expected due to the forces of gravity
        //As of now the output units are in Newton-meters but are subject to change
        
        
        //These will change once measurements are taken
        let L = [Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5] //Link Lengths
        let CM_L = Vector.multiply(.5, L) // Center of mass as distance along the link
        let M = [5, 2, 2, .5, .5] //Link masses (kg) (guesses)
        let g = [0, 0, -9.80665] // (micron/millisecond^2 or m/s^2, they are equivalent)
        var T_vector = new Array(5).fill(new Array(3))
        var T = new Array(5)
        var F_vector = new Array(5).fill(new Array(3))
        var CM_r = new Array(5).fill(new Array(3))

        let P0 = Kin.base_rotation_to_plane(base_rotation, base_plane)
        let fk_result = Kin.forward_kinematics(J_angles, base_xyz, base_plane, P0)
        let U = fk_result[0]
        let V = (fk_result[1])
        let Vn = new Array(3).fill(new Array(5))
        for(var i = 0; i < 5; i++){
        	Vn[i] = Vector.normalize(V[i])
            F_vector[i] = Vector.multiply(M[i], g)
            CM_r[i] = Vector.multiply(CM_L[i], Vn[i])
        }
        //var P1 = Vector.points_to_plane(U[1], U[0], U[4])
        var P1 = Vector.rotate(P0, base_plane, J_angles[0])
        
        
        
        
        //Torques are calculated backwards from the end effector
        //The system is stationary so the sum of the torques equal zero 
        //the torque vector is found by crossing the radius (distance from joint to link's center of mass) and the weight vector
        //that torque vector may only have some components that affect the actual joint's torque reading
        //This is dealt with by projecting the torque vector onto the axis of the joint's rotation 
        let T_sum = [0, 0, 0]
        let F_sum = 0
        let radius
        let planes_of_rotation = [Vn[0], P1, P1, P1, Vn[3]]
        
        //Joints 1 and 2 
        T_sum = [0, 0, 0]
        T_sum = Vector.add(T_sum, Vector.cross(Vector.multiply(CM_L[1], Vn[1]), F_vector[1]))
        radius = Vector.add(V[1], CM_r[2])
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[2]))
        radius = Vector.add(V[1], V[2], CM_r[3])
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[3]))
        radius = Vector.add(V[1], V[2], V[2], CM_r[4])
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[4]))
        T_vector[0] = T_sum
        T_vector[1] = T_sum
        
        //Joint 3
        T_sum = [0, 0, 0]
        radius = CM_r[2]
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[2]))
        radius = Vector.add(V[2], CM_r[3])
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[3]))
        radius = Vector.add(V[2], V[3], CM_r[4])
		T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[4]))
		T_vector[2] = T_sum
        
        //Joint 4
        T_sum = [0, 0, 0]
        radius = CM_r[3]
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[3]))
        radius = Vector.add(V[3], CM_r[4])
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[4]))
		T_vector[3] = T_sum
        
        //Joint 5
        T_sum = [0, 0, 0]
        radius = CM_r[4]
        T_sum = Vector.add(T_sum, Vector.cross(radius, F_vector[4]))
		T_vector[4] = T_sum
        
        for(var i = 0; i < 5; i++){
        	T[i] = Vector.dot(planes_of_rotation[i], T_vector[i])
        }
        
        T = Vector.multiply(.000001, T) // Converting to Nm (will change)
		return [T, T_vector, U, planes_of_rotation] 
    }*/
    
 
    //similar to Dexter.joints_out_of_range, but returns different values
    static check_J_ranges(J_angles, dexter_inst){
        let lower_limit;
        let upper_limit;
        if(dexter_inst instanceof Dexter$1) {
            lower_limit = [dexter_inst.J1_angle_min, dexter_inst.J2_angle_min, dexter_inst.J3_angle_min, dexter_inst.J4_angle_min, dexter_inst.J5_angle_min];
            upper_limit = [dexter_inst.J1_angle_max, dexter_inst.J2_angle_max, dexter_inst.J3_angle_max, dexter_inst.J4_angle_max, dexter_inst.J5_angle_max];
        }
        else {
    	    lower_limit = [Dexter$1.J1_ANGLE_MIN, Dexter$1.J2_ANGLE_MIN, Dexter$1.J3_ANGLE_MIN, Dexter$1.J4_ANGLE_MIN, Dexter$1.J5_ANGLE_MIN];
            upper_limit = [Dexter$1.J1_ANGLE_MAX, Dexter$1.J2_ANGLE_MAX, Dexter$1.J3_ANGLE_MAX, Dexter$1.J4_ANGLE_MAX, Dexter$1.J5_ANGLE_MAX];
        }
        for(var i = 0; i < J_angles.length; i++){
        	let angle = J_angles[i];
        	if((angle != null) && ((lower_limit[i] > angle) || (upper_limit[i] < angle))){
            	return false
            }
        }
        return true
    }

	/**************************************************************
	Wrapper Functions:
	***************************************************************/

    //Wrapper function for inverse kinematics
    //Returns joint angles
    
    //Depricated wrapper functions:
    static xyz_to_J_angles(xyz, J5_direction = [0, 0, -1], config = Dexter$1.RIGHT_UP_OUT, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        return Kin$1.inverse_kinematics(xyz, J5_direction, config, dexter_inst_or_workspace_pose)[0]
    }

    static xyz_to_J_points(xyz, J5_direction = [0, 0, -1], config = Dexter$1.RIGHT_UP_OUT, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        return Kin$1.inverse_kinematics(xyz, J5_direction, config, dexter_inst_or_workspace_pose)[1]
    }
    
    static xyz_to_J_planes(xyz, J5_direction = [0, 0, -1], config = Dexter$1.RIGHT_UP_OUT, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        return Kin$1.inverse_kinematics(xyz, J5_direction, config, dexter_inst_or_workspace_pose)[2]
    }

    
    /*
    var EE_pose = Vector.make_pose([-0.4, 0.4, 0.2], [90, 0, 0])
    var direction = Vector.transpose(Vector.pull(EE_pose, [0,2], [1,1]))
    debugger
    var J_angles = Kin.xyz_to_J_angles_6_axes(EE_pose)
    
    
    */
    static xyz_to_J_angles_6_axes(EE_pose, config = Dexter$1.RIGHT_UP_OUT, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        let direction = Vector$1.transpose(Vector$1.pull(EE_pose, [0,2], [1,1]));
        let xyz = Vector$1.transpose(Vector$1.pull(EE_pose, [0,2], [3,3]));
        let kin_res = Kin$1.inverse_kinematics(xyz, direction, config, dexter_inst_or_workspace_pose);
        let x_vector = kin_res[2][2].slice(0,3);
        //let y_vector = direction
        //let z_vector = Vector.cross(x_vector, y_vector)
        let x_vector_desired = Vector$1.transpose(Vector$1.pull(EE_pose, [0,2], [0,0]));
        let J6 = Vector$1.signed_angle(x_vector, x_vector_desired, direction);
		
        return [kin_res[0][0], kin_res[0][1], kin_res[0][2], kin_res[0][3], kin_res[0][4], J6]
    }
    
	
    //Wrapper function for forward kinematics
    static J_angles_to_xyz(joint_angles, dexter_inst_or_workspace_pose = Vector$1.make_pose()){
        let temp_angles = Vector$1.deep_copy(joint_angles);
        let xyzs = Kin$1.forward_kinematics(temp_angles, dexter_inst_or_workspace_pose)[0];
        //out(xyzs)
        let direction = Vector$1.normalize(Vector$1.subtract(xyzs[5], xyzs[4]));
        let config = Kin$1.J_angles_to_config(temp_angles, dexter_inst_or_workspace_pose);
        return [xyzs[5], direction, config]
    }
    
    static J_angles_to_coor(joint_angles, L0_pose, dexter_inst){
        let L0;
        if(Object.isNewObject(L0_pose)){
            L0 = L0_pose;
        }else if(Vector$1.is_pose(L0_pose)){
        	L0 = Coor.Table.create_child(L0_pose);
        }else if(L0_pose == undefined){ // this should get replaced with is_Coor()
            L0 = Coor.Table.create_child(Vector$1.make_pose());
        }else {
        	dde_error("L0_pose input arg must be a Coordinate System Object, a pose, or undefined");
        }
        let L = ((dexter_inst instanceof Dexter$1) ?
                   [dexter_inst.Link1, dexter_inst.Link2, dexter_inst.Link3, dexter_inst.Link4, dexter_inst.Link5] :
                   [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5]);
        let J = joint_angles;
        
        
		let L1 = L0.create_child(Vector$1.make_pose([0, 0, L[0]]), "L1");
		let L2 = L1.create_child(Vector$1.make_pose([0, 0, L[1]]), "L2");
		let L3 = L2.create_child(Vector$1.make_pose([0, 0, L[2]]), "L3");
        let L4 = L3.create_child(Vector$1.make_pose([0, 0, L[3]]), "L4");
        let L5 = L4.create_child(Vector$1.make_pose([0, 0,    0]), "L5");
		
        L1.rotate("Z", J[0], [0, 0, 0]);
        L2.rotate("X", J[1], [0, 0, 0]);
        L3.rotate("X", J[2], [0, 0, 0]);
        L4.rotate("X", J[3], [0, 0, 0]);
        L5.rotate("Z", J[4], [0, 0, 0]);
        
        return [L0.get_pose(Coor.Table), L1.get_pose(Coor.Table), L2.get_pose(Coor.Table), L3.get_pose(Coor.Table), L4.get_pose(Coor.Table), L5.get_pose(Coor.Table)]
    }
    
    static three_positions_to_pose(J_angles_1, J_angles_2, J_angles_3, scale_factor, dexter_inst){
    	let points_A, points_B, points_C, UA5, UA4, UB5, UB4, UC5, UC4, U5_ave, U4_ave, U45;
        let point, x_vector, z_vector, pose, angleA, angleB, angleC, vector_1, vector_2;
        
        points_A = Kin$1.forward_kinematics(J_angles_1, dexter_inst)[0];
        points_B = Kin$1.forward_kinematics(J_angles_2, dexter_inst)[0];
        points_C = Kin$1.forward_kinematics(J_angles_3, dexter_inst)[0];
        
        UA5 = points_A[5];
        UA4 = points_A[4];
        UB5 = points_B[5];
        UB4 = points_B[4];
        UC5 = points_C[5];
        UC4 = points_C[4];
        
        U5_ave = Vector$1.average(UA5, UB5, UC5);
        U4_ave = Vector$1.average(UA4, UB4, UC4);
        U45 = Vector$1.subtract(U4_ave, U5_ave);
        
        angleA = Vector$1.angle(Vector$1.subtract(UB5, UA5), Vector$1.subtract(UC5, UA5));
        angleB = Vector$1.angle(Vector$1.subtract(UA5, UB5), Vector$1.subtract(UC5, UB5));
        angleC = Vector$1.angle(Vector$1.subtract(UB5, UC5), Vector$1.subtract(UA5, UC5));
        
        switch(Math.max(angleA, angleB, angleC)){
        	case angleA:
            	point = UA5;
                vector_1 = Vector$1.subtract(UB5, UA5);
                vector_2 = Vector$1.subtract(UC5, UA5);
            	break
                
            case angleB:
            	point = UB5;
                vector_1 = Vector$1.subtract(UA5, UB5);
                vector_2 = Vector$1.subtract(UC5, UB5);
            	break
                
            case angleC:
            	point = UC5;
                vector_1 = Vector$1.subtract(UB5, UC5);
                vector_2 = Vector$1.subtract(UA5, UC5);
            	break
        }
        
        if(0 < Vector$1.dot(Vector$1.cross(vector_1, vector_2), U45)){
        	x_vector = Vector$1.normalize(vector_1);
        }else {
        	x_vector = Vector$1.normalize(vector_2);
        }
        
        z_vector = Vector$1.pull(Vector$1.points_to_plane(UA5, UB5, UC5), 0, [0, 2]);
        if(0 > Vector$1.dot(z_vector, U45)){
        	z_vector = Vector$1.multiply(-1, z_vector);
        }
        
        pose = Vector$1.make_pose(point, Vector$1.make_DCM_from_3_vectors(x_vector, undefined, z_vector), scale_factor);
        return pose
    }
    /*
    var applied_force = -75 //N
    var angles = [0, 45, 90, -45, 0]
    var fk = Kin.forward_kinematics(angles)
    var points = fk[0]

	var forcepoint = points[5]
    var arm1 = Vector.subtract(points[5], points[1])[1]
    var arm2 = 0
    var arm3 = 0
    //var arm1 = 0
    //var arm2 = Vector.subtract(points[5], points[1])[1]
    //var arm3 = Vector.subtract(points[5], points[2])[1]
    var T = [0, 0, 0]
    T[0] = arm1*applied_force
    T[1] = arm2*applied_force
    T[2] = arm3*applied_force
    out(T)
    
    //var angles = [0, 45, 0, 0, 0]
    //T = [0, -0.8255, 0.8255]
    //debugger
    Kin.three_torques_to_force(angles, T)
    
    */

    static three_torques_to_force(J_angles, torques = [0, 0, 0], dexter_inst){
    	if(torques.length != 3){dde_error("Only the first three torques are required for this function");}
        
        let U, V, P, U_contact;
        let axes = [0, 0, 0];
        let D = [0, 0, 0];
        let T = [0, 0, 0];
        let F = [0, 0, 0];
        let temp_J_angles = Vector$1.deep_copy(J_angles);
        temp_J_angles[0] = 0;
        let fk = Kin$1.forward_kinematics(temp_J_angles);
        U = fk[0];
        V = fk[1];
        P = fk[2];
        (dexter_inst ? dexter_inst.Link2 : Dexter$1.LINK2);
        (dexter_inst ? dexter_inst.Link3 : Dexter$1.LINK3);
        
        U_contact = U[5];
        
        //Torque axes
        axes[0] = Vector$1.normalize(V[0]);
        axes[1] = P[1];
        axes[2] = P[1];
        
        //Moment arms (as vectors):
        D[0] = Vector$1.project_vector_onto_plane(U_contact, axes[0]);
        D[1] = Vector$1.subtract(Vector$1.project_vector_onto_plane(U_contact, P[1]), U[1]);
        D[2] = Vector$1.subtract(Vector$1.project_vector_onto_plane(U_contact, P[1]), U[2]);
		
        //Torques (as vectors):
        T[0] = Vector$1.multiply(torques[0], axes[0]);
        T[1] = Vector$1.multiply(torques[1], axes[1]);
        T[2] = Vector$1.multiply(torques[2], axes[2]);
        
        //Perpendicular forces:
        F[0] = Vector$1.multiply(Vector$1.abs(torques[0]/Vector$1.magnitude(D[0])), Vector$1.normalize(Vector$1.cross(D[0], T[0])));
        F[1] = Vector$1.multiply(Vector$1.abs(torques[1]/Vector$1.magnitude(D[1])), Vector$1.normalize(Vector$1.cross(D[1], T[1])));
        F[2] = Vector$1.multiply(Vector$1.abs(torques[2]/Vector$1.magnitude(D[2])), Vector$1.normalize(Vector$1.cross(D[2], T[2])));
        
        //Force-space calcs:
        let F1a = F[1];
        let F1b = Vector$1.add(F[1], Vector$1.cross(F[1], P[1]));
        let F2a = F[2];
        let F2b = Vector$1.add(F[2], Vector$1.cross(F[2], P[1]));
        
        
        let A = (F2b[1]-F1b[1])/(F1a[1]-F1b[1]);
        let B = ((F2a[1]-F2b[1])*(F1b[2]-F2b[2]))/((F1a[1]-F1b[1])*(F2a[2]-F2b[2]));
        let C = ((F2a[1]-F2b[1])*(F1a[2]-F1b[2]))/((F1a[1]-F1b[1])*(F2a[2]-F2b[2]));
        let alpha = (A+B)/(1-C);
        let beta = (F1b[2]-F2b[2]+(F1a[2]-F1b[2])*alpha)/(F2a[2]-F2b[2]);
        
        let ForceYZ = Vector$1.add(F2b, Vector$1.multiply(beta, Vector$1.subtract(F2a, F2b)));
		if(torques[1] == 0 && torques[2] == 0){
        	ForceYZ[1] = 0;
            ForceYZ[2] = 0;
        }

		let lineYZa = [0, ForceYZ[1], ForceYZ[2]];
        let lineYZb = [1, ForceYZ[1], ForceYZ[2]];
        let ForceXYZ;
        if(torques[0] == 0){
        	ForceXYZ = [0, ForceYZ[1], ForceYZ[2]];
        }else {
        	ForceXYZ = Vector$1.project_point_onto_line(F[0], lineYZa, lineYZb);
        }
        
        ForceXYZ[1] *= -1;
        ForceXYZ[2] *= -1;
        return ForceXYZ
    }
    /*
    var J_angles = Convert.degrees_to_arcseconds([0, 0, 0, 0, 0]) 
    var F = 22
    var T = [F*Convert.mms_to_microns(40.7), F*(Dexter.LINK2 + Dexter.LINK3), F*Dexter.LINK3]
    debugger
    out(Kin.three_joints_force(J_angles, T, 'EndAxisHub'))
    
    
    
    var J_angles = Convert.degrees_to_arcseconds([0, 0, 90, 0, 0]) 
    var F = 22
    var F2 = 0
    var T = [F2*Dexter.LINK3, F*Dexter.LINK3, F*Dexter.LINK3]
    //debugger
    out(Kin.three_joints_force(J_angles, T, 'EndAxisHub'))
    
    var J_angles = Convert.degrees_to_arcseconds([45, 0, 45, 0, 0]) 
    var Fz = 13
    var Fx = 0
    var T = [Fx*Dexter.LINK3, Fz*Dexter.LINK3, Fz*Dexter.LINK3]
    //debugger
    out(Kin.three_joints_force(J_angles, T, 'EndAxisHub'))
    
    
    var Fv_mag = Vector.magnitude(Fv[1])
    var angle = Math.atan(Fv[1][1]/Fv[1][2])
    var hyp = Fv_mag/Math.cos(angle)
    var hyp2 = Fv_mag*Math.sqrt(1+Math.pow(Math.hypot(Fv[1][1], Fv[0][1])/Fv[1][2],2))
    var hyp2 = Fv_mag*Math.sqrt(1+Math.pow(Fv[0][1]/Fv[1][2],2))
    Vector.cross(Fv[1], [0,0,1])
    */
    /*
    function dde_warning(message){
        if(!(dde_warning_list.indexOf(message) > -1)){
        	dde_warning_list.push(message)
    		out("dde_warning: " + message, "red")
        }
    }
    */
    
    static make_xyz_dir_config(xyz = [0, 0.5, 0.1], dir = [0, 0, -1], config = [1, 1, 1]){
    	return [xyz, dir, config]
    }

    /*returns time in milliseconds*/
    /* this errors if the 2 args are of different length.
       It also counts joints beyond joint 5, which it shouldn't
	static predict_move_dur(J_angles_original, J_angles_destination, robot){
        
        //let speed = robot.prop("MAX_SPEED")
        let speed = 30
        let delta = Vector.subtract(J_angles_destination, J_angles_original)
        for(let i = 0; i < delta.length; i++){
        	delta[i] = Math.abs(delta[i])
        }
        return Vector.max(delta)/speed
    }*/

    /*returns time in milliseconds*/
    static predict_move_dur_5_joint(J_angles_original, J_angles_destination, robot){
        //let speed = robot.prop("MAX_SPEED")
        let speed = 30; //degrees per second
        let angle_length = Math.min(J_angles_original.length, J_angles_destination.length);
        angle_length = Math.min(angle_length, 5);
        let delta = [];
        for(let i = 0; i < angle_length; i++){
            let delta_val = J_angles_destination[i] - J_angles_original[i];
            delta.push(Math.abs(delta_val));
        }
        return Vector$1.max(delta)/speed
    }

    static predict_move_dur(J_angles_original, J_angles_destination, robot){
        //let speed = robot.prop("MAX_SPEED")
        //let speed = 30 //degrees per second
        let angle_length = Math.min(J_angles_original.length, J_angles_destination.length);
        //angle_length = Math.min(angle_length, 5)
        let result_dur_in_seconds = 0;
        for(let i = 0; i < angle_length; i++){
            let delta_val = J_angles_destination[i] - J_angles_original[i];
            delta_val = Math.abs(delta_val);
            let speed = ((i <= 4) ? Kin$1.j1_thru_j5_motor_degrees_per_second  :
                                    Kin$1.dynamixel_320_degrees_per_second);
            let dur = delta_val / speed;
            result_dur_in_seconds = Math.max(result_dur_in_seconds, dur);
        }
        return result_dur_in_seconds
    }

    static tip_speed_to_angle_speed(J_angles_original, J_angles_destination, tip_speed, dexter_inst_or_workspace_pose){
        let EE_point_1 = Kin$1.J_angles_to_xyz(J_angles_destination, dexter_inst_or_workspace_pose)[0];
        let EE_point_2 = Kin$1.J_angles_to_xyz(J_angles_original, dexter_inst_or_workspace_pose)[0];
        let delta = Vector$1.subtract(J_angles_destination, J_angles_original);
        let dist = Vector$1.distance(EE_point_2, EE_point_1);
        if(dist == 0){return 30}
        let time = dist/tip_speed;
        for(let i = 0; i < delta.length; i++){
        	delta[i] = Math.abs(delta[i]);
        }
        let max_theta = Vector$1.max(delta);
        return max_theta/time
    }
    
    static delta_time_to_angle_speed(J_angles_original, J_angles_destination, delta_time){
		let delta = Vector$1.subtract(J_angles_destination, J_angles_original);
    	for(let i = 0; i < delta.length; i++){
    		delta[i] = Math.abs(delta[i]);
    	}
    	let max_theta = Vector$1.max(delta);
    	return max_theta/delta_time
	}
    
    /*
    Kin.tip_speed_to_angle_speed([0, 90, 0, 0, 0], [1, 90, 0, 0, 0], 5*_mm/_s)
    */
    
    static angles_to_dir_xyz (x_angle = 0, y_angle = 0){
        if(x_angle.length == 2){
        	y_angle = x_angle[1];
            x_angle = x_angle[0];
        }
        let ZX_plane = [0, cosd(y_angle), sind(y_angle)];
        let ZY_plane = [cosd(x_angle), 0, sind(x_angle)];
        if(Vector$1.is_equal(ZX_plane, ZY_plane) || Vector$1.is_equal(Vector$1.multiply(-1, ZX_plane), ZY_plane)){
        	dde_error("Direction (" + x_angle +", " + y_angle + ") causes a singularity");
        }
		return Vector$1.round(Vector$1.normalize(Vector$1.cross(ZX_plane, ZY_plane)), 15)
    }
    
    static dir_xyz_to_angles(dir_xyz = [0, 0, -1]){
    	let x_angle, y_angle;
        if(dir_xyz[2] == 0){
        	dde_error("The direction " + dir_xyz + " cannot be converted to angles");
        }
        if(dir_xyz[2] < 0){
        	x_angle = atan2d(dir_xyz[0], -dir_xyz[2]);
        	y_angle = atan2d(dir_xyz[1], -dir_xyz[2]);
        }else {
        	if(Math.abs(dir_xyz[0]) > Math.abs(dir_xyz[1])){
        		x_angle = atan2d(dir_xyz[0], -dir_xyz[2]);
        		y_angle = -atan2d(dir_xyz[1], dir_xyz[2]);
            }else {
            	x_angle = -atan2d(dir_xyz[0], dir_xyz[2]);
        		y_angle = atan2d(dir_xyz[1], -dir_xyz[2]);
            }
        }
		return [x_angle, y_angle]
    }
    
    /*
    
    Kin.angles_to_dir_xyz(90, 0)
    
    Kin.angles_to_dir_xyz(91, 45) //[0.999695459881888, -0.017449749160683, 0.017449749160683]
    Kin.angles_to_dir_xyz(91, -45) //[0.999695459881888, 0.017449749160683, 0.017449749160683]
    Kin.angles_to_dir_xyz(-91, 45) //[-0.999695459881888, -0.017449749160683, 0.017449749160683]
    Kin.angles_to_dir_xyz(-91, -45) //[-0.999695459881888, 0.017449749160683, 0.017449749160683]
    
    
    Kin.angles_to_dir_xyz(45, 91) //[-0.017449749160683, 0.999695459881888, 0.017449749160683]
    Kin.angles_to_dir_xyz(-45, 91) //[0.017449749160683, 0.999695459881888, 0.017449749160683]
    
    Kin.angles_to_dir_xyz(91, 91) //[-0.707052927141246, -0.707052927141246, -0.012341654750937]
    Kin.angles_to_dir_xyz(-91, 91) //[0.707052927141246, -0.707052927141246, -0.012341654750937]
    Kin.angles_to_dir_xyz(91, -91) //[-0.707052927141246, 0.707052927141246, -0.012341654750937]
    Kin.angles_to_dir_xyz(-95, -95) //[0.707052927141246, 0.707052927141246, -0.012341654750937]
    
    [0.705757556807952, 0.705757556807952, -0.061745785418449]
    [0.705757556807952, 0.705757556807952, -0.061745785418449] 
    
    Kin.angles_to_dir_xyz(85, 85) //[0.707052927141246, 0.707052927141246, -0.012341654750937]
    
    */
    
    static dir_xyz_to_percent(dir_xyz = [0, 0, -1]){
    	let total = Vector$1.sum(Vector$1.abs(dir_xyz));
		return Vector$1.multiply(100, Vector$1.divide(dir_xyz, total))
    }
    
	/*
    debugger
    Kin.interp_movement([0, 0, 0, 0, 0], [44, 45, 0, 0, 0], 30)
    */
    static interp_movement(J_angles_original, J_angles_destination, resolution = 5*_deg){
    	let delta = Vector$1.subtract(J_angles_destination, J_angles_original);
        let abs_delta = [0, 0, 0, 0, 0];
        for(let i = 0; i < delta.length; i++){
        	abs_delta[i] = Math.abs(delta[i]);
        }
        let max_delta = Vector$1.max(abs_delta);
        let div = 1;
    	let step = Infinity;
    	while(resolution < step){
    		div++;
        	step = max_delta / div;
    	}
        let J_angles_array = [];
        let delta_steps = Vector$1.divide(delta, div);
        for(let i = 1; i < div+1; i++){
    		J_angles_array.push(Vector$1.add(Vector$1.multiply(i, delta_steps), J_angles_original));
    	}
        return J_angles_array
    }
    /*
    out(Kin.angles_to_direction(0, 45))
    */
    
    static move_to_straight(xyz_1, xyz_2, J5_direction, config, tool_speed = 5*_mm / _s, resolution = .5*_mm, dexter_inst_or_workspace_pose, no_error = false){
    	let U1 = xyz_1;
    	let U2 = xyz_2;
    	let U21 = Vector$1.subtract(U2, U1);
    	let v21 = Vector$1.normalize(U21);
    	let mag = Vector$1.magnitude(U21);
    	let div = 1;
    	let step = Infinity;
    	while(resolution < step){
    		div++;
        	step = mag / div;
    	}
    	let angular_velocity;
    	let Ui, new_J_angles;
    	let old_J_angles = Kin$1.xyz_to_J_angles(U1, J5_direction, config, dexter_inst_or_workspace_pose);
        let xyzs = [];
        let speeds = [];
    	for(let i = 0; i < div+1; i++){
    		Ui = Vector$1.add(U1, Vector$1.multiply(i*step, v21));
            if(!Kin$1.is_in_reach(Ui, J5_direction, config, dexter_inst_or_workspace_pose) && no_error){
        		return xyzs
            }
            new_J_angles = Kin$1.xyz_to_J_angles(Ui, J5_direction, config, dexter_inst_or_workspace_pose);
        	angular_velocity = Kin$1.tip_speed_to_angle_speed(old_J_angles, new_J_angles, tool_speed, dexter_inst_or_workspace_pose);
        	old_J_angles = new_J_angles;
            
            xyzs.push(Ui);
            speeds.push(angular_velocity);
            /*
        	movCMD.push(make_ins("S", "MaxSpeed", angular_velocity))
    		movCMD.push(make_ins("S", "StartSpeed", angular_velocity))
        	movCMD.push(Dexter.move_to(Ui, J5_direction, config, workspace_pose))
            */
    	}
		return [xyzs, speeds]
	}

    //this will probably be put into Kin at some point
    //will only work with configs of [1, 1, 1] or [1, 0, 1]
    /*static point_down(J_angles){
        //let J = JSON.parse(JSON.stringify(J_angles)) //the new copy function we wrote doesn't exist in LTS
        //J[3] = 90 - J[2] - J[1]
        //J[4] = 0
        //return J
        return [J_angles[0],
                J_angles[1],
                J_angles[2],
                90 - J_angles[2] - J_angles[1],
                0 ]
    }*/

    static point_down(J_angles){
        let result = [];
        for(let i = 0; i < J_angles.length; i++){
            if(i === 3) { result.push(90 - J_angles[2] - J_angles[1]); }
            else if(i === 4) { result.push(0); }
            else { result.push(J_angles[i]); }
        }
        return result
    }

    //if angles(the joint angles of a dexter) are
    //pointing in the direction of "direction" within a
    //tolerance of tolerance_in_deg, then return true.
    static is_direction(angles,
                        direction=[0, 0, -1], //down
                        tolerance_in_deg=0.01){ //always non-negative
        let cur_dir = Kin$1.J_angles_to_xyz(angles)[1];
        let deg = Math.abs(Vector$1.angle(direction, cur_dir)); //angle between the cur dir and the arg direction
        return deg <= tolerance_in_deg
    }

    //Returns an array of an inner radius, an outer radius, and the center point
    //of the outer circle. All xyz locations between the two radii are valid "in-range"
    //locations including locations ON the returned inner and outer radii.
    static xy_donut_slice_approx(Z, dir){
        let inner_r, outer_r;
        let feet_r = 210 * _mm;
        let non_zero_r = 2 * _cm; //5 * _mm
        if(Z < Dexter$1.LINK1){
            inner_r = feet_r;
        }else if(Z < Dexter$1.LINK1 + feet_r){
            inner_r = Math.sqrt(Math.pow(feet_r, 2) - Math.pow(Z - Dexter$1.LINK1, 2));
            if(inner_r < non_zero_r){
                inner_r = non_zero_r;
            }
        }else {
            inner_r = non_zero_r;
        }

        let v54 = Vector$1.multiply(-Dexter$1.LINK5, dir);
        let v54_proj = [v54[0], 0, v54[2]];
        let v43 = Vector$1.multiply(Dexter$1.LINK4, Vector$1.normalize(Vector$1.rotate(v54_proj, [0, 1, 0], 90)));
        let v35 = Vector$1.add(v54, v43);

        outer_r = v35[0] + Math.sqrt(Math.pow(Dexter$1.LINK2 + Dexter$1.LINK3, 2) - Math.pow((Z + v35[2] - Dexter$1.LINK1), 2));

        let outer_xy = [0, 0];
        if(Number.isNaN(outer_r)) {
            inner_r = 0;
            outer_r = 0;
        }
        return [inner_r, outer_r, outer_xy]
    }

    //example of use:
    //var my_angles = Kin.xyz_to_J_angles([0, 0.3, 0.3], [1, 1, -1])
    //out(Kin.J_angles_to_dir(my_angles))
    static J_angles_to_dir(J_angles){
        let U = Kin$1.forward_kinematics(J_angles.slice(0, 5));
        return Vector$1.normalize(Vector$1.subtract(U[0][5], U[0][4]))
    }

    //Returns one positive float in meters of how far Dexter can go from its origin, the table,
    //to straight up. ie is maximun height.
    //When the Kin fns are changed to using the actual link lengths from
    //a particular Dexter, this fn will get passed a dexter instance
    //and get its link lengths from that.
    //ultimately needs to get the link lengths from the dexter instance,
    //bot for now, all kin fns work off just the Dexter.LINK1 to 5 constants
    //return Dexter.LINK1 + Dexter.LINK2 + Dexter.LINK3 - Dexter.LINK5
    //returns the highest z value you can move Dexter to for a given xy position and direction
    //returns NaN if xy is out of range or in singularity
    static max_z( x, y, dir = [0, 0, -1],) {
            let L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5];
            if(x == 0 && y == 0){
                return NaN
            }

            let u54 = Vector$1.multiply(-L[4], dir);
            let u54_xy_proj = [u54[0], u54[1], 0];
            let u4 = Vector$1.add([x, y, 0], u54_xy_proj);

            let u0 = [0, 0, 0];
            let u1 = [0, 0, L[0]];

            let p1 = Vector$1.points_to_plane(u1, u0, u4);

            let v54_p1_proj = Vector$1.project_vector_onto_plane(u54, p1);
            let u43_a = Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(v54_p1_proj), p1, 90));
            let u43_b = Vector$1.multiply(L[3], Vector$1.rotate(Vector$1.normalize(v54_p1_proj), p1, -90));

            let u3_a = [u43_a[0], u43_a[1], 0];
            let u3_b = [u43_b[0], u43_b[1], 0];
            u3_a = Vector$1.add(u3_a, u4);
            u3_b = Vector$1.add(u3_b, u4);

            let dist_a = Vector$1.distance(u3_a, [0, 0, 0]);
            let dist_b = Vector$1.distance(u3_b, [0, 0, 0]);

            let u3, u34;
            if(dist_a < dist_b){
                u3 = u3_a;
                u34 = Vector$1.multiply(-1, u43_a);
            }else {
                u3 = u3_b;
                u34 = Vector$1.multiply(-1, u43_b);
            }
            let xy_mag = Vector$1.magnitude(u3);
            let R = L[1] + L[2];
            u3[2] = Math.sqrt(Math.pow(R, 2) - Math.pow(xy_mag, 2));

            let u45 = Vector$1.multiply(-1, u54);
            let u5 = Vector$1.add(u3, u34, u45, u1);

            return u5[2]
        }
//Examples:
        /*
        reach_extents()
        */

        /*
        var my_x = 0
        var my_y = 0.4
        var my_dir = [0, 0, -1]

        max_z(my_x, my_y, my_dir)
        */

        /*
        //Brute force method of finding max z:
        for(let z = 0; z < 1; z+=1*_mm){
            Kin.xyz_to_J_angles([my_x, my_y, z], my_dir)
            out(z)
        }
        */


    //returns furthest possible reach in each axis
    //format: [[x_min, x_max], [y_min, y_max], [z_min, z_max]]
    //assumes obscure but maximized direction vector
    static reach_extents(){
        let L = [Dexter$1.LINK1, Dexter$1.LINK2, Dexter$1.LINK3, Dexter$1.LINK4, Dexter$1.LINK5];
        let R = L[1] + L[2] + Math.hypot(L[3], L[4]);
        return [[-R, R], [-R, R], [L[0] - R, L[0] + R]]
    }

    static roll_to_J6(xyz, roll = 0){
        return atan2d(xyz[1], xyz[0]) - 90 - roll
    }

    static J6_to_roll(xyz, J6 = 0){
        return atan2d(xyz[1], xyz[0]) - 90 - J6
    }
    
    /*
	Kin.inverse_kinematics([0, Dexter.LINK5, Dexter.LINK1+Dexter.LINK2+Dexter.LINK3+Dexter.LINK4], [0, 1, 0])
	debugger
    Kin.context_inverse_kinematics(
    	[0, Dexter.LINK5, Dexter.LINK1+Dexter.LINK2+Dexter.LINK3+Dexter.LINK4],
        [0, 1, 0],
        [1, 1, 1],
        {similar_J_angles: [30, 1e-10, 0, -1e-10, 0]}
    )
    var my_context = {similar_J_angles: [30, 1e-10, 0, -1e-10, 0]}
    Kin.context_inverse_kinematics(
    	[0, Dexter.LINK5, Dexter.LINK1+Dexter.LINK2+Dexter.LINK3+Dexter.LINK4],
        [0, 1, 0],
        [1, 1, 1],
        my_context
    )
	
    */
    
    /*
    this.context_inverse_kinematics = function (xyz, direction = [0, 0, -1], config = [1, 1, 1], 
    	context = {
        	workspace_pose: Vector.make_pose(),
            similar_J_angles: [30, 0, 0, 0, 0],
            link_lengths: [Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5]
        }
        
     this.context_inverse_kinematics = function (xyz, direction = [0, 0, -1], config = [1, 1, 1], 
    	context = {
        	workspace_pose: Vector.make_pose(),
            similar_J_angles: [30, 0, 0, 0, 0],
            link_lengths: [Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5]
        }
        
		
        //Singularity at home position
		var jangles = Kin.context_inverse_kinematics({
     		xyz: [0, Dexter.LINK5, Dexter.LINK1+Dexter.LINK2+Dexter.LINK3+Dexter.LINK4],
            dir: [0, 1, 0],
     		similar_J_angles: [-30, 0, 0, 0, 0],
     	})[0]
        out(jangles, 3)
        
        
        
        
        
        //Singularity when J5 is +/- 90
		var jangles = Kin.context_inverse_kinematics({
     		xyz: [Dexter.LINK5, 0.5, 0.3],
            dir: [1, 0, 0],
     		similar_J_angles: [0, 0, 0, 0, 0],
     	})[0]
        out(jangles, 3)
        
        
        new Job({name: "my_job",
         do_list: [
         	Dexter.set_parameter("MaxSpeed", 20),
         	Dexter.move_all_joints(jangles),
            //Dexter.move_to([0, 0.0001, 0.45])
         ]}).start()
		
        
        function main(){
        	CMD = []
            let jangles
            let start_theta = -90
            let end_theta = 90
            let theta_step = 1
            
            CMD.push(Dexter.set_parameter("MaxSpeed", 3))
            CMD.push(Dexter.set_parameter("StartSpeed", 3))
            
            for(let theta = start_theta; theta < end_theta; theta += theta_step){
            	jangles = Kin.context_inverse_kinematics({
     				xyz: [Dexter.LINK5, 0.5, 0.3],
            		dir: [1, 0, 0],
     				similar_J_angles: [0, 0, 0, theta, 0],
     			})[0]
            	CMD.push(Dexter.move_all_joints(jangles))
            }
            for(let theta = end_theta; theta > start_theta; theta -= theta_step){
            	jangles = Kin.context_inverse_kinematics({
     				xyz: [Dexter.LINK5, 0.5, 0.3],
            		dir: [1, 0, 0],
     				similar_J_angles: [0, 0, 0, theta, 0],
     			})[0]
            	CMD.push(Dexter.move_all_joints(jangles))
            }
            
            return CMD
        }
        
        new Job({name: "J4_90_Singularity",
         do_list: [
         	Dexter.set_parameter("MaxSpeed", 20),
            Dexter.set_parameter("StartSpeed", 0.1),
         	main
         ]}).start()
         
        
        
        Kin.inverse_kinematics([0, 0.0001, 0.45])[0]
        
        //Singularity at [0, 0, z]
		var jangles = Kin.context_inverse_kinematics({
     		xyz: [0, 0, 0.45],
            dir: [0, 0, -1],
            config: [1, 1, 1],
     		similar_J_angles: [0, 0, 0, 0, 0],
     	})[0]
        out(jangles, 3)
        
        
        
        
        
        Kin.context_inverse_kinematics({
     		xyz: [0, 0.5, 0.1],
            dir: [0, 1, 0],
     		similar_J_angles: [0, 0, 0, 0, 0],
     	})
        
      	Kin.context_inverse_kinematics()
     */

     /*not called may 30, 2019 and James W said ok to comment out. --fry
     static signed_angle_test(vector_A, vector_B, plane){
    	let epsilon = 1e-14
    	//checks if vectors lie in plane
        let cross_product = Vector.normalize(Vector.cross(Vector.shorten(vector_A), Vector.shorten(vector_B)))
        let short_plane = Vector.shorten(plane)
        
        let guess_angle = Vector.angle(vector_A, vector_B)
        if(Vector.is_equal(cross_product, short_plane)){
        	return guess_angle
        }else if(Vector.is_equal(Vector.multiply(-1, cross_product), short_plane)){
        	return -guess_angle
        }else{
        	dde_error("Error: input vectors do not lie in plane")
        }
    }*/
    
     
     /* not called. May be used some day. Has the pre-may 2019 use of global vars for Dexter.LINK1 nd firends.
     this.context_inverse_kinematics = function(args){
	
		//Input arg management:
        
        if(args.xyz_dir_config && (args.xyz || args.dir || args.config)){
        	let error_string
            if(args.config){error_string = "config"}
            if(args.dir){error_string = "dir"}
            if(args.xyz){error_string = "xyz"}
            
            dde_error("Both " + error_string + " and xyz_dir_config cannot be passed into Kin.context_inverse_kinematics")
        }
        
        //Defaults:
        if(args.xyz === undefined){				args.xyz = [0, 0.5, 0.1]}
        if(args.dir === undefined){				args.dir = [0, 0, -1]}
        if(args.config === undefined){			args.config = [1, 1, 1]}
        if(args.workspace_pose === undefined){	args.workspace_pose = Vector.make_pose()}
        if(args.similar_J_angles === undefined){args.similar_J_angles = [0, 0, 0, 0, 0]}
        if(args.link_lengths === undefined){	args.link_lengths = [Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5]}

		let xyz, direction, config
		if(args.xyz_dir_config){
			xyz = args.xyz_dir_config[0]
            direction = args.xyz_dir_config[1]
            config = args.xyz_dir_config[2]
        }else{
        	xyz = args.xyz
            direction = args.dir
            config = args.config
        }


		//Kinematics Start
        let J = Vector.make_matrix(1, 5)[0] // Joint Angles
        let U = Vector.make_matrix(5, 3)
        let P = [0, 0, 0, 0]
        let L = args.link_lengths 
		let normal = direction
    	let right_arm = config[0]
    	let elbow_up = config[1]
    	let wrist_out = config[2]
        
        if(direction.length == 2){
        	normal = Kin.angles_to_dir_xyz(direction[0], direction[1])
        }else if(direction.length == 3){
        	if(Vector.magnitude(direction) == 0){
            	dde_error("Direction must have a magnitude. Try [0, 0, -1] or [0, 0] for the [x_angle, y_angle] form")
            }
        }else{
        	dde_error("Direction must be in the form [x, y, z] or [x_angle, y_angle]")
        }
        
  		let xyz_trans = Vector.transpose(Vector.matrix_multiply(args.workspace_pose, Vector.properly_define_point(xyz))).slice(0,3)
		let normal_trans = Vector.transpose(Vector.matrix_multiply(args.workspace_pose, Vector.properly_define_vector(normal))).slice(0,3)

        
        
    	//Knowns:
        P[0] = [1, 0, 0, 0]
    	let V54 = Vector.multiply(-1, Vector.normalize(normal_trans)) //Direction of EE
        U[0] = [0, 0, 0]
        let V10 = [0, 0, 1]
    	U[1] = Vector.multiply(L[0], V10)
        U[4] = Vector.add(xyz_trans, Vector.multiply(Dexter.LINK5, V54))
        U[5] = xyz_trans
        
    	
    	//Solving for P1
    	P[1] = Vector.points_to_plane(U[1], U[0], U[4])
        if(Vector.is_NaN(P[1])){
        	P[1] = Vector.points_to_plane(U[1], U[0], U[3])
            if(Vector.is_NaN(P[1])){

        		//dde_error(`Singularity: Toolpoint xyz is on Base axis. [0, 0, z] divides by 0.
            	//Try [0, 1e-10, z] if it works use the ouputted joint angles for a move_all_joints() instead.
            	//The first joint angle can be changed to any value without affecting the tool point`)

                
                P[1] = Vector.rotate([1, 0, 0], [0, 0, -1], args.similar_J_angles[0])
                
            }
        }
		
    
		//Solving for U3
    	let U54_Proj = Vector.project_vector_onto_plane(V54, P[1])
        
        let U3_a, U3_b, dist_a, dist_b
        if(Vector.magnitude(U54_Proj) > 1e-10){
        
    		U3_a = Vector.add(U[4], Vector.multiply(L[3], Vector.rotate(Vector.normalize(U54_Proj), P[1], 90)))
        	U3_b = Vector.add(U[4], Vector.multiply(L[3], Vector.rotate(Vector.normalize(U54_Proj), P[1], -90)))
        	
        
        	//This is proven to work for directions of approx. [0, 1, 0] but has potentially not been tested enough
        	dist_a = Vector.distance(U3_a, [0, 0, 0])
    		dist_b = Vector.distance(U3_b, [0, 0, 0])

        	//if (wrist_out){
    		//	if (dist_a < dist_b){
        	//		U[3] = U3_a
        	//	}else{
        	//		U[3] = U3_b
        	//	}
    		//}else{
    		//	if (dist_a > dist_b){
        	//		U[3] = U3_a
        	//	}else{
        	//		U[3] = U3_b
        	//	}
    		//}

            
            //Solving for P2
    		//P[2] = Vector.points_to_plane(U[5], U[4], U[3])
        	let P2_a = Vector.points_to_plane(U[5], U[4], U3_a)
            if(Vector.is_NaN(P2_a)){
        		dde_error("Unknown plane_a singularity at: " + xyz + ", " + direction + ", " + config + ". Please copy this message and report it as a bug.")
        	}
            let P2_b = Vector.points_to_plane(U[5], U[4], U3_b)
            if(Vector.is_NaN(P2_b)){
        		dde_error("Unknown plane_b singularity at: " + xyz + ", " + direction + ", " + config + ". Please copy this message and report it as a bug.")
        	}
		
    		//Solving for U2
    		let D3_a = Vector.distance(U3_a, U[1])
        	if(Vector.is_equal(D3_a, Dexter.LINK2 + Dexter.LINK3, 9)){
        		D3_a = Dexter.LINK2 + Dexter.LINK3
        	}
            let D3_b = Vector.distance(U3_b, U[1])
        	if(Vector.is_equal(D3_b, Dexter.LINK2 + Dexter.LINK3, 9)){
        		D3_b = Dexter.LINK2 + Dexter.LINK3
        	}
        	
        	let wrist_a_in_reach = true
            let wrist_b_in_reach = true
        	
        	//Checking if in reach
        	if (D3_a > Dexter.LINK2 + Dexter.LINK3){
        		let out_of_reach_dist_a = Vector.round(D3_a - (Dexter.LINK2 + Dexter.LINK3), 4)
        		wrist_a_in_reach = false
                //dde_error("Point [" + Vector.round(xyz, 3)+"], [" + Vector.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach')
        	}
            if (D3_b > Dexter.LINK2 + Dexter.LINK3){
        		let out_of_reach_dist_b = Vector.round(D3_b - (Dexter.LINK2 + Dexter.LINK3), 4)
        		//dde_error("Point [" + Vector.round(xyz, 3)+"], [" + Vector.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach')
        		wrist_b_in_reach = false
            }
        
        
    		//let Beta = acosd((-Math.pow(L[2], 2) + Math.pow(L[1], 2) + Math.pow(D3, 2)) / (2 * D3 * L[1])) // Law of Cosines
        	let Beta_a = acosd((-Math.pow(L[2], 2) + Math.pow(L[1], 2) + Math.pow(D3_a, 2)) / (2 * D3_a * L[1])) // Law of Cosines
        	let V31_a = Vector.normalize(Vector.subtract(U3_a, U[1]))
            
            let Beta_b = acosd((-Math.pow(L[2], 2) + Math.pow(L[1], 2) + Math.pow(D3_b, 2)) / (2 * D3_b * L[1])) // Law of Cosines
        	let V31_b = Vector.normalize(Vector.subtract(U3_b, U[1]))
            
            
    		let V23_a, V23_b
        	//For wrist a
    		let U2_aA = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V31_a, P[1], Beta_a)))
    		let U2_aB = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V31_a, P[1], -Beta_a)))
        	let V2A1_a = Vector.subtract(U2_aA, U[1])
        	let V32A_a = Vector.subtract(U[3], U2_aA)
        	
        	let U2_a
    		if (elbow_up){
    			if(Vector.dot(Vector.cross(V2A1_a, V32A_a), P[1]) < 0){
        			U2_a = U2_aA
        		}else{
        			U2_a = U2_aB
        		}
    		}else{
      			if(Vector.dot(Vector.cross(V2A1_a, V32A_a), P[1]) > 0){
        			U2_a = U2_aA
        		}else{
        			U2_a = U2_aB
        		}
    		}
            
            
            
            //For wrist b
    		let U2_bA = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V31_b, P[1], Beta_b)))
    		let U2_bB = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V31_b, P[1], -Beta_b)))
        	let V2A1_b = Vector.subtract(U2_bA, U[1])
        	let V32A_b = Vector.subtract(U[3], U2_bA)
        
        	let U2_b
    		if (elbow_up){
    			if(Vector.dot(Vector.cross(V2A1_b, V32A_b), P[1]) < 0){
        			U2_b = U2_bA
        		}else{
        			U2_b = U2_bB
        		}
    		}else{
      			if(Vector.dot(Vector.cross(V2A1_b, V32A_b), P[1]) > 0){
        			U2_b = U2_bA
        		}else{
        			U2_b = U2_bB
        		}
    		}
            
            
            //Solving for joint angles
            
            //wrist a
    		let V21_a = Vector.normalize(Vector.subtract(U2_a, U[1]))
    		let V32_a = Vector.normalize(Vector.subtract(U3_a, U2_a))
    		let V43_a = Vector.normalize(Vector.subtract(U[4], U3_a))
            let J0_a = Vector.signed_angle(P[1], P[0], V10) 
    		let J1_a = Vector.signed_angle(V21_a, V10, P[1])
    		let J2_a = Vector.signed_angle(V32_a, V21_a, P[1])
    		let J3_a = Vector.signed_angle(V43_a, V32_a, P[1])
    		let J4_a = Vector.signed_angle(P2_a, P[1], V43_a)
            
            //wrist b
            let V21_b = Vector.normalize(Vector.subtract(U2_b, U[1]))
    		let V32_b = Vector.normalize(Vector.subtract(U3_b, U2_b))
    		let V43_b = Vector.normalize(Vector.subtract(U[4], U3_b))
            let J0_b = Vector.signed_angle(P[1], P[0], V10) 
    		let J1_b = Vector.signed_angle(V21_b, V10, P[1])
    		let J2_b = Vector.signed_angle(V32_b, V21_b, P[1])
    		let J3_b = Vector.signed_angle(V43_b, V32_b, P[1])
    		let J4_b = Vector.signed_angle(P2_b, P[1], V43_b)
            
            let J0, J1, J2, J3, J4
            let wrist_score_a = Math.abs(J3_a) + Math.abs(J4_a)
            let wrist_score_b = Math.abs(J3_b) + Math.abs(J4_b)
            if(!wrist_a_in_reach){
            	wrist_score_a = Infinity 
            }
            if(!wrist_b_in_reach){
            	wrist_score_b = Infinity 
            }
            
            if(wrist_score_a < wrist_score_b){
            	if(!wrist_a_in_reach){
            		dde_error("Point [" + Vector.round(xyz, 3)+"], [" + Vector.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach')
            	}
            	J0 = J0_a
                J1 = J1_a
                J2 = J2_a
                J3 = J3_a
                J4 = J4_a
            }else{
            	if(!wrist_b_in_reach){
            		dde_error("Point [" + Vector.round(xyz, 3)+"], [" + Vector.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach')
            	}
            	J0 = J0_b
                J1 = J1_b
                J2 = J2_b
                J3 = J3_b
                J4 = J4_b
            }
            
			if(right_arm == 1){
    			J[0] = J0
    			J[1] = J1
    			J[2] = J2
    			J[3] = J3
    			J[4] = J4
    		}else{
    			J[0] = J0
    			J[1] = -J1
    			J[2] = -J2
    			J[3] = -J3
    			J[4] = -J4
    		}
            
            
    	}else{
        	let a = L[3]
            let b = L[2]
            let c = Math.sqrt(Math.pow(a, 2) + Math.pow(b, 2) -2*a*b*cosd(180-args.similar_J_angles[3])) //Law of Cosines
            
            let Gamma = acosd((-Math.pow(a, 2) + Math.pow(c, 2) + Math.pow(b, 2)) / (2 * c * b)) // Law of Cosines
            
            
            a = L[1]
            b = Vector.distance(U[4], U[1])
            
            let L41_max = L[1] + L[2] + L[3]
        	if(Vector.is_equal(b, L41_max, 9)){
        		b = L41_max
        	}
        
        	//Checking if in reach
        	if (b > L41_max){
        		let out_of_reach_dist = Vector.round(b - (L41_max), 4)
        		dde_error("Point [" + Vector.round(xyz, 3)+"], [" + Vector.round(V54,3) + '] is ' + out_of_reach_dist + 'm out of reach')
        	}
            
        	let Beta = acosd((-Math.pow(c, 2) + Math.pow(a, 2) + Math.pow(b, 2)) / (2 * a * b)) // Law of Cosines
        	let V41 = Vector.normalize(Vector.subtract(U[4], U[1]))
    		let V23
            
            let U2_a = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V41, P[1], Beta)))
    		let U2_b = Vector.add(U[1], Vector.multiply(L[1], Vector.rotate(V41, P[1], -Beta)))
        	
            let V2a1 = Vector.subtract(U2_a, U[1])
            let V2b1 = Vector.subtract(U2_b, U[1])
        	//let V32a = Vector.subtract(U[3], U2_a)
            
            let V42a = Vector.subtract(U[4], U2_a)
            let V42b = Vector.subtract(U[4], U2_b)
            
			
            
            let rot_sign = -1
            
            let theta_a = signed_angle_test(V2a1, V41, P[1])
            let theta_b = signed_angle_test(V2b1, V41, P[1])
            
            if (elbow_up){
    			if(theta_a < theta_b){
        			U[2] = U2_a
                    
        		}else{
        			U[2] = U2_b
                    rot_sign = 1
        		}
    		}else{
      			if(theta_a < theta_b){
        			U[2] = U2_a
                    rot_sign = 1
        		}else{
        			U[2] = U2_b
        		}
    		}
            

    		//if (elbow_up){
    		//	if(Vector.dot(Vector.cross(V2a1, V32a), P[1]) < 0){
        	//		U[2] = U2_a
            //        rot_sign = 1
        	//	}else{
        	//		U[2] = U2_b
        	//	}
    		//}else{
      		//	if(Vector.dot(Vector.cross(V2a1, V32a), P[1]) > 0){
        	//		U[2] = U2_a
        	//	}else{
        	//		U[2] = U2_b
            //        rot_sign = 1
        	//	}
    		//}

            

           // V21 = Vector.normalize(Vector.subtract(U[2], U[1]))
           // V31 = Vector.rotate(V21, P[1], rot_sign*Gamma)
           // U[3] = Vector.add(U[2], Vector.multiply(L[2], V31))

            
            let V42 = Vector.normalize(Vector.subtract(U[4], U[2]))
            let V32 = Vector.rotate(V42, P[1], Math.sign(args.similar_J_angles[3])*Gamma)
            U[3] = Vector.add(U[2], Vector.multiply(L[2], V32))
            
            //Solving for P2
    		P[2] = Vector.points_to_plane(U[5], U[4], U[3])
        	if(Vector.is_NaN(P[2])){
        		dde_error("Unknown plane singularity at: " + xyz + ", " + direction + ", " + config + ". Please copy this message and report it as a bug.")
        	}
            
            
            //Solving for joint angles
    		let V21 = Vector.normalize(Vector.subtract(U[2], U[1]))
    		V32 = Vector.normalize(Vector.subtract(U[3], U[2]))
    		let V43 = Vector.normalize(Vector.subtract(U[4], U[3]))
			if(right_arm == 1){
    			J[0] = Vector.signed_angle(P[1], P[0], V10) 
    			J[1] = Vector.signed_angle(V21, V10, P[1])
    			J[2] = Vector.signed_angle(V32, V21, P[1])
    			J[3] = Vector.signed_angle(V43, V32, P[1])
    			J[4] = Vector.signed_angle(P[2], P[1], V43)
    		}else{
    			J[0] = Vector.signed_angle(P[1], P[0], V10) + 180
    			J[1] = -Vector.signed_angle(V21, V10, P[1])
    			J[2] = -Vector.signed_angle(V32, V21, P[1])
    			J[3] = -Vector.signed_angle(V43, V32, P[1])
    			J[4] = -Vector.signed_angle(P[2], P[1], V43)
    		}
            
            
        }
        
        
       
    	


    	
    	
    	if(Vector.is_NaN(J[2])){
        	let thres = 100
        	if(Dexter.LINK1 > thres || Dexter.LINK2 > thres || Dexter.LINK3 > thres || Dexter.LINK4 > thres || Dexter.LINK5 > thres){
            	dde_error("Link lengths are non properly defined: "  
                + "</br>Dexter.LINK1: " + Dexter.LINK1 + " (meters)"
                + "</br>Dexter.LINK2: " + Dexter.LINK2 + " (meters)"
                + "</br>Dexter.LINK3: " + Dexter.LINK3 + " (meters)"
                + "</br>Dexter.LINK4: " + Dexter.LINK4 + " (meters)"
                + "</br>Dexter.LINK5: " + Dexter.LINK5 + " (meters)")
            }
        	dde_error("Singularity at: " + xyz + ", " + direction + ", " + config + ".</br>Please copy this message and report it as a bug.")
    	}
    
    	return [J, U, P]
    } end of context_inverse_kinematics */
}

module.exports = Kin$1;


//Used in predict_move_dur
//Computation based on James N reading of Dynamixel XL 320, 114RPM at 7.4 volts.
//but we're running it at 5 volts so down to 77RPM, which is 1.28rps
//which is 461 deg per sec.
//the dynamixel 430 has a slower RPM, but the 320 is our default.
//used in
Kin$1.dynamixel_320_degrees_per_second = 461;
Kin$1.j1_thru_j5_motor_degrees_per_second = 30;
    /*
    
    Kin.move_to_straight([0, .5, .075], [0, .6, .075])
    */
    /*
    this.make_ins_move_straight(xyz_1, xyz_2, J5_direction, config, tool_speed = 5*_mm / _s, resolution = .5*_mm, robot_pose){
    	let CMD = []
        
        
        for(let i = 0; i < .length; i++){
    		CMD.push(make_ins("S", "MaxSpeed", angular_velocity))
    		CMD.push(make_ins("S", "StartSpeed", angular_velocity))
        	CMD.push(Dexter.move_to(Ui, J5_direction, config, robot_pose))
        }
        return CMD
    }*/

/*
var point_1 = [0, .3, .4]
//debugger
//var myJangles = Kin.xyz_to_J_angles([-0.4961591506890708, 0.4961591506890706, 0.08255000000000005], [0, 0, -1], Dexter.RIGHT_UP_OUT)
myJangles = [0,-45, -45, 0, 0]
var myPoints = Kin.forward_kinematics(myJangles)[0]
var myPosition = Kin.J_angles_to_xyz(myJangles)
debugger
Kin.xyz_to_J_angles(myPosition[0], myPosition[1], myPosition[2])


var point_1 = [.1, .2, .3]
//debugger
var myJangles = Kin.xyz_to_J_angles(point_1, [0, 1, -1], Dexter.RIGHT_DOWN_OUT)
var new_point = Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3], [0, 1, -1], Dexter.RIGHT_DOWN_OUT))
*/

/*
new TestSuite("Inverse to Forward Kinematics and Back",
	["Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3]))", "[[0.09999999999999996, 0.20000000000000004, 0.30000000000000004],[0, 0, -1],[1, 1, 1]]"],
	["Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3], [0, .1, -1]))", "[ [0.10000000000000012, 0.19999999999999998, 0.30000000000000004], [3.362274453740632e-16, 0.09950371902099878, -0.995037190209989], [1, 1, 1]]"],
	["Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3], [0, 0, -1], [1, 0, 1]))", "[ [0.09999999999999994, 0.20000000000000004, 0.3], [-3.362274453740631e-16, -6.724548907481262e-16, -1], [1, 0, 1]]", "known, wrist_out vs wrist_in issue"],
    ["Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3], [0, 0, -1], [1, 0, 0]))", "[[0.1, 0.20000000000000012, 0.29999999999999993], [0, 0, -1], [1, 0, 0]]"],
    ["Kin.xyz_to_J_angles(Kin.J_angles_to_xyz([0, 45, 45, 30, 0]))", "[0, 45, 44.999999999999986, 30.000000000000014, 0]"]
)

debugger
Kin.xyz_to_J_angles([.1, .2, .3])
Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([.1, .2, .3]))

Kin.J_angles_to_xyz(Kin.xyz_to_J_angles([0.1, .5, .3]))



*/

/**
 * Created by Fry on 4/30/16.
 */

function ob_sys_is_class(obj){
    return ((typeof(obj) == "function") && obj.toString().startsWith("class "))
}

var Root$1 = {name: "Root"}; //"root" is an old node,js global that's been depricated but still defined. I decidd to steer clear of it by using capitalied Root.

//window.Root = Root //if I don't to this, value_of_path fails since window["rootObjject"] fails
//rootObject.name = "rootObject" //errors if I do this. the error happens in Jquery on something
                               //that looks very unlrelated, in ready, when seting the operating_system variable.
                               //mysterious. try again once electron is up.
                               //BUT search below for rootObject to see the solution.

    /* User can pass as many property_objects as they like.
     None will be modified by this fn.
     Properties from all will be combined in to one object.
     If there are duplicates, the last one wins.
     You might want a different winner so you can reorder the
     property_objects, but if there is a conflict in ordering,
     you can add an extra property_object to the end to
     ensure a win for a particular property. For instance
     var myboat = {prototype:boat, color:white}
     var my_fav_colors = {prototype:color_pallette, color:blue, trim:green},
     newObject(myboat, mycolors)
     Here we want to make an instance of myboat,
     BUT we want to over-ride the default color of "white" for a myboat,
     and use my_fav_colors to get the color from.
     If we just passed those 2 classes to newObject, we would indeed get
     a color of blue, however we'd make a color_pallette, not a boat.
     To fix that, we add an extra properties object on the end
     whose job is simply to over-ride the prototype in mycolors.
     newObject(myboat, mycolors, {prototype: boat})
     If no properties object has a prototype property, we use rootObject
     as the default.
     */

function newObject(...property_objects){
    property_objects.unshift({}); //put new obj on front as assign mungs the first arg and if first arg is used elsewhere, this would be bad.
    let properties = Object.assign(...property_objects);
    let prototype;
    if (properties.hasOwnProperty("prototype")){
        prototype = properties.prototype;
        delete properties.prototype;
    }
    if (!prototype){ prototype = Root$1; }
    else if (typeof(prototype) == "string"){
        var new_prototype = value_of_path$1(prototype);
        if ((new_prototype == null) || (typeof(new_prototype) != "object")){
            throw new Error("In a call to newObject, failed to resolve: " + prototype +
                " into the prototype object.")
        }
        else {prototype = new_prototype;}
    }
    if (!prototype) { //no prototype arg passed and no prototype property in properties
        prototype = Root$1;
    }
    if (properties.hasOwnProperty("name")){
        const name_val = properties.name;
        if (name_val) {
            if (typeof(name_val) != "string") {
                dde_error("newObject called with name: " + name_val + " but that is not a string. Names must be strings.");
            }
            //else OK as is
        }
        else { //name is null or undefined so just get rid of it. IF we don't, it will cause a bad bug
            delete properties.name;
        }
    }
    var result;
    if(ob_sys_is_class(prototype)){
        return new prototype(properties) //only works when the class accepts 1 literal object in its constructor
        //if (prototype == Job) {
        //return new Job(properties) //weak as hell
        //result = Reflect.construct(prototype, properties) //errors too
        // result = new (Function.prototype.bind.call(prototype, properties)) //errors
        //}
    }
    else if (ob_sys_is_class(prototype.constructor)){ //ie prototype is a job instance
        //we are going to call effectively new Job(props)
        //so we've got to get the class of prototype in its "constructor" prop,
        //then we have to fill in the defaults of the args to that class's
        //constructor params with values from the actual prototype.
        //
        var class_param_names = function_param_names(prototype.constructor);
        properties = Object.assign({}, properties); //make a copy
        for(let pname of class_param_names){
            if (!(properties.hasOwnProperty(pname))){ //props doesn't have a necessary arg so inherit it from the prototype
                var inherited_val;
                if ((pname == "do_list") && (prototype.constructor == Job)){ //special hack for Job's do_list because
                    //a running job modifies its do_list
                    //so we want to use the orig.
                    inherited_val = prototype.orig_args.do_list;
                }
                else {inherited_val = prototype[pname]; }
                properties[pname] = inherited_val;
            }
        }
        return new prototype.constructor(properties) //only works when the class accepts 1 literal object in its constructor
    }
    else { //not related to classes at all, ie a normal dobject object.
        result = Object.assign(Object.create(prototype), properties);
        if (properties.hasOwnProperty("name")){prototype[properties.name] = result;}
        else if(prototype.name) {//we don't want to inherit so block inheritance
            result.name = undefined;
        }
        result.prototype = prototype; //commenting this out doesn't get rid of jquery bug, but it has a different one.
        result.constructor(); //note this is called even on the obj that defines it! That's true prototype
        //it is never passed args but "this" inside it is the new obj.
        return result
    }
}

Object.defineProperty(Object, 'isNewObject',{
    enumerable : false,
    value : function(obj, require_name_in_prototype = true, permit_rootObject = true){
        if(obj == Root$1) {
            if (permit_rootObject) { return true}
            else { return false }
        }
        else if ((obj == undefined) || (obj == null) || (typeof(obj) != "object")) { return false }
        else {
            let proto;
            try { proto = Object.getPrototypeOf(obj);}
            catch (err) { return false }
            if (proto){
               if (obj.hasOwnProperty("prototype") && (obj.prototype == proto)){
                   if (require_name_in_prototype){
                       if ((proto == Root$1) || proto.name) {
                            if ((obj.name == undefined) || (proto[obj.name] == obj)) { return true }
                            else { return false} //obj has a name but it isn't in the proto bound to obj
                       }
                       else { return false }
                   }
                   else { return true }
               }
               else { return false }
            }
            else { return false }
        }
    }
});

//jquery breaks if you add properties to Object prototype in the usual way. ie
// Object.prototype.subObjectsOf129 = function(){ ...}
//but http://stackoverflow.com/questions/21729895/jquery-conflict-with-native-prototype
//says the workaround for this jquery bug is to add non-enumerable props.
/* Nope, the below also screws up Jquery. Try in next version of Jquery perhaps.
Object.defineProperty(Object.prototype, 'name',{
    enumerable : false,
    configurable: true,
    writable: true,
    value: "rootObject"})
*/

Object.defineProperty(Object.prototype, 'subObjects',{
    enumerable : false,
    value : function(){
        var result = [];
        for(var sub_ob_name in this){
            if(this.hasOwnProperty(sub_ob_name)){
                var sub_ob = this[sub_ob_name];
                if(Object.isNewObject(sub_ob) && (sub_ob.name == sub_ob_name)){
                   result.push(sub_ob);
                }
            }
        }
        return result
    }
});

Object.defineProperty(Object.prototype, 'isSubObject',{
    value : function(prototype_maybe){
        let pt = (prototype_maybe ? prototype_maybe : Object.getPrototypeOf(this));
        if (pt && //if this is rootObject, pt will be null and this will fail as it should.
                this.hasOwnProperty("name") &&
                this.name &&
                pt.hasOwnProperty(this.name) &&
                (pt[this.name] == this)) { return true } //note (null && 33)evals to null, not false
        else { return false }
    },
    enumerable : false
});

Object.defineProperty(Object.prototype, 'isLeafObject',{
    value : function(){
        let sub_objs = this.subObjects();
        return sub_objs.length == 0
    }
});

Object.defineProperty(Object.prototype, 'leafObjectNamed',{
    value : function(leaf_name){
        if(this.isLeafObject()){
            if(this.name == leaf_name) { return this }
            else { return null }
        }
        else {
            for(let subobj of this.subObjects()){
                let result = subobj.leafObjectNamed(leaf_name);
                if(result) { return result }
            }
            return null
        }
    }
});


//returns true if this == ancestor. This makes sense for prototype object system.
Object.defineProperty(Object.prototype, 'isA',{
    value : function(ancestor){
        if (this == ancestor) { return true }
        else if (Object.isNewObject(ancestor)) { return ancestor.isPrototypeOf(this) }
        else { return false }
    },
    enumerable : false
});

Object.defineProperty(Object.prototype, 'siblings',{
    value : function(include_this=false){
                if(this === Root$1) {
                    if (include_this){ return [Root$1] }
                    else { return [] }
                }
                else {
                    var pt;
                    try{ pt = Object.getPrototypeOf(this);}
                    catch(e) { return [] }
                    if(pt) {
                        var result = pt.subObjects();
                        if (!include_this){
                            for(var i = result.length-1; i--;){ //traverse in reverse order is necessary!
                                if (result[i] === this) result.splice(i, 1);
                            }
                        }
                        return result
                    }
                    else { return [] }
                }
    },
    enumerable : false
});

// retruns true if all args are siblings
Object.defineProperty(Object, 'areSiblings',{
    value : function(...maybe_siblings){
        if(maybe_siblings.length < 2) { return true }
        else {
            var pt;
            try{ pt = Object.getPrototypeOf(maybe_siblings[0]);}
            catch(e) { return [] }
            if(pt) {
                for(var maybe_sib of maybe_siblings){
                    if (Object.getPrototypeOf(maybe_sib) !== pt) { return false }
                }
                return true
            }
            else { return false } //hmm, I'm being conservative here.
        }
    },
    enumerable : false
});


//climbs up the prototype chain from obj,
//returning the first obj that has prop_name, or null
Object.defineProperty(Object.prototype, 'inheritsPropertyFrom',{
    value : function(property_name){
                if(this == null) { return null }
                else if (this.hasOwnProperty(property_name)) {return this}
                else if (this === Root$1) { return null }
                else { return Object.getPrototypeOf(this).inheritsPropertyFrom(property_name) }
    },
    enumerable : false
});

/*fails because "this" needs to be the original obj, but
as we go up the stack we need to remember the previous obj
we came from which isn't 'this' after we've alread gone up one.*/
Object.defineProperty(Object.prototype, 'callPrototypeConstructor',{
    value : function(){
        let next_cons = newObect_find_next_constructor(this);
        if (next_cons) {
            //return Object.getPrototypeOf(this).constructor.apply(this)
            next_cons.apply(this);
        }
       // else {} //do nothing if there is no next_cons
    }
});

//callPrototypeConstructor is called within a constructor.
//we don't want to return THAT constuctor, but rather the
//next one up the change.
function newObect_find_next_constructor(obj, cur_constructor){
    let obj_of_cur_cons = obj.inheritsPropertyFrom("constructor");
    let next_ans_above_cur_cons = Object.getPrototypeOf(obj_of_cur_cons);
    if(next_ans_above_cur_cons) { return next_ans_above_cur_cons.constructor } //might be nothing
    else { return null }
    //if(!cur_constructor) { cur_constructor = obj.constructor }
    //let obj_cons = obj.constructor
    //if (!obj_constructor) { return null } //there is no next constructor
    //else if (obj_cons != cur_constructor) { return obj_cons }
    //else { return newObject_find_next_constructor(Object.getPrototypeOf(obj), cur_constructor) }
}

Object.defineProperty(Object.prototype, 'normal_keys',{
    enumerable : false,
    value : function(include_inherited=false,
                     include_functions=false,
                     include_subobject_names=false,
                     include_name_and_prototype=false){
        return this.normal_keys_aux(include_inherited,  //maybe should be true
                                    include_functions,
                                    include_subobject_names,
                                    include_name_and_prototype,
                                    [])
    }

});

Object.defineProperty(Object.prototype, 'normal_keys_aux',{
    enumerable : false,
    value : function(include_inherited,  //maybe should be true
                     include_functions,
                     include_subobject_names,
                     include_name_and_prototype,
                     result){
        if (this == Root$1){ return result }
        else {
            for(let key of Object.getOwnPropertyNames(this)){
                if (!result.includes(key)) {
                   let val = this[key];
                   if (((typeof(val) != "function") || include_functions) &&
                       (!val.isSubObject() || include_subobject_names) &&
                       (((key != "name") && (key != "prototype")) || include_name_and_prototype)){
                        result.push(key);
                    }
                }
            }
            if (include_inherited) {
                return Object.getPrototypeOf(this).normal_keys_aux(include_inherited,  //maybe should be true
                                            include_functions,
                                            include_subobject_names,
                                            include_name_and_prototype,
                                            result)
            }
            else { return result }
        }
    }
});


//result array has Root first
Object.defineProperty(Object.prototype, 'ancestors',{
    value : function(include_self=false){
                if(this == Root$1){
                    if(include_self) { return [this] }
                    else { return [] }
                }
                else {
                    var obj = this;
                    if (!include_self) { obj = Object.getPrototypeOf(obj); }
                    var result = obj.ancestors_of_aux([]);
                    return result
                }
    },
    enumerable : false
});

Object.defineProperty(Object.prototype, 'ancestors_of_aux',{
    value : function(result){
        if (this == null){ return result }
        else {
            result.unshift(this); //push onto front of array, order is top of ancestors first
            if (this == Root$1) { return result } //must do this becasue ancestors_of_axu not on this's prototype
            return Object.getPrototypeOf(this).ancestors_of_aux(result)
        }
    },
    enumerable : false
});

Object.defineProperty(Object, 'allCommonAncestors',{
    value : function(...objects){
        let result = [];
        for(let obj of objects){
            var ans = obj.ancestors();
            if(result.length == 0) { result = ans; }
            else {
                for(let i = 0; i < result.length; i++){
                    if(result[i] !== ans[i]) { result = result.slice(0, i);}
                }
            }
        }
        return result
    },
    enumerable : false
    });

Object.defineProperty(Object, 'lowestCommonAncestor',{
    value : function(...objects){
        let ans = Object.allCommonAncestors(...objects);
        if(ans.length == 0) { return null }
        else { return ans[ans.length - 1] }
    },
    enumerable : false
});


//returns a string of a path to "this", or null
//evaling the string should return "this" object.
Object.defineProperty(Object.prototype, 'objectPath',{
    value : function(){ return this.object_path_aux("") },
    enumerable : false
});

Object.defineProperty(Object.prototype, 'object_path_aux',{
    value : function(result){
        if (this == null) {return result} //usually never hits
        else if (this == Root$1) { return "Root" } //hits just once in the recursion
        else if (this.hasOwnProperty("name") && this.name){ //note obj could have name == undefined when we block inheritance.
            //var separator = ((result == "")? "" : ".")
            //result = this.name + separator + result //push onto front of path, order is top of ancestors first
            var proto = Object.getPrototypeOf(this);
            //if (proto == Root) {
             //  return "Root." + this.name
            //}
            //else {
                var result = proto.object_path_aux(result);
                if (result){ return result + "." +  this.name}
                else       { return null }
            //}
        }
        else { return null }
    } ,
    enumerable : false
});

//new_obj.toString errors without this fn
Root$1.toString = function(){
    const path = this.objectPath();
    if (path) { return path }
    else {
        const anses = this.ancestors(true); //include self
        let result = "";
        for(let ans of anses){
            if(ans === Root$1) { result = "Root"; }
            else if (Object.hasOwnProperty("name") && ans.name){
                result +=  "." + ans.name;
            }
            else { //no more named ancestors
                result = "An instance of: " + result;
                break;
            }
        }
        return result
    }
};

// the printer!
// print_this=true, kid_levels="all" or non-neg-int, last_level_format="path"/"full"
/*hier arch printer, fails with refs up  tree
Object.defineProperty(Object.prototype, 'sourceCode',{
    value : function(print_object_values_as_strings=true, indent="  "){
        if (this == Root) { return "Root" }
        else {
            let proto = Object.getPrototypeOf(this)
            if (!proto) { throw new Error("Object.sourceCode passed this with no prototype: " + stringify_value(this))}
            else {
                let prop_names     = Object.getOwnPropertyNames(this)
                let proto_index    = prop_names.indexOf("prototype")
                proto_prop = prop_names.splice(proto_index, 1)
                prop_names = proto_prop.concat(prop_names) //move prototype to begin of list.
                let has_props      = prop_names.length != 0 //since newobjects will always have a prototype, I think this will always be true
                let last_prop_name = (has_props? prop_names[prop_names.length - 1] : undefined)
                let result = "newObject({\n"
                for(let prop_name of prop_names){
                   // let prefix
                   // if (prop_name == "prototype") { prefix = "{"}
                   // else                          { prefix = " "}
                    let val = this[prop_name]
                    let val_string
                    if (Object.isNewObject(val)){
                        if (print_object_values_as_strings || (prop_name == "prototype")) { val_string = val.objectPath() }
                        else {
                            val_string = val.sourceCode(false, indent + "  ")
                        }
                    }
                    else { val_string = stringify_value_sans_html(val) }
                    result += indent + prop_name + ": " + val_string + ((prop_name == last_prop_name)?
                                                                           "\n" +
                                                                           indent +
                                                                           "})" : ",\n")
                }
                return result
            }
        }
    } ,
    enumerable : false
})
*/
//flat list of obj def printer.
Object.defineProperty(Object.prototype, 'sourceCode',{
    value : function({include_this=true, include_subobjects=true, indent="", at_top_level=true}={}){
        if (this == Root$1) { return "Root" }
        else {
            let proto = Object.getPrototypeOf(this);
            if (!proto) { throw new Error("Object.sourceCode passed this with no prototype: " + stringify_value(this))}
            else {
                let prop_names     = Object.getOwnPropertyNames(this);
                let sub_objs = [];
                let non_subobject_prop_names = ["prototype"];
                for(let prop_name of prop_names){
                    let val = this[prop_name];
                    if (prop_name === "prototype") ; //already is first in non_subobject_prop_names
                    else if(val && val.isSubObject(this)) { sub_objs.push(val); } //needed to check that val is not undefined in order for val.isSubject to be found
                    else { non_subobject_prop_names.push(prop_name); }
                }
                let result = "";
                if(include_this){
                    result = indent + "newObject({\n";
                    indent += "  ";
                    for(let prop_name of non_subobject_prop_names){
                        let val = this[prop_name];
                        let val_string;
                        if (Object.isNewObject(val)){ //whether its the prototype or some other random, non-subobject, just print its path
                            if (val.hasOwnProperty("name")) { //hits for prototype and possibly others, but no subobjects will even be tried here
                                val_string = val.objectPath();
                            }
                            else { val_string = val.sourceCode({include_this: true, include_subobjects: true, indent: indent + "  ", at_top_level: false}); }
                        }
                        else { val_string = stringify_value_sans_html(val); }
                        result += indent + prop_name + ": " + val_string + ((prop_name == last(non_subobject_prop_names))?
                            "\n" +
                            indent.substring(2) +
                            "})\n" : ",\n");
                    }
                }
                //all non-subojects printed, so the only thing left in this to print are subojects, if any
                if (include_subobjects){
                    let on_first_subobject = true;
                    for (let sub_ob of sub_objs){
                        let comma_prefix = ((include_this || !on_first_subobject || !at_top_level) ? ", " : "");
                        result += comma_prefix + sub_ob.sourceCode({include_this: true, include_subobjects: true, indent: indent, at_top_level: false});
                        on_first_subobject = false;
                    }
                }
                if (at_top_level) {
                    if (include_this){
                        if(include_subobjects && (sub_objs.length > 0)) { result = "[" + result + "\n][0]"; } //only printing this, just leave the object src as is
                    }
                    else {
                        if(include_subobjects) { result = "[" + result + "]"; }  //result is empty string so just leave it.
                    }
                }
                return result
            }
        }
    } ,
    enumerable : false
});

function to_source_code$1({value, indent="", function_names=false, newObject_paths=false,
                        job_names=false, robot_names=false,
                        depth_limit=100, depth=0, job_orig_args=false,
                        one_line_per_array_elt=false, array_elt_max_chars=60} = {}){
        //console.log("Object.isNewObject: " + Object.isNewObject)
        if(window.Ammo && (value === Ammo)) { return "Ammo" } //if I let this go, it causes some infinite recursion which also happens in inspect
        if (!((typeof(arguments[0]) == "object") && arguments[0].hasOwnProperty("value"))){
            value = arguments[0]; //so we can just do calls of to_source_code("stuf")
        }
        if (depth > depth_limit) { return "***" } //stops infinite recursion in circular structures.
        //console.log("to_source_code before big if")
        if      (value === undefined)       { return "undefined" }
        else if (value === null)            { return "null" } //since typeof(null) == "object", this must be before the typeof(value) == "object" clause
        else if (value === true)            { return "true"}
        else if (value === false)           { return "false"}
        else if (typeof(value) == "number") { return value.toString() } //works for NaN too, no need to use (isNaN(value)) { result = "NaN" } //note the check for number before checking isNanN is necessary because JS wasn't designed.
        else if (typeof(value) == "string") {
            if (value.includes("\n") ||
                (value.includes("'") && value.includes('"')))
                                             { return indent + "`" + value + "`" }
            else if  (value.includes('"'))   { return indent + "'" + value + "'" }
            else                             { return indent + '"' + value + '"' }
        }
        else if (value instanceof Date)      { return value.toString() }
        else if (typeof(value) == "function"){
             let new_args = {value: value, indent: indent};
             return to_source_code_function(new_args)
        }
        else if (Object.isNewObject(value)) {
            //console.log("in to_source_code isNewObject")
            if (newObject_paths) { return value.objectPath }
            else                 { return value.sourceCode() }
        }
        else if (typed_array_name(value)){ //any type of array
            //console.log("calling to_source_code_array")
            return to_source_code_array(arguments[0])
        }
        //Job. Robot, Instruction, Duration
        else if (value.to_source_code){
            let new_args = {value: value, indent: indent, depth: depth + 1}; //use depth because we can potentially have infinite recursion here.
            return value.to_source_code(new_args)
        }
        else if (value === window)     { return "window"  } //too many weird values in there and too slow so punt.
        else if (window.Picture && Picture.is_mat(value)){ //we can't and probably shouldn't attempt to print out a readable mat here,
                                          //so just print a string to let a user know what it is in the inspector
                                          //without this, bad bug happens when inspecting Jobs that have taken a picture and
                                          //put it in a user_data variable
            let result = "Mat (picture) of: width: " +  Picture.mat_width(value) +
                         " height: "  + Picture.mat_height(value);
            return result
        }
        else if (typeof(value) == "object"){//beware if we didn't catch arrays above this would hit
                                            //assumes at this point we just have a lit obj.
            return to_source_code_lit_obj(arguments[0])
        }
        else { shouldnt("to_source_code passed: " + value + " which is not a handled type."); }
}

function to_source_code_array(args){
    let value = args.value;
    if (Instruction$1.is_oplet_array(value)) {
        return to_source_code_instruction_array(args)
    }
    let chars_added_since_last_newline = 0;
    let result = "[";
    let len = value.length;
    let max_chars = (args.array_elt_max_chars ? args.array_elt_max_chars : 60);
    for (let i = 0; i < len; i++){ //don't use "for ... in here as it gets some wrong stuff
        let prefix = "";
        let val = value[i];
        let val_str = to_source_code$1({value: val, array_elt_max_chars: max_chars});
        let comma_maybe = ((i < (len - 1)) ? "," : "");
        let newline_or_space_suffix = ((i == (len - 1))? "" : " ");
        let str_and_suffix_len = val_str.length;
        if (args.one_line_per_array_elt) { newline_or_space_suffix = "\n"; }
        else if (chars_added_since_last_newline > max_chars) {
            prefix = "\n";
            chars_added_since_last_newline = str_and_suffix_len;
        }
        else if ((chars_added_since_last_newline == 0) && (val_str.length > max_chars)) {
            chars_added_since_last_newline = str_and_suffix_len; //add it in the usual way
        }
        else if ((chars_added_since_last_newline + str_and_suffix_len) > args.array_elt_max_chars) {
            prefix = "\n";
            chars_added_since_last_newline = str_and_suffix_len;
        }
        else { chars_added_since_last_newline += str_and_suffix_len; }
        //if (Array.isArray(elt_val)) sep = sep + "<br/>" //put each sub-array on its own line
        result += prefix + val_str + comma_maybe + newline_or_space_suffix;
    }
    result += "]";
    return result
}

/* errors on at least some instruction arrays .function to_source_code_instruction_array(args){
    let inst_array = args.value
    let the_indent = ((args.indent === undefined) ? "" : args.indent)
    let result = the_indent + "make_ins("
    let prop_args = Object.assign({}, args) //jQuery.extend({}, args)
    prop_args.indent = ""
    for(let prop_index in inst_array) {
        prop_args.value = inst_array[prop_index]
        let prop_src = to_source_code(prop_args)
        let suffix = ((prop_index == (inst_array.length - 1)) ? "" : ", ")
        result += prop_src + suffix
    }
    result += ")"
    return result
}*/

function to_source_code_instruction_array(args){
    let inst_array = args.value;
    let the_indent = ((args.indent === undefined) ? "" : args.indent);
    let result = the_indent + "make_ins(";
    let start_array_index = Instruction$1.INSTRUCTION_TYPE;
    for(let i = start_array_index; i <  inst_array.length; i++) {
        let val = inst_array[i];
        let val_src = to_source_code$1(val);
        let suffix = ((i == (inst_array.length - 1)) ? "" : ", ");
        result += val_src + suffix;
    }
    result += ")";
    return result
}

function to_source_code_lit_obj(args){
        let value = args.value;
        let indent = args.indent;
        if (!indent) { indent = ""; }
        let result = indent + "{";
        let prop_names = Object.getOwnPropertyNames(value); //long objects like cv cause problems
        for (var prop_index = 0; prop_index < prop_names.length; prop_index++) {
            let prop_name   = prop_names[prop_index];
            let prop_val    = value[prop_name];
            let prop_args   = Object.assign({}, args); //jQuery.extend({}, args) //copy the args
            prop_args.value = prop_val;
            prop_args.indent = ""; //((prop_index == 0) ? "" : (indent + " "))
            let prop_indent = ((prop_index == 0) ? "" : (indent + " "));
            let quote_char = "";
            if (prop_name.indexOf(" ") != -1){
                quote_char = '"';
                if (prop_name.indexOf('"') != -1) { prop_name = replace_substrings(prop_name, '"',  '\\"'); }
            }
            let trailing_comma = ((prop_index == (prop_names.length - 1)) ? "" : ", ");
            result += prop_indent + quote_char + prop_name + quote_char + ": " + to_source_code$1(prop_args) +
                      trailing_comma + "\n";
        }
        result += indent + "}";
        return result
}

function to_source_code_function(args){
    let fn_name = function_name(args.value);
    if (args.function_names && (fn_name !== null) && (fn_name !== "")) {
        return args.indent + fn_name
    }
    else {
        let src = args.value.toString();
        return replace_substrings(src, "\n", args.indent + "\n")
    }
}

/** Created by Fry on 3/5/16. */


var Instruction$1 = class Instruction {
    init_instruction(){} //shadowed by at least wait_until and loop

    static to_string(instr){
       if(instr instanceof Instruction) { return instr.toString() }
       else if (Instruction.is_oplet_array(instr)) {
           var oplet = instr[Dexter$1.INSTRUCTION_TYPE];
           var fn_name = Dexter$1.instruction_type_to_function_name(oplet);
           var args = instr.slice(Instruction.INSTRUCTION_ARG0);
           return fn_name + " " + args
       }
       else if (Array.isArray(instr)) { return "Array of " + instr.length + " instructions" }
       else if (typeof(instr) == "function") {
           let name = instr.name;
           if(name && name !== "") { return "function " + name }
           else { return "anonymous function" }
       }
       else { return instr.toString() }
    }
    toString(){
        return "{instanceof: " + stringify_value_aux(this.constructor) + "}"
    }

    //excludes at_sign instructions but includes "a" and "a!
    //if first elt is a 2 char string , the 2nd char must be !
    /*
    static is_short_instruction(obj) {
        if(!Array.isArray(obj))     { return false }
        if (obj.length == 0)        { return false }
        return Instruction.is_short_instruction_name(obj[0])
    }

    //used by Job def to verify at_sign_function
    static is_short_instruction_name(a_string){
        if(this.is_short_instruction_name_no_convert(a_string)) { return true } //the only permissible 2 char string
        if(typeof(a_string) != "string")  { return false }
        if(a_string.length != 1)          { return false }
        if(a_string == "@")               { return false }
        else                              { return true  }
    }

    //called from socket.js
    static is_short_instruction_name_no_convert(a_string){
        if(typeof(a_string) != "string")  { return false }
        else if(a_string.length != 2)     { return false }
        else                              { return a_string[1] == "!" }
    }

    static is_at_sign_instruction(item) {
        return (Array.isArray(item) && (item[0] == "@"))
    }
    */

    //if oplet is null, returns true for any oplet. if its a one char string.
    //only returns true if the oplet in obj is that one char string
    static is_oplet_array(obj, oplet=null){
        //since we're making the instruction arrays by our fn calls, ie Job.move,
        //the user isn't making up the arrays, so we assume all arrays that start
        //with a first elt of a string or length 1 are legitimate. But
        //we COULD check that the first char is legal and
        //the length and types of the rest of the elts matched what that op-let needs.
        if (Array.isArray(obj) && (obj.length > 0)){
            var oplet_maybe = obj[Instruction.INSTRUCTION_TYPE];
            if(typeof(oplet) === "string") {
                return oplet_maybe === oplet
            }
            else {
                return Robot$1.is_oplet(oplet_maybe)//true for any 1 char strings. There's an arg for is_oplet to make it more restrictive=, but Kent likes the flexibility for creating new oplets
            }
        }
        return false
    }

    static is_instructions_array(obj){
        if(!Array.isArray(obj))                                  { return false }
        else if (Instruction.is_oplet_array(obj))                { return false }
        else if (Instruction.is_empty_nested_array(obj))         { return false }
        else {
            for(let elt of obj) {
                if(Instruction.is_non_instructions_array_do_list_item(elt)) ; //ok, might still be an instructions array
                else if(!Instruction.is_instructions_array(elt)) { return false }
            }
            return true
        }
    }

    static is_data_array(obj){
        if(!Array.isArray(obj))                   { return false }
        else if (Instruction.is_oplet_array(obj)) { return false }
        else if (this.is_instructions_array(obj)) { return false }
        else                                      { return true }
    }

    static is_start_object(obj){
        return ((typeof(obj) == "object") &&
                (typeof(obj.start) == "function") &&
                 !(obj instanceof Robot$1))
    }

    //If the instruction *could* insert into the do_list, return true.
    //else return false
    //the following instructions insert as of Mar 6, 2019
    //Instruction.Dexter.read_file
    //Instruction.human_enter_choice
    //Instruction.human_enter_instruction
    //Instruction.human_enter_position
    //Instruction.if_any_errors
    //Instruction.include_job
    //Instruction.loop
    //Instruction.send_to_job
    //Instruction.sent_from_job
    //SOMETIMES:
    //   Instruction.Dexter.move_to_straight
    //   Instruction.wait_for
    static is_inserting_instruction(item, job_instance){
       if(item == undefined)  {return false}
       else if (item == null) {return false}
       else if (typeof(item) === "string") {return false}
       else if (Array.isArray(item) && (item.length == 0)) { return false }
       else if (Instruction.is_data_array(item)){
           if(!job_instance) { return true } //we can't resolve the data_array so be conservative as it *might* return an inserting instruction depending on the job data_array_transformer
           else {
               let fn = job_instance.data_array_transformer;
               if(Robot$1.oplet(fn)) { return false }
               else if (Instruction.is_inserting_instruction(fn)) { return true }
               else { return false } //don't know what it is so be conservative and return false
           }
       }
       else if (typeof(item) === "function")     {return true }
       else if (Array.isArray(item))             { return true }
       else if(Instruction.is_oplet_array(item)) { return false }
       else if (is_iterator(item))               { return true }
       else if (item instanceof Instruction){
           if(item.inserting_instruction)        { return true }
           else { return false }
       }
       else { shouldnt$1("Instruction.is_inserting_instruction passed unhandled instruction: " + item); }
    }

    static array_has_only_non_inserting_instructions(a_do_list, job_instance){
        for(let item of a_do_list){
            if(this.is_inserting_instruction(item, job_instance)) {return false}
        }
        return true
    }

    //used by do_next_item to determine if the return value of
    //calling the data_array_transformer can be directly sent.
    //a data_array is not sendable because it has to be transformed first.
    static is_sendable_instruction(item){
        return (Instruction.is_oplet_array(item) ||
                (typeof(item) == "string"))
    }

    static is_no_op_instruction(item){
       return ((item === undefined) ||
               (item === null)      ||
                Instruction.is_empty_nested_array(item)
       )
    }

    static is_empty_nested_array(array_maybe){
        if(!Array.isArray(array_maybe)) { return false }
        else {
            for(let elt of array_maybe) {
                if(!Instruction.is_empty_nested_array(elt)) {
                    return false
                }

            }
            return true
        }
    }

    static is_non_instructions_array_do_list_item(item){
       return ( Instruction.is_no_op_instruction(item) ||
                (item instanceof Instruction) ||
                Instruction.is_oplet_array(item) ||
                is_iterator(item) ||
                (typeof(item) === "string") ||
                (typeof(item) === "function") ||
                Instruction.is_start_object(item)
                )
    }

    //a valid item to put on a do_list
    //mirrors Job.do_next_item ordering
    static is_do_list_item(item){
        return ( Array.isArray(item) ||   //accept data_arrays too. //Instruction.is_instructions_array(item)
                 Instruction.is_non_instructions_array_do_list_item(item)
               )
    }

    static is_F_instruction_string(str){
        return ((typeof(str) === "string") && str.endsWith(" F;"))
    }

    static extract_job_id(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") { oplet_array_or_string = oplet_array_or_string.split(" "); }
        let str= oplet_array_or_string[Instruction.JOB_ID];
        return parseInt(str)
    }

    static extract_instruction_id(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") { oplet_array_or_string = oplet_array_or_string.split(" "); }
        let str= oplet_array_or_string[Instruction.INSTRUCTION_ID];
        return parseInt(str)
    }

    static extract_start_time(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") { oplet_array_or_string = oplet_array_or_string.split(" "); }
        let str= oplet_array_or_string[Instruction.START_TIME];
        if (str == "undefined") { return undefined } //probably should never happen
        else { return parseInt(str) }
    }

    static extract_stop_time(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") { oplet_array_or_string = oplet_array_or_string.split(" "); }
        let str = oplet_array_or_string[Instruction.STOP_TIME];
        if (str == "undefined") { return undefined } //will happen for all string instructions
        else { return parseInt(str) }
    }

    static extract_instruction_type(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") {
            oplet_array_or_string = oplet_array_or_string.substring(0, oplet_array_or_string.length - 1); //cut the ending semicolon
            oplet_array_or_string = oplet_array_or_string.split(" ");
        }
        return oplet_array_or_string[Instruction.INSTRUCTION_TYPE]
    }

    static extract_args(oplet_array_or_string){
        if(typeof(oplet_array_or_string) == "string") {
            oplet_array_or_string = oplet_array_or_string.substring(0, oplet_array_or_string.length - 1); //cut the ending semicolon
            oplet_array_or_string = oplet_array_or_string.split(" ");
            let arg_strings = oplet_array_or_string.slice(Instruction.INSTRUCTION_ARG0);
            let result = [];
            for(let substr of arg_strings) {
                let num_maybe = parseFloat(substr); //on the last arg, it probably ends with semicolon. that's ok
                if(Number.isNaN(num_maybe)) { result.push(substr); } //assume its just a string
                else { result.push(num_maybe); }
            }
            return result
        }
        else {
            return oplet_array_or_string.slice(Instruction.INSTRUCTION_ARG0)
        }
    }

    //return an array of the instruction args
    static args(ins_array){
        return ins_array.slice(Instruction.INSTRUCTION_ARG0)
    }

    static job_of_instruction_array(ins_array){
        var job_id = ins_array[Instruction.JOB_ID];
        return Job$1.job_id_to_job_instance(job_id)
    }

    static instruction_color(ins){
        if(Instruction.is_oplet_array(ins))              { return "#FFFFFF" } //white
        else if(Instruction.is_data_array(ins))          { return "#FFFFFF" } //white
        else if(typeof(ins) == "string")                 { return "#DDEEFF" } //light blue
        else if (ins instanceof Instruction) {
            if(ins.constructor.name.startsWith("human"))  { return "#ffb3d1" }//pink
            else if (ins instanceof Instruction.break)    { return "red" }    //red
            else if (ins instanceof Instruction.debugger) { return "red" }    //red
            else                                          { return "#e6b3ff" }//lavender
        }
        else if (is_generator_function(ins))              { return "#ccffcc" } //green
        else if (is_iterator(ins))                        { return "#aaffaa" } //lighter green
        else if (typeof(ins) == "function")               { return "#b3e6ff" } //blue
        else if (Instruction.is_start_object(ins))        { return "#ffd492"}  //tan
        else if (ins === null)                            { return "#aaaaaa" } //gray
        else if (ins ===undefined)                        { return "#aaaaaa" } //gray

        else if (Array.isArray(ins))                      { return "#aaaaaa" } //gray
        else { shouldnt$1("Instruction.instruction_color got unknown instruction type: " + ins); }
    }
    static text_for_do_list_item(ins){
        if (ins === undefined)            { return 'undefined' }
        else if (ins == null)             { return 'null' }
        else if (typeof(ins) == "string") { return '"' + ins + '"' }
        else if (Instruction.is_data_array(ins)){
            let text = JSON.stringify(ins);
            let title = "data_array instructions use\ntheir Job's data_array_transformer for functionality,\n which is, by default: Dexter.pid_move_all_joints";
            return "<span title='" + title + "'>" + text + "</span>"
        }
        else if(Instruction.is_oplet_array(ins)) {
            let text;
            try { text  = JSON.stringify(ins); } //we want 1 line here, not the multi-lines that stringify_value(ins) puts out
            catch(err) { //happens for instructions like Dexter.dexter0.sleep(2) where the dexeter instance is circular, so just do something cheaper.
                text = ins.toString();
            }
            return "<span title='" + Robot$1.instruction_type_to_function_name(ins[Instruction.INSTRUCTION_TYPE]) + "'>" + text + "</span>"
        }
        else if (ins instanceof Instruction) {
            let name = ins.constructor.name;
            let props = "";
            for(let prop_name of Object.keys(ins)){
                props += "<i>" + prop_name + "</i>: " + ins[prop_name] + "; ";
            }
            return name + " with " + props
        }
        else if (is_generator_function(ins)) {
            return "generator function " + ins.toString().substring(0, 70)
        }
        else if (is_iterator(ins)){
            return "iterator " + ins.toString().substring(0, 70)
        }
        else if (typeof(ins)  == "function")       { return ins.toString().substring(0, 80) }
        else if (Instruction.is_start_object(ins)) {
            if(ins.to_source_code) { return ins.to_source_code() } //hits for Note and Phrase
            else { return ins.toString().substring(0, 80)  }
        }

        else if (Array.isArray(ins))        { return stringify_value(ins) }
        else { shouldnt$1("Instruction.text_for_do_list_item got unknown instruction type: " + ins); }
    }
    static text_for_do_list_item_for_stepper(ins){
        if(Instruction.is_oplet_array(ins)) {
            let text = JSON.stringify(ins.slice(4)); //we want 1 line here, not the multi-lines that stringify_value(ins) puts out
            return "<span title='" + Robot$1.instruction_type_to_function_name(ins[Instruction.INSTRUCTION_TYPE]) + "'>" + text + "</span>"
        }
        else if (ins instanceof Instruction) {
            let name = ins.constructor.name;
            let props = "";
            for(let prop_name of Object.keys(ins)){
                props += "<i>" + prop_name + "</i>: " + ins[prop_name] + "; ";
            }
            return name + " with " + props
        }
        else if (is_generator_function(ins)) {
            return "generator function " + ins.toString().substring(0, 70)
        }
        else if (is_iterator(ins)){
            return "iterator " + ins.toString().substring(0, 70)
        }
        else if (typeof(ins) == "function") { return ins.toString().substring(0, 80) }
        else if (ins == null) { return 'null' }
        else if (Array.isArray(ins)) { return stringify_value(ins) }
        else { shouldnt$1("Instruction.text_for_do_list_item_for_stepper got unknown instruction type: " + ins); }
    }

    //side effects instr (if it can take a robot) and returns it.
    static add_robot_to_instruction(instr, robot){
        if (robot === undefined) ;
        else if (instr instanceof Instruction){
            if(instr.hasOwnProperty("robot")) { instr.robot = robot; }
            return instr
        }
        else if (Instruction.is_oplet_array(instr)) {
            let last_elt = last(instr);
            if (last_elt instanceof Robot$1) { instr[instr.length - 1] = robot; }
            else { instr.push(robot); }
        }
        else if (Array.isArray(instr)) { Instruction.add_robot_to_instructions(instr, robot);}
        return instr
    }

    //instr is an array of any kind of job instruction.
    //side effects each instr in instrs (if it can take a robot) and returns it.
    static add_robot_to_instructions(instrs=[], robot){
        for (let instr of instrs){
            Instruction.add_robot_to_instruction(instr, robot);
        }
        return instrs
    }

    //this helps catch mismatches of instruction robot and job robot quickly with
    //a good error message.
    set_instruction_robot_from_job(job_instance){
        let error_mess_or_true = Instruction.can_instruction_run_on_robot(this, job_instance.robot);
        if (typeof(error_mess_or_true) == "string") {
            error_mess_or_true = "In Job: " + job_instance.name + ",<br/>" + error_mess_or_true;
            dde_error(error_mess_or_true);
        }
        else { this.robot = job_instance.robot; }
    }
    //returns true or a string of an error message
    static can_instruction_run_on_robot(instruction, robot_instance){
        if(!this.is_do_list_item(instruction)) {
           return instruction + " is not a valid instruction.<br/>It can't run on any robot."
        }
        else if((instruction == null) || (instruction == undefined)) { return true }
        else if (instruction instanceof Instruction){
            let job_robot_class_name  = robot_instance.constructor.name;
            let instruction_class_name = Object.getPrototypeOf(instruction).constructor.name;
            if(instruction_class_name == "Instruction") { return true } //can run on any robot
            let instruction_superclass_name = Object.getPrototypeOf(Object.getPrototypeOf(instruction)).constructor.name; //often "Control"
            if(instruction_superclass_name == job_robot_class_name) { //ie "Dexter", "Serial"
                return true
            }
            else {
                return "attempt to run instruction: " + instruction_superclass_name + "." + instruction_class_name + "<br/>" +
                       "on Robot of class: " + job_robot_class_name + "<br/>" +
                       "but that Robot can't handle instructions of class: " + instruction_superclass_name
            }
        }
        else { return true }
    }
};

Instruction$1.labels = [
"JOB_ID",             // 0
"INSTRUCTION_ID",     // 1
"START_TIME",         // 2
"STOP_TIME",          // 3 //END_TIME is better in this context BUT stop_time, stop_reason is used in Jobs and I wanted to be consistent with that.
"INSTRUCTION_TYPE",   // 4 //ie "oplet"
"INSTRUCTION_ARG0",   // 5
"INSTRUCTION_ARG1",   // 6
"INSTRUCTION_ARG2",   // 7
"INSTRUCTION_ARG3",   // 8
"INSTRUCTION_ARG4",   // 9
"INSTRUCTION_ARG5",   // 10
"INSTRUCTION_ARG6",   // 11
"INSTRUCTION_ARG7",   // 12
"INSTRUCTION_ARG8",   // 13
"INSTRUCTION_ARG9",   // 14
"INSTRUCTION_ARG10",  // 15
"INSTRUCTION_ARG11",  // 16
"INSTRUCTION_ARG12"   // 17 //used in Socket.js instruction_array_degrees_to_arcseconds_maybe for "T"
]; // and after those come the args to the instruction.

for (let i = 0; i < Instruction$1.labels.length; i++){
    Instruction$1[Instruction$1.labels[i]] = i;
}

/* correct as of ap 2020 BUT we decidd to allow any non-neg integer
Instruction.valid_w_addresses = [5,
                                20, 21, 26, 27, 28,
                                31, 32, 33, 34, 35, 36, 39,
                                40, 41, 42, 43, 44, 45, 46, 47, 48, 49,
                                50, 51, 52, 53, 54, 55, 56,
                                61, 62, 64, 66, 67, 68, 69,
                                70, 71, 73, 74, 75, 78, 79,
                                80, 81]
*/

Instruction$1.is_valid_w_address = function(addr) {
  return is_non_neg_integer(addr)
};

Instruction$1.w_address_names = [
    "BASE_POSITION", //"0"
    "END_POSITION", //"1"
    "PIVOT_POSITION", //"2"
    "ANGLE_POSITION", //"3"
    "ROT_POSITION", //"4"
    "ACCELERATION_MAXSPEED", //"5"
    "BASE_SIN_CENTER", //"6"
    "BASE_COS_CENTER", //"7"
    "END_SIN_CENTER", //"8"
    "END_COS_CENTER", //"9"
    "PIVOT_SIN_CENTER", //"10"
    "PIVOT_COS_CENTER", //"11"
    "ANGLE_SIN_CENTER", //"12"
    "ANGLE_COS_CENTER", //"13"
    "ROT_SIN_CENTER", //"14"
    "ROT_COS_CENTER", //"15"
    "PID_DELTATNOT", //"16"
    "PID_DELTAT", //"17"
    "PID_D", //"18"
    "PID_I", //"19"
    "PID_P", //"20"
    "PID_ADDRESS", //"21"
    "BOUNDRY_BASE", //"22"
    "BOUNDRY_END", //"23"
    "BOUNDRY_PIVOT", //"24"
    "BOUNDRY_ANGLE", //"25"
    "BOUNDRY_ROT", //"26"
    "SPEED_FACTORA", //"27"
    "SPEED_FACTORB", //"28"
    "FRICTION_BASE", //"29"
    "FRICTION_END", //"30"
    "FRICTION_PIVOT", //"31"
    "FRICTION_ANGLE", //"32"
    "FRICTION_ROT", //"33"
    "MOVE_TRHESHOLD", //"34"
    "F_FACTOR", //"35"
    "MAX_ERROR", //"36"
    "FORCE_BIAS_BASE", //"37"
    "FORCE_BIAS_END", //"38"
    "FORCE_BIAS_PIVOT", //"39"
    "FORCE_BIAS_ANGLE", //"40"
    "FORCE_BIAS_ROT", //"41"
    "COMMAND_REG", //"42"
    "DMA_CONTROL", //"43"
    "DMA_WRITE_DATA", //"44"
    "DMA_WRITE_PARAMS", //"45"
    "DMA_WRITE_ADDRESS", //"46"
    "DMA_READ_PARAMS", //"47"
    "DMA_READ_ADDRESS", //"48"
    "REC_PLAY_CMD", //"49"
    "REC_PLAY_TIMEBASE", //"50"
    "MAXSPEED_XYZ", //"51"
    "DIFF_FORCE_BETA", //"52"
    "DIFF_FORCE_MOVE_THRESHOLD", //"53"
    "DIFF_FORCE_MAX_SPEED", //"54"
    "DIFF_FORCE_SPEED_FACTOR_ANGLE", //"55"
    "DIFF_FORCE_SPEED_FACTOR_ROT", //"56"
    "DIFF_FORCE_ANGLE_COMPENSATE", //"57"
    "FINE_ADJUST_BASE", //"58"
    "FINE_ADJUST_END", //"59"
    "FINE_ADJUST_PIVOT", //"60"
    "FINE_ADJUST_ANGLE", //"61"
    "FINE_ADJUST_ROT", //"62"
    "RECORD_LENGTH", //"63"
    "END_EFFECTOR_IO", //"64"
    "SERVO_SETPOINT_A", //"65"
    "SERVO_SETPOINT_B", //"66"
    "BASE_FORCE_DECAY", //"67"
    "END_FORCE_DECAY", //"68"
    "PIVOT_FORCE_DECAY", //"69"
    "ANGLE_FORCE_DECAY", //"70"
    "ROTATE_FORCE_DECAY", //"71"
    "PID_SCHEDULE_INDEX", //"72"
    "GRIPPER_MOTOR_CONTROL", //"73"
    "GRIPPER_MOTOR_OFF_WIDTH", //"74"
    "GRIPPER_MOTOR_ON_WIDTH", //"75"
    "START_SPEED", //"76"
    "ANGLE_END_RATIO", //"77"
    "RESET_PID_AND_FLUSH_QUEUE", //"78"
    "XYZ_FORCE_TIMEBASE", //"79"
    "DIFFERENTIAL_FORCE_TIMEBASE", //"80"
    "PID_TIMEBASE" //"81"
];
/*Instruction.w_address_number_to_name = function(num){
    if(!Instruction.is_valid_w_address(num)) { return "unknown" }
    let w_address_names = Series.id_to_series("series_w_oplet_address_id").array
    if (num >= w_address_names.length) { return "unknown" }
    else { return w_address_names[num] }
}*/

//returns undefined for invalid nums
Instruction$1.w_address_number_to_name = function(num){
    return Instruction$1.w_address_names[num]
};

//beware: will return -1 if name is invalid
/*Instruction.w_address_name_to_number = function(name){
    let w_address_names = Series.id_to_series("series_w_oplet_address_id").array
    return w_address_names.indexOf(name)
}*/

//beware: will return -1 if name is invalid
Instruction$1.w_address_name_to_number = function(name){
    return Instruction$1.w_address_names.indexOf(name)
};

//user might call this at top level in a do_list so make it's name short.
//the last arg can be a Dexter robot, but if not, the robot comes from the
//default robot for the job that this instruction is in.
function make_ins$1(instruction_type, ...args){
    /*if(!Dexter.instruction_type_to_function_name_map[instruction_type] &&
       !Serial.instruction_type_to_function_name_map[instruction_type]){
        warning("make_ins called with an invalid instruction_type: " + instruction_type +
                "<br/>make_ins still returning an array using: " + instruction_type)
    }*/
    //let first_arg = args[0]
    /*if((instruction_type == "w") && !Instruction.is_valid_w_address(first_arg)){
        dde_error('make_ins("w" ...) does not support an address of ' + first_arg +
                  '.<br/>Valid addresses are non-negative integers. ' +
                  '.<br/>See <a target="_blank" href="https://github.com/HaddingtonDynamics/Dexter/wiki/oplet-write">oplet_write doc</a>. for details.')
    }*/
    let result = new Array(Instruction$1.INSTRUCTION_TYPE);
    result.push(instruction_type);
    if (args.length === 0) { return result } //avoids generating the garbage that concat with an arg of an empty list would for this common case, ie for "g" ahd "h" instructions
    else                   { return result.concat(args) }
}

//to_source_code_insruction_array(isntr_array) //inplemented in to_source_code.js

//now Instruction.INSTRUCTION_TYPE == 4, and some_ins_array[Instruction.INSTRUCTION_TYPE] will return the oplet
//make_ins("a", 1, 2, 3, 4, 5) works
//make_ins("a", ...[1, 2, 3, 4, 5]) works

Instruction$1.break = class Break extends Instruction$1{ //class name must be upper case because lower case conflicts with js break
    constructor () { super(); }
    do_item (job_instance){
        let loop_pc = Instruction$1.loop.pc_of_enclosing_loop(job_instance);
        if (loop_pc === null) {
            warning("Job " + job_instance.name + ' has a Control.break instruction at pc: ' + job_instance.program_counter +
                "<br/> but there is no Control.loop instruction above it.");
            job_instance.set_up_next_do(1);
        }
        else {
            let loop_ins = job_instance.do_list[loop_pc];
            loop_ins.init_instruction(); //just in case this loop is nested in another loop
            //or we "go_to backwards" to it, we want its next "first_call" to initialize
            //the loop so set this prop to null
            let items_within_loop = job_instance.total_sub_instruction_count(loop_pc); //job_instance.added_items_count[loop_pc]
            job_instance.program_counter = loop_pc + items_within_loop; //now pc is pointing at last inst of loop iteration instrs
            job_instance.set_up_next_do(1); //skip past the last inst in the loop iteration, as we're done with the loop
        }
    }
    toString(){ return "break" }
    to_source_code(args){ return args.indent + "Control.break()" }
};

//like JS continue but in a dde LOOP instruction
//very similar to Instruction.break, but without loop_ins.init_instruction()
Instruction$1.continue = class Continue extends Instruction$1{ //class name must be upper case because lower case conflicts with js continue
    constructor () { super(); }
    do_item (job_instance){
        let loop_pc = Instruction$1.loop.pc_of_enclosing_loop(job_instance);
        if (loop_pc === null) {
            dde_error("Job " + job_instance.name + ' has a Control.Continue instruction at pc: ' + job_instance.program_counter +
                "<br/> but there is no Control.loop instruction above it.");
            job_instance.set_up_next_do(1);
        }
        else {
            job_instance.do_list[loop_pc];
            job_instance.program_counter = loop_pc;
            job_instance.set_up_next_do(0);
        }
    }
    toString(){ return "continue" }
    to_source_code(args){ return args.indent + "Control.continue()" }
};


Instruction$1.debugger = class Debugger extends Instruction$1{ //class name must be upper case because lower case conflicts with js debugger
    constructor () {
        super();
        this.time_dev_tools_was_opened = null;
    }
    do_item (job_instance){
        if(this.time_dev_tools_was_opened === null){
            open_dev_tools();
            this.time_dev_tools_was_opened = Date.now(); //in milliseconds
            job_instance.set_up_next_do(0);
        }
        else if((Date.now() - this.time_dev_tools_was_opened) < 1000) {
            job_instance.set_up_next_do(0); //give open_dev_tools() a chance to ipen up.
                                           //otherwise it won't break when executing debugger
                                           //in do_next_item
        }
        else {
            js_debugger_checkbox_id.checked = true; //this is here and not in the first clause
            //because we really don't want to waste time and pause during execution
            //of the debugger instruction itself while looping in clause 2,
            //we just want to skip ahead to the next instruction and debug from there.
            job_instance.set_up_next_do(1); } //ready to move on and break in do_next_item
    }
    toString(){ return "debugger" }
    to_source_code(args){ return args.indent + "Control.debugger()" }
};

Instruction$1.step_instructions = class step_instructions extends Instruction$1{ //class name must be upper case because lower case conflicts with js debugger
    constructor () { super(); }
    do_item (job_instance){
        Job$1.set_go_button_state(false);
        job_instance.set_up_next_do(1, true);
    }
    toString(){ return "step_instructions" }
    to_source_code(args){ return args.indent + "Control.step_instructions()" }
};

Instruction$1.error = class error extends Instruction$1{
    constructor (reason="Job stopped due to executing a Control.error instruction.", perform_when_stopped=true) {
        super();
        if(typeof(perform_when_stopped) !== "boolean") {
          dde_error("Instruction Control.error passed perform_when_stopped of: " + perform_when_stopped +
                    "<br/>but it should be true or false.");
        }
        this.reason = reason;
        this.perform_when_stopped=perform_when_stopped;
    }
    do_item (job_instance){
        job_instance.when_stopped_conditions = this.perform_when_stopped;
        job_instance.when_do_list_done = "run_when_stopped";
        if(!this.perform_when_stopped) {
            job_instance.when_stopped = "stop";
        }
        job_instance.stop_for_reason("errored",  "Instruction Control.error run with reason: " + this.reason);
        job_instance.set_up_next_do(0);
    }
    toString(){
        return "error: " + this.reason
    }
    to_source_code(args){
        let this_indent = args.indent;
        args        = jQuery.extend({}, arguments[0]);
        args.value  = this.reason;
        args.indent = "";
        return this_indent + "Control.error(" + to_source_code$1(args) + ")"
    }
};

//upper case G to avoid a conflict, but the user instruction is spelled Control.get_page
Instruction$1.Get_page = class Get_page extends Instruction$1{
    constructor (url_or_options, response_variable_name="http_response") {
        super();
        this.url_or_options = url_or_options;
        this.response_variable_name = response_variable_name;
        this.sent = false;
    }
    do_item (job_instance){
        var the_var_name = this.response_variable_name;  //for the closures
        if (this.sent == false){ //hits first time only
            job_instance.user_data[the_var_name] = undefined; //must do in case there was some other
            //http_request for this var name, esp likely if its default is used.
            get_page_async(this.url_or_options, //note I *could* simplify here and use get_page (syncrhonos), but this doesn't freeze up UI while getting the page so a little safer.
                function(err, response, body) {
                    //console.log("gp top of cb with the_var_name: " + the_var_name)
                    //console.log("gp got err: " + err)
                    //console.log("ojb inst: "   + job_instance)
                    //console.log("response: "    + response)
                    if(err) { //bug err is not null when bad url
                        console.log("gp in err: ");
                        job_instance.user_data[the_var_name] = "Error: " + err;
                        console.log("gp after err: ");
                    }
                    else if(response.statusCode !== 200){
                        job_instance.user_data[the_var_name] = "Error: in getting url: " + this.url_or_options + ", received error status code: " + response.statusCode;
                    }
                    else {
                        //console.log("gp in good: ")
                        job_instance.user_data[the_var_name] = body;
                        //console.log("gp after good: ")
                    }
                });
            this.sent = true;
            job_instance.set_up_next_do(0);
        }
        else if (job_instance.user_data[the_var_name] === undefined){ //still waiting for the response
            job_instance.set_up_next_do(0);
        }
        else { job_instance.set_up_next_do(1);} //got the response, move to next instruction
    }
    to_source_code(args){
        return args.indent + "Control.get_page(" +
            to_source_code$1({value: this.url_or_options}) +
            ((this.response_variable_name == "http_response") ? "" : (", " + to_source_code$1({value: this.response_variable_name})))  +
            ")"
    }
};

Instruction$1.go_to = class go_to extends Instruction$1{
    constructor (instruction_location) {
        super();
        if (instruction_location === undefined){
            dde_error("go_to has not been passed an instruction_location.");
        }
        this.instruction_location = instruction_location;
    }
    do_item (job_instance){
        let id = job_instance.instruction_location_to_id(this.instruction_location);
        if (id == job_instance.program_counter){
            job_instance.stop_for_reason("errored", "In job." + job_instance.name +
                        "<br/>with a go_to instruction whose instruction_location: " + this.instruction_location +
                        "<br/>points to id: " + id +
                        "<br/>that is the same as this go_to instruction," +
                        "<br/>which would cause an infinite loop.");
            job_instance.set_up_next_do(0);

        }
        else {
            job_instance.program_counter = id;
            job_instance.set_up_next_do(0);
        }
    }
    toString(){ return "Control.go_to instruction_location: " + this.instruction_location }

    to_source_code(args){
        let this_indent = args.indent;
        args        = jQuery.extend({}, arguments[0]);
        args.value  = this.instruction_location;
        args.indent = "";
        return this_indent + "Control.go_to(" + to_source_code$1(args) + ")"
    }
};

Instruction$1.grab_robot_status = class grab_robot_status extends Instruction$1{
    constructor (user_data_variable = "grabbed_robot_status", //a string
                 start_index = Serial$1.DATA0, //integer, but can also be "all"
                 end_index=null,  //if integer and same as start_index,
                                //makes a vector of the start_index value,
                                //otherwise makes array of the start_index THROUGH
                                //end_index. OR can be the string "end" meaning
                                //grab through the end of the array
                 robot=null)
                 {
        super();
        this.user_data_variable = user_data_variable;
        this.start_index        = start_index;
        this.end_index          = end_index;
        this.robot = robot;
    }
    do_item (job_instance){
        let robot = (this.robot ? this.robot : job_instance.robot);
        let rs = robot.robot_status;
        let val;
        if (this.start_index == "data_array") {
            this.start_index = Serial$1.DATA0;
            this.end_index   = "end";
        }
        //set val
        if (this.start_index == "all") { val = rs; }
        else if (this.end_index) {
            if (this.end_index === "end") { this.end_index = rs.length - 1; }
            else if (this.start_index > this.end_index ) {
                job_instance.stop_for_reason("errored", "instruction: grab_robot_status passed end_index: " + this.end_index +
                          " that is less than start_index: " + this.start_index);
                job_instance.set_up_next_do(0);
                return
            }
            else { val = rs.slice(this.start_index, this.end_index + 1); }
        }
        else { val = rs[this.start_index]; } //the one case that val is not an array
        job_instance.user_data[this.user_data_variable] = val;
        job_instance.set_up_next_do(1);
    }
    toString(){
        return "grab_robot_status: " + this.user_data_variable
    }
    to_source_code(args){
        let this_indent = args.indent;
        args        = jQuery.extend({}, args);
        args.value  = this.user_data_variable;
        args.indent = "";
        let ud_src  = to_source_code$1(args);
        args        = jQuery.extend({}, args);
        args.value  = this.start_index;
        args.indent = "";
        let si_src  = to_source_code$1(args);
        args        = jQuery.extend({}, args);
        args.value  = this.end_index;
        args.indent = "";
        let ei_src  = to_source_code$1(args);
        return this_indent + "IO.grab_robot_status(" +
               ud_src + ", " + si_src + ", " + ei_src + ")"
    }
};

/*
Instruction.human_recognize_speech = class human_recognize_speech extends Instruction{
    constructor (args){
        super()
        this.args = args
    }
    do_item (job_instance){
        let the_instruction = this
        this.args.callback = function(reco) {
            job_instance.user_data[the_instruction.args.user_data_variable_name] = reco
            inspect(reco)
            job_instance.set_up_next_do(1)
        }
        //this.args.job_instance = job_instance
        recognize_speech(this.args)
    }
    static finished(job_instance, reco){
        let the_instruction = job_instance.current_instruction()
        job_instance.user_data[the_instruction.args.user_data_variable_name] = reco
        inspect(reco)
        job_instance.set_up_next_do(1)
    }
    to_source_code(args){
        let this_indent = args.indent
        args        = jQuery.extend({}, arguments[0])
        args.indent = ""
        args.value = this.args
        return this_indent + "Human.recognize_speech(" + to_source_code(args) + ")"
    }
}*/

Instruction$1.human_speak = class human_speak extends Instruction$1{
    constructor (args){
        super();
        this.args = args;
    }
    do_item (job_instance){
       //delete this.args.wait //don't do because in case user has backwards go_to. Probably the extra arg
       //in this.args won't matter
       if (this.args.wait){
           this.args.callback = function (){
                job_instance.set_up_next_do(1);
           };
           speak(this.args);
           return
       }
       else { //don't wait for speak to be done to call the next instruction
           speak(this.args);
           job_instance.set_up_next_do(1);
       }
    }
    to_source_code(args){
        return args.indent + "Human.speak({"  +
            ((this.task == "") ? "" : ("task: " + to_source_code$1({value: this.task}) + ", ")) +
            ((this.title === undefined) ? "" : ("title: " + to_source_code$1({value: this.title})  + ", ")) +
            ((this.add_stop_button == true)         ? "" : ("add_stop_button: "     + this.add_stop_button  + ", ")) +
            ((this.dependent_job_names.length == 0) ? "" : ("dependent_job_names: " + to_source_code$1({value: this.dependent_job_names}) + ", ")) +
            ((this.x      == 200) ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200) ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400) ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400) ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

Instruction$1.human_task = class human_task extends Instruction$1{
    constructor ({task="",
                  title, //don't give this default of "" because we reserve that for when you want NO title.
                         //without passing this, or passing "undefined", you get a smart default including the job name and "Human Task"
                  add_stop_button=true,
                  dependent_job_names=[],
                  x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"}={}) {
        super();
        this.task    = task;
        this.add_stop_button     = add_stop_button;
        this.dependent_job_names = dependent_job_names;
        this.title   = title;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
    }
    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>";
        var buttons = '<center><input type="submit" value="Continue Job" title="Signify you are done with this task which\ncloses this dialog box and\ncontinues this job"/>&nbsp;';
        if (this.add_stop_button) { buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>'; }
        buttons += '</center>';
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Task";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        job_instance.set_status_code("waiting", "user on Human.task interaction.");
        show_window({job_name: job_instance.name,
                    content: this.task + "<p/>" + buttons + hidden,
                    callback: human_task_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color});
    }
    to_source_code(args){
        return args.indent + "Human.task({"  +
               ((this.task == "") ? "" : ("task: " + to_source_code$1({value: this.task}) + ", ")) +
               ((this.title === undefined) ? "" : ("title: " + to_source_code$1({value: this.title})  + ", ")) +
               ((this.add_stop_button == true)         ? "" : ("add_stop_button: "     + this.add_stop_button  + ", ")) +
               ((this.dependent_job_names.length == 0) ? "" : ("dependent_job_names: " + to_source_code$1({value: this.dependent_job_names}) + ", ")) +
               ((this.x      == 200) ? "" : ("x: " + this.x       + ", "   )) +
               ((this.y      == 200) ? "" : ("y: " + this.y       + ", "   )) +
               ((this.width  == 400) ? "" : ("width: "  + this.width   + ", "   )) +
               ((this.height == 400) ? "" : ("height: " + this.height  + ", "   )) +
               ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
               "})"
    }
};

var human_task_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    if(vals.clicked_button_value == "Continue Job") ; //the dialog closes automatically
    else if (vals.clicked_button_value == "Stop Job"){
        job_instance.stop_for_reason("interrupted", "In human_task, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
                    //creating the human_job, dep_job_names will now be [] so the below if hits but
                    //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && //if j_inst doesn't exist, just forget about it as it doesn't need to be stopped.
                              //without this check we'd pointlessly error.
                    !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_task, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                }
            }
        }
    }
    job_instance.set_up_next_do(1); //even for the case where we're stopping the job,
     //this lets the do_next_item handle finishing the job properly
};
module.exports.human_task_handler = human_task_handler;

Instruction$1.human_enter_choice = class human_enter_choice extends Instruction$1{
    constructor ({task="",
                  choices=[["Yes", true], ["No", false]],
                  show_choices_as_buttons=false,
                  one_button_per_line=false,
                  user_data_variable_name="choice",
                  dependent_job_names=[],
                  add_stop_button=true,
                  title, x=200, y=200, width=400, height=400,
                  background_color="rgb(238, 238, 238)"}={}) {
        super();
        this.task    = task;
        this.user_data_variable_name = user_data_variable_name;
        //this.choices                 = choices
        this.show_choices_as_buttons = show_choices_as_buttons;
        this.one_button_per_line     = one_button_per_line;
        this.add_stop_button         = add_stop_button;
        this.dependent_job_names     = dependent_job_names;
        this.title   = title;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
        this.choices = [];
        for (let choice of choices){  //put each choice into an array. If already an array. leave it as is.
            if (typeof(choice) == "string") { choice = [choice]; }
            if (Array.isArray(choice)) {  this.choices.push(choice); }
            else {dde_error("Human.enter_choice passed a choice that is not a string and not an array: " + choice);}
        }
        this.inserting_instruction = true;
    }
    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>\n" +
                      "<input type='hidden' name='user_data_variable_name' value='" + this.user_data_variable_name         + "'/>\n" +
                      "<input type='hidden' name='choices_string' value='" + JSON.stringify(this.choices)                  + "'/>\n";
        let select = "";
        let buttons;
        if (this.show_choices_as_buttons){
            for (var item of this.choices){
                select += "<input type='submit' style='background-color:#FFACB6;margin:4px;' value='" + item[0] + "'/> ";
                if (this.one_button_per_line) { select += "<br/>"; }
            }
            if(this.add_stop_button) {
                buttons = ' <center> <input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/> </center>';
            }
        }
        else { //show as menu items,the default because we can have more of them.
            select  = "<center><select name='choice'>";
            for (var item of this.choices){ select += "<option>" + item[0] + "</option>"; }
            select += "</select></center>";
            buttons = '<center><input type="submit" value="Continue Job" title="Close dialog box and\ncontinue this job"/>&nbsp;';
            if(this.add_stop_button) {
                buttons += ' <input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>';
            }
            buttons += "</center>";
        }
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Enter Choice";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        job_instance.set_status_code("waiting", "user on Human.enter_choice interaction.");
        show_window({job_name: job_instance.name,
                    content: this.task + "<br/>" + select + "<br/>" + buttons  + hidden,
                    callback: human_enter_choice_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color});
    }

    to_source_code(args){
        return args.indent + "Human.enter_choice({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.user_data_variable_name == "choice")      ? "" : ("user_data_variable_name: " + to_source_code$1({value: this.user_data_variable_name}) + ", ")) +
            ((this.show_choices_as_buttons == false)         ? "" : ("show_choices_as_buttons: " + this.show_choices_as_buttons                          + ", ")) +
            ((this.one_button_per_line == false)             ? "" : ("one_button_per_line: "     + this.one_button_per_line                              + ", ")) +
            ((this.choices.length == 0)                      ? "" : ("choices: "                 + to_source_code$1({value: this.choices})                 + ", ")) +
            ((this.add_stop_button == true)                  ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_enter_choice_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    if(vals.clicked_button_value == "Continue Job") { //means the choices are in a menu, not individual buttons
        //job_instance.user_data[vals.user_data_variable_name] = vals.choice
        human_enter_choice_set_var(job_instance, vals.choice, vals.choices_string, vals.user_data_variable_name);
    }
    else if (vals.clicked_button_value == "Stop Job"){
        job_instance.stop_for_reason("interrupted", "In human_enter_choice, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_choice, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                    return
                }
            }
        }
    }
    else { //individual choices are in buttons and the user clicked on one of them
        //job_instance.user_data[vals.user_data_variable_name] = vals.clicked_button_value
        human_enter_choice_set_var(job_instance, vals.clicked_button_value, vals.choices_string, vals.user_data_variable_name);
    }
    job_instance.set_up_next_do(1); //even for the case where we're stopping the job,
    //this lets the do_next_item handle finishing the job properly
};
module.exports.human_enter_choice_handler = human_enter_choice_handler;


var human_enter_choice_set_var = function (job_instance, choice_string, choices_string, user_data_variable_name){
    let choices = JSON.parse(choices_string);
    let choice_array;
    for(let a_choice_array of choices) {
        if (a_choice_array[0] == choice_string) {
            choice_array = a_choice_array;
            break;
        }
    }
    if (!choice_array) { shouldnt$1("human_enter_choice got choice_string of: " + choice_string +
        " that isn't in: " + choices);}
    if (choice_array.length == 1) { job_instance.user_data[user_data_variable_name] = choice_array[0]; }
    else {
        let val_src = choice_array[1];
        let val;
        if(typeof(val_src == "string")) {
            let fn = new Function("return (" + val_src + ")"); //create a new fn with no args and body of val_src
            val = fn.call(job_instance);
        }
        else { val = val_src; }
        if (!choice_array[2]) {
            job_instance.user_data[user_data_variable_name] = val;
        }
        else {
            Job$1.insert_instruction(val, {job: job_instance.name, offset:"after_program_counter"});
        }
    }
};

Instruction$1.human_enter_filepath = class human_filepath extends Instruction$1{
    constructor ({task="",
                  user_data_variable_name="a_filepath",
                  initial_value="",
                  add_stop_button = true,
                  dependent_job_names=[],
                  title, x=200, y=200, width=400, height=400,  background_color="rgb(238, 238, 238)"}={}) {
        super();
        this.task = task;
        this.user_data_variable_name = user_data_variable_name;
        this.initial_value           = initial_value;
        this.add_stop_button         = add_stop_button;
        this.dependent_job_names     = dependent_job_names;
        this.title   = title;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
    }

    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>" +
                      "<input type='hidden' name='user_data_variable_name' value='" + this.user_data_variable_name         + "'/>";
        var text_html = "<input type='file' name='choice' style='font-size:14px;'/>";

        var buttons = '<center><input type="submit" value="Continue Job" title="Close dialog box and\\ncontinue this job"/>&nbsp;';
        if (this.add_stop_button) buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>';
        buttons += '</center>';
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Enter Filepath";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        job_instance.set_status_code("waiting", "user on Human.enter_filepath interaction." );
        show_window({ job_name: job_instance.name,
                    content: this.task + "<br/>" + text_html + "<br/><br/>" + buttons + hidden,
                    callback: human_enter_filepath_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color}
        );
    }
    to_source_code(args){
        return args.indent + "Human.enter_file_path({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.initial_value == "")                      ? "" : ("initial_value: "           + to_source_code$1({value: this.initial_value})           + ", ")) +
            ((this.add_stop_button  == true)                 ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

function human_enter_filepath_handler(vals){
    var job_instance = Job$1[vals.job_name];
    if(vals.clicked_button_value == "Continue Job") { //means the choices are in a menu, not individual buttons
        job_instance.user_data[vals.user_data_variable_name] = vals.choice;
    }
    else if (vals.clicked_button_value == "Stop Job"){
        job_instance.stop_for_reason("interrupted", "In human_enter_filepath, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_filepath, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                    return
                }
            }
        }
    }
    job_instance.set_up_next_do(1); //even for the case where we're stopping the job,
    //this lets the do_next_item handle finishing the job properly
}
module.exports.human_enter_filepath_handler = human_enter_filepath_handler;


Instruction$1.human_enter_instruction = class human_enter_instruction extends Instruction$1{
    constructor ({task = "Enter a next instruction for this Job.",
                  instruction_type = "Dexter.move_all_joints",
                  instruction_args = "0, 0, 0, 0, 0",
                  add_stop_button = true,
                  dependent_job_names = [],
                  title, x=300, y=200, width=420, height=400,  background_color="rgb(238, 238, 238)"}={}) {
        super();
        this.task = task;
        this.instruction_type    = instruction_type;
        this.instruction_args    = instruction_args;
        this.dependent_job_names = dependent_job_names;
        this.add_stop_button     = add_stop_button;
        this.title   = title;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
        this.inserting_instruction = true;
    }

    make_instruction_options(){
        let result = "";
        let key_value_pairs = []; //Object.keys(Dexter.instruction_type_to_function_name_map).sort()
        for(let oplet of Object.keys(Dexter$1.instruction_type_to_function_name_map)){
           key_value_pairs.push([oplet, Robot$1.instruction_type_to_function_name(oplet)]);
        }
        key_value_pairs.sort(function(a, b){ return ((a[1] < b[1])? -1 : 1 ) });
        for (let pair of key_value_pairs){
            let oplet = pair[0];
            let name  = pair[1];
            let label    = name + " (" + oplet + ")";
            let sel_html = ((name == this.instruction_type) ? "selected" : "");
            let the_html = "<option " + sel_html + ">" + label + "</option>";
            result      += the_html;
        }
        return result
    }

    do_item (job_instance){
        if (!job_instance.enter_instruction_recording) { //don't always init as might have instructions from prev dialog in this set
             job_instance.enter_instruction_recording = [];
        }
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>";

        var type_html = '<span id="instruction_type" class="combo_box" style="display:inline-block;vertical-align:middle;width:235px;">' +
                        this.make_instruction_options() +
                        '</span>';
        let rs = job_instance.robot.robot_status;
        var immediate_do = '<b><i>&nbsp;or</i></b><fieldset style="margin-bottom:10px;margin-top:10px;background-color:#DDDDDD">' +
                           '<div style="margin-bottom:10px;"> <i title="'    +
                           'Find valid oplet letters at end of&#013;'        +
                           'each item in the Instruction type menu.&#013;'   +
                           "Type 'space' to create an 'a' instruction&#013;" +
                           "with joint angles from Dexter's current angles." +
                           '">Immediately do & record typed-in oplet</i>: ' +
                           '<input id="immediate_do_id" autofocus name="immediate_do" data-oninput="true" style="width:30px;"/></div>' +
                           '<span title="' + "Each letter you type into&#013;the above type-in box is recorded." +
                           '"><span style="font-size:12px;">Recorded instructions: ' +
                           '</span><span id="recorded_instructions_count_id">' + job_instance.enter_instruction_recording.length + '</span>' +
                           "</span>&nbsp;&nbsp;" +
                            '<input type="button" value="Save" title="Inserts the recorded instructions&#013;into the editor at the cursor,&#013;wrapped in a Job definition.&#013;Also erases (clears) the recording."/> &nbsp;'  +
                            '<input type="button" value="Clear" title="Erases all the instructions in the recording."/> &nbsp;' +
                            '<input type="button" value="Erase last" title="Erases just the last instruction recorded."/><br/>'   +
                            '<span style="font-size:12px;">' + job_instance.robot.name + " current angles: " +
                            rs[Dexter$1.J1_ANGLE] + ", " +
                            rs[Dexter$1.J2_ANGLE] + ", " +
                            rs[Dexter$1.J3_ANGLE] + ", " +
                            rs[Dexter$1.J4_ANGLE] + ", " +
                            rs[Dexter$1.J5_ANGLE] + "</span>" +
                           '</fieldset>';

        var args_html = "<input name='args' style='width:290px;' value='" + this.instruction_args + "'/>";
        var buttons =   '<input type="submit" value="Run instruction & reprompt"/><p/>' +
                        '<input type="submit" value="Continue this job without reprompting" title="Close dialog box and\ncontinue this job"/><p/>' +
            (this.add_stop_button ? '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>' : "");
        if (this.title === undefined) {
            this.title = "Job: " + job_instance.name + ", Human Enter Instruction";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        if(job_instance.robot instanceof Dexter$1){
            out(Dexter$1.robot_status_to_html(job_instance.robot.robot_status, "on job: " + job_instance.name), "black", true);
        }
        job_instance.set_status_code("waiting", "user on Human.enter_instruction interaction.");
        show_window({job_name: job_instance.name,
                    content: "<div style='margin-bottom:10px;'><i>" + this.task + "</i></div>" +
                              "Instruction type: " + type_html +
                              immediate_do +
                              "<div style='padding-left:95px;font-size:12px'><i>Separate args with a comma.</i></div>"  +
                              "Arguments: " + args_html + "<p/>"  +
                              buttons +
                              hidden ,
                    callback: human_enter_instruction_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color //having larger than 350 does not increase the number of combo box menu items shown.
                    });
        //setTimeout(function(){immediate_do_id.focus()}, 100) //always focus on immediate_do_id id because if user is in a loop using it, we might as well focus on it. No other widgets where focus would matter in this dialog
        //above line can't work because we're in sandbox where immediate_do_id is unbound
        immediate_do_id.focus();
    }

    to_source_code(args){
        return args.indent + "Human.enter_instruction({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.instruction_type == "Dexter.move_all_joints") ? "" : ("instruction_type: "    + to_source_code$1({value: this.instruction_type}) + ", ")) +
            ((this.instruction_args  == "0, 0, 0, 0, 0")     ? "" : ("instruction_args: "        + to_source_code$1({value: this.instruction_args}) + ", ")) +
            ((this.add_stop_button  == true)                 ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_enter_instruction_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    var hei_instance = job_instance.do_list[job_instance.program_counter];
    if(vals.clicked_button_value == "Stop Job"){
        job_instance.enter_instruction_recording = [];
        job_instance.stop_for_reason("interrupted", "In human_enter_instruction, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                let j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_instruction, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                    return
                }
            }
        }
        //close_window(vals.window_index) //not needed. this is a submit button
    }
    else if (vals.clicked_button_value == "Continue this job without reprompting") {
        job_instance.enter_instruction_recording = [];
        //close_window(vals.window_index) //not needed. this is a submit button
    }
    else if (vals.clicked_button_value == "Save") {
        let job_source_to_save = human_enter_instruction_job_source_to_save(job_instance);
        Editor.insert(job_source_to_save, "selection_end");
        job_instance.enter_instruction_recording = [];
        recorded_instructions_count_id.innerHTML =  "0";
        out("Human.enter_instruction: recorded instructions saved and cleared.", "purple", true);
        immediate_do_id.focus();
        return
    }
    else if (vals.clicked_button_value == "Clear") {
        job_instance.enter_instruction_recording = [];
        recorded_instructions_count_id.innerHTML =  "0";
        out("Human.enter_instruction cleared all recorded instructions.", "purple");
        immediate_do_id.focus();
        return
    }
    else if (vals.clicked_button_value == "Erase last") {
        let last_ins = job_instance.enter_instruction_recording.pop();
        if (last_ins){
            recorded_instructions_count_id.innerHTML = "" + job_instance.enter_instruction_recording.length;
            out("Human.enter_instruction erased the last previously recorded instruction of:<br/>" + stringify_value(last_ins),
                "purple");
        }
        else {
            out("There are no instructions in the recording to erase.", "red", true);
        }
        immediate_do_id.focus();
        return
    }

    else { //Run ins & reprompt" or "immediate_do
      let oplet, ins_type;
      if (vals.clicked_button_value == "immediate_do"){
          if (vals.immediate_do == "") {
              oplet = "a";
          }
          else {
              oplet = last(vals.immediate_do);
          }
          ins_type = oplet; //probably won't do any good as its hard to init the combo box to something other than one of its already named items.
          SW.close_window(vals.window_index);
          //console.log("in human_enter_instruction_handler after close_window")
      }
      else { //user clicked a submit button so don't need to close the window.
          ins_type = vals.instruction_type.trim();
          if (ins_type.length == 1){ oplet = ins_type; }
          else {
             oplet = ins_type.split("(")[1];
             oplet = oplet[0];
          }
      }
      let args = vals.args;
      let args_array = args.split(/,s*/); //the s* doesn't soak up the whitespace unfortunately
      if ((vals.clicked_button_value == "immediate_do") && (vals.immediate_do == "")){
          let rs = job_instance.robot.robot_status;
          args_array = make_ins$1(oplet, rs[Dexter$1.J1_ANGLE], rs[Dexter$1.J2_ANGLE],
                                rs[Dexter$1.J3_ANGLE], rs[Dexter$1.J4_ANGLE], rs[Dexter$1.J5_ANGLE]);
      }
      else {
          let new_array = make_ins$1(oplet);
          for (let i = 0; i < args_array.length; i++){
              new_array.push(parseFloat(args_array[i]));
          }
          args_array = new_array;
      }
      if (vals.clicked_button_value == "immediate_do"){
          let prefix = "Human.enter_instruction made instruction:";
          if (vals.immediate_do == ""){
              prefix = "Human.enter_instruction captured Dexter's joint angles for instruction:";
          }
          out(prefix + "<br/>" + stringify_value(args_array), "purple");
          job_instance.enter_instruction_recording.push(args_array);
          //don't to the above set_in_ui because the win is now closed, but the new count will show up when the window redisplays
      }
      let ins_name = ins_type.split(" ")[0];
      let new_human_instruction = Human.enter_instruction({task: hei_instance.task, instruction_type: ins_name, instruction_args: args, dependent_job_names: hei_instance.dependent_job_names});
      let new_ins_array = [args_array, new_human_instruction];
      job_instance.insert_instructions(new_ins_array);
      //job_instance.added_items_count[job_instance.program_counter] = 2 //now performed by insert_instructions
    }
    job_instance.set_up_next_do(1); //even for the case where we're stopping the job,
    //this lets the do_next_item handle finishing the job properly
};
module.exports.human_enter_instruction_handler = human_enter_instruction_handler;


var human_enter_instruction_job_source_to_save = function(job_instance){
    let instructions_src = "";
    let prefix = "";
    for (let ins of job_instance.enter_instruction_recording){
        let ins_src = "make_ins(";
        for (let i = Dexter$1.INSTRUCTION_TYPE; i < ins.length; i++){
            let val = stringify_value_sans_html(ins[i]);
            let arg_prefix = ((i == Dexter$1.INSTRUCTION_TYPE) ? "" : ", ");
            ins_src += arg_prefix + val;

        }
        ins_src += ")";
        instructions_src += prefix + ins_src;
        prefix = ",\n                   ";
    }
    let new_job_name = "recorded_from_" + job_instance.name;
    let result = '\n' +
'new Job({name: "' + new_job_name + '",\n' +
'         robot: Robot.' + job_instance.robot.name + ',\n' +
'         do_list: [' + instructions_src +
'\n                  ]})\n';
    return result + "Job." + new_job_name + ".start()\n"
};

Instruction$1.human_enter_number = class human_enter_number extends Instruction$1{
    constructor (  {task="",
                    user_data_variable_name="a_number",
                    initial_value=0,
                    min=0,
                    max=100,
                    step=1,
                    add_stop_button = true,
                    dependent_job_names=[],
                    title, x=200, y=200, width=400, height=400,  background_color="rgb(238, 238, 238)"}={}){
        if (initial_value < min) {
            dde_error("Human.enter_number passed an initial value: " + initial_value +
                      "<br/> that is less than the min value of: " + min);
        }
        else if (initial_value > max) {
            dde_error("Human.enter_number passed an initial value: " + initial_value +
                      "<br/> that is more than the max value of: " + max);
        }
        else {
            super();
            this.task = task;
            this.user_data_variable_name = user_data_variable_name;
            this.initial_value=initial_value;
            this.min = min;
            this.max = max;
            this.step = step;
            this.add_stop_button = add_stop_button;
            this.dependent_job_names = dependent_job_names;
            this.title   = title;
            this.x       = x;
            this.y       = y;
            this.width   = width;
            this.height  = height;
            this.background_color = background_color;
        }
    }
    
    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>" +
                      "<input type='hidden' name='user_data_variable_name' value='" + this.user_data_variable_name         + "'/>";

        var number_html  = "<table  style='border:none';border-collapse:collapse;>" +
                           "<tr><td style='border:none;float:right;'>max: </td><td>" + this.max + "</td></tr>" +
                           "<tr><td style='border:none;'>" + this.user_data_variable_name + " = </td><td>" +
                           "<input type='number' name='choice' style='width:100px;font-size:16px;' " +
                           "' value='" + this.initial_value +
                           "' min='"   + this.min +
                           "' max='"   + this.max +
                           "' step='"  + this.step +
                           "'/></td></tr>" +
                           "<tr><td style='border:none;float:right;'>min: </td><td>" + this.min + "</td></tr>" +
                           "</table>";
        var buttons = '<center><input type="submit" value="Continue Job" title="Close dialog box and\ncontinue this job"/>&nbsp;';
        if (this.add_stop_button) { buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>'; }
        buttons += '</center>';
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Enter Number";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        job_instance.set_status_code("waiting", "user on Human.enter_number interaction." );
        show_window({job_name: job_instance.name,
                    content: this.task + "<br/>" + number_html + "<br/>" + buttons + hidden,
                    callback: human_enter_number_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color});
    }
    to_source_code(args){
        return args.indent + "Human.enter_number({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.initial_value == 0)                       ? "" : ("initial_value: "           + to_source_code$1({value: this.initial_value})           + ", ")) +
            ((this.min           == 0)                       ? "" : ("min: "                     + to_source_code$1({value: this.min})                     + ", ")) +
            ((this.max           == 1000)                    ? "" : ("max: "                     + to_source_code$1({value: this.max})                     + ", ")) +
            ((this.step          == 1)                       ? "" : ("step: "                    + to_source_code$1({value: this.step})                    + ", ")) +
            ((this.add_stop_button  == true)                 ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_enter_number_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    if (vals.clicked_button_value != "Continue Job"){
        job_instance.stop_for_reason("interrupted", "In human_enter_number, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_number, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                    return
                }
            }
        }
        job_instance.set_up_next_do(1); //we're stopping this job as it has a stop_reason so let it stop normally
    }
    else { //Done if the_choice is in range
        let the_choice = parseFloat(vals.choice);
        let instruction_instance = job_instance.current_instruction();
        if(the_choice > instruction_instance.max) {
            alert("Job: " + job_instance.name + "\nhas a Human.enter_number instruction\nwhose entered value: " + the_choice +
                  ",\n is more than the maximum: " + instruction_instance.max + ".\nPlease pick a lower value.");
        job_instance.set_up_next_do(0);
        }
        else if(the_choice < instruction_instance.min) {
            alert("Job: " + job_instance.name + "\nhas a Human.enter_number instruction\nwhose entered value: " + the_choice +
                ",\n is less than the minimum: " + instruction_instance.min + ".\n Please pick a higher value.");
            job_instance.set_up_next_do(0);
        }
        else {
            job_instance.user_data[vals.user_data_variable_name] = the_choice;
            job_instance.set_up_next_do(1);
        }
    }
};
module.exports.human_enter_number_handler = human_enter_number_handler;


//beware: Human.enter_position returns an array of Dexter.follow_me AND an instance of this class.
Instruction$1.human_enter_position = class human_enter_position extends Instruction$1{
    constructor (  {task="Position Dexter&apos;s end effector<br/>to the position that you want to record,<br/>and click <b>Continue Job</b>.",
                    user_data_variable_name="a_position",
                    add_stop_button = true,
                    dependent_job_names=[],
                    title, x=200, y=200, width=400, height=400,  background_color="rgb(238, 238, 238)"}={}){
            super();
            this.task = task;
            this.user_data_variable_name = user_data_variable_name;
            this.add_stop_button = add_stop_button;
            this.dependent_job_names = dependent_job_names;
            this.title   = title;
            this.x       = x;
            this.y       = y;
            this.width   = width;
            this.height  = height;
            this.background_color = background_color;
            this.status = "not started";
            this.inserting_instruction = true;
    }

    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>" +
                      "<input type='hidden' name='user_data_variable_name' value='" + this.user_data_variable_name         + "'/>";

        var buttons = '<center><input type="submit" value="Continue Job" title="Capture position,\nclose dialog box and\ncontinue this job"/>&nbsp;';
        if (this.add_stop_button) { buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>'; }
        buttons += '</center>';
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Enter Position";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        job_instance.set_status_code("waiting", "user on Human.enter_position interaction.");
        show_window({job_name: job_instance.name,
                    content: this.task + "<br/>" + buttons + hidden,
                    callback: human_enter_position_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color});
    }
    to_source_code(args){
        return args.indent + "Human.enter_position({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.add_stop_button  == true)                 ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_enter_position_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    if (vals.clicked_button_value != "Continue Job"){
        job_instance.stop_for_reason("interrupted", "In human_enter_position, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_position, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                    return
                }
            }
        }
        job_instance.set_up_next_do(1); //we're stopping this job as it has a stop_reason so let it stop normally
    }
    else {
        let new_ins =
            [Dexter$1.get_robot_status,
             function(){
                 let xyz = job_instance.robot.joint_xyz();
                 job_instance.user_data[vals.user_data_variable_name] = xyz;
             },
             Dexter$1.set_keep_position
             ];
        job_instance.insert_instructions(new_ins);
        job_instance.set_up_next_do(1);
    }
};
module.exports.human_enter_position_handler = human_enter_position_handler;


Instruction$1.human_enter_text = class human_enter_text extends Instruction$1{
    constructor ({task="",
                    user_data_variable_name="a_text",
                    initial_value="",
                    line_count=1, //if 1, makes an input type=text. If > 1 makes a resizeable text area
                    add_stop_button = true,
                    dependent_job_names=[],
                    title, x=200, y=200, width=400, height=400,  background_color="rgb(238, 238, 238)"}={}) {
        super();
        this.task = task;
        this.user_data_variable_name = user_data_variable_name;
        this.initial_value = initial_value;
        this.line_count = line_count;
        this.add_stop_button = add_stop_button;
        this.dependent_job_names = dependent_job_names;
        this.title   = title;
        this.x       = x;
        this.y       = y;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
    }
    
    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>" +
                      "<input type='hidden' name='user_data_variable_name' value='" + this.user_data_variable_name         + "'/>";
        var text_html;
        if(this.line_count == 1){
            text_html = "<br/><input type='text' name='choice" +
                        "' size='50" +
                        "' value='" + this.initial_value +
                        "'style='font-size:14px;" +
                        "'/>";
        }
        else {
            text_html = "<br/><textarea name='choice" +
                        "' rows='" + this.line_count +
                        "' cols='50' style='font-size:14px;'>" +
                         this.initial_value +
                         "</textarea>";
        }
        var buttons = '<center><input type="submit" value="Continue Job"/>&nbsp;';
        if (this.add_stop_button) buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>';
        buttons += '</center>';
        if (this.title === undefined){
            this.title = "Job: " + job_instance.name + ", Human Enter Text";
            if (job_instance.robot instanceof Human){
                this.title = job_instance.name + " task for: " +  job_instance.robot.name;
            }
        }
        job_instance.set_status_code("waiting", "user on Human.enter_text interaction.");
        show_window({job_name: job_instance.name,
                    content: this.task + "<br/>" + text_html + "<br/><br/>" + buttons + hidden,
                    callback: human_enter_text_handler,
                    title: this.title,
                    x: this.x,
                    y: this.y,
                    width: this.width,
                    height: this.height,
                    background_color: this.background_color}
                    );
    }
    to_source_code(args){
        return args.indent + "Human.enter_text({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.initial_value == "")                      ? "" : ("initial_value: "           + to_source_code$1({value: this.initial_value})           + ", ")) +
            ((this.line_count    == 1)                       ? "" : ("line_count: "              + this.line_count                                       + ", ")) +
            ((this.add_stop_button  == true)                 ? "" : ("add_stop_button: "         + this.add_stop_button                                  + ", ")) +
            ((this.dependent_job_names.length == 0)          ? "" : ("dependent_job_names: "     + to_source_code$1({value: this.dependent_job_names})     + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x       + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y       + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width   + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height  + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_enter_text_handler = function(vals){
    var job_instance = Job$1[vals.job_name];
    if (vals.clicked_button_value != "Continue Job"){
        job_instance.stop_for_reason("interrupted", "In human_enter_text, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_enter_text, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                }
            }
        }
    }
    else { //Done
        var the_choice = vals.choice;
        job_instance.user_data[vals.user_data_variable_name] = the_choice;
    }
    job_instance.set_up_next_do(1); //even for the case where we're stopping the job,
    //this lets the do_next_item handle finishing the job properly
};
module.exports.human_enter_text_handler = human_enter_text_handler;


Instruction$1.human_notify = class human_notify extends Instruction$1{
    constructor ({task="",
                  window=true,
                  output_pane=true,
                  beep_count=0,
                  speak=false,
                  add_stop_button=true,
                  dependent_job_names = [],
                  //does not have x and y because those are automatically set to make
                  //multiple notify windows visible.
                  title,
                  close_same_titled_windows = false,
                  width=400, height=400,  background_color="rgb(238, 238, 238)"}={}) {

        super();
        this.task=task,
        this.window=window,
        this.output_pane=output_pane,
        this.beep_count=beep_count,
        this.add_stop_button = add_stop_button;
        this.dependent_job_names = dependent_job_names;
        this.speak=speak;
        this.title   = title;
        this.close_same_titled_windows = close_same_titled_windows;
        this.width   = width;
        this.height  = height;
        this.background_color = background_color;
    }
    
    do_item (job_instance){
        var hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.dependent_job_names) + "'/>";
        if (this.title === undefined){
            this.title = job_instance.name + ", Notification";
            if (job_instance.robot instanceof Human){
                this.title += " for: " +  job_instance.robot.name;
            }
        }
        else if (this.title == "") { this.title = "<span style='height:25px;'>&nbsp;</span>"; }
        var prefix = "<div style='font-size:11px;'>Presented at: " + new Date() + "<br/>" +
            "Instruction " + job_instance.program_counter +
            " of " + job_instance.do_list.length + "</div>";
        let buttons = "";
        if(this.add_stop_button) {
            buttons += '<center><input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/></center>';
        }
        if (this.window){
            show_window({job_name: job_instance.name,
                         content: prefix + "<br/>" + this.task + "<p/>" + buttons + hidden,
                         y: human_notify.get_window_y(), //do y first since it might cause reset of positions
                         x: human_notify.get_window_x(),
                         title:  this.title,
                         width:  this.width,
                         height: this.height,
                         background_color: this.background_color,
                         close_same_titled_windows: this.close_same_titled_windows,
                         callback: human_notify_handler
            });
        }
        if (this.output_pane){
            out(this.title + "<br/>" + prefix + this.task, "#951616");
        }
        var the_notifiy = this;
        beeps(this.beep_count,
             function(){if (the_notifiy.speak){
                             speak({speak_data: the_notifiy.title + ", " + the_notifiy.task});
             }});
        job_instance.set_up_next_do(1);
    }
    static get_window_x(){
        human_notify.window_x += 40;
        return window.outerWidth - 370 - human_notify.window_x
    }
    static get_window_y(){
        human_notify.window_y += 40;
        if (human_notify.window_y > (window.outerHeight - 300)){
            human_notify.window_x = 0;
            human_notify.window_y = 40;
        }
        return human_notify.window_y
    }
    to_source_code(args){
        return args.indent + "Human.notify({" +
            ((this.task == "")                               ? "" : ("task: "                    + to_source_code$1({value: this.task})                    + ", ")) +
            ((this.title === undefined)                      ? "" : ("title: "                   + to_source_code$1({value: this.title})                   + ", ")) +
            ((this.window      == true)                      ? "" : ("window: "                  + this.window                                           + ", ")) +
            ((this.output_pane == true)                      ? "" : ("output_pane: "             + this.output_pane                                      + ", ")) +
            ((this.beep_count  == 0)                         ? "" : ("beep_count: "              + this.beep_count                                       + ", ")) +
            ((this.speak       == false)                     ? "" : ("speak: "                   + this.speak                                            + ", ")) +
            ((this.x      == 200)                            ? "" : ("x: " + this.x              + ", "   )) +
            ((this.y      == 200)                            ? "" : ("y: " + this.y              + ", "   )) +
            ((this.width  == 400)                            ? "" : ("width: "  + this.width     + ", "   )) +
            ((this.height == 400)                            ? "" : ("height: " + this.height    + ", "   )) +
            ((this.background_color == "rgb(238, 238, 238)") ? "" : ("background_color: " + to_source_code$1({value: this.background_color}))) +
            "})"
    }
};

var human_notify_handler = function(vals){
    let job_instance = Job$1[vals.job_name];
    if ((vals.clicked_button_value === "Stop Job") && job_instance.is_active()){
        job_instance.stop_for_reason("interrupted", "In human_notify, user stopped this job.");
        var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
        //creating the human_job, dep_job_names will now be [] so the below if hits but
        //the for loop has nothing to loop over so nothing will be done.
        if (dep_job_names && Array.isArray(dep_job_names)){
            for (let j_name of dep_job_names){
                var j_inst = Job$1[j_name];
                if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                    j_inst.stop_for_reason("interrupted", "In human_notify, user stopped this job which is dependent on job: " + job_instance.name);
                    j_inst.set_up_next_do(0);
                }
            }
        }
    }
};


module.exports.human_notify_handler = human_notify_handler;

Instruction$1.human_notify.window_x = 0;
Instruction$1.human_notify.window_y = 0;

Instruction$1.human_show_window = class human_show_window extends Instruction$1{
    constructor (sw_lit_obj_args = {}) {
        super();
        this.win_index = null;
        this.sw_lit_obj_args = sw_lit_obj_args;
        this.user_data_variable_name = sw_lit_obj_args.user_data_variable_name;
        this.orig_callback = sw_lit_obj_args.callback;
    }

    do_item (job_instance){ //only gets called once, the first time this instr is run
        //this.sw_lit_obj_args.the_instruction_id = job_instance.do_list.indexOf(this)
        this.sw_lit_obj_args.job_name = job_instance.name;
        let hidden  = "<input type='hidden' name='dependent_job_names' value='" + JSON.stringify(this.sw_lit_obj_args.dependent_job_names) + "'/>";
        job_instance.set_status_code("waiting", "user on Human.show_window interaction.");
        //can't use a closure here bevause if its an anonymous fn, then it gets src code
        //saved in the show-window dom, and that has to get evaled in an env
        //that's not this one so closed over vars won't work.
        let content = this.sw_lit_obj_args.content;
        let buttons = '<center><input type="submit" value="Continue Job"/>&nbsp;';
        if (this.sw_lit_obj_args.add_stop_button) buttons += '<input type="submit" value="Stop Job" title="Close dialog box,\nstop this job and all dependent jobs."/>';
        buttons += '</center>';
        if(!content.includes("Continue Job")) { content += buttons + hidden; } //if I don't check, we'll add the buttons each time the job is restarted
        this.sw_lit_obj_args.content = content;
        this.sw_lit_obj_args.callback = human_show_window_handler;
        this.win_index = show_window(this.sw_lit_obj_args);
    }
    to_source_code(args){
        let extra_indent = ' '.repeat(37);
        return args.indent + "Human.show_window(\n" +
               to_source_code$1({indent: args.indent + extra_indent, value: this.sw_lit_obj_args}) + ")"
    }
};

var human_show_window_handler = function(vals){
    console.log("top of human_show_window_handler with is_submit of: " + vals.is_submit);
    const job_instance  = Job$1[vals.job_name];
    //delete vals.the_job_name
    const hsw_inst = job_instance.current_instruction(); //job_instance.do_list[vals.the_instruction_id]
    const cb = hsw_inst.orig_callback;
    if (cb) { cb.call(job_instance, vals); }
    if(vals.is_submit //|| //useful when running this job in the browser, and user clicks a submit button.
      //!SW.is_window_shown(vals.window_index) //too hard to support right now for browser
      //as requires finding out about browser state. todo  when more support for
      //modifying and discovering browser state is available.
      ){
        if (vals.clicked_button_value === "Stop Job"){
            job_instance.stop_for_reason("interrupted", "In human_show_window, user stopped this job.");
            var dep_job_names = JSON.parse(vals.dependent_job_names); //If the user did not pass in a dependent_job_names arg when
            //creating the human_job, dep_job_names will now be [] so the below if hits but
            //the for loop has nothing to loop over so nothing will be done.
            if (dep_job_names && Array.isArray(dep_job_names)){
                for (let j_name of dep_job_names){
                    var j_inst = Job$1[j_name];
                    if (j_inst && !j_inst.stop_reason){ //if j_inst is still going, stop it.
                        j_inst.stop_for_reason("interrupted", "In human_show_window, user stopped this job which is dependent on job: " + job_instance.name);
                        j_inst.set_up_next_do(0);
                    }
                }
            }
        }
        else { //continue the job
            //if windows is not shown, that means time to save its values in the job an let the job go to its next instruction
            job_instance.user_data[hsw_inst.sw_lit_obj_args.user_data_variable_name] = vals;
            job_instance.set_status_code("running");
            job_instance.set_up_next_do(1);
        }
    }
};
module.exports.human_show_window_handler = human_show_window_handler;


Instruction$1.if_any_errors = class if_any_errors extends Instruction$1{
    constructor (job_names=[], instruction_if_error=null) {
        super();
        this.job_names = job_names;
        this.instruction_if_error = instruction_if_error;
        this.inserting_instruction = true;
    }
    do_item (job_instance){
        for(let job_name of this.job_names){
            let j_inst = Job$1[job_name];
            if (j_inst){
                if ((j_inst.status_code == "errored") ||
                    (j_inst.status_code == "interrupted")){
                    let the_error_ins = this.instruction_if_error;
                    if (the_error_ins == null){
                        let message = "In job: " + job_instance.name +
                                      ", an instruction of type: Control.if_any_errors, " +
                                      "discovered that job: " + job_name + " has errored.";
                        the_error_ins =  Control.error(message);
                    }
                    job_instance.insert_single_instruction(the_error_ins);
                    break;
                }
            }
            else {
                job_instance.stop_for_reason("errored", "In job: " + job_instance.name +
                             ", an instruction of type: Control.if_any_errors<br/> " +
                             "was passed a job name of:  " + job_name + "<br/> that doesn't exist.");
                job_instance.set_up_next_do(0);
                return
            }
        }
        job_instance.set_up_next_do(1);
    }
    to_source_code(args){
        return args.indent + "Control.if_any_errors(" +
                              to_source_code$1({value: this.job_names}) + ", " +
                              to_source_code$1({value: this.instruction_if_error}) + ")"
    }
};

Instruction$1.include_job = class include_job extends Instruction$1{
    constructor (job_name, start_loc, end_loc) {
        super();
        if(job_name === undefined){
            dde_error("Control.include_job was not passed a <b>job_name</b> which is required.");
        }
        this.job_name = job_name;
        //It *might* be good to permit job_name to be a job obj, but
        //usually better to have it be a string and evaled at instruction executing time
        //to permit order of job defs in file to not matter.
        //MakeInstruction insertion of jobs depends on instruction executing time
        //for resolving of job_name
        this.start_loc = start_loc;
        this.end_loc = end_loc;
        this.inserting_instruction = true;
        }
    do_item (job_instance){
        let first_arg = this.job_name;
        let resolved_first_arg; //could be a job or an array of instructions
        let do_list_array_to_use;
        if(first_arg instanceof Job$1) {
            resolved_first_arg   = first_arg;
            do_list_array_to_use = first_arg.orig_args.do_list;
        }
        else if (Array.isArray(first_arg)) {
            resolved_first_arg   = first_arg;
            do_list_array_to_use = first_arg;
        }
        else if (typeof(first_arg == "string")){  // "Job.job_name"
            if(first_arg.startsWith("Job.")) {
                resolved_first_arg   = value_of_path$1(first_arg);
                if(!(resolved_first_arg instanceof Job$1)){
                    dde_error("Control.include_job's first argument: " + first_arg +
                              "<br/>resolved to: " + resolved_first_arg +
                              "<br/>but was expected to resolve to a Job instance.");
                }
                do_list_array_to_use = resolved_first_arg.orig_args.do_list;
            }
            else if (Job$1[first_arg]) { // "job name"
                resolved_first_arg   = Job$1[first_arg];
                do_list_array_to_use = resolved_first_arg.orig_args.do_list;
            }
            else if (first_arg.includes(".")){ //got a file path with an extension.
                if(file_exists(first_arg)){
                    let job_instances_in_file = Job$1.instances_in_file(first_arg);
                    if(job_instances_in_file.length > 0) {
                        resolved_first_arg   = job_instances_in_file[0];
                        do_list_array_to_use = resolved_first_arg.orig_args.do_list;
                    }
                    else { //maybe file src starts with var foo = an_array_of_instructions
                        let file_src = read_file(first_arg);
                        let result_obj = eval_js_part2(file_src, false); // warning: calling straight eval often doesn't return the value of the last expr in the src, but my eval_js_part2 usually does. //window.eval(file_src)
                        if(result_obj.error_message){
                           dde_error("Control.include_job's first argument: " + first_arg +
                                     "<br/>refers to an existing file but<br/>" +
                                     "that file contains the JavaScript error of:<br/>" +
                                     err.message);
                        }
                        let file_value = result_obj.value;
                        if (Array.isArray(file_value)) {
                            resolved_first_arg   = file_value;
                            do_list_array_to_use = file_value;
                        }
                        else if (file_value === undefined){ // if first expr in file is var foo = arrayof_instructions, use that
                            file_src = trim_comments_from_front(file_src);
                            if(file_src.startsWith("var ")){
                                let equal_sign_pos = file_src.indexOf("=");
                                if(equal_sign_pos == -1){
                                    dde_error("Control.include_job's first argument: " + first_arg +
                                              "<br/>refers to an existing file containing variable: " + var_name + ".<br/>" +
                                             "However, their is no equal sign after 'var'");
                                }
                                let var_name = file_src.substring(4, equal_sign_pos).trim();
                                let var_val = window[var_name];
                                if(Array.isArray(var_val)){
                                    resolved_first_arg   = var_val;
                                    do_list_array_to_use = var_val;
                                }
                                else {
                                    dde_error("Control.include_job's first argument: " + first_arg +
                                            "<br/>refers to an existing file containing variable: " + var_name + ".<br/>" +
                                            "However, the value is not an array of instructions, but rather:<br/>" +
                                            var_val);
                                }
                            }
                        }
                    }
                }
                else {
                    dde_error("Control.include_job's first argument: " + first_arg + " has a dot in it<br/>" +
                               "so it is presumed to be a file path<br/>" +
                               "but no such file exists.");
                }
            }
            else if (window[first_arg]) {
                resolved_first_arg = window[first_arg];
                if(!Array.isArray(resolved_first_arg)) {
                    dde_error("Control.include_job's first argument: " + first_arg + " is a variable<br/>" +
                              "but the value of the variable is not an array:<br/>" +
                               resolved_first_arg);
                }
                else {
                    do_list_array_to_use = resolved_first_arg;
                }
            }
            else {
                dde_error("Control.include_job, got a first argument of: " + first_arg +
                          "<br/>which is invalid because, although it is a string,<br/>" +
                          "it isn't a Job name, file name, nor variable name.");
            }
        } //end of first_arg is a string processing
        else {
            dde_error("Control.include_job, got a first argument of: " + first_arg +
                      "<br/>which is invalid because its not a Job, array, or string.");
        }
        //at this point either the above code errored, or we have
        //resolved_first_arg   set to a Job or a do_list array and
        //do_list_array_to_use set to an array
        if(Instruction$1.is_oplet_array(do_list_array_to_use)){
            dde_error("Control.include_job, got a first argument of: " + first_arg +
                      "<br/>but that resolved to an oplet array: " + do_list_array_to_use +
                      "<br/>which is not a valid array of instruction.<br/>" +
                      "If you wrap this oplet array in an outer array, it will be valid.");
        }
        else {//the base do list instructions to use are ready to go!
            let the_start_loc;
            let the_end_loc;
            if(resolved_first_arg instanceof Job$1){
                the_start_loc = ((this.start_loc === null) ? resolved_first_arg.orig_args.program_counter        : this.start_loc);
                the_end_loc   = ((this.end_loc   === null) ? resolved_first_arg.orig_args.ending_program_counter : this.end_loc);

                the_start_loc = resolved_first_arg.instruction_location_to_id(
                                         the_start_loc, undefined, undefined, true); //use orig do_list
                the_end_loc = resolved_first_arg.instruction_location_to_id(
                                         the_end_loc,   undefined, undefined, true); //use orig do_list
            }
            else {
                if(the_start_loc == null) { the_start_loc = 0; }
                if(the_end_loc   == null) { the_end_loc   = do_list_array_to_use.length; }
            }
            if(!is_non_neg_integer(the_start_loc)){
                dde_error("Control.include_job passed start_loc of: " + this.start_loc +
                          "<br/>but that resolved to: " +  the_start_loc +
                          "<br/>which is not a non-negative integer.");
            }
            else if(!is_non_neg_integer(the_end_loc)){
                dde_error("Control.include_job passed end_loc of: " + this.end_loc +
                          "<br/>but that resolved to: " +  the_end_loc +
                          "<br/>which is not a non-negative integer.");
            }
            else { //finally ready to do the actual work
                let instrs_to_insert = do_list_array_to_use.slice(the_start_loc, the_end_loc); //excludes the_end_loc
                job_instance.insert_instructions(instrs_to_insert);
                job_instance.set_up_next_do(1);
            }
        }
    }

    to_source_code(args){
        return args.indent + "Control.include_job(" +
            to_source_code$1({value: this.job_name}) + ")"
    }
};

Instruction$1.label = class label extends Instruction$1{
    //also job_names may or may not contain the name of the current job. It doesn't matter.
    constructor (name) {
        super();
        if (!name){
            dde_error("Instruction label has not been passed a name.");
        }
        this.name = name;
    }
    do_item (job_instance){
        job_instance.set_up_next_do(1);
    }
    toString(){ return this.name }
    to_source_code(args){
        return args.indent + "Control.label(" +
              to_source_code$1({value: this.name})  + ")"
    }
};

Instruction$1.loop = class loop extends Instruction$1{
    constructor (times_to_loop, body_fn) {
        super();
        this.times_to_loop          = times_to_loop;
        this.body_fn                = body_fn;
        this.iter_index             = -1;
        this.iter_total             = Infinity;
        this.times_to_loop_object   = null; //only used when times_to_loop is an object.
                                           //in that case, we use resolved_times_to_loop to hold
                                           //the array of own property names of the object,
                                           //and thus can use its length for iter_total,
                                           //and index into it to get the cur prop name
                                           //which we then use to llok up in times_to_loop_object
                                           //for the iter_val
        this.inserting_instruction = true;
        this.init_instruction();
    }
    //there is no do_items for loop. But this is similar. It does not call set_up_next_do,
    //which is done only in the Job.prototype.do_next_item section that handles loop
    //Returns an array of instructions to do for one iteration.
    //If on a normal iteration with more to come, the last inst returned will be a
    //go_to to this loop instruction. (and that go_to might be the ONLY instruction in the returned array)
    //else if null is returned, we're done with this loop.
    //the returned instruction array may contain a Control.break instruction that
    //ends this loop. That ending is handled in Job.prototype.do_next_item section that handles loop
    get_instructions_for_one_iteration(job_instance){ //strategy: compute:
        //1. iter_index, 2. iter_total,3. iter_val & iter_key, 4. instructions for this iteration & return them
        let fn_result = null;
        //compute  this.iter_total and this.resolved_time_to_loop
        if(this.resolved_times_to_loop === null){ //first time only
            this.iter_index = -1;
            if      (typeof(this.times_to_loop) == "boolean")  { this.resolved_times_to_loop = this.times_to_loop;} //leave iter_total at Infinity
            else if (is_non_neg_integer(this.times_to_loop))   { this.resolved_times_to_loop = this.times_to_loop; this.iter_total = this.resolved_times_to_loop;}
            else if (Array.isArray(this.times_to_loop))        { this.resolved_times_to_loop = this.times_to_loop; this.iter_total = this.resolved_times_to_loop.length;}
            else if (typeof(this.times_to_loop) == "object")   {
                this.times_to_loop_object = this.times_to_loop;
                this.resolved_times_to_loop = Object.getOwnPropertyNames(this.times_to_loop_object);
                this.iter_total = this.resolved_times_to_loop.length;
            }
            else if (typeof(this.times_to_loop) == "function"){
               fn_result = this.times_to_loop.call(job_instance, this.iter_index, undefined, undefined, undefined);
               if      (typeof(fn_result) == "boolean")        { this.resolved_times_to_loop = this.times_to_loop; } //leave iter_total at Infinity
               else if (typeof(fn_result) == "number"){
                   if(is_non_neg_integer(fn_result))           { this.resolved_times_to_loop = fn_result; this.iter_total = this.resolved_times_to_loop;}
                   else {
                       job_instance.stop_for_reason("errored", "Control.loop passed times_to_loop that returned a number: " +  fn_result +
                                                       "\n but it isn't a non-negative integer.");
                       return null
                   }
               }
               else if (Array.isArray(fn_result))              { this.resolved_times_to_loop = fn_result; this.iter_total = this.resolved_times_to_loop.length;}
               else if (typeof(fn_result) == "object")         {
                   this.times_to_loop_object = fn_result;
                   this.resolved_times_to_loop = Object.getOwnPropertyNames(this.times_to_loop_object);
                   this.iter_total = this.resolved_times_to_loop.length;
               }
               else if (typeof(fn_result) == "function")       { this.resolved_times_to_loop = fn_result;} //rare but possible. //leave iter_total at Infinity
               else { job_instance.stop_for_reason("errored", "Control.loop passed function for boolean_int_array_number but that function" +
                                "\n returned an invalid type: " + fn_result +
                                "\n It must return a boolean, non-negative integer, array, or function");
                      return null
               }
           }
           else { job_instance.stop_for_reason("errored", "Control.loop passed times_to_loop of:\n " +
                  this.times_to_loop +
                "\n but that is not one of the valid types of:\n boolean, non-negative integer, array, or function.");
                return null
           }
        } //end of special processing for first iteration.
          // the below code is run for all iterations including the first iteration.
        this.iter_index++; //First compute iter_index. no changes to iter_index after this.
        //compute iter_val & iter_key.  iter_index is computed at the top of this fn, iter_total computed just above
        let iter_val = undefined;
        let iter_key = this.iter_index; //valid for all times_to_loop types except object.
        if (this.resolved_times_to_loop === false) { //no iterations of this loop will happen
            this.init_instruction(); //ready for next start of this job
            return null
        }
        else if (this.resolved_times_to_loop === true){ iter_val = true; } //loop forever or until body_fn returns Control.break instruction
        else if(is_non_neg_integer(this.resolved_times_to_loop)){
            iter_val = this.iter_index;
        }
        else if (this.times_to_loop_object){ //must be before Array.isArray(this.resolved_times_to_loop)
            iter_key = this.resolved_times_to_loop[this.iter_index];
            iter_val = this.times_to_loop_object[iter_key];
        }
        else if (Array.isArray(this.resolved_times_to_loop)) {
             iter_val = this.resolved_times_to_loop[this.iter_index];
        }
        else if (typeof(this.resolved_times_to_loop) == "function"){
           if      (this.iter_index > 0) { fn_result = this.resolved_times_to_loop.call(job_instance, this.iter_index, this.iter_index, this.iter_total);}
           if      (fn_result === false) { //looping is over, Jim
               this.init_instruction(); //ready for next start of this job
               return null
           }
           else if (fn_result === true)  { iter_val = true; }
           else {
               job_instance.stop_for_reason("errored", "Control.loop passed a function to call to determine if another iteration should occur" +
                         "\n but that function returned: " + fn_result +
                         "\n however, only true and false are valid results.");
               return null
           }
       }
       else { shouldnt$1("Control.loop has an invalid this.resolved_times_to_loop of: " + this.resolved_times_to_loop);}
       if(this.iter_index >= this.iter_total) { //done looping but initialize so if the job is restarted, the loop will restart
            this.init_instruction(); //ready for next time this whole loop might be called.
            return null
       }
       else {//ok, finally compute instructions for this iteration
           let body_fn_result = this.body_fn.call(job_instance, this.iter_index, iter_val, this.iter_total, iter_key);
           if((body_fn_result === undefined) ||  (body_fn_result === null)){ //slight optimization
               body_fn_result = [];
           }
           else if(!Array.isArray(body_fn_result) ||
              Instruction$1.is_oplet_array(body_fn_result) ||
              Instruction$1.is_data_array(body_fn_result)
              ){
               body_fn_result = [body_fn_result]; //we must return a real array of instructions from this fn.
                                                 //below we add the go_to at the end.
           }
           //body_fn_result can legitimately be the empty array at this point.
           //it might also contain a Control.break instruction.
           let go_to_ins = new Instruction$1.go_to(job_instance.program_counter);
           body_fn_result.push(go_to_ins);
           return body_fn_result
       }
    }
    init_instruction(){
        this.resolved_times_to_loop = null;
    }
    //when called, pc of job_instance will (as of apr 2020 ) be to a Control.break instruction
    //Just search backwards for the first loop instruction and return its pc.
    //If job_instance.program_counter happens to be pointing at a loop,
    //its just returned.
    static pc_of_enclosing_loop(job_instance){
        let break_instr_id = job_instance.program_counter;
        for(let a_pc = break_instr_id; a_pc >=0; a_pc--){
            let a_ins = job_instance.do_list[a_pc];
            if(a_ins instanceof Instruction$1.loop) {
                let sub_instructions_under_loop = job_instance.total_sub_instruction_count(a_pc);
                let last_sub_instr_id = a_pc + sub_instructions_under_loop;
                if(break_instr_id <= last_sub_instr_id) { //then the break inst is a sub_ins of the loop at a_pc
                    return a_pc
                }
                //else we keep searching back up for the next loop up the do_list
            }
        }
        return null // not good. we didn't find an enclosing loop. this will become a warning.
    }
    to_source_code(args){
        return args.indent + "Control.loop(" +
            to_source_code$1({value: this.times_to_loop})  + ",\n" +
            to_source_code$1({value: this.body_fn}) +
            ")"
    }
};

Instruction$1.out = class Out extends Instruction$1{
    constructor (val="", color="black", temp=false, print_job_info=false) {
        super();
        this.val   = val;
        this.color = color;
        this.temp  = temp;
        this.print_job_info = print_job_info;
    }
    do_item (job_instance){
        let prefix = (this.print_job_info ? "Job: " + job_instance.name + ", instruction ID: " + job_instance.program_counter + ", Instruction type: IO.out<br/>" : "");
        let message = prefix + this.val;
        out(message, this.color, this.temp);
        job_instance.set_up_next_do(1);
    }
    toString() { return "IO.out of: " + this.val }
    to_source_code(args){
        return args.indent + "IO.out(" +
                to_source_code$1({value: this.val})  +
                ((this.color == "black") ? "" : (", " + to_source_code$1({value: this.color}))) +
                (this.temp ? (", " + to_source_code$1({value: this.temp})) : "") +
                ")"
    }
};

/*Obsoleted by just putting a phrase directly on the do_list
Instruction.play_notes = class play_notes extends Instruction{
    constructor (note_or_phrase) {
        super()
        if (typeof(note_or_phrase) == "string"){
            note_or_phrase = note_or_phrase.trim()
            if(note_or_phrase.includes(" ")){ //phrase
                   note_or_phrase = new Phrase({notes: note_or_phrase})
            }
            else { note_or_phrase = Note.n(note_or_phrase) }
        }
        this.note_or_phrase = note_or_phrase
    }
    do_item(job_instance){ //send all the notes on first call, then do a set_timeout of the overall dur to setup_next
        //works when note_or_phrase is either a note or a phrase
        this.note_or_phrase.play()
        //setTimeout(function(){
              job_instance.set_up_next_do(1, false, this.note_or_phrase.dur_in_seconds())
           // },
           // this.note_or_phrase.dur_in_ms())
    }
}*/

Instruction$1.send_to_job = class send_to_job extends Instruction$1{
    constructor ({//to_job_name     = "required",
                  do_list_item    = null, //can be null, a single instruction, or an array of instructions
                  where_to_insert = "required", //"next_top_level",
                  wait_until_done = false,
                  start           = false,
                  unsuspend       = false,
                  status_variable_name = null} = {}) {
        super();
        this.do_list_item    = do_list_item;
        this.where_to_insert = where_to_insert;
        this.wait_until_done = wait_until_done;
        this.start           = start;
        this.unsuspend       = unsuspend;
        this.status_variable_name = status_variable_name;
        this.already_sent_instruction = false; //used internally
        let params = arguments[0];
        if (!params.where_to_insert || (params.where_to_insert == "required")) { //the defaults listed above don't actually work
            //params.where_to_insert = "next_top_level"
            dde_error("Instruction send_to_job was not supplied with a 'where_to_insert' instruction location.");
        }
        copy_missing_fields(params, this);
        this.inserting_instruction = true;
    }

    do_item (job_instance){ //job_instance is the "from" job
        this.from_job_name       = job_instance.name;
        this.from_instruction_id = job_instance.program_counter;
        if (!this.already_sent_instruction) { //only excute this code once per send_to_job instance
            if (this.status_variable_name){
             job_instance.user_data[this.status_variable_name] = "sent";
            }
            this.destination_do_send_to_job(job_instance); //this COULD be just a json obj of name value pairs. Don't really need the whole instance here.
                                                         //if we need to send to a job on another computer, convert to that json obj.
            this.already_sent_instruction = true;
        }
        if(this.wait_until_done){
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter;
            //don't do the below because the to_job will, when its inserted instr is done,
            //call from_job.send_to_job_receive_done which will call set_up_next_do(1)
           // job_instance.set_up_next_do(0) //a rare place I pass 0 here!
                      //since this is not going through robot_done_with_instruction
        }
        else {
            job_instance.set_up_next_do(1);
        }
    }
    to_source_code(args){
        return args.indent + "Control.send_to_job({" +
            ((this.do_list_item == null)          ? "" :  ("do_list_item: "         + to_source_code$1({value: this.do_list_item})                 + ", ")) +
            ((this.where_to_insert === undefined) ? "" :  ("where_to_insert: "      + to_source_code$1({value: this.where_to_insert})      + ", ")) +
            ((this.wait_until_done === false)     ? "" :  ("wait_until_done: "      + to_source_code$1({value: this.wait_until_done})      + ", ")) +
            ((this.start === false)               ? "" :  ("start: "                + to_source_code$1({value: this.start})                + ", ")) +
            ((this.unsuspend === false)           ? "" :  ("unsuspend: "            + to_source_code$1({value: this.unsuspend})            + ", ")) +
            ((this.status_variable_name == null)  ? "" :  ("status_variable_name: " + to_source_code$1({value: this.status_variable_name}) )) +
            "})"
    }

            //fns prefixed with destination are run on the to_job.
//"this" is the send_to_job instruction instance
//This fn is not a user fn and is not an instruction for a do_list.
    destination_do_send_to_job(from_job_instance){
        let params = this;
        var to_job_instance = Job$1.instruction_location_to_job(params.where_to_insert, false);
        if (!to_job_instance) { to_job_instance = from_job_instance; }
        if (to_job_instance === from_job_instance) { this.wait_until_done = false; } //when a job is inserting code into itself,//we don't want it to hang waiting for itself.

        //first, add destination_send_to_job_is_done to do_items if need be.
        let do_items = params.do_list_item;
        var notify_item = null;
        if (params.wait_until_done){
            //var send_back_obj = {from_job_name:        params.from_job_name,
            //                     from_instruction_id:  params.from_instruction_id,
            //                     status_variable_name: params.status_variable_name
            //                    }
            var notify_item = new Instruction$1.destination_send_to_job_is_done(params);
            //notify_item is appeneded to the end of do_items, and the whole array of instructions
            //stuck into the destination job's do_list
            if (do_items == null){
                do_items = notify_item;
            }
            else if (Instruction$1.is_oplet_array(do_items)){
                if(notify_item){
                    do_items = [do_items,  notify_item];
                }
            }
            else if (Instruction$1.is_instructions_array(do_items)){
                if(notify_item){
                    do_items = do_items.slice(0).push(notify_item);
                }
            }
            else { //typically a function.
                if(notify_item){
                    do_items = [do_items,  notify_item];
                }
            }
        }
        // next, bundle do_items into a sent_from_job instruction and stick it on the to_job
        let sfj_ins = new Instruction$1.sent_from_job({do_list_item: do_items,
                                                     from_job_name: from_job_instance.name,
                                                     from_instruction_id: from_job_instance.program_counter,
                                                     where_to_insert: params.where_to_insert, //just for debugging
                                                     wait_until_done: params.wait_until_done //just for debugging
                                                    });
        Job$1.insert_instruction(sfj_ins, params.where_to_insert); //must do before starting or unsuspending
        if (to_job_instance.status_code == "not_started"){
            if(params.start){
                to_job_instance.start(); //{initial_instruction: sfj_ins} //commented out because its redunant with insert_instruction and would put sfj_ins on to_job twice

            }
        }
        if (to_job_instance.status_code == "suspended"){
            if(params.unsuspend){
                to_job_instance.unsuspend();
                //this.set_up_next_do(1) //don't do this because unsuspend does it.
            }
        }
        //don't do this as to_job should already be running.
        //else{
        //    to_job_instance.set_up_next_do(1)
        //}
    }
};

Instruction$1.send_to_job.param_names = ["do_list_item",    "where_to_insert",
                                               "wait_until_done", "start",
                                               "unsuspend",       "status_variable_name",
                                               "from_job_name",   "from_instruction_id",
                                                "already_sent_instruction"];

//user's never create this directly, but an instance of this is created by destination_do_send_to_job
//and stuck on the to_job do_list.
Instruction$1.destination_send_to_job_is_done = class destination_send_to_job_is_done extends Instruction$1{
    constructor (params){
        super();
        this.params = params;
    }
    do_item(job_instance){ //job_instance is the "to" job
        var from_job_instance = Job$1[this.params.from_job_name];
        for (var user_var of Object.getOwnPropertyNames(this.params)){ //we can have multiple user_data vars that we set. The vars arae set in the sending job
            if(Instruction$1.send_to_job.param_names.indexOf(user_var) == -1){ //if its not one of the regular paranms. that means its the name of a user_data var to set in the from_job_instance
                var fn = this.params[user_var];
                if (typeof(fn) == "function"){
                    var val = fn.call(job_instance);
                    from_job_instance.user_data[user_var] = val;  //this.params is really the to_job_instance.
                }
                else {
                    job_instance.stop_for_reason("errored", "In job: " + job_instance.name +
                        " Instruction.destination_send_to_job_is_done.do_item got user var: " + user_var +
                        " whose value: " + fn + " is not a function.");
                    return
                }
            }
        }
        from_job_instance.send_to_job_receive_done(this.params);
        job_instance.set_up_next_do(1);
    }
};

//an instance of this instr is stuck on the to_job by instr send_to_job
Instruction$1.sent_from_job = class sent_from_job extends Instruction$1{
    constructor ({do_list_item       = null, //can be null, a single instruction, or an array of instructions
                 from_job_name       = "required",
                 from_instruction_id = "required",
                 where_to_insert     = "next_top_level", //just for debugging
                 wait_until_done     = null //just for debugging
                } = {}) {
        super();
        let params = arguments[0];
        if (!params.where_to_insert) { //the defaults listed above don't actually work
            params.where_to_insert = "next_top_level";
        }
        copy_missing_fields(params, this);
        this.inserting_instruction = true;
    }

    do_item (job_instance){
        if (Instruction$1.is_oplet_array(this.do_list_item) ||
            !Array.isArray(this.do_list_item)){
            job_instance.insert_single_instruction(this.do_list_item);
        }
        else { //we've got more than 1 instr to insert.
            job_instance.insert_instructions(this.do_list_item);
        }
        job_instance.set_up_next_do(1);
    }
};

Instruction$1.set_inter_do_item_dur = class set_inter_do_item_dur extends Instruction$1{
    constructor ({dur = null, //can be null, a single instruction, or an array of instructions
                  instructions_array = []
                  } = {}) {
        super();
        if(dur == null) ; //ok
        else if(typeof(dur) == "number"){
            if(dur >= 0) ; //ok
            else if([-1. -2, -3].includes(dur)) ; //ok
            else {
                dde_error("Control,.inter_do_item_dur passed invalid dur of: " + dur +
                    "<br/>Valid values are only: null, non-neg number, -1, -2, -3.");
            }
        }
        this.dur = dur;
        this.instructions_array = instructions_array;
    }

    do_item (job_instance){
        if(this.instructions_array.length == 0){
            if(this.dur != null) {
                job_instance.prev_inter_do_item_dur = job_instance.inter_do_item_dur; //cache for when another instance of this insturcgtion is called with dur == null
                job_instance.inter_do_item_dur = this.dur;
            }
            else { //restores the previous inter_do_item_dur if any
                if(job_instance.hasOwnProperty("prev_inter_do_item_dur")) {
                    job_instance.inter_do_item_dur = job_instance.prev_inter_do_item_dur;
                } //just leave whatever the existing inter_do_item_dur.
                        //if this cause is reached, its probably a programmer mistake.
                        //BUT we don't want to error, as errors in this code that
                        //might be running in an intolerant-to-errors mode, aren't good,
                        //so just let it go.
            }
        }
        //we have an instruction array
        else if (this.dur == null) { //unusual and not much point, but allow
            job_instance.insert_instructions(this.instructions_array);
        }
        else { //normal. We have a dur and an instruction array.
            let prev_inter_do_item_dur = job_instance.inter_do_item_dur;
            job_instance.inter_do_item_dur = this.dur;
            this.instructions_array.push(function(){
                                            job_instance.inter_do_item_dur = prev_inter_do_item_dur;
                                         });
            job_instance.insert_instructions(this.instructions_array);
        }
        job_instance.set_up_next_do(1);
    }
};


Instruction$1.start_job = class start_job extends Instruction$1{
    constructor (job_name, start_options={}, if_started="ignore", wait_until_job_done=false) {
        if(!["ignore", "error", "restart"].includes(if_started)){
            dde_error("Control.start_job has invalid value for if_started of: " +
                       if_started +
                       '<br/>Valid values are: "ignore", "error", "restart"');
        }
        if(![true, false].includes(wait_until_job_done)){
            dde_error("Control.start_job has invalid value for wait_until_job_done of: " +
                if_started +
                '<br/>Valid values are: true and false');
        }
        super();
        if(job_name === undefined){
            dde_error("start_job was not passed a <b>job_name</b> which is required.");
        }
        if((typeof(job_name) != "string") && !(job_name instanceof Job$1)){
            dde_error("start_job was passed an invalid <b>job_name</b> of: " + job_name + "<br/>" +
                      "It must be a Job instance,<br/>the string of a Job name<br/>" +
                      "or the string of a file containing a Job definition.");
        }
        this.job_name      = job_name;
        this.start_options = start_options;
        this.if_started    = if_started;
        this.wait_until_job_done = wait_until_job_done;
        this.job_to_start = null;
        this.on_first_call_to_do_item = true;
    }
    do_item (job_instance){
        if(!this.job_to_start) {
            if (this.job_name instanceof Job$1) { this.job_to_start = this.job_name; }
            else if(typeof(this.job_name) == "string") {
                if (this.job_name.startsWith("Job.")) { this.job_to_start = value_of_path$1(this.job_name); }
                else if (Job$1[this.job_name]) {  this.job_to_start = Job$1[this.job_name]; }
                else if(file_exists(this.job_name)) {
                    let jobs_in_file = Job$1.instances_in_file(this.job_name);
                    if(jobs_in_file.length > 0) { this.job_to_start = jobs_in_file[0]; }
                    else {
                        dde_error("Control.start_job has a job_name that's a path to an existing file: " + this.job_name + "<br/>" +
                                  "but that file doesn't define any jobs.");
                    }
                }
                else {
                    dde_error("Control.start_job has a job_name of: " + this.job_name +
                              "<br/>but it doesn't resolve to a Job or a file containing one.");
                }
            }
            if(!(this.job_to_start instanceof Job$1)){
                job_instance.stop_for_reason("errored", "Control.start_job attempted to start non-existent Job." + this.job_name);
                job_instance.set_up_next_do(0);
            }
        }
        //this.job_to_start has a valid job instance in it
        const stat = this.job_to_start.status_code;
        if (this.wait_until_job_done) {
             if ((stat == "not_started") || ((stat == "completed") && this.on_first_call_to_do_item))   {
                 this.on_first_call_to_do_item = false;
                job_instance.set_status_code("waiting", "This job waiting for " + this.job_to_start.name + " to complete.");
                this.job_to_start.start(this.start_options);
                job_instance.set_up_next_do(0);
                return
             }
             else if (stat == "completed"){ //all done with successful runnning of job_to_start
                 job_instance.wait_reason = null;
                 job_instance.stop_reason = null;
                 this.on_first_call_to_do_item = true; //in case this job is inside a loop, prepare for next iteration
                 job_instance.set_status_code("running");
                 job_instance.set_up_next_do(1);
                 return
             }
             else if(["starting", "running", "stopping", "running_when_stopped"].includes(stat)) {
                let wait_reason = "Control.start_job waiting at instruction " +
                                          job_instance.program_counter + " for " + this.job_to_start.name + " to complete.";
                job_instance.set_status_code("waiting", wait_reason);
                job_instance.set_up_next_do(0);
                return
             }
             else if(stat == "waiting") {
                 let wait_reason = "Control.start_job waiting at instruction " +
                     job_instance.program_counter + " for " + this.job_to_start.name + " to complete,\n" +
                      "but its now waiting for: " + this.job_to_start.wait_reason;
                 job_instance.set_status_code("waiting", wait_reason);
                 job_instance.set_up_next_do(0);
                 return
             }
             else if (stat == "suspended")   {
                    this.job_to_start.unsuspend();
                    let wait_reason = "Control.start_job waiting at instruction " +
                        job_instance.program_counter + " for " + this.job_to_start.name + " to complete.";
                    job_instance.set_status_code("waiting", wait_reason);
                    job_instance.set_up_next_do(0);
                    return
             }
             else if (stat == "errored")   {
                let stop_reason = "This job stopped because the job it is waiting for, " +
                                            this.job_to_start.name + " has errored with: " +
                                            this.job_to_start.stop_reason;
                job_instance.set_status_code("errored", stop_reason);
                job_instance.set_up_next_do(1);
                return
             }
             else if (stat == "interrupted")   {
                let stop_reason = "This job stopped because the job it is waiting for, " +
                                  this.job_to_start.name + " was interrupted with: " +
                                  this.job_to_start.stop_reason;
                job_instance.set_status_code("interrupted", stop_reason);
                job_instance.set_up_next_do(1);
                return
             }
        }
        //below here. we're not waiting until this.job_to_start is done.
        else if (stat == "starting")    { job_instance.set_up_next_do(1); } //just let continue starting
        else if (stat == "suspended")   {
            this.job_to_start.unsuspend();
            job_instance.set_up_next_do(1);
        }
        else if (["running", "waiting", "stopping", "running_when_stopped"].includes(stat)){
           if     (this.if_started == "ignore") {job_instance.set_up_next_do(1);}
           else if(this.if_started == "error") {
               job_instance.stop_for_reason("errored",
                    "Robot_start_job tried to start job: " + this.job_name +
                    " but it was already started.");
               job_instance.set_up_next_do(0);
               return
           }
           else if (this.if_started == "restart"){
               this.job_to_start.stop_for_reason("interrupted",
                  "interrupted by start_job instruction in " + job_instance.name);
               setTimeout(function(){ this.job_to_start.start(this.start_options);   },
                          this.job_to_start.inter_do_item_dur * 2);
               job_instance.set_up_next_do(1);
           }
           else { //if_started is tested for validity in the constructor, but just in case...
               shouldnt$1("Job." + job_instance.name +
                 " has a Control.start_job instruction with an invalid " +
                 "<br/> if_started value of: " + this.if_started);
           }
        }
        else if (["not_started", "completed", "errored", "interrupted"].includes(stat)) {
           this.job_to_start.start(this.start_options);
            job_instance.set_up_next_do(1);
        }
        else {
            shouldnt$1("Control.start_job got a status_code from Job." +
                      this.job_to_start.name + " that it doesn't understand.");
        }
    }
    toString(){
        return "start_job: " + this.job_name
    }
    to_source_code(args){
        return args.indent + "Control.start_job(" +
            to_source_code$1({value: this.job_name})  +
            (similar(this.start_options, {}) ? "" : (", " + to_source_code$1({value: this.start_options}))) +
            ((this.if_started == "ignore")   ? "" : (", " + to_source_code$1({value: this.if_started}))) +
            ")"
    }
};

Instruction$1.stop_job = class stop_job extends Instruction$1{
    constructor (instruction_location="program_counter", //do not make this be able to be a job instance because we want the dynamic lookup of the job to stop by name that's in the instruction_location
                 stop_reason=null,
                 perform_when_stopped=true) {
        super();
        this.instruction_location = instruction_location;
        this.stop_reason = stop_reason;
        this.perform_when_stopped = perform_when_stopped;
    }
    do_item (job_instance){
        //this is not an error or interrupted, its a normal stoppage of the job.
        var job_to_stop = Job$1.instruction_location_to_job(this.instruction_location, false);
        //job_to_stop might or might not be the same as job_instance
        if (!job_to_stop) { job_to_stop = job_instance; }
        //don't set stop_reason here. Its set in do_next_item from the pc being equal to the ending_program_counter
        //let the_stop_reason
        //if(this.stop_reason) { the_stop_reason = this.stop_reason }
        //else { the_stop_reason = "Stopped by Job." + job_instance.name + "the  instruction: Control.stop_job."s when_stopped instruction
        //job_to_stop.stop_for_reason("completed", the_stop_reason) //don't do as we only want it to stop when it gets to location
        let the_stop_msg = this.stop_reason;
        if(!the_stop_msg) {
            the_stop_msg = "A Control.stop_job instruction was run.";
        }
        warning("Stopping Job." + job_to_stop.name + " for reason: " + the_stop_msg);
        job_to_stop.when_stopped_conditions = this.perform_when_stopped; //the stop_job instruction overrules the job def's when_stopped_conditions
        job_to_stop.ending_program_counter = this.instruction_location;
        job_to_stop.when_do_list_done = "run_when_stopped"; //if I don't do this, and its value is "wait", the job will wait forever.
        if(!this.perform_when_stopped) {
            job_to_stop.when_stopped = "stop";
        }
        job_instance.set_up_next_do(); //continue on with the current job.
            //if the current job is the same as the job_to_stop, fine, it will stop
            //else the job_to_stop will stop of its own accord now that it has a status of "completed",
            // and the current job (job_instance) will continue on to its next instruction.
    }
    toString(){
        var job_to_stop = Job$1.instruction_location_to_job(this.instruction_location, false);
        if (!job_to_stop) { job_to_stop = " containing this instruction"; }
        else              { job_to_stop = ": Job." + job_to_stop.name; }
        return "stop_job" + job_to_stop + " because: " + this.stop_reason
    }
    to_source_code(args){
        let indent = ((args && args.indent) ? args.indent : "");
        let props_args = args        = jQuery.extend({}, arguments[0]);
        props_args.indent = "";
        props_args.value = this.instruction_location;
        let loc_src = to_source_code$1(props_args);
        props_args.value = this.stop_reason;
        let sr_src = to_source_code$1(props_args);
        props_args.value = this.perform_when_stopped;
        let pws_src = to_source_code$1(props_args);
        let result = indent +
                     "Control.stop_job(" +
                     loc_src + ", " +
                     sr_src          + ", " +
                     pws_src +
                     ")";
        return result
    }
};

Instruction$1.suspend = class suspend extends Instruction$1{
    constructor (job_name = null, reason = "") {
        super();
        if (job_name instanceof Job$1) { job_name = job_name.name; }
        this.job_name = job_name;
        this.reason   = reason;
    }
    do_item (job_instance){
        let job_to_suspend = this.job_name;
        if (!job_to_suspend) { job_to_suspend = job_instance; }
        else if (typeof(job_to_suspend) == "string") { job_to_suspend = Job$1[job_to_suspend]; }
        if (!job_to_suspend instanceof Job$1) {
           job_instance.stop_for_reason("error", "suspend attempted to suspend job: " + job_to_suspend + " but that isn't a job.");
           job_instance.set_up_next_do(1);
           return
        }
        else {
            job_to_suspend.suspend(this.reason);
            if (job_to_suspend !== job_instance) { job_instance.set_up_next_do(1); }
            //else, it doesn't send a set_up_next_do which causes the job to  be suspended.
        }
    }
    to_source_code(args){
        return args.indent + "Control.suspend(" +
            to_source_code$1({value: this.job_name}) +
            ((this.reason == "") ? "" : (", " + to_source_code$1({value: this.reason})))  +
            ")"
    }
};

Instruction$1.unsuspend = class unsuspend extends Instruction$1{
    constructor (job_name = "required", stop_reason=false) {
        super();
        if(job_name == "required"){
            dde_error("unsuspend not given a job name to unsuspend. A job cannot unsuspend itself.");
        }
        if (job_name instanceof Job$1) { job_name = job_name.name; }
        this.job_name = job_name;
        this.stop_reason = stop_reason;
    }
    do_item (job_instance){
        let job_to_unsuspend = this.job_name;
        if (typeof(job_to_unsuspend) == "string") { job_to_unsuspend = Job$1[job_to_unsuspend]; }
        if (!(job_to_unsuspend instanceof Job$1))      {
            job_instance.stop_for_reason("errored", "unsuspend attempted to unsuspend job: " + this.job_name + " but that isn't a job.");
        }
        else if (job_to_unsuspend == job_instance) { shouldnt$1("unsuspend instruction attempting to unsuspend itself.: " + this.job_name); }
        else if (job_to_unsuspend.status_code == "suspended"){
            job_to_unsuspend.unsuspend(this.stop_reason);
        }
        else ; //if job_to_unsuspend is not suspended, do nothing
        job_instance.set_up_next_do(1);

    }
    to_source_code(args){
        return args.indent + "Control.unsuspend(" +
            to_source_code$1({value: this.job_name}) +
            ")"
    }
};

Instruction$1.sync_point = class sync_point extends Instruction$1{
        //permit an empty array for job_names. We might be getting such an array from some computation
        //that legitimately has no items. Allow it. Then when this instruction's do_item is called,
        //it will always be in_sync and proceed. Empty job_names also useful for send_to_job
        //where_to_insert labels.
        //also job_names may or may not contain the name of the current job. It doesn't matter.
        constructor (name, job_names=[]) {
            super();
            if (!name){
                dde_error("Instruction sync_point has not been passed a name.");
            }
            this.name = name;
            this.job_names = job_names;
            this.inserted_empty_instruction_queue = false;
        }
    do_item (job_instance){
        if ((job_instance.robot instanceof Dexter$1) &&
            (this.inserted_empty_instruction_queue == false) &&
            (this.job_names.length > 0) &&
            ((this.job_names.length > 1)  || //must contain a job other than itself
            (this.job_names[0] != job_instance.name))){ //the one job name its got is not job_instance so we've got to flush the instruction_queue
            let instruction_array = Dexter$1.empty_instruction_queue();
            //   job_instance.do_list.splice(job_instance.program_counter, 0, instruction_array); //before really testing th sync point, first empty the queue. We only need to do this the first time this do_item is called.
            //   job_instance.added_items_count.splice(this.program_counter, 0, 0);
            //job_instance.insert_single_instruction(instruction_array) //don't call because this inserts AFTER PC, not at it.
            //Job.insert_instruction(instruction_array, {job: job_instance, offset: "program_counter"})
            this.send(instruction_array);
            this.inserted_empty_instruction_queue = true;
            job_instance.set_up_next_do(0); //go and do this empty_instruction_queue instruction, and when it finally returns, do the sync_point proper that is the next instruction
        }
        else {
            for(let job_name of this.job_names){
                if (job_name != job_instance.name){ //ignore self
                    var j_inst = Job$1[job_name];
                    if(!j_inst){
                        job_instance.stop_for_reason("errored",
                            "Job." + job_instance.name +
                            " has a sync_point instruction that has a job-to-sync-with named: " + job_name +
                            " which is not defined.");
                        return;
                    }
                    else if(!j_inst.is_active()) { //perhaps not_started, perhaps done (but might be restarted).
                        let wait_reason = "Job." + j_inst.name + " to get to sync_point named: " + this.name +
                                          "\nbut that Job has status: " + j_inst.status_code;
                        job_instance.set_status_code("waiting", wait_reason);
                        job_instance.set_up_next_do(0);
                        return
                    }
                    else {
                        if (j_inst.at_or_past_sync_point(this.name)){ continue; } //good. j_inst is at the sync point.
                        //beware that j_inst *could* be at a sync point of a different name, and if so,
                        //let's hope there's a 3rd job that it will sync with to get it passed that sync point.
                        else { //j_inst didn't get to sync point yet
                            let wait_reason = "Job." + j_inst.name + " to get to sync_point named: " + this.name;
                            job_instance.set_status_code("waiting", wait_reason);
                            job_instance.set_up_next_do(0);
                            return; //we have not acheived sync, so just pause job_instance, in hopes
                                    //that another job will be the last job to reach sync and cause job_instance
                                    //to proceed.
                        }
                    }
                }
            }
            //made it through all job_names, so everybody's in sync, but each job has to unfreeze itself.
            job_instance.set_status_code("running");
            job_instance.set_up_next_do(1);
        }
    }
    to_source_code(args){
        return args.indent + "Control.sync_point("   +
            to_source_code$1({value: this.name})     + ", " +
            to_source_code$1({value: this.job_names}) +
            ")"
    }
};

Instruction$1.wait_until = class wait_until extends Instruction$1{
    constructor (fn_date_dur) {
        super();
        this.fn_date_dur = fn_date_dur;
        if      (typeof(this.fn_date_dur) == "function");
        else if (this.fn_date_dur instanceof Date) ;
        else if (typeof(fn_date_dur) == "number")  ;
        else if (fn_date_dur instanceof Duration)  { this.fn_date_dur = fn_date_dur.to_seconds(); }
        else if (this.fn_date_dur == "new_instruction");
        else if (Array.isArray(this.fn_date_dur) ||
                 (typeof(this.fn_date_dur) == "object")){
                 if(!Job$1.instruction_location_to_job(this.fn_date_dur, false)){
                     warning("Control.wait_until passed an array or literal object<br/>" +
                             "for an instruction location but<br/>" +
                             "it does not contain a job.<br/>" +
                             "That implies this job will wait for itself, and thus forever.<br/>" +
                             "However, unusual circumstances could make this ok.");
                 }
        }
        else if (fn_data_dur instanceof Job$1) ;
        else {
            dde_error("Control.wait_until instruction passed: " + this.fn_date_dur +
                      '<br/> which is not a number, date, function,<br/>' +
                      '"new_instruction" or instruction location array.');
        }
        if((typeof(fn_date_dur) == "number") && (fn_date_dur >= 1)) {
            this.inserting_instruction = true;
        }
        this.init_instruction();
    }
    do_item (job_instance){
        if (typeof(this.fn_date_dur) == "function"){
            if (this.fn_date_dur.call(job_instance)) {
                //console.log("wait_until fn returned true")
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(1); //advance the PC
            }
            else {
                job_instance.set_status_code("waiting", "a wait_until function returns true.");
                job_instance.set_up_next_do(0); //loop until its true
            }
        }
        else if (this.fn_date_dur instanceof Date){
            if(Date.now() >= this.fn_date_dur){
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(1);
            }
            else {
                job_instance.set_status_code("waiting", "a wait_until Date of: " +  this.fn_date_dur);
                job_instance.set_up_next_do(0);
            }
        }
        else if (typeof(this.fn_date_dur) == "number"){ //number is seconds
            let the_now_in_ms = Date.now();
            if (this.start_time_in_ms == null) { this.start_time_in_ms = the_now_in_ms; } //hits the first time this do_item is called for an inst
            let dur_from_start_in_ms = the_now_in_ms - this.start_time_in_ms;
            if (dur_from_start_in_ms >= this.fn_date_dur * 1000){ //The wait is over. dur_from_start_in_ms is in ms, fn_date_dur is in seconds
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                this.init_instruction(); //essential for the 2nd thru nth call to start() for this job.
                job_instance.set_up_next_do(1);
            }/* this 'keep alive/ clause should be unnecessary because if the socket times out, the
               //Socket.send method will reconnect the socket when the next send to dexter instruction comes through.
               //We'd need that socket code anyway for other do_lists that have long running sections
               //that don't involve sending instructions to dexter for a long period.
            else if ((job_instance.robot instanceof Dexter) && (dur_from_start_in_ms > 1000)){
                //so that we can keep the tcp connection alive, send a virtual heartbeat
                let new_wait_dur_in_sec = this.fn_date_dur - (dur_from_start_in_ms / 1000)
                let new_instructions = [make_ins("g"), //just a do nothing to get a round trip to Dexter.
                                       Control.wait_until(new_wait_dur_in_sec)] //create new wait_until to wait for the remaining time
                job_instance.insert_instructions(new_instructions)
                this.start_time_in_ms = null //essential for the 2nd thru nth call to start() for this job.
                job_instance.wait_reason = null
                job_instance.set_status_code("running")
                job_instance.set_up_next_do(1)
            }*/
            else {
                job_instance.set_status_code("waiting", "a wait_until duration of: " +  this.fn_date_dur + " seconds");
                job_instance.set_up_next_do(0);
            }
        }
        else if (this.fn_date_dur == "new_instruction"){
            const pc               = job_instance.program_counter;
            const pc_on_last_instr = (pc == (job_instance.do_list.length - 1));
            const next_instruction = (pc_on_last_instr ?
                                       null : job_instance.do_list[pc + 1]);
            if (this.old_instruction === undefined){ //first time through only
                this.old_instruction = next_instruction;
                job_instance.set_status_code("waiting", 'a wait_until gets a "new_instruction"');
                job_instance.set_up_next_do(0);
            }
            else if (this.old_instruction === null){ //started with this instr as the last one
                if (pc_on_last_instr) { job_instance.set_up_next_do(0); }
                else                  {
                   job_instance.set_up_next_do(1);
                } //got a new last instr
            }
            else if (next_instruction == this.old_instruction){//no change so don't advance the pos
                job_instance.set_up_next_do(0);
            }
            else { //got a new instruction since this instruction started running so execute it
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(1);
            }
        }
        else if (this.fn_date_dur instanceof Job$1) {
            let status_code = this.fn_date_dur.status_code;
            if(status_code == "completed") {
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(1);
            }
            else if(status_code == "errored") {
                job_instance.wait_reason = null;
                let stop_reason = "The job that this job was waiting for to complete, " +
                                   this.fn_date_dur.name + ", errored with: " +
                                   "\n " + this.fn_date_dur.stop_reason;
                job_instance.set_status_code("errored", stop_reason);
                job_instance.set_up_next_do(1);
            }
            else if(status_code == "interrupted") {
                job_instance.wait_reason = null;
                let stop_reason = "The job that this job was waiting for to complete, " +
                                                this.fn_date_dur.name + ", was interrupted with: " +
                                                "\n " + this.fn_date_dur.stop_reason;
                job_instance.set_status_code("interrupted", stop_reason);
                job_instance.set_up_next_do(1);
            }
            else {
               job_instance.set_status_code("waiting", "a wait_until for Job " + this.fn_date_dur.name + " completes.");
               job_instance.set_up_next_do(0);
            }
        }
        else if (Array.isArray(this.fn_date_dur) ||
                 (typeof(this.fn_date_dur) == "object")){ //instruction_location, but not integer and string formats
            var loc_job_instance = Job$1.instruction_location_to_job(this.fn_date_dur, false);
            if (!loc_job_instance) {
                loc_job_instance = job_instance;
            }
            var loc_pc = loc_job_instance.instruction_location_to_id(this.fn_date_dur);
            if(loc_pc > loc_job_instance.program_counter){ //wait until loc_job_instance advances
                if(loc_job_instance.stop_reason){
                    warning("Control.wait_until is waiting for job: " + loc_job_instance.name +
                            "<br/>but that job is stopped, so it will probably wait forever.");
                }
                job_instance.set_status_code("waiting", "a wait_until instruction_location is reached.");
                job_instance.set_up_next_do(0);
            }
            else { //done waiting, loc_job_instance already at or passe loc_ps
                job_instance.wait_reason = null;
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(1);
            }
        }
        else { //this is checked in the constructor, but just in case ...
            shouldnt$1("In job: " + job_instance.name +
                      ' in wait_until("new_instruction")<br/>' +
                      " got fn_date_dur of: " + this.fn_date_dur +
                      " which is invalid.<br/>" +
                      ' It should be a function, a date, a number, or "new_instruction".');
        }
    }
    //called by stop_for_reason, in case user terminates job during a wait_until
    init_instruction(){
            this.start_time_in_ms = null; //essential for the 2nd thru nth call to start() for this job.
    }

    to_source_code(args){
        return args.indent + "Control.wait_until("       +
            to_source_code$1({value: this.fn_date_dur, function_names: true})  +
            ")"
    }

};


//______Picture Instructions
Instruction$1.save_picture = class save_picture extends Instruction$1{
    constructor({canvas_id_or_mat="canvas_id",
                 path="my_pic.png"}){
        super();
        this.canvas_id_or_mat = canvas_id_or_mat;
        this.path = path;
        let width;
        let height;
        let canvas_elt;
        if(canvas_id_or_mat instanceof HTMLElement){
            canvas_elt = canvas_id_or_mat;
        }
        else if (typeof(canvas_id_or_mat) == "string"){
            canvas_elt = value_of_path$1(canvas_id_or_mat);
        }
        if(canvas_elt) {
            width = canvas_elt.width;
            height = canvas_elt.height;
        }
        else { //its a mat
           width = canvas_id_or_mat.cols;
           height = canvas_id_or_mat.rows;
        }
        Picture.init({width: width, height: height}); //do at job def time
    }
    do_item (job_instance){
        Picture.save_picture({canvas_id_or_mat: this.canvas_id_or_mat,
                              path: this.path});
        job_instance.set_up_next_do(1);
    }
};

Instruction$1.show_picture = class show_picture extends Instruction$1{
    constructor ({canvas_id="canvas_id", //string of a canvas_id or canvasId dom elt
                  content=null, //mat or file_path
                  title=undefined,
                  x=200, y=40, width=320, height=240,
                  rect_to_draw=null}){
        super();
        this.canvas_id = canvas_id;
        this.content = content;
        this.title = title;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.rect_to_draw = rect_to_draw;
        this.first_time = true;
        Picture.init({width: width, height: height});
    }
    do_item (job_instance){
        if(this.first_time){
            let cont = this.content;
            if((typeof(this.content) == "string") &&
                job_instance.user_data[this.content]){
                cont = job_instance.user_data[this.content]; //should be a mat
            }
            Picture.show_picture({canvas_id: this.canvas_id, //string of a canvas_id or canvasId dom elt
                                    content: cont, //mat or file_path
                                    title: this.title,
                                    x: this.x,
                                    y: this.y,
                                    width: this.width,
                                    height: this.height,
                                    rect_to_draw: this.rect_to_draw});
            this.first_time = false;
            job_instance.set_up_next_do(0);
        }
        else if (is_dom_elt(this.canvas_id)) {
            this.first_time = true; //in case we're in a loop, initialize for next time around
            job_instance.set_up_next_do(1);
        }
        else if (value_of_path$1(this.canvas_id)) { //canvas_id is a string
            this.first_time = true; //in case we're in a loop, initialize for next time around
            job_instance.set_up_next_do(1);
        }
        else { job_instance.set_up_next_do(0); } //wait until picture is up
    }
};

Instruction$1.show_video = class show_video extends Instruction$1{
    constructor ({video_id="video_id", //string of a canvas_id or canvasId dom elt
                     content="webcam", //file_path or "webcam"
                     title=undefined,
                     x=200, y=40, width=320, height=240,
                     play=true,
                     visible=true}){
        super();
        this.video_id = video_id;
        this.content = content;
        this.title = title;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.play = play;
        this.visible = visible;
        this.first_time = true;
        Picture.init({width: width, height: height}); //do at job def time
    }
    do_item (job_instance){
        if(this.first_time){
            Picture.show_video({video_id: this.video_id, //string of a canvas_id or canvasId dom elt
                                content: this.content, //mat or file_path
                                title: this.title,
                                x: this.x,
                                y: this.y,
                                width: this.width,
                                height: this.height,
                                play: this.play,
                                visible: this.visible});
            this.first_time = false;
            job_instance.set_up_next_do(0);
        }
        else if (is_dom_elt(this.video_id)) {
            this.first_time = true; //in case we're in a loop, initialize for next time around
            job_instance.set_up_next_do(1);
        }
        else if (value_of_path$1(this.video_id)) { //video_id is a string
            this.first_time = true; //in case we're in a loop, initialize for next time around
            job_instance.set_up_next_do(1);
        }
        else { job_instance.set_up_next_do(0); } //wait until video is up
    }
};

/*Instruction.take_picture = class take_picture extends Instruction{
    constructor ({video_id="video_id", //string of a canvas_id or canvasId dom elt
                  callback=Picture.show_picture_of_mat}={}){
        super()
        this.video_id = video_id
        this.callback = callback
        this.first_time = true
        this.clock_start = null
        Picture.init() //do at fn def time, not at run time, else, grabbing the pic fails
    }
    do_item (job_instance){
        if(this.clock_start_ms) { //at least close to done. take_picture called and video is up but has the callback been called and is done?
            if ((Date.now() - this.clock_start_ms) > 150){ //Now assume done. Had to give a pause to make sure  the callback got run before moving on to the next instruction, in case it depends upon it.
                //in case we're in a loop, initialize for next time around
                this.clock_start_ms = null
                this.first_time = true
                job_instance.set_up_next_do(1)
            }
            else { job_instance.set_up_next_do(0) } //not done yet
        }
        else if(this.first_time){
            let cb
            if(typeof(this.callback) == "string"){
              let user_data_var_name = this.callback
              cb = function(mat) {
                   job_instance.user_data[user_data_var_name] = mat
                  }
            }
            else { cb = this.callback }
            Picture.take_picture({video_id: this.video_id, //string of a canvas_id or canvasId dom elt
                                  callback: cb})
            this.first_time = false
            job_instance.set_up_next_do(0)
        }

        else if (is_dom_elt(this.video_id) ||value_of_path(this.video_id)) {
           this.clock_start_ms = Date.now() //start the timer
            job_instance.set_up_next_do(0)
        }
        else { job_instance.set_up_next_do(0) } //take_pciture has been called, but wait until video is up
    }
}*/
Instruction$1.take_picture = class take_picture extends Instruction$1{
    constructor ({video_id="video_id", //string of a canvas_id or canvasId dom elt
                  camera_id=undefined,
                  width=320, height=240,
                  callback=Picture.show_picture_of_mat}={}){
        super();
        this.video_id = video_id;
        this.camera_id = camera_id;
        this.width = width;
        this.height = height;
        this.callback = callback;
        this.first_time = true;
        this.pic_taken = false;
        Picture.init({width: width, height: height}); //do at fn def time, not at run time, else, grabbing the pic fails
    }
    do_item (job_instance){
        if(this.first_time){
            //prepare the callback passed to Picture.take_picture
            let cb;
            let this_instruction = this;
            if(typeof(this.callback) == "string"){
                let user_data_var_name = this.callback;
                cb = function(mat) {
                        job_instance.user_data[user_data_var_name] = mat;
                        this_instruction.pic_taken = true;
                };
            }
            else {
                cb = function(mat) {
                        if (this_instruction.callback) {
                            this_instruction.callback.call(job_instance, mat);
                        }
                        this_instruction.pic_taken = true;
                     };
            }
            Picture.take_picture({video_id: this.video_id, //string of a canvas_id or canvas_id dom elt
                                  camera_id: this.camera_id,
                                  width: this.width, height: this.height,
                                  callback: cb});
            this.first_time = false;
            job_instance.set_up_next_do(0); //loop around.
        }
        else if(this.pic_taken) { //all done
            this.first_time = true; //get ready for next time this instuction may be called in a loop
            this.pic_taken = false;
            job_instance.set_up_next_do(1);
        }
        else { job_instance.set_up_next_do(0); } //take_picture has been called, but its not done yet
    }
};
//______________________________________________________
Instruction$1.Serial = class Serial extends Instruction$1{};

//for Serial.string_instruction when we have a Robot.Serial instance
Instruction$1.Serial.string_instruction = class string_instruction extends Instruction$1.Serial{
    constructor (instruction_string, robot = null //this is a robot instance. spelling of this prop name is important. Used by other methods & classes
    ) {
        super();
        this.inst_array = Serial$1.string_instruction(instruction_string);
        this.robot = robot;
    }
    do_item (job_instance){
        if (!this.robot) { //this.robot = job_instance.robot
            this.set_instruction_robot_from_job(job_instance); //might error which is good
        }
        //job_instance.wait_until_instruction_id_has_run = job_instance.program_counter// dont
        //do this here because in the case that we have a robot, we might still be
        //in the "connecting" state, ie initing the robot, in which case,
        //we don't want to be waiting for this instruction because that
        //will preclude processing of the instruction by the lower part of do_next_item.
        job_instance.send(this.inst_array, this.robot);
        //don't set up next do. That's handled by the wait_until_instruction_id_has_run code
    }
};

function shouldnt$1(message){
    console.log(message);
    if(window.contact_doc_id) {
        open_doc(contact_doc_id);
    }
    dde_error("The function: shouldnt has been called.<br/>" +
                    "This means there is a bug in DDE.<br/>" +
                    "Please send a bug report. See User_Guide/Contact.<br/>" +
                    "Include this whole message.<br/>" +
                     prepend_file_message_maybe(message));
}

function is_non_neg_integer(anything){
    return Number.isInteger(anything) && (anything > -1)
}

function is_NaN_null_or_undefined(arg) {
    return (isNaN(arg) || (arg === null) || (arg === undefined) )
}

//this will count reserved words (ie "break" as an identifier, which
//isn't what JS thinks of as a valid user variable or fn name identifier
function is_string_an_identifier(a_string){
  let the_regex = /^[_$a-zA-Z\xA0-\uFFFF][_$a-zA-Z0-9\xA0-\uFFFF]*$/;
  return the_regex.test(a_string)
}


function is_generator_function(obj){
    if(obj && obj.constructor && (obj.constructor.name == "GeneratorFunction")){
        return true
    }
    else { return false }
}


//Beware: this *might* only catch iterators made by generator functions.
function is_iterator(obj){
    if(obj && obj.constructor && is_generator_function(obj.constructor)){
        return true
    }
    else {
        return false
    }
}


function is_hour_colon_minute(a_string){
    return a_string.match(/^\d\d:\d\d$/)
}


function is_hour_colon_minute_colon_second(a_string){
    return a_string.match(/^\d\d:\d\d:\d\d$/)
}


//date_int is ms from jan 1, 1970 as returned by Date.now()
function date_integer_to_long_string(date_int=Date.now()){
    let date_obj = new Date(date_int);
    let result = date_obj.toString();
    let ms = date_obj.getMilliseconds();
    result +=  " " + ms + "ms";
    return result
}


//integer milliseconds in, output "123:23:59:59:999" ie
// days:hours:minutes:seconds:milliseconds
function milliseconds_to_human_string(total_ms=Date.now(), include_total_days=true){
   let remain_ms   = total_ms % 1000;
   let total_secs  = (total_ms - remain_ms) / 1000;

   let remain_secs = total_secs % 60;
   let total_mins = (total_secs - remain_secs) / 60;

   let remain_mins = total_mins % 60;
   let total_hours = (total_mins - remain_mins) / 60;

   let remain_hours = total_hours % 24;
   let total_days   = (total_hours - remain_hours) / 24;
   return (include_total_days ? total_days + ":" : "") +
          pad_integer(remain_hours, 2) + ":" +
          pad_integer(remain_mins, 2) + ":" +
          pad_integer(remain_secs, 2) + ":" +
          pad_integer(remain_ms, 3)
}



//pad_integer(123, 5, "x") => "xx123"
function pad_integer(int, places=3, pad_char="0"){
    let result = "" + int;
    if (result.length < places) { result = pad_char.repeat(places - result.length) + result;}
    return result
}


//the default for Robot Serial.sim_fun
function return_first_arg(arg){ return arg }

function typed_array_name(item){
    if(Array.isArray(item)) { return "Array" }
    else if (item instanceof Int8Array)         { return "Int8Array" }
    else if (item instanceof Uint8Array)        { return "Uint8Array" }
    else if (item instanceof Uint8ClampedArray) { return "Uint8ClampedArray" }
    else if (item instanceof Int16Array)        { return "Int16Array" }
    else if (item instanceof Uint16Array)       { return "Uint16Array" }
    else if (item instanceof Int32Array)        { return "Int32Array" }
    else if (item instanceof Uint32Array)       { return "Uint32Array" }
    else if (item instanceof Float32Array)      { return "Float32Array" }
    else if (item instanceof Float64Array)      { return "Float64Array" }
    else { return null } //not an array of any type
}

//returns null or the last elt of an array or a string
function last(arg){
    let len = arg.length;
    if (len == 0)                     { return undefined }
    else if (typeof(arg) == "string") { return arg[len - 1 ] }
    else if (Array.isArray(arg))      { return arg[len - 1] }
    else if (arg instanceof NodeList) { return arg[len - 1] }
    else if (arg instanceof HTMLCollection) { return arg[len - 1] }
    else                              { dde_error("last passed unhandled type of arg: " + arg); }
}

//avoids calling eval. If the path isn't defined, this fn returns undefined.
//arg can either be a string with dots or an array of strings that are path elts.
function value_of_path$1(path_string){
    let path = path_string;
    if (typeof(path) == "string"){ path = path.split("."); }
    else if(Array.isArray(path)) ; //ok as is
    else {
        dde_error("value_of_path passed: " + path_string + " which is not a string or an array.");
    }
    let result;
    if(window[path[0]] !== undefined) { result = window; }
    //note window["window"] returns the window obj so the arg can be "window" and we still win
    else if (Object.prototype[path[0]] !== undefined) { result = Object.prototype; }
    else { return undefined }
    for (var path_elt of path){
        result = result[path_elt];
        if (result === undefined) {break}
    }
    return result
}

//returns null if fn_src doesn't look like a fn def.
//returns "" if its an anonymous fn
//else returns the fn name
//beware: js is clever about assigning names to annonymous fns if
//th happen to be bound to a keyword arg to a fn,
//In such cases, some.fn.name might yield the name its bound to,
//not the name its given in its source code.
function function_name(fn_or_src){
    if (typeof(fn_or_src) == "string"){
        if (!fn_or_src.startsWith("function ")) {return null}
        else {
            let parts = fn_or_src.split(" ");
            if (parts.length < 2) { return "" }
            else {
                let name_maybe = parts[1];
                if (name_maybe.startsWith("(")) { return "" }
                else {
                    let paren_pos = name_maybe.indexOf("(");
                    if (paren_pos == -1) { return name_maybe }
                    else { return name_maybe.substring(0, paren_pos) }
                }
            }
        }
    }
    else if (typeof(fn_or_src) == "function"){
        return  fn_or_src.name   //returns "" if anonymous function
    }
    else { return null }
}

//returns a string
function function_params(fn, include_parens=true){
    let src = fn.toString();
    let open_pos = src.indexOf("(");
    let close_pos = Editor.find_matching_delimiter(src, open_pos);
    /*close_pos = src.indexOf("){") //beware, with default args, there can be syntax in params, but this will at least mostly work
    if (close_pos == -1) {close_pos = src.indexOf(") {") //that space is in some system defs like isPrototypeOf
    if (close_pos == -1) {close_pos = src.indexOf(")") //one last try. Not so good since a default value
          // *might* have a paren in it, but not too many fns with such default values so might as well.
    */
    let result = src.substring(open_pos + 1, close_pos);
    if ((result == "") && (fn.length !== 0)) { //the src of the fn does not contain the params as is true for Math fns, and fns whose body source is [native code]
        let prefix = "arg";
        if (Math.hasOwnProperty(fn.name)) { prefix = "num"; } //all fns in Math take only number args. This is not true for the "Number" class fns.
        for (let i = 0; i < fn.length; i++) {
            result += prefix + i;
            if (i != (fn.length - 1)) { result += ", ";}
        }
    }
    if (include_parens){ result = "(" + result + ")"; }
    return result
}

//fn can be a constructor or other method who's src string doesn't have to start with "function".
//we really only care about the text between the first paren and the first ")}", exclusive
//returns an array of strings, the names of the params
//function(a, {b=2, c=3}){ return 99}   returns ["a", "b", "c"]
function function_param_names(fn){
    var params_full_string = function_params(fn, false);
    return params_string_to_param_names(params_full_string)
}


//used only by this file
//params_full_string can either be wrapped in parens or not
function params_string_to_param_names(params_full_string){
    if (params_full_string.startsWith("(")) {params_full_string = params_full_string.substring(1);}
    if (params_full_string.endsWith(")"))   {params_full_string = params_full_string.substring(0, params_full_string.length - 1);}
    params_full_string = remove_comments(params_full_string);
    var params_and_defaults_array = params_full_string.split(",");
    var param_names = [];
    for(var param_and_default of params_and_defaults_array){
        param_and_default = param_and_default.trim();
        if (param_and_default.startsWith("{")){
            var inner_params_and_defaults = param_and_default.substring(1); //cut off {
            if(inner_params_and_defaults.endsWith("}")) {
                 inner_params_and_defaults = param_and_default.substring(0, param_and_default.length -1); //cut off }
            }
            var inner_params_and_defaults_array = inner_params_and_defaults.split(",");
            for(var inner_param_and_default of inner_params_and_defaults_array){
                inner_param_and_default = inner_param_and_default.trim();
                var the_match = inner_param_and_default.match(/^[A-Za-z_-]+/);
                if (!the_match) {return null} //invalid syntax
                var the_param = the_match[0];
                param_names.push(the_param);
            }
        }
        else {
            var equal_pos = param_and_default.indexOf("=");
            var the_param;
            if (equal_pos != -1){
                the_param = param_and_default.substring(0, equal_pos);
                the_param = the_param.trim();
            }
            else {
                the_param =  param_and_default;
            }
            param_names.push(the_param);
        }
    }
    return param_names
}

function remove_comments(a_string) {
    while(true){
        let start_index = a_string.indexOf("/*");
        let end_index;
        if(start_index !== -1) {
            end_index = a_string.indexOf("*/");
            if(end_index !== -1){
                a_string = a_string.substring(0, start_index) + a_string.substring(end_index + 2);
            }
            else {
                a_string = a_string.substring(0, start_index); //nothing left in string so stop
                break;
            } //remove all the way to the end. Not always right, but the string is screwed up anyway.
        }
        else {
            start_index = a_string.indexOf("//");
            if(start_index !== -1) {
                end_index = a_string.indexOf("\n", start_index);
                if(end_index !== -1){
                    a_string = a_string.substring(0, start_index) + a_string.substring(end_index + 1);
                }
                else {
                    a_string = a_string.substring(0, start_index); //nothing left in string so stop
                    break;
                } //remove all the way to the end. Not always right, but the string is screwed up anyway.
            }
            else { break; } //no more comments to remove
        }
    }
    return a_string
}


//not general purpose
function shallow_copy(obj){ //copies only enumerable, own properites. Used in
                            //copying Job's user_data at start
    let result = obj;
    if(result === null) ; //typeof returns "object" for null
    else if(Array.isArray(obj)){
        result = [];
        for (let elt of obj) { result.push(elt); }
    }
    else if (typeof(obj) == "object"){ //typeof returns "object" for null
        result = {};
        for(let name of Object.keys(obj)){
            result[name] = obj[name];
        }
    }
    return result //might be a Date, I hope that's not mungable
}

function shallow_copy_lit_obj(obj){ //copies only enumerable, own properites. Used in
    //copying Job's user_data at start
    let result = {};
    for(let name of Object.keys(obj)){
        result[name] = shallow_copy(obj[name]);
    }
    return result
}

//used to fix broken ES6 not allowing a keyword obj with destructuring.
                             //defaults   keyword_args
function copy_missing_fields(source_arg, target_obj){
    for(var name of Object.getOwnPropertyNames(source_arg)){
        if (!target_obj.hasOwnProperty(name)){
            var new_val = source_arg[name];
            if (new_val == "required"){
                shouldnt$1("copy_missing_fields passed target object: " + target_obj +
                        " that was missing required field of: " + name);
            }
            else { target_obj[name] = new_val; }
        }
    }
}

//returns a string that starts with the first char of src
//by trimming whitespace and comments from the front of src
//used by Control.include_job
function trim_comments_from_front(src){
    src = src.trimLeft();
    if(src.startsWith("//")) {
        let end = src.indexOf("\n");
        if(end == -1){ return "" } //src was a one-liner comment
        else {
            src = src.substring(end + 1);
            return trim_comments_from_front(src)
        }
    }
    else if(src.startsWith("/*")) {
        let end = src.indexOf("*/");
        if(end == -1) { //crap, we've got a faulty multi-line comment.
            return ""
        }
        else {
            src = src.substring(end + 2);
            return trim_comments_from_front(src)
        }
    }
    else { return src }
}

//only used in this file
function regexp_escape_special_chars(str){
    return str.replace(/[-\/\\^$*+?.()|\[\]{}]/g, '\\$&')
}


//the first arg to new RegExp is a regexp pattern that treats
//lots of punctuation chars like parens specially.
//To turn off that special treatment, pass in a 4th arg of false
function replace_substrings(orig_string, substring_to_replace, replacement, substring_to_replace_treated_specially=true){
    if(!substring_to_replace_treated_specially) {
        substring_to_replace = regexp_escape_special_chars(substring_to_replace);
    }
    return orig_string.replace(new RegExp(substring_to_replace, 'g'), replacement);
}


 //uses html to format newlines
//use for printing ANY possible value from JS so that a human (usually a programmer) can make sense of it.
//Use stringify_value_sans_html  for evalable string (but still not perfrect
//returns a string.
//called on the eval result by eval part 2, and by show_output if the input is not already a string
//and by Js_info
function stringify_value$1(value){
    //if (Object.isNewObject(value)) { inspect_new_object(value) }
    //else {
        var result = stringify_value_aux (value);
        //if (typeof(value) != "string"){
        //    result = "<code>" + result + "</code>"
        //}
        return result
    //}
}


function stringify_value_aux(value, job, depth=0){
    if (depth > 2) { return "***" } //stops infinite recustion in circular structures.
    var result;
    if      (value === undefined)       { return "undefined" }
    else if (value === null)            { return "null" } //since typeof(null) == "object", this must be before the typeof(value) == "object" clause
    else if (value === window)          { return "{window object: stores globals}" } //too many weird values in there and too slow so punt.
    else if (typeof(value) == "number") { return value.toString() } //works for NaN too, no need to use (isNaN(value)) { result = "NaN" } //note the check for number before checking isNanN is necessary because JS wasn't designed.
    else if (typeof(value) == "string") { return JSON.stringify(value) }
    else if (value instanceof Date){ result = value.toString(); }
    else if (typeof(value) == "function") {
        result = value.toString();
        var bod_pos = result.indexOf("{");
        if (bod_pos.length <= 12) { //very little to go on. probably an anonymous fn with no args
            if (result.length > 25){ //shorten longer defs
                result = result.substring(0, 22) + "...}";
            }
        }
        else {
            result = result.substring(0, bod_pos) + "{...}"; //just show "function foo(a, b){...}"
        }
    }
    else if (Object.isNewObject(value)) {
        result = value.objectPath(value);
        if (!result) {
            result = "Instance of: " + value.prototype.objectPath(); //todo what if we make an instance of an unnamed instance? we shoud go up the tree to find the first named prototype.
        }
        //from top level, we'll be in sandbox, so value can be browsed without it having to have a path to it.
        //but hopuflly value.prototype WILL have a path (as is likely). For now don't worry about
        //unnamed objs 2 levels down.
        else {
        //inspect_new_object(value) //causes infinite loop in electron dde
        result = inspect_stringify_new_object_clickable_path(value); //causes infinite loop in electron dd
        //just let result be the string of the path.
        }
    }
    else if (depth > 2) { return "***" } //the below clauses call stringify_value_aux meaning
        //they can get into infinite recursion, so cut that off here.
    else if (typed_array_name(value)){ //any type of array
        let len = Math.min(value.length, 100);  //large arrays will cause problems
        result = "[<br/>";
        for (let i = 0; i < len; i++){ //don't use "for ... in here as it gets some wrong stuff
            let sep = ((i == len - 1) ? "<br/>" : ",<br/>");
            var elt_val = value[i];
            var elt_val_string = stringify_value_aux(elt_val, job, depth + 1);
            //if (Array.isArray(elt_val)) sep = sep + "<br/>" //put each sub-array on its own line
            result += " " + elt_val_string + sep;
        }
        result += "]";
        if ((result.length < 100) && (result.indexOf("{") == -1)){ //worked up until I put in indicies above
            result = result.replace(/\[<br\/>\s+/g, "[");
            result = result.replace(/,<br\/>\s+/g, ", ");
            result = result.replace(/<br\/>\]/g, "]");
            result = result.replace(/\[\s+/g, "[");
        }
        result = result.replace(/\],\s+\[/g, "],<br/>&nbsp;[");
    }

    /*else if (value == rootObject) {
        result = "{prototype: undefined<br/>" +
                 '&nbsp;name: "rootObject"<br/>'
        for(let prop in value){
            let prop_val = value[prop]
            let val_str
            if (value.hasOwnProperty(prop) && (prop != "name") && (prop != "prototype")){
               if (Object.isNewObject(prop_val)){
                  val_str = stringify_new_object_clickable_path(prop_val)
               }
               else { val_str = stringify_value_aux(prop_val) }
               result += "&nbsp;" + prop + ": " +  val_str + "<br/>"
            }
        }
        result += "}"
    }
    else if (Object.isNewObject(value)) {
        let prop_val = value["prototype"]
        let val_str = (Object.isNewObject(prop_val)?
                        stringify_new_object_clickable_path(prop_val):
                        stringify_value_aux(prop_val))
        result = "{prototype: "   + val_str + "<br/>" +
                   "&nbsp;name: " + ((value.name == undefined) ? "undefined" : JSON.stringify(value.name)) + "<br/>"
        for(let prop in value){
           if (value.hasOwnProperty(prop) && (prop != "name") && (prop != "prototype")){
               prop_val = value[prop]
               val_str = Object.isNewObject(prop_val)? stringify_new_object_clickable_path(prop_val): stringify_value_aux(prop_val)
               result += "&nbsp;" + prop + ": " +  val_str + "<br/>"
           }
        }
        result += "}"
    }*/

    else if (typeof(value) == "object"){//beware if we didn't catch arrays above this would hit
        if (value.constructor == Job){ //must be under object clause since value might be null
            job = value;
        }
        //I can't figure out how to tell if toString is explicity defined on value. hasOwnProperty doesn't work
        if ((value instanceof Instruction$1) || (value instanceof Duration) || (value instanceof Brain) ||
            (value instanceof Human) || (value instanceof TestSuite)){
            return value.toString()
        }
        var result = "{";
        let constructor_name = value.constructor.name;
        if (constructor_name != "Object") { result += "class: " + constructor_name + ",<br/>";}
        let prop_names = Object.getOwnPropertyNames(value); //long objects like cv cause problems
        for (var prop_index = 0; prop_index < Math.min(prop_names.length, 100); prop_index++) {
            let prop_name = prop_names[prop_index];
            let prop_val = value[prop_name];
            if(prop_name == "devToolsWebContents") ; //causes error so just ignore this rare item. occurs in electron BrowserWindow instances
            else if (prop_name == "robot_status"){
                if (!job && value.job_id) { job = Job.job_id_to_job_instance(value.job_id); }
                let where_from = "";
                if (value instanceof Job)   { where_from = " on job: "   + value.name; }
                if (value instanceof Robot$1) { where_from = " on robot: " + value.name; }
                result += Dexter$1.robot_status_to_html(prop_val, where_from);
            }
            else if ((prop_name == "do_list") && job) { //must check to insure job is defined or this errors as happens when inspecting Job.job_default_params
                result += job.do_list_to_html(); //Job.do_list_to_html(value[prop])
            }
            else if (prop_name == "original_do_list"){
                result += Job.non_hierarchical_do_list_to_html(prop_val); //Job.do_list_to_html(value[prop])
            }
            else if (prop_name == "sent_instructions"){
                result += Dexter$1.sent_instructions_to_html(prop_val);
            }
            else if (prop_name == "rs_history"){ //value is instance of Dexter
                result += prop_name + ": " + Dexter$1.make_show_rs_history_button_html(value.job_id);
            }
            else {
                try{
                  result += prop_name + ": " + stringify_value_aux(prop_val, job, depth + 1) + ",<br/>";
                }
                catch(e) {} //doing window["caches"] errors so just forget about this prop and maybe others.
            }
        }
        result += "}";
        if (result == "{}") {  //as is the case with iterators
            if (is_iterator(value)) {
              result = value.toString(); //not great as might make "[object Generator]" or "[object Array Iterator]" but better than {}
            }
            else {
                 try{
                     var result = value.toString();
                     if (result == "[object Object]"){
                         if (value.constructor == Object) { result = "{}"; }
                         else { result = "{instanceof: " + stringify_value_aux(value.constructor, job, depth + 1) + "}"; }
                     }
                 }
                 catch(e) {return "{}" }
            }
        }
    }
    else {
        result = JSON.stringify(value, null, 2); //beware if a val of a field in a obj is a fn, it prints as null
        if (result == undefined){ //as happens at least for functions
            result = value.toString();
        }
        else {//as for js objects, etc.
            result = result.replace(/\{\n  /g, "{&nbsp;");
            result = result.replace(/\[\n  /g, "[&nbsp;");
            result = result.replace(/\n/g, "<br/>");
            result = result.replace(/\ \ /g, "&nbsp;&nbsp;");
        }
    }
    return result
}

//crude but guarentees fidelity with stringify_value, but that might not be what I really want.
function stringify_value_sans_html(value){
    let result = stringify_value$1(value);
    //result = replace_substrings(result, "<co"  + "de>", "") //screws up inspetion of this fn (while inspecting 'window') having '<co  de>' in it. //
    result = result.replace(/<code>/g,   "");
    //result = replace_substrings(result, "</co" + "de>", "") //
    result = result.replace(/<\/code>/g, "");
    result = result.replace(/<br\/>/g,   "\n");
    result = result.replace(/&nbsp;/g,   " ");
    return result
}
///// End CSV //////

function inspect_new_object(new_object_or_path, add_to_stack=true){ //called from Insert menu item and stringify_value
    // still causes jquery infinite error if the below is commented in.
    //if (typeof(new_object_or_path) == "string")  { return new_object_or_path }
    //else { return value_of_path(new_object_or_path) }

    let new_object = (typeof(new_object_or_path) == "string") ?
                        value_of_path$1(new_object_or_path) :
                        new_object_or_path;
    let prop_val = new_object["prototype"];
    let val_str;
    if (prop_val == undefined)             { val_str = "undefined"; }
    else if (Object.isNewObject(prop_val)) { val_str = inspect_stringify_new_object_clickable_path(prop_val); }
    else                                   { val_str = stringify_value_aux(prop_val); }
    let the_name = new_object.name;
    if ((the_name == undefined) && (new_object == Root)) { the_name = '"Root"'; }
    else if (the_name == undefined) { the_name = "undefined"; }
    else { the_name = '"' + the_name + '"'; }
    result = "{prototype: " + val_str  + "<br/>" +
             "&nbsp;name: " + the_name + "<br/>";
    for(let prop in new_object){
        if (new_object.hasOwnProperty(prop) && (prop != "name") && (prop != "prototype")){
            prop_val = new_object[prop];
            if (prop_val == undefined)             { val_str = "undefined"; }
            else if (Object.isNewObject(prop_val)) { val_str = inspect_stringify_new_object_clickable_path(prop_val); }
            else                                   { val_str = stringify_value_aux(prop_val); }
            result += "&nbsp;" + prop + ": " +  val_str + "<br/>";
        }
    }
    result += "}";
    if(add_to_stack){ //do this before computing opacity
        inspect_stack.push(new_object);
        inspect_stack_pos = inspect_stack.length - 1;
    }
    let prev_opacity = (inspect_stack_pos >= 1) ? 1 : 0.3;
    let next_opacity = (inspect_stack_pos < (inspect_stack.length - 1)) ? 1 : 0.3;
    result = "<div id='inspector_id' style='background-color:#ffd9b4;'>" +
             "&nbsp;<span             id='inspect_previous_value_id' title='Inspect previous value.' style='color:blue;font-weight:900; opacity:" + prev_opacity + ";'>&lt;</span>" +
             "&nbsp;&nbsp;&nbsp;<span id='inspect_next_value_id'     title='Inspect next value.'     style='color:blue;font-weight:900; opacity:" + next_opacity + ";'>&gt;</span>" +
             "<b style='padding-left:100px;'><i>Inspector</i></b><br/>"  +
             result + "</div>";

    setTimeout(function(){out(result, "black", true);}, 200); //give the regular return value
      //a chance to be rendered, so that the temp browser will be rendered AFTER it,
      //because otherewise the temp browser will be erased by the regular result output.
      //but beware, after the browser html is renderend, we need to set the onclicks,
      //which has a timeout too that must be longer than this timeout.
}

var inspect_stack = [];
var inspect_stack_pos = -1;
function inspect_previous_value(){
    if(inspect_stack_pos > 0) {
        inspect_stack_pos -= 1;
        inspect_new_object(inspect_stack[inspect_stack_pos], false);
    }
}

function inspect_next_value(){
        if(inspect_stack_pos < (inspect_stack.length - 1)) {
            inspect_stack_pos += 1;
            inspect_new_object(inspect_stack[inspect_stack_pos], false);
        }
}

function inspect_stringify_new_object_clickable_path(new_obj){
    let path = new_obj.objectPath();
    let id_string = path.replace(/\./g, "_") + "_path_id";
    let result = '<span id="' + id_string + '" style="color:blue; text-decoration:underline;">' + path + '</span/>';
    inspect_set_new_object_onclick(id_string, path);
    return result
}

function inspect_set_new_object_onclick(id_string, path){
    setTimeout(function(){ //we need to wait until the html is actually rendered.
        let fn = function(){ inspect_new_object(path); };
        let elts = window[id_string]; //beware, if there's more than one elt with this id, we get an HTMlCollection of the etls.
        // this is a very broken data struture that I can't even test for except with length
        if (elts == undefined) ;
        else if (elts.length){
            for(let i = 0; i < elts.length; i++) {
                elts[i].onclick = fn;
            }
        }
        else { elts.onclick = fn; } //only one
        if(window.inspect_previous_value_id){
            inspect_previous_value_id.onclick = inspect_previous_value;
        }
        if(window.inspect_next_value_id) {
            inspect_next_value_id.onclick     = inspect_next_value;
        }
    }, 1000);
}

class Duration {
    //DO NOT default minutes to anything as we need null there so that the first arg will be interprested as ms
    constructor(string_or_hours=0, minutes=0, seconds=0, milliseconds=0){ //First arg can be "12:34" for hours:mins,
                                                                         // "12:34:56" for hours:mins:secs,
                                                                         // or 123 for hours
        if (typeof(string_or_hours) == "string") { //presume "12:34"(hours and mins) or "12:34:56" hours, mins, secs
            if (is_hour_colon_minute(string_or_hours) || is_hour_colon_minute_colon_second(string_or_hours)){
                var [h, m, s] = string_or_hours.split(":");
                var secs = parseInt(h) * 60 * 60;
                secs += parseInt(m) * 60;
                if (s) { secs += parseInt(s); }
                this.milliseconds = secs * 1000; //to get milliseconds
                return
            }
        }
        else if (typeof(string_or_hours) == "number"){
                let secs = (string_or_hours * 60 * 60) + (minutes * 60) + seconds;
                this.milliseconds = (secs * 1000) + milliseconds;
                return
        }
        throw new Error("new Duration passed arg: " + string_or_hours + " which is not a number or a string of the format 12:34 or 12:34:56 ")
    }
    toString() { return this.to_source_code }

    to_source_code(){
        let total_ms  = this.milliseconds;
        let ms        = total_ms  % 1000;
        let total_sec = (total_ms - ms)   / 1000;
        let sec       = total_sec % 60;
        let total_min = (total_sec - sec) / 60;
        let min       = total_min % 60;
        let hour      = (total_min - min) / 60;
        return "new Duration(" + hour + ", " + min + ", " + sec + ", " + ms + ")"
    }

    to_seconds(){ return this.milliseconds / 1000 }
}

/**
 * Helpers.
 */
var s = 1000;
var m = s * 60;
var h = m * 60;
var d = h * 24;
var w = d * 7;
var y = d * 365.25;

/**
 * Parse or format the given `val`.
 *
 * Options:
 *
 *  - `long` verbose formatting [false]
 *
 * @param {String|Number} val
 * @param {Object} [options]
 * @throws {Error} throw an error if val is not a non-empty string or a number
 * @return {String|Number}
 * @api public
 */

var ms = function(val, options) {
  options = options || {};
  var type = typeof val;
  if (type === 'string' && val.length > 0) {
    return parse(val);
  } else if (type === 'number' && isFinite(val)) {
    return options.long ? fmtLong(val) : fmtShort(val);
  }
  throw new Error(
    'val is not a non-empty string or a valid number. val=' +
      JSON.stringify(val)
  );
};

/**
 * Parse the given `str` and return milliseconds.
 *
 * @param {String} str
 * @return {Number}
 * @api private
 */

function parse(str) {
  str = String(str);
  if (str.length > 100) {
    return;
  }
  var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
    str
  );
  if (!match) {
    return;
  }
  var n = parseFloat(match[1]);
  var type = (match[2] || 'ms').toLowerCase();
  switch (type) {
    case 'years':
    case 'year':
    case 'yrs':
    case 'yr':
    case 'y':
      return n * y;
    case 'weeks':
    case 'week':
    case 'w':
      return n * w;
    case 'days':
    case 'day':
    case 'd':
      return n * d;
    case 'hours':
    case 'hour':
    case 'hrs':
    case 'hr':
    case 'h':
      return n * h;
    case 'minutes':
    case 'minute':
    case 'mins':
    case 'min':
    case 'm':
      return n * m;
    case 'seconds':
    case 'second':
    case 'secs':
    case 'sec':
    case 's':
      return n * s;
    case 'milliseconds':
    case 'millisecond':
    case 'msecs':
    case 'msec':
    case 'ms':
      return n;
    default:
      return undefined;
  }
}

/**
 * Short format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtShort(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return Math.round(ms / d) + 'd';
  }
  if (msAbs >= h) {
    return Math.round(ms / h) + 'h';
  }
  if (msAbs >= m) {
    return Math.round(ms / m) + 'm';
  }
  if (msAbs >= s) {
    return Math.round(ms / s) + 's';
  }
  return ms + 'ms';
}

/**
 * Long format for `ms`.
 *
 * @param {Number} ms
 * @return {String}
 * @api private
 */

function fmtLong(ms) {
  var msAbs = Math.abs(ms);
  if (msAbs >= d) {
    return plural(ms, msAbs, d, 'day');
  }
  if (msAbs >= h) {
    return plural(ms, msAbs, h, 'hour');
  }
  if (msAbs >= m) {
    return plural(ms, msAbs, m, 'minute');
  }
  if (msAbs >= s) {
    return plural(ms, msAbs, s, 'second');
  }
  return ms + ' ms';
}

/**
 * Pluralization helper.
 */

function plural(ms, msAbs, n, name) {
  var isPlural = msAbs >= n * 1.5;
  return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
}

/**
 * This is the common logic for both the Node.js and web browser
 * implementations of `debug()`.
 */

function setup(env) {
	createDebug.debug = createDebug;
	createDebug.default = createDebug;
	createDebug.coerce = coerce;
	createDebug.disable = disable;
	createDebug.enable = enable;
	createDebug.enabled = enabled;
	createDebug.humanize = ms;
	createDebug.destroy = destroy;

	Object.keys(env).forEach(key => {
		createDebug[key] = env[key];
	});

	/**
	* The currently active debug mode names, and names to skip.
	*/

	createDebug.names = [];
	createDebug.skips = [];

	/**
	* Map of special "%n" handling functions, for the debug "format" argument.
	*
	* Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
	*/
	createDebug.formatters = {};

	/**
	* Selects a color for a debug namespace
	* @param {String} namespace The namespace string for the for the debug instance to be colored
	* @return {Number|String} An ANSI color code for the given namespace
	* @api private
	*/
	function selectColor(namespace) {
		let hash = 0;

		for (let i = 0; i < namespace.length; i++) {
			hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
			hash |= 0; // Convert to 32bit integer
		}

		return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
	}
	createDebug.selectColor = selectColor;

	/**
	* Create a debugger with the given `namespace`.
	*
	* @param {String} namespace
	* @return {Function}
	* @api public
	*/
	function createDebug(namespace) {
		let prevTime;
		let enableOverride = null;
		let namespacesCache;
		let enabledCache;

		function debug(...args) {
			// Disabled?
			if (!debug.enabled) {
				return;
			}

			const self = debug;

			// Set `diff` timestamp
			const curr = Number(new Date());
			const ms = curr - (prevTime || curr);
			self.diff = ms;
			self.prev = prevTime;
			self.curr = curr;
			prevTime = curr;

			args[0] = createDebug.coerce(args[0]);

			if (typeof args[0] !== 'string') {
				// Anything else let's inspect with %O
				args.unshift('%O');
			}

			// Apply any `formatters` transformations
			let index = 0;
			args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
				// If we encounter an escaped % then don't increase the array index
				if (match === '%%') {
					return '%';
				}
				index++;
				const formatter = createDebug.formatters[format];
				if (typeof formatter === 'function') {
					const val = args[index];
					match = formatter.call(self, val);

					// Now we need to remove `args[index]` since it's inlined in the `format`
					args.splice(index, 1);
					index--;
				}
				return match;
			});

			// Apply env-specific formatting (colors, etc.)
			createDebug.formatArgs.call(self, args);

			const logFn = self.log || createDebug.log;
			logFn.apply(self, args);
		}

		debug.namespace = namespace;
		debug.useColors = createDebug.useColors();
		debug.color = createDebug.selectColor(namespace);
		debug.extend = extend;
		debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.

		Object.defineProperty(debug, 'enabled', {
			enumerable: true,
			configurable: false,
			get: () => {
				if (enableOverride !== null) {
					return enableOverride;
				}
				if (namespacesCache !== createDebug.namespaces) {
					namespacesCache = createDebug.namespaces;
					enabledCache = createDebug.enabled(namespace);
				}

				return enabledCache;
			},
			set: v => {
				enableOverride = v;
			}
		});

		// Env-specific initialization logic for debug instances
		if (typeof createDebug.init === 'function') {
			createDebug.init(debug);
		}

		return debug;
	}

	function extend(namespace, delimiter) {
		const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
		newDebug.log = this.log;
		return newDebug;
	}

	/**
	* Enables a debug mode by namespaces. This can include modes
	* separated by a colon and wildcards.
	*
	* @param {String} namespaces
	* @api public
	*/
	function enable(namespaces) {
		createDebug.save(namespaces);
		createDebug.namespaces = namespaces;

		createDebug.names = [];
		createDebug.skips = [];

		let i;
		const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
		const len = split.length;

		for (i = 0; i < len; i++) {
			if (!split[i]) {
				// ignore empty strings
				continue;
			}

			namespaces = split[i].replace(/\*/g, '.*?');

			if (namespaces[0] === '-') {
				createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
			} else {
				createDebug.names.push(new RegExp('^' + namespaces + '$'));
			}
		}
	}

	/**
	* Disable debug output.
	*
	* @return {String} namespaces
	* @api public
	*/
	function disable() {
		const namespaces = [
			...createDebug.names.map(toNamespace),
			...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
		].join(',');
		createDebug.enable('');
		return namespaces;
	}

	/**
	* Returns true if the given mode name is enabled, false otherwise.
	*
	* @param {String} name
	* @return {Boolean}
	* @api public
	*/
	function enabled(name) {
		if (name[name.length - 1] === '*') {
			return true;
		}

		let i;
		let len;

		for (i = 0, len = createDebug.skips.length; i < len; i++) {
			if (createDebug.skips[i].test(name)) {
				return false;
			}
		}

		for (i = 0, len = createDebug.names.length; i < len; i++) {
			if (createDebug.names[i].test(name)) {
				return true;
			}
		}

		return false;
	}

	/**
	* Convert regexp to namespace
	*
	* @param {RegExp} regxep
	* @return {String} namespace
	* @api private
	*/
	function toNamespace(regexp) {
		return regexp.toString()
			.substring(2, regexp.toString().length - 2)
			.replace(/\.\*\?$/, '*');
	}

	/**
	* Coerce `val`.
	*
	* @param {Mixed} val
	* @return {Mixed}
	* @api private
	*/
	function coerce(val) {
		if (val instanceof Error) {
			return val.stack || val.message;
		}
		return val;
	}

	/**
	* XXX DO NOT USE. This is a temporary stub function.
	* XXX It WILL be removed in the next major release.
	*/
	function destroy() {
		console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
	}

	createDebug.enable(createDebug.load());

	return createDebug;
}

var common = setup;

/* eslint-env browser */

var browser = createCommonjsModule(function (module, exports) {
/**
 * This is the web browser implementation of `debug()`.
 */

exports.formatArgs = formatArgs;
exports.save = save;
exports.load = load;
exports.useColors = useColors;
exports.storage = localstorage();
exports.destroy = (() => {
	let warned = false;

	return () => {
		if (!warned) {
			warned = true;
			console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
		}
	};
})();

/**
 * Colors.
 */

exports.colors = [
	'#0000CC',
	'#0000FF',
	'#0033CC',
	'#0033FF',
	'#0066CC',
	'#0066FF',
	'#0099CC',
	'#0099FF',
	'#00CC00',
	'#00CC33',
	'#00CC66',
	'#00CC99',
	'#00CCCC',
	'#00CCFF',
	'#3300CC',
	'#3300FF',
	'#3333CC',
	'#3333FF',
	'#3366CC',
	'#3366FF',
	'#3399CC',
	'#3399FF',
	'#33CC00',
	'#33CC33',
	'#33CC66',
	'#33CC99',
	'#33CCCC',
	'#33CCFF',
	'#6600CC',
	'#6600FF',
	'#6633CC',
	'#6633FF',
	'#66CC00',
	'#66CC33',
	'#9900CC',
	'#9900FF',
	'#9933CC',
	'#9933FF',
	'#99CC00',
	'#99CC33',
	'#CC0000',
	'#CC0033',
	'#CC0066',
	'#CC0099',
	'#CC00CC',
	'#CC00FF',
	'#CC3300',
	'#CC3333',
	'#CC3366',
	'#CC3399',
	'#CC33CC',
	'#CC33FF',
	'#CC6600',
	'#CC6633',
	'#CC9900',
	'#CC9933',
	'#CCCC00',
	'#CCCC33',
	'#FF0000',
	'#FF0033',
	'#FF0066',
	'#FF0099',
	'#FF00CC',
	'#FF00FF',
	'#FF3300',
	'#FF3333',
	'#FF3366',
	'#FF3399',
	'#FF33CC',
	'#FF33FF',
	'#FF6600',
	'#FF6633',
	'#FF9900',
	'#FF9933',
	'#FFCC00',
	'#FFCC33'
];

/**
 * Currently only WebKit-based Web Inspectors, Firefox >= v31,
 * and the Firebug extension (any Firefox version) are known
 * to support "%c" CSS customizations.
 *
 * TODO: add a `localStorage` variable to explicitly enable/disable colors
 */

// eslint-disable-next-line complexity
function useColors() {
	// NB: In an Electron preload script, document will be defined but not fully
	// initialized. Since we know we're in Chrome, we'll just detect this case
	// explicitly
	if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
		return true;
	}

	// Internet Explorer and Edge do not support colors.
	if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
		return false;
	}

	// Is webkit? http://stackoverflow.com/a/16459606/376773
	// document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
	return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
		// Is firebug? http://stackoverflow.com/a/398120/376773
		(typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
		// Is firefox >= v31?
		// https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
		// Double check webkit in userAgent just in case we are in a worker
		(typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
}

/**
 * Colorize log arguments if enabled.
 *
 * @api public
 */

function formatArgs(args) {
	args[0] = (this.useColors ? '%c' : '') +
		this.namespace +
		(this.useColors ? ' %c' : ' ') +
		args[0] +
		(this.useColors ? '%c ' : ' ') +
		'+' + module.exports.humanize(this.diff);

	if (!this.useColors) {
		return;
	}

	const c = 'color: ' + this.color;
	args.splice(1, 0, c, 'color: inherit');

	// The final "%c" is somewhat tricky, because there could be other
	// arguments passed either before or after the %c, so we need to
	// figure out the correct index to insert the CSS into
	let index = 0;
	let lastC = 0;
	args[0].replace(/%[a-zA-Z%]/g, match => {
		if (match === '%%') {
			return;
		}
		index++;
		if (match === '%c') {
			// We only are interested in the *last* %c
			// (the user may have provided their own)
			lastC = index;
		}
	});

	args.splice(lastC, 0, c);
}

/**
 * Invokes `console.debug()` when available.
 * No-op when `console.debug` is not a "function".
 * If `console.debug` is not available, falls back
 * to `console.log`.
 *
 * @api public
 */
exports.log = console.debug || console.log || (() => {});

/**
 * Save `namespaces`.
 *
 * @param {String} namespaces
 * @api private
 */
function save(namespaces) {
	try {
		if (namespaces) {
			exports.storage.setItem('debug', namespaces);
		} else {
			exports.storage.removeItem('debug');
		}
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

/**
 * Load `namespaces`.
 *
 * @return {String} returns the previously persisted debug modes
 * @api private
 */
function load() {
	let r;
	try {
		r = exports.storage.getItem('debug');
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}

	// If debug isn't set in LS, and we're in Electron, try to load $DEBUG
	if (!r && typeof process !== 'undefined' && 'env' in process) {
		r = process.env.DEBUG;
	}

	return r;
}

/**
 * Localstorage attempts to return the localstorage.
 *
 * This is necessary because safari throws
 * when a user disables cookies/localstorage
 * and you attempt to access it.
 *
 * @return {LocalStorage}
 * @api private
 */

function localstorage() {
	try {
		// TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
		// The Browser also has localStorage in the global context.
		return localStorage;
	} catch (error) {
		// Swallow
		// XXX (@Qix-) should we be logging these?
	}
}

module.exports = common(exports);

const {formatters} = module.exports;

/**
 * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
 */

formatters.j = function (v) {
	try {
		return JSON.stringify(v);
	} catch (error) {
		return '[UnexpectedJSONParseError]: ' + error.message;
	}
};
});

const debug$1 = browser('serialport/stream');

//  VALIDATION
const DATABITS = Object.freeze([5, 6, 7, 8]);
const STOPBITS = Object.freeze([1, 1.5, 2]);
const PARITY = Object.freeze(['none', 'even', 'mark', 'odd', 'space']);
const FLOWCONTROLS = Object.freeze(['xon', 'xoff', 'xany', 'rtscts']);

const defaultSettings = Object.freeze({
  autoOpen: true,
  endOnClose: false,
  baudRate: 9600,
  dataBits: 8,
  hupcl: true,
  lock: true,
  parity: 'none',
  rtscts: false,
  stopBits: 1,
  xany: false,
  xoff: false,
  xon: false,
  highWaterMark: 64 * 1024,
});

const defaultSetFlags = Object.freeze({
  brk: false,
  cts: false,
  dtr: true,
  dts: false,
  rts: true,
});

function allocNewReadPool(poolSize) {
  const pool = Buffer.allocUnsafe(poolSize);
  pool.used = 0;
  return pool
}

/**
 * A callback called with an error or null.
 * @typedef {function} errorCallback
 * @param {?error} error
 */

/**
 * A callback called with an error or an object with the modem line values (cts, dsr, dcd).
 * @typedef {function} modemBitsCallback
 * @param {?error} error
 * @param {?object} status
 * @param {boolean} [status.cts=false]
 * @param {boolean} [status.dsr=false]
 * @param {boolean} [status.dcd=false]
 */

/**
 * @typedef {Object} openOptions
 * @property {boolean} [autoOpen=true] Automatically opens the port on `nextTick`.
 * @property {number=} [baudRate=9600] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
 * @property {number} [dataBits=8] Must be one of these: 8, 7, 6, or 5.
 * @property {number} [highWaterMark=65536] The size of the read and write buffers defaults to 64k.
 * @property {boolean} [lock=true] Prevent other processes from opening the port. Windows does not currently support `false`.
 * @property {number} [stopBits=1] Must be one of these: 1 or 2.
 * @property {string} [parity=none] Must be one of these: 'none', 'even', 'mark', 'odd', 'space'.
 * @property {boolean} [rtscts=false] flow control setting
 * @property {boolean} [xon=false] flow control setting
 * @property {boolean} [xoff=false] flow control setting
 * @property {boolean} [xany=false] flow control setting
 * @property {object=} bindingOptions sets binding-specific options
 * @property {Binding=} binding The hardware access binding. `Bindings` are how Node-Serialport talks to the underlying system. By default we auto detect Windows (`WindowsBinding`), Linux (`LinuxBinding`) and OS X (`DarwinBinding`) and load the appropriate module for your system.
 * @property {number} [bindingOptions.vmin=1] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding
 * @property {number} [bindingOptions.vtime=0] see [`man termios`](http://linux.die.net/man/3/termios) LinuxBinding and DarwinBinding
 */

/**
 * Create a new serial port object for the `path`. In the case of invalid arguments or invalid options, when constructing a new SerialPort it will throw an error. The port will open automatically by default, which is the equivalent of calling `port.open(openCallback)` in the next tick. You can disable this by setting the option `autoOpen` to `false`.
 * @class SerialPort
 * @param {string} path - The system path of the serial port you want to open. For example, `/dev/tty.XXX` on Mac/Linux, or `COM1` on Windows.
 * @param {openOptions=} options - Port configuration options
 * @param {errorCallback=} openCallback - Called after a connection is opened. If this is not provided and an error occurs, it will be emitted on the port's `error` event. The callback will NOT be called if `autoOpen` is set to `false` in the `openOptions` as the open will not be performed.
 * @property {number} baudRate The port's baudRate. Use `.update` to change it. Read-only.
 * @property {object} binding The binding object backing the port. Read-only.
 * @property {boolean} isOpen `true` if the port is open, `false` otherwise. Read-only. (`since 5.0.0`)
 * @property {string} path The system path or name of the serial port. Read-only.
 * @throws {TypeError} When given invalid arguments, a `TypeError` will be thrown.
 * @emits open
 * @emits data
 * @emits close
 * @emits error
 * @alias module:serialport
 */
function SerialPort(path, options, openCallback) {
  if (!(this instanceof SerialPort)) {
    return new SerialPort(path, options, openCallback)
  }

  if (options instanceof Function) {
    openCallback = options;
    options = {};
  }

  const settings = { ...defaultSettings, ...options };

  stream.Duplex.call(this, {
    highWaterMark: settings.highWaterMark,
  });

  const Binding = settings.binding || SerialPort.Binding;

  if (!Binding) {
    throw new TypeError('"Bindings" is invalid pass it as `options.binding` or set it on `SerialPort.Binding`')
  }

  if (!path) {
    throw new TypeError(`"path" is not defined: ${path}`)
  }

  if (settings.baudrate) {
    throw new TypeError(`"baudrate" is an unknown option, did you mean "baudRate"?`)
  }

  if (typeof settings.baudRate !== 'number') {
    throw new TypeError(`"baudRate" must be a number: ${settings.baudRate}`)
  }

  if (DATABITS.indexOf(settings.dataBits) === -1) {
    throw new TypeError(`"databits" is invalid: ${settings.dataBits}`)
  }

  if (STOPBITS.indexOf(settings.stopBits) === -1) {
    throw new TypeError(`"stopbits" is invalid: ${settings.stopbits}`)
  }

  if (PARITY.indexOf(settings.parity) === -1) {
    throw new TypeError(`"parity" is invalid: ${settings.parity}`)
  }

  FLOWCONTROLS.forEach(control => {
    if (typeof settings[control] !== 'boolean') {
      throw new TypeError(`"${control}" is not boolean: ${settings[control]}`)
    }
  });

  const binding = new Binding({
    bindingOptions: settings.bindingOptions,
  });

  Object.defineProperties(this, {
    binding: {
      enumerable: true,
      value: binding,
    },
    path: {
      enumerable: true,
      value: path,
    },
    settings: {
      enumerable: true,
      value: settings,
    },
  });

  this.opening = false;
  this.closing = false;
  this._pool = allocNewReadPool(this.settings.highWaterMark);
  this._kMinPoolSpace = 128;

  if (this.settings.autoOpen) {
    this.open(openCallback);
  }
}

util$2.inherits(SerialPort, stream.Duplex);

Object.defineProperties(SerialPort.prototype, {
  isOpen: {
    enumerable: true,
    get() {
      return this.binding.isOpen && !this.closing
    },
  },
  baudRate: {
    enumerable: true,
    get() {
      return this.settings.baudRate
    },
  },
});

/**
 * The `error` event's callback is called with an error object whenever there is an error.
 * @event error
 */

SerialPort.prototype._error = function (error, callback) {
  if (callback) {
    callback.call(this, error);
  } else {
    this.emit('error', error);
  }
};

SerialPort.prototype._asyncError = function (error, callback) {
  process.nextTick(() => this._error(error, callback));
};

/**
 * The `open` event's callback is called with no arguments when the port is opened and ready for writing. This happens if you have the constructor open immediately (which opens in the next tick) or if you open the port manually with `open()`. See [Useage/Opening a Port](#opening-a-port) for more information.
 * @event open
 */

/**
 * Opens a connection to the given serial port.
 * @param {errorCallback=} openCallback - Called after a connection is opened. If this is not provided and an error occurs, it will be emitted on the port's `error` event.
 * @emits open
 * @returns {undefined}
 */
SerialPort.prototype.open = function (openCallback) {
  if (this.isOpen) {
    return this._asyncError(new Error('Port is already open'), openCallback)
  }

  if (this.opening) {
    return this._asyncError(new Error('Port is opening'), openCallback)
  }

  this.opening = true;
  debug$1('opening', `path: ${this.path}`);
  this.binding.open(this.path, this.settings).then(
    () => {
      debug$1('opened', `path: ${this.path}`);
      this.opening = false;
      this.emit('open');
      if (openCallback) {
        openCallback.call(this, null);
      }
    },
    err => {
      this.opening = false;
      debug$1('Binding #open had an error', err);
      this._error(err, openCallback);
    }
  );
};

/**
 * Changes the baud rate for an open port. Throws if you provide a bad argument. Emits an error or calls the callback if the baud rate isn't supported.
 * @param {object=} options Only supports `baudRate`.
 * @param {number=} [options.baudRate] The baud rate of the port to be opened. This should match one of the commonly available baud rates, such as 110, 300, 1200, 2400, 4800, 9600, 14400, 19200, 38400, 57600, or 115200. Custom rates are supported best effort per platform. The device connected to the serial port is not guaranteed to support the requested baud rate, even if the port itself supports that baud rate.
 * @param {errorCallback=} [callback] Called once the port's baud rate changes. If `.update` is called without a callback, and there is an error, an error event is emitted.
 * @returns {undefined}
 */
SerialPort.prototype.update = function (options, callback) {
  if (typeof options !== 'object') {
    throw TypeError('"options" is not an object')
  }

  if (!this.isOpen) {
    debug$1('update attempted, but port is not open');
    return this._asyncError(new Error('Port is not open'), callback)
  }

  const settings = { ...defaultSettings, ...options };
  this.settings.baudRate = settings.baudRate;

  debug$1('update', `baudRate: ${settings.baudRate}`);
  this.binding.update(this.settings).then(
    () => {
      debug$1('binding.update', 'finished');
      if (callback) {
        callback.call(this, null);
      }
    },
    err => {
      debug$1('binding.update', 'error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * Writes data to the given serial port. Buffers written data if the port is not open.

The write operation is non-blocking. When it returns, data might still not have been written to the serial port. See `drain()`.

Some devices, like the Arduino, reset when you open a connection to them. In such cases, immediately writing to the device will cause lost data as they wont be ready to receive the data. This is often worked around by having the Arduino send a "ready" byte that your Node program waits for before writing. You can also often get away with waiting around 400ms.

If a port is disconnected during a write, the write will error in addition to the `close` event.

From the [stream docs](https://nodejs.org/api/stream.html#stream_writable_write_chunk_encoding_callback) write errors don't always provide the error in the callback, sometimes they use the error event.
> If an error occurs, the callback may or may not be called with the error as its first argument. To reliably detect write errors, add a listener for the 'error' event.

In addition to the usual `stream.write` arguments (`String` and `Buffer`), `write()` can accept arrays of bytes (positive numbers under 256) which is passed to `Buffer.from([])` for conversion. This extra functionality is pretty sweet.
 * @method SerialPort.prototype.write
 * @param  {(string|array|buffer)} data Accepts a [`Buffer`](http://nodejs.org/api/buffer.html) object, or a type that is accepted by the `Buffer` constructor (e.g. an array of bytes or a string).
 * @param  {string=} encoding The encoding, if chunk is a string. Defaults to `'utf8'`. Also accepts `'ascii'`, `'base64'`, `'binary'`, and `'hex'` See [Buffers and Character Encodings](https://nodejs.org/api/buffer.html#buffer_buffers_and_character_encodings) for all available options.
 * @param  {function=} callback Called once the write operation finishes. Data may not yet be flushed to the underlying port. No arguments.
 * @returns {boolean} `false` if the stream wishes for the calling code to wait for the `'drain'` event to be emitted before continuing to write additional data; otherwise `true`.
 * @since 5.0.0
 */
const superWrite = SerialPort.prototype.write;
SerialPort.prototype.write = function (data, encoding, callback) {
  if (Array.isArray(data)) {
    data = Buffer.from(data);
  }
  return superWrite.call(this, data, encoding, callback)
};

SerialPort.prototype._write = function (data, encoding, callback) {
  if (!this.isOpen) {
    return this.once('open', function afterOpenWrite() {
      this._write(data, encoding, callback);
    })
  }
  debug$1('_write', `${data.length} bytes of data`);
  this.binding.write(data).then(
    () => {
      debug$1('binding.write', 'write finished');
      callback(null);
    },
    err => {
      debug$1('binding.write', 'error', err);
      if (!err.canceled) {
        this._disconnected(err);
      }
      callback(err);
    }
  );
};

SerialPort.prototype._writev = function (data, callback) {
  debug$1('_writev', `${data.length} chunks of data`);
  const dataV = data.map(write => write.chunk);
  this._write(Buffer.concat(dataV), null, callback);
};

/**
 * Request a number of bytes from the SerialPort. The `read()` method pulls some data out of the internal buffer and returns it. If no data is available to be read, null is returned. By default, the data is returned as a `Buffer` object unless an encoding has been specified using the `.setEncoding()` method.
 * @method SerialPort.prototype.read
 * @param {number=} size Specify how many bytes of data to return, if available
 * @returns {(string|Buffer|null)} The data from internal buffers
 * @since 5.0.0
 */

/**
 * Listening for the `data` event puts the port in flowing mode. Data is emitted as soon as it's received. Data is a `Buffer` object with a varying amount of data in it. The `readLine` parser converts the data into string lines. See the [parsers](https://serialport.io/docs/api-parsers-overview) section for more information on parsers, and the [Node.js stream documentation](https://nodejs.org/api/stream.html#stream_event_data) for more information on the data event.
 * @event data
 */

SerialPort.prototype._read = function (bytesToRead) {
  if (!this.isOpen) {
    debug$1('_read', 'queueing _read for after open');
    this.once('open', () => {
      this._read(bytesToRead);
    });
    return
  }

  if (!this._pool || this._pool.length - this._pool.used < this._kMinPoolSpace) {
    debug$1('_read', 'discarding the read buffer pool because it is below kMinPoolSpace');
    this._pool = allocNewReadPool(this.settings.highWaterMark);
  }

  // Grab another reference to the pool in the case that while we're
  // in the thread pool another read() finishes up the pool, and
  // allocates a new one.
  const pool = this._pool;
  // Read the smaller of rest of the pool or however many bytes we want
  const toRead = Math.min(pool.length - pool.used, bytesToRead);
  const start = pool.used;

  // the actual read.
  debug$1('_read', `reading`, { start, toRead });
  this.binding.read(pool, start, toRead).then(
    ({ bytesRead }) => {
      debug$1('binding.read', `finished`, { bytesRead });
      // zero bytes means read means we've hit EOF? Maybe this should be an error
      if (bytesRead === 0) {
        debug$1('binding.read', 'Zero bytes read closing readable stream');
        this.push(null);
        return
      }
      pool.used += bytesRead;
      this.push(pool.slice(start, start + bytesRead));
    },
    err => {
      debug$1('binding.read', `error`, err);
      if (!err.canceled) {
        this._disconnected(err);
      }
      this._read(bytesToRead); // prime to read more once we're reconnected
    }
  );
};

SerialPort.prototype._disconnected = function (err) {
  if (!this.isOpen) {
    debug$1('disconnected aborted because already closed', err);
    return
  }
  debug$1('disconnected', err);
  err.disconnected = true;
  this.close(null, err);
};

/**
 * The `close` event's callback is called with no arguments when the port is closed. In the case of a disconnect it will be called with a Disconnect Error object (`err.disconnected == true`). In the event of a close error (unlikely), an error event is triggered.
 * @event close
 */

/**
 * Closes an open connection.
 *
 * If there are in progress writes when the port is closed the writes will error.
 * @param {errorCallback} callback Called once a connection is closed.
 * @param {Error} disconnectError used internally to propagate a disconnect error
 * @emits close
 * @returns {undefined}
 */
SerialPort.prototype.close = function (callback, disconnectError) {
  disconnectError = disconnectError || null;

  if (!this.isOpen) {
    debug$1('close attempted, but port is not open');
    return this._asyncError(new Error('Port is not open'), callback)
  }

  this.closing = true;
  debug$1('#close');
  this.binding.close().then(
    () => {
      this.closing = false;
      debug$1('binding.close', 'finished');
      this.emit('close', disconnectError);
      if (this.settings.endOnClose) {
        this.emit('end');
      }
      if (callback) {
        callback.call(this, disconnectError);
      }
    },
    err => {
      this.closing = false;
      debug$1('binding.close', 'had an error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * Set control flags on an open port. Uses [`SetCommMask`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363257(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for OS X and Linux.
 * @param {object=} options All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. If options isn't provided default options is used.
 * @param {Boolean} [options.brk=false] sets the brk flag
 * @param {Boolean} [options.cts=false] sets the cts flag
 * @param {Boolean} [options.dsr=false] sets the dsr flag
 * @param {Boolean} [options.dtr=true] sets the dtr flag
 * @param {Boolean} [options.rts=true] sets the rts flag
 * @param {errorCallback=} callback Called once the port's flags have been set.
 * @since 5.0.0
 * @returns {undefined}
 */
SerialPort.prototype.set = function (options, callback) {
  if (typeof options !== 'object') {
    throw TypeError('"options" is not an object')
  }

  if (!this.isOpen) {
    debug$1('set attempted, but port is not open');
    return this._asyncError(new Error('Port is not open'), callback)
  }

  const settings = { ...defaultSetFlags, ...options };
  debug$1('#set', settings);
  this.binding.set(settings).then(
    () => {
      debug$1('binding.set', 'finished');
      if (callback) {
        callback.call(this, null);
      }
    },
    err => {
      debug$1('binding.set', 'had an error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * Returns the control flags (CTS, DSR, DCD) on the open port.
 * Uses [`GetCommModemStatus`](https://msdn.microsoft.com/en-us/library/windows/desktop/aa363258(v=vs.85).aspx) for Windows and [`ioctl`](http://linux.die.net/man/4/tty_ioctl) for mac and linux.
 * @param {modemBitsCallback=} callback Called once the modem bits are retrieved.
 * @returns {undefined}
 */
SerialPort.prototype.get = function (callback) {
  if (!this.isOpen) {
    debug$1('get attempted, but port is not open');
    return this._asyncError(new Error('Port is not open'), callback)
  }

  debug$1('#get');
  this.binding.get().then(
    status => {
      debug$1('binding.get', 'finished');
      if (callback) {
        callback.call(this, null, status);
      }
    },
    err => {
      debug$1('binding.get', 'had an error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * Flush discards data received but not read, and written but not transmitted by the operating system. For more technical details, see [`tcflush(fd, TCIOFLUSH)`](http://linux.die.net/man/3/tcflush) for Mac/Linux and [`FlushFileBuffers`](http://msdn.microsoft.com/en-us/library/windows/desktop/aa364439) for Windows.
 * @param  {errorCallback=} callback Called once the flush operation finishes.
 * @returns {undefined}
 */
SerialPort.prototype.flush = function (callback) {
  if (!this.isOpen) {
    debug$1('flush attempted, but port is not open');
    return this._asyncError(new Error('Port is not open'), callback)
  }

  debug$1('#flush');
  this.binding.flush().then(
    () => {
      debug$1('binding.flush', 'finished');
      if (callback) {
        callback.call(this, null);
      }
    },
    err => {
      debug$1('binding.flush', 'had an error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * Waits until all output data is transmitted to the serial port. After any pending write has completed it calls [`tcdrain()`](http://linux.die.net/man/3/tcdrain) or [FlushFileBuffers()](https://msdn.microsoft.com/en-us/library/windows/desktop/aa364439(v=vs.85).aspx) to ensure it has been written to the device.
 * @param {errorCallback=} callback Called once the drain operation returns.
 * @returns {undefined}
 * @example
Write the `data` and wait until it has finished transmitting to the target serial port before calling the callback. This will queue until the port is open and writes are finished.

```js
function writeAndDrain (data, callback) {
  port.write(data);
  port.drain(callback);
}
```
 */
SerialPort.prototype.drain = function (callback) {
  debug$1('drain');
  if (!this.isOpen) {
    debug$1('drain queuing on port open');
    return this.once('open', () => {
      this.drain(callback);
    })
  }
  this.binding.drain().then(
    () => {
      debug$1('binding.drain', 'finished');
      if (callback) {
        callback.call(this, null);
      }
    },
    err => {
      debug$1('binding.drain', 'had an error', err);
      return this._error(err, callback)
    }
  );
};

/**
 * The `pause()` method causes a stream in flowing mode to stop emitting 'data' events, switching out of flowing mode. Any data that becomes available remains in the internal buffer.
 * @method SerialPort.prototype.pause
 * @see resume
 * @since 5.0.0
 * @returns `this`
 */

/**
 * The `resume()` method causes an explicitly paused, `Readable` stream to resume emitting 'data' events, switching the stream into flowing mode.
 * @method SerialPort.prototype.resume
 * @see pause
 * @since 5.0.0
 * @returns `this`
 */

/**
 * Retrieves a list of available serial ports with metadata. Only the `path` is guaranteed. If unavailable the other fields will be undefined. The `path` is either the path or an identifier (eg `COM1`) used to open the SerialPort.
 *
 * We make an effort to identify the hardware attached and have consistent results between systems. Linux and OS X are mostly consistent. Windows relies on 3rd party device drivers for the information and is unable to guarantee the information. On windows If you have a USB connected device can we provide a serial number otherwise it will be `undefined`. The `pnpId` and `locationId` are not the same or present on all systems. The examples below were run with the same Arduino Uno.
 * @type {function}
 * @returns {Promise} Resolves with the list of available serial ports.
 * @example
```js
// OSX example port
{
  path: '/dev/tty.usbmodem1421',
  manufacturer: 'Arduino (www.arduino.cc)',
  serialNumber: '752303138333518011C1',
  pnpId: undefined,
  locationId: '14500000',
  productId: '0043',
  vendorId: '2341'
}

// Linux example port
{
  path: '/dev/ttyACM0',
  manufacturer: 'Arduino (www.arduino.cc)',
  serialNumber: '752303138333518011C1',
  pnpId: 'usb-Arduino__www.arduino.cc__0043_752303138333518011C1-if00',
  locationId: undefined,
  productId: '0043',
  vendorId: '2341'
}

// Windows example port
{
  path: 'COM3',
  manufacturer: 'Arduino LLC (www.arduino.cc)',
  serialNumber: '752303138333518011C1',
  pnpId: 'USB\\VID_2341&PID_0043\\752303138333518011C1',
  locationId: 'Port_#0003.Hub_#0001',
  productId: '0043',
  vendorId: '2341'
}
```

```js
var SerialPort = require('serialport');

// promise approach
SerialPort.list()
  .then(ports) {...});
  .catch(err) {...});
```
 */
SerialPort.list = async function (callback) {
  debug$1('.list');
  if (!SerialPort.Binding) {
    throw new TypeError('No Binding set on `SerialPort.Binding`')
  }
  if (callback) {
    throw new TypeError('SerialPort.list no longer takes a callback and only returns a promise')
  }
  return SerialPort.Binding.list()
};

var lib$a = SerialPort;

/**
 * Module dependencies.
 */

var sep = path.sep || '/';

/**
 * Module exports.
 */

var fileUriToPath_1 = fileUriToPath;

/**
 * File URI to Path function.
 *
 * @param {String} uri
 * @return {String} path
 * @api public
 */

function fileUriToPath (uri) {
  if ('string' != typeof uri ||
      uri.length <= 7 ||
      'file://' != uri.substring(0, 7)) {
    throw new TypeError('must pass in a file:// URI to convert to a file path');
  }

  var rest = decodeURI(uri.substring(7));
  var firstSlash = rest.indexOf('/');
  var host = rest.substring(0, firstSlash);
  var path = rest.substring(firstSlash + 1);

  // 2.  Scheme Definition
  // As a special case, <host> can be the string "localhost" or the empty
  // string; this is interpreted as "the machine from which the URL is
  // being interpreted".
  if ('localhost' == host) host = '';

  if (host) {
    host = sep + sep + host;
  }

  // 3.2  Drives, drive letters, mount points, file system root
  // Drive letters are mapped into the top of a file URI in various ways,
  // depending on the implementation; some applications substitute
  // vertical bar ("|") for the colon after the drive letter, yielding
  // "file:///c|/tmp/test.txt".  In some cases, the colon is left
  // unchanged, as in "file:///c:/tmp/test.txt".  In other cases, the
  // colon is simply omitted, as in "file:///c/tmp/test.txt".
  path = path.replace(/^(.+)\|/, '$1:');

  // for Windows, we need to invert the path separators from what a URI uses
  if (sep == '\\') {
    path = path.replace(/\//g, '\\');
  }

  if (/^.+\:/.test(path)) ; else {
    // unix path…
    path = sep + path;
  }

  return host + path;
}

/**
 * Module dependencies.
 */

var bindings_1 = createCommonjsModule(function (module, exports) {
var join = path.join,
  dirname = path.dirname,
  exists =
    (fs.accessSync &&
      function(path) {
        try {
          fs.accessSync(path);
        } catch (e) {
          return false;
        }
        return true;
      }) ||
    fs.existsSync ||
    path.existsSync,
  defaults = {
    arrow: process.env.NODE_BINDINGS_ARROW || ' → ',
    compiled: process.env.NODE_BINDINGS_COMPILED_DIR || 'compiled',
    platform: process.platform,
    arch: process.arch,
    nodePreGyp:
      'node-v' +
      process.versions.modules +
      '-' +
      process.platform +
      '-' +
      process.arch,
    version: process.versions.node,
    bindings: 'bindings.node',
    try: [
      // node-gyp's linked version in the "build" dir
      ['module_root', 'build', 'bindings'],
      // node-waf and gyp_addon (a.k.a node-gyp)
      ['module_root', 'build', 'Debug', 'bindings'],
      ['module_root', 'build', 'Release', 'bindings'],
      // Debug files, for development (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Debug', 'bindings'],
      ['module_root', 'Debug', 'bindings'],
      // Release files, but manually compiled (legacy behavior, remove for node v0.9)
      ['module_root', 'out', 'Release', 'bindings'],
      ['module_root', 'Release', 'bindings'],
      // Legacy from node-waf, node <= 0.4.x
      ['module_root', 'build', 'default', 'bindings'],
      // Production "Release" buildtype binary (meh...)
      ['module_root', 'compiled', 'version', 'platform', 'arch', 'bindings'],
      // node-qbs builds
      ['module_root', 'addon-build', 'release', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'debug', 'install-root', 'bindings'],
      ['module_root', 'addon-build', 'default', 'install-root', 'bindings'],
      // node-pre-gyp path ./lib/binding/{node_abi}-{platform}-{arch}
      ['module_root', 'lib', 'binding', 'nodePreGyp', 'bindings']
    ]
  };

/**
 * The main `bindings()` function loads the compiled bindings for a given module.
 * It uses V8's Error API to determine the parent filename that this function is
 * being invoked from, which is then used to find the root directory.
 */

function bindings(opts) {
  // Argument surgery
  if (typeof opts == 'string') {
    opts = { bindings: opts };
  } else if (!opts) {
    opts = {};
  }

  // maps `defaults` onto `opts` object
  Object.keys(defaults).map(function(i) {
    if (!(i in opts)) opts[i] = defaults[i];
  });

  // Get the module root
  if (!opts.module_root) {
    opts.module_root = exports.getRoot(exports.getFileName());
  }

  // Ensure the given bindings name ends with .node
  if (path.extname(opts.bindings) != '.node') {
    opts.bindings += '.node';
  }

  // https://github.com/webpack/webpack/issues/4175#issuecomment-342931035
  var requireFunc =
    typeof __webpack_require__ === 'function'
      ? __non_webpack_require__
      : commonjsRequire;

  var tries = [],
    i = 0,
    l = opts.try.length,
    n,
    b,
    err;

  for (; i < l; i++) {
    n = join.apply(
      null,
      opts.try[i].map(function(p) {
        return opts[p] || p;
      })
    );
    tries.push(n);
    try {
      b = opts.path ? requireFunc.resolve(n) : requireFunc(n);
      if (!opts.path) {
        b.path = n;
      }
      return b;
    } catch (e) {
      if (e.code !== 'MODULE_NOT_FOUND' &&
          e.code !== 'QUALIFIED_PATH_RESOLUTION_FAILED' &&
          !/not find/i.test(e.message)) {
        throw e;
      }
    }
  }

  err = new Error(
    'Could not locate the bindings file. Tried:\n' +
      tries
        .map(function(a) {
          return opts.arrow + a;
        })
        .join('\n')
  );
  err.tries = tries;
  throw err;
}
module.exports = exports = bindings;

/**
 * Gets the filename of the JavaScript file that invokes this function.
 * Used to help find the root directory of a module.
 * Optionally accepts an filename argument to skip when searching for the invoking filename
 */

exports.getFileName = function getFileName(calling_file) {
  var origPST = Error.prepareStackTrace,
    origSTL = Error.stackTraceLimit,
    dummy = {},
    fileName;

  Error.stackTraceLimit = 10;

  Error.prepareStackTrace = function(e, st) {
    for (var i = 0, l = st.length; i < l; i++) {
      fileName = st[i].getFileName();
      if (fileName !== __filename) {
        if (calling_file) {
          if (fileName !== calling_file) {
            return;
          }
        } else {
          return;
        }
      }
    }
  };

  // run the 'prepareStackTrace' function above
  Error.captureStackTrace(dummy);
  dummy.stack;

  // cleanup
  Error.prepareStackTrace = origPST;
  Error.stackTraceLimit = origSTL;

  // handle filename that starts with "file://"
  var fileSchema = 'file://';
  if (fileName.indexOf(fileSchema) === 0) {
    fileName = fileUriToPath_1(fileName);
  }

  return fileName;
};

/**
 * Gets the root directory of a module, given an arbitrary filename
 * somewhere in the module tree. The "root directory" is the directory
 * containing the `package.json` file.
 *
 *   In:  /home/nate/node-native-module/lib/index.js
 *   Out: /home/nate/node-native-module
 */

exports.getRoot = function getRoot(file) {
  var dir = dirname(file),
    prev;
  while (true) {
    if (dir === '.') {
      // Avoids an infinite loop in rare cases, like the REPL
      dir = process.cwd();
    }
    if (
      exists(join(dir, 'package.json')) ||
      exists(join(dir, 'node_modules'))
    ) {
      // Found the 'package.json' file or 'node_modules' dir; we're done
      return dir;
    }
    if (prev === dir) {
      // Got to the top
      throw new Error(
        'Could not find module root given file: "' +
          file +
          '". Do you have a `package.json` file? '
      );
    }
    // Try the parent dir next
    prev = dir;
    dir = join(dir, '..');
  }
};
});

const debug = browser('serialport/binding-abstract');

/**
 * @name Binding
 * @type {AbstractBinding}
 * @since 5.0.0
 * @description The `Binding` is how Node-SerialPort talks to the underlying system. By default, we auto detect Windows, Linux and OS X, and load the appropriate module for your system. You can assign `SerialPort.Binding` to any binding you like. Find more by searching at [npm](https://npmjs.org/).
  Prevent auto loading the default bindings by requiring SerialPort with:
  ```js
  var SerialPort = require('@serialport/stream');
  SerialPort.Binding = MyBindingClass;
  ```
 */

/**
 * You never have to use `Binding` objects directly. SerialPort uses them to access the underlying hardware. This documentation is geared towards people who are making bindings for different platforms. This class can be inherited from to get type checking for each method.
 * @class AbstractBinding
 * @param {object} options options for the binding
 * @property {boolean} isOpen Required property. `true` if the port is open, `false` otherwise. Should be read-only.
 * @throws {TypeError} When given invalid arguments, a `TypeError` is thrown.
 * @since 5.0.0
 */
class AbstractBinding {
  /**
   * Retrieves a list of available serial ports with metadata. The `path` must be guaranteed, and all other fields should be undefined if unavailable. The `path` is either the path or an identifier (eg `COM1`) used to open the serialport.
   * @returns {Promise} resolves to an array of port [info objects](#module_serialport--SerialPort.list).
   */
  static async list() {
    debug('list');
  }

  constructor(opt = {}) {
    if (typeof opt !== 'object') {
      throw new TypeError('"options" is not an object')
    }
  }

  /**
   * Opens a connection to the serial port referenced by the path.
   * @param {string} path the path or com port to open
   * @param {openOptions} options openOptions for the serialport
   * @returns {Promise} Resolves after the port is opened and configured.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async open(path, options) {
    if (!path) {
      throw new TypeError('"path" is not a valid port')
    }

    if (typeof options !== 'object') {
      throw new TypeError('"options" is not an object')
    }
    debug('open');

    if (this.isOpen) {
      throw new Error('Already open')
    }
  }

  /**
   * Closes an open connection
   * @returns {Promise} Resolves once the connection is closed.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async close() {
    debug('close');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Request a number of bytes from the SerialPort. This function is similar to Node's [`fs.read`](http://nodejs.org/api/fs.html#fs_fs_read_fd_buffer_offset_length_position_callback) except it will always return at least one byte.

The in progress reads must error when the port is closed with an error object that has the property `canceled` equal to `true`. Any other error will cause a disconnection.

   * @param {buffer} buffer Accepts a [`Buffer`](http://nodejs.org/api/buffer.html) object.
   * @param {integer} offset The offset in the buffer to start writing at.
   * @param {integer} length Specifies the maximum number of bytes to read.
   * @returns {Promise} Resolves with the number of bytes read after a read operation.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async read(buffer, offset, length) {
    if (!Buffer.isBuffer(buffer)) {
      throw new TypeError('"buffer" is not a Buffer')
    }

    if (typeof offset !== 'number' || isNaN(offset)) {
      throw new TypeError(`"offset" is not an integer got "${isNaN(offset) ? 'NaN' : typeof offset}"`)
    }

    if (typeof length !== 'number' || isNaN(length)) {
      throw new TypeError(`"length" is not an integer got "${isNaN(length) ? 'NaN' : typeof length}"`)
    }

    debug('read');
    if (buffer.length < offset + length) {
      throw new Error('buffer is too small')
    }

    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Write bytes to the SerialPort. Only called when there is no pending write operation.

The in progress writes must error when the port is closed with an error object that has the property `canceled` equal to `true`. Any other error will cause a disconnection.

   * @param {buffer} buffer - Accepts a [`Buffer`](http://nodejs.org/api/buffer.html) object.
   * @returns {Promise} Resolves after the data is passed to the operating system for writing.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async write(buffer) {
    if (!Buffer.isBuffer(buffer)) {
      throw new TypeError('"buffer" is not a Buffer')
    }

    debug('write', buffer.length, 'bytes');
    if (!this.isOpen) {
      debug('write', 'error port is not open');

      throw new Error('Port is not open')
    }
  }

  /**
   * Changes connection settings on an open port. Only `baudRate` is supported.
   * @param {object=} options Only supports `baudRate`.
   * @param {number=} [options.baudRate] If provided a baud rate that the bindings do not support, it should reject.
   * @returns {Promise} Resolves once the port's baud rate changes.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async update(options) {
    if (typeof options !== 'object') {
      throw TypeError('"options" is not an object')
    }

    if (typeof options.baudRate !== 'number') {
      throw new TypeError('"options.baudRate" is not a number')
    }

    debug('update');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Set control flags on an open port.
   * @param {object=} options All options are operating system default when the port is opened. Every flag is set on each call to the provided or default values. All options are always provided.
   * @param {Boolean} [options.brk=false] flag for brk
   * @param {Boolean} [options.cts=false] flag for cts
   * @param {Boolean} [options.dsr=false] flag for dsr
   * @param {Boolean} [options.dtr=true] flag for dtr
   * @param {Boolean} [options.rts=true] flag for rts
   * @param {Boolean} [options.lowLatency=false] flag for lowLatency mode on Linux
   * @returns {Promise} Resolves once the port's flags are set.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async set(options) {
    if (typeof options !== 'object') {
      throw new TypeError('"options" is not an object')
    }
    debug('set');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Get the control flags (CTS, DSR, DCD) on the open port.
   * @returns {Promise} Resolves with the retrieved flags.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async get() {
    debug('get');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Get the OS reported baud rate for the open port.
   * Used mostly for debugging custom baud rates.
   * @returns {Promise} Resolves with the current baud rate.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async getBaudRate() {
    debug('getbaudRate');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Flush (discard) data received but not read, and written but not transmitted.
   * @returns {Promise} Resolves once the flush operation finishes.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async flush() {
    debug('flush');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }

  /**
   * Drain waits until all output data is transmitted to the serial port. An in progress write should be completed before this returns.
   * @returns {Promise} Resolves once the drain operation finishes.
   * @rejects {TypeError} When given invalid arguments, a `TypeError` is rejected.
   */
  async drain() {
    debug('drain');
    if (!this.isOpen) {
      throw new Error('Port is not open')
    }
  }
}

var lib$9 = AbstractBinding;

const PARSERS = [/USB\\(?:.+)\\(.+)/, /FTDIBUS\\(?:.+)\+(.+?)A?\\.+/];

var win32SnParser = pnpId => {
  if (!pnpId) {
    return null
  }
  for (const parser of PARSERS) {
    const sn = pnpId.match(parser);
    if (sn) {
      return sn[1]
    }
  }
  return null
};

let warningSent = false;

const wrapWithHiddenComName$3 = async portsPromise => {
  const ports = await portsPromise;
  return ports.map(port => {
    const newPort = { ...port };
    return Object.defineProperties(newPort, {
      comName: {
        get() {
          if (!warningSent) {
            warningSent = true;
            console.warn(
              `"PortInfo.comName" has been deprecated. You should now use "PortInfo.path". The property will be removed in the next major release.`
            );
          }
          return newPort.path
        },
        enumerable: false,
      },
    })
  })
};

var legacy = {
  wrapWithHiddenComName: wrapWithHiddenComName$3,
};

const binding$2 = bindings_1('bindings.node');

const { promisify: promisify$4 } = util$2;


const asyncList$1 = promisify$4(binding$2.list);
const asyncOpen$2 = promisify$4(binding$2.open);
const asyncClose$2 = promisify$4(binding$2.close);
const asyncRead = promisify$4(binding$2.read);
const asyncWrite = promisify$4(binding$2.write);
const asyncUpdate$2 = promisify$4(binding$2.update);
const asyncSet$2 = promisify$4(binding$2.set);
const asyncGet$2 = promisify$4(binding$2.get);
const asyncGetBaudRate$2 = promisify$4(binding$2.getBaudRate);
const asyncDrain$2 = promisify$4(binding$2.drain);
const asyncFlush$2 = promisify$4(binding$2.flush);
const { wrapWithHiddenComName: wrapWithHiddenComName$2 } = legacy;

/**
 * The Windows binding layer
 */
class WindowsBinding extends lib$9 {
  static async list() {
    const ports = await asyncList$1();
    // Grab the serial number from the pnp id
    return wrapWithHiddenComName$2(
      ports.map(port => {
        if (port.pnpId && !port.serialNumber) {
          const serialNumber = win32SnParser(port.pnpId);
          if (serialNumber) {
            return {
              ...port,
              serialNumber,
            }
          }
        }
        return port
      })
    )
  }

  constructor(opt = {}) {
    super(opt);
    this.bindingOptions = { ...opt.bindingOptions };
    this.fd = null;
    this.writeOperation = null;
  }

  get isOpen() {
    return this.fd !== null
  }

  async open(path, options) {
    await super.open(path, options);
    this.openOptions = { ...this.bindingOptions, ...options };
    const fd = await asyncOpen$2(path, this.openOptions);
    this.fd = fd;
  }

  async close() {
    await super.close();
    const fd = this.fd;
    this.fd = null;
    return asyncClose$2(fd)
  }

  async read(buffer, offset, length) {
    await super.read(buffer, offset, length);
    try {
      const bytesRead = await asyncRead(this.fd, buffer, offset, length);
      return { bytesRead, buffer }
    } catch (err) {
      if (!this.isOpen) {
        err.canceled = true;
      }
      throw err
    }
  }

  async write(buffer) {
    this.writeOperation = super.write(buffer).then(async () => {
      if (buffer.length === 0) {
        return
      }
      await asyncWrite(this.fd, buffer);
      this.writeOperation = null;
    });
    return this.writeOperation
  }

  async update(options) {
    await super.update(options);
    return asyncUpdate$2(this.fd, options)
  }

  async set(options) {
    await super.set(options);
    return asyncSet$2(this.fd, options)
  }

  async get() {
    await super.get();
    return asyncGet$2(this.fd)
  }

  async getBaudRate() {
    await super.get();
    return asyncGetBaudRate$2(this.fd)
  }

  async drain() {
    await super.drain();
    await this.writeOperation;
    return asyncDrain$2(this.fd)
  }

  async flush() {
    await super.flush();
    return asyncFlush$2(this.fd)
  }
}

var win32 = WindowsBinding;

const logger$2 = browser('serialport/bindings/poller');

const PollerBindings = bindings_1('bindings.node').Poller;

const EVENTS = {
  UV_READABLE: 0b0001,
  UV_WRITABLE: 0b0010,
  UV_DISCONNECT: 0b0100,
};

function handleEvent(error, eventFlag) {
  if (error) {
    logger$2('error', error);
    this.emit('readable', error);
    this.emit('writable', error);
    this.emit('disconnect', error);
    return
  }
  if (eventFlag & EVENTS.UV_READABLE) {
    logger$2('received "readable"');
    this.emit('readable', null);
  }
  if (eventFlag & EVENTS.UV_WRITABLE) {
    logger$2('received "writable"');
    this.emit('writable', null);
  }
  if (eventFlag & EVENTS.UV_DISCONNECT) {
    logger$2('received "disconnect"');
    this.emit('disconnect', null);
  }
}

/**
 * Polls unix systems for readable or writable states of a file or serialport
 */
class Poller extends events {
  constructor(fd, FDPoller = PollerBindings) {
    logger$2('Creating poller');
    super();
    this.poller = new FDPoller(fd, handleEvent.bind(this));
  }
  /**
   * Wait for the next event to occur
   * @param {string} event ('readable'|'writable'|'disconnect')
   * @returns {Poller} returns itself
   */
  once(event, callback) {
    switch (event) {
      case 'readable':
        this.poll(EVENTS.UV_READABLE);
        break
      case 'writable':
        this.poll(EVENTS.UV_WRITABLE);
        break
      case 'disconnect':
        this.poll(EVENTS.UV_DISCONNECT);
        break
    }
    return super.once(event, callback)
  }

  /**
   * Ask the bindings to listen for an event, it is recommend to use `.once()` for easy use
   * @param {EVENTS} eventFlag polls for an event or group of events based upon a flag.
   * @returns {undefined}
   */
  poll(eventFlag) {
    eventFlag = eventFlag || 0;

    if (eventFlag & EVENTS.UV_READABLE) {
      logger$2('Polling for "readable"');
    }
    if (eventFlag & EVENTS.UV_WRITABLE) {
      logger$2('Polling for "writable"');
    }
    if (eventFlag & EVENTS.UV_DISCONNECT) {
      logger$2('Polling for "disconnect"');
    }

    this.poller.poll(eventFlag);
  }

  /**
   * Stop listening for events and cancel all outstanding listening with an error
   * @returns {undefined}
   */
  stop() {
    logger$2('Stopping poller');
    this.poller.stop();
    this.emitCanceled();
  }

  destroy() {
    logger$2('Destroying poller');
    this.poller.destroy();
    this.emitCanceled();
  }

  emitCanceled() {
    const err = new Error('Canceled');
    err.canceled = true;
    this.emit('readable', err);
    this.emit('writable', err);
    this.emit('disconnect', err);
  }
}

Poller.EVENTS = EVENTS;

var poller = Poller;

const logger$1 = browser('serialport/bindings/unixRead');
const { promisify: promisify$3 } = util$2;

const readAsync = promisify$3(fs.read);

const readable = binding => {
  return new Promise((resolve, reject) => {
    binding.poller.once('readable', err => (err ? reject(err) : resolve()));
  })
};

const unixRead = async ({ binding, buffer, offset, length, fsReadAsync = readAsync }) => {
  logger$1('Starting read');
  if (!binding.isOpen) {
    const err = new Error('Port is not open');
    err.canceled = true;
    throw err
  }

  try {
    const { bytesRead } = await fsReadAsync(binding.fd, buffer, offset, length, null);
    if (bytesRead === 0) {
      return unixRead({ binding, buffer, offset, length, fsReadAsync })
    }
    logger$1('Finished read', bytesRead, 'bytes');
    return { bytesRead, buffer }
  } catch (err) {
    logger$1('read error', err);
    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {
      if (!binding.isOpen) {
        const err = new Error('Port is not open');
        err.canceled = true;
        throw err
      }
      logger$1('waiting for readable because of code:', err.code);
      await readable(binding);
      return unixRead({ binding, buffer, offset, length, fsReadAsync })
    }

    const disconnectError =
      err.code === 'EBADF' || // Bad file number means we got closed
      err.code === 'ENXIO' || // No such device or address probably usb disconnect
      err.code === 'UNKNOWN' ||
      err.errno === -1; // generic error

    if (disconnectError) {
      err.disconnect = true;
      logger$1('disconnecting', err);
    }

    throw err
  }
};

var unixRead_1 = unixRead;

const logger = browser('serialport/bindings/unixWrite');
const { promisify: promisify$2 } = util$2;

const writeAsync = promisify$2(fs.write);

const writable = binding => {
  return new Promise((resolve, reject) => {
    binding.poller.once('writable', err => (err ? reject(err) : resolve()));
  })
};

const unixWrite = async ({ binding, buffer, offset = 0, fsWriteAsync = writeAsync }) => {
  const bytesToWrite = buffer.length - offset;
  logger('Starting write', buffer.length, 'bytes offset', offset, 'bytesToWrite', bytesToWrite);
  if (!binding.isOpen) {
    throw new Error('Port is not open')
  }
  try {
    const { bytesWritten } = await fsWriteAsync(binding.fd, buffer, offset, bytesToWrite);
    logger('write returned: wrote', bytesWritten, 'bytes');
    if (bytesWritten + offset < buffer.length) {
      if (!binding.isOpen) {
        throw new Error('Port is not open')
      }
      return unixWrite({ binding, buffer, offset: bytesWritten + offset, fsWriteAsync })
    }

    logger('Finished writing', bytesWritten + offset, 'bytes');
  } catch (err) {
    logger('write errored', err);
    if (err.code === 'EAGAIN' || err.code === 'EWOULDBLOCK' || err.code === 'EINTR') {
      if (!binding.isOpen) {
        throw new Error('Port is not open')
      }
      logger('waiting for writable because of code:', err.code);
      await writable(binding);
      return unixWrite({ binding, buffer, offset, fsWriteAsync })
    }

    const disconnectError =
      err.code === 'EBADF' || // Bad file number means we got closed
      err.code === 'ENXIO' || // No such device or address probably usb disconnect
      err.code === 'UNKNOWN' ||
      err.errno === -1; // generic error

    if (disconnectError) {
      err.disconnect = true;
      logger('disconnecting', err);
    }

    logger('error', err);
    throw err
  }
};
var unixWrite_1 = unixWrite;

const { promisify: promisify$1 } = util$2;
const binding$1 = bindings_1('bindings.node');




const { wrapWithHiddenComName: wrapWithHiddenComName$1 } = legacy;

const defaultBindingOptions$1 = Object.freeze({
  vmin: 1,
  vtime: 0,
});

const asyncList = promisify$1(binding$1.list);
const asyncOpen$1 = promisify$1(binding$1.open);
const asyncClose$1 = promisify$1(binding$1.close);
const asyncUpdate$1 = promisify$1(binding$1.update);
const asyncSet$1 = promisify$1(binding$1.set);
const asyncGet$1 = promisify$1(binding$1.get);
const asyncGetBaudRate$1 = promisify$1(binding$1.getBaudRate);
const asyncDrain$1 = promisify$1(binding$1.drain);
const asyncFlush$1 = promisify$1(binding$1.flush);

/**
 * The Darwin binding layer for OSX
 */
class DarwinBinding extends lib$9 {
  static list() {
    return wrapWithHiddenComName$1(asyncList())
  }

  constructor(opt = {}) {
    super(opt);
    this.bindingOptions = { ...defaultBindingOptions$1, ...opt.bindingOptions };
    this.fd = null;
    this.writeOperation = null;
  }

  get isOpen() {
    return this.fd !== null
  }

  async open(path, options) {
    await super.open(path, options);
    this.openOptions = { ...this.bindingOptions, ...options };
    const fd = await asyncOpen$1(path, this.openOptions);
    this.fd = fd;
    this.poller = new poller(fd);
  }

  async close() {
    await super.close();
    const fd = this.fd;
    this.poller.stop();
    this.poller.destroy();
    this.poller = null;
    this.openOptions = null;
    this.fd = null;
    return asyncClose$1(fd)
  }

  async read(buffer, offset, length) {
    await super.read(buffer, offset, length);
    return unixRead_1({ binding: this, buffer, offset, length })
  }

  async write(buffer) {
    this.writeOperation = super.write(buffer).then(async () => {
      if (buffer.length === 0) {
        return
      }
      await unixWrite_1({ binding: this, buffer });
      this.writeOperation = null;
    });
    return this.writeOperation
  }

  async update(options) {
    await super.update(options);
    return asyncUpdate$1(this.fd, options)
  }

  async set(options) {
    await super.set(options);
    return asyncSet$1(this.fd, options)
  }

  async get() {
    await super.get();
    return asyncGet$1(this.fd)
  }

  async getBaudRate() {
    await super.get();
    return asyncGetBaudRate$1(this.fd)
  }

  async drain() {
    await super.drain();
    await this.writeOperation;
    return asyncDrain$1(this.fd)
  }

  async flush() {
    await super.flush();
    return asyncFlush$1(this.fd)
  }
}

var darwin = DarwinBinding;

const { Transform: Transform$5 } = stream;

/**
 * A transform stream that emits data each time a byte sequence is received.
 * @extends Transform
 * @summary To use the `Delimiter` parser, provide a delimiter as a string, buffer, or array of bytes. Runs in O(n) time.
 * @example
const SerialPort = require('serialport')
const Delimiter = require('@serialport/parser-delimiter')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new Delimiter({ delimiter: '\n' }))
parser.on('data', console.log)
 */
class DelimiterParser extends Transform$5 {
  constructor(options = {}) {
    super(options);

    if (options.delimiter === undefined) {
      throw new TypeError('"delimiter" is not a bufferable object')
    }

    if (options.delimiter.length === 0) {
      throw new TypeError('"delimiter" has a 0 or undefined length')
    }

    this.includeDelimiter = options.includeDelimiter !== undefined ? options.includeDelimiter : false;
    this.delimiter = Buffer.from(options.delimiter);
    this.buffer = Buffer.alloc(0);
  }

  _transform(chunk, encoding, cb) {
    let data = Buffer.concat([this.buffer, chunk]);
    let position;
    while ((position = data.indexOf(this.delimiter)) !== -1) {
      this.push(data.slice(0, position + (this.includeDelimiter ? this.delimiter.length : 0)));
      data = data.slice(position + this.delimiter.length);
    }
    this.buffer = data;
    cb();
  }

  _flush(cb) {
    this.push(this.buffer);
    this.buffer = Buffer.alloc(0);
    cb();
  }
}

var lib$8 = DelimiterParser;

/**
 *  A transform stream that emits data after a newline delimiter is received.
 * @summary To use the `Readline` parser, provide a delimiter (defaults to `\n`). Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).
 * @extends DelimiterParser
 * @example
const SerialPort = require('serialport')
const Readline = require('@serialport/parser-readline')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new Readline({ delimiter: '\r\n' }))
parser.on('data', console.log)
*/
class ReadLineParser extends lib$8 {
  constructor(options) {
    const opts = {
      delimiter: Buffer.from('\n', 'utf8'),
      encoding: 'utf8',
      ...options,
    };

    if (typeof opts.delimiter === 'string') {
      opts.delimiter = Buffer.from(opts.delimiter, opts.encoding);
    }

    super(opts);
  }
}

var lib$7 = ReadLineParser;

// get only serial port names
function checkPathOfDevice(path) {
  return /(tty(S|WCH|ACM|USB|AMA|MFD|O|XRUSB)|rfcomm)/.test(path) && path
}

function propName(name) {
  return {
    DEVNAME: 'path',
    ID_VENDOR_ENC: 'manufacturer',
    ID_SERIAL_SHORT: 'serialNumber',
    ID_VENDOR_ID: 'vendorId',
    ID_MODEL_ID: 'productId',
    DEVLINKS: 'pnpId',
  }[name.toUpperCase()]
}

function decodeHexEscape(str) {
  return str.replace(/\\x([a-fA-F0-9]{2})/g, (a, b) => {
    return String.fromCharCode(parseInt(b, 16))
  })
}

function propVal(name, val) {
  if (name === 'pnpId') {
    const match = val.match(/\/by-id\/([^\s]+)/);
    return (match && match[1]) || undefined
  }
  if (name === 'manufacturer') {
    return decodeHexEscape(val)
  }
  if (/^0x/.test(val)) {
    return val.substr(2)
  }
  return val
}

function listLinux() {
  return new Promise((resolve, reject) => {
    const ports = [];
    const ude = child_process.spawn('udevadm', ['info', '-e']);
    const lines = ude.stdout.pipe(new lib$7());
    ude.on('close', code => code && reject(new Error(`Error listing ports udevadm exited with error code: ${code}`)));
    ude.on('error', reject);
    lines.on('error', reject);

    let port = {};
    let skipPort = false;
    lines.on('data', line => {
      const lineType = line.slice(0, 1);
      const data = line.slice(3);
      // new port entry
      if (lineType === 'P') {
        port = {
          manufacturer: undefined,
          serialNumber: undefined,
          pnpId: undefined,
          locationId: undefined,
          vendorId: undefined,
          productId: undefined,
        };
        skipPort = false;
        return
      }

      if (skipPort) {
        return
      }

      // Check dev name and save port if it matches flag to skip the rest of the data if not
      if (lineType === 'N') {
        if (checkPathOfDevice(data)) {
          ports.push(port);
        } else {
          skipPort = true;
        }
        return
      }

      // parse data about each port
      if (lineType === 'E') {
        const keyValue = data.match(/^(.+)=(.*)/);
        if (!keyValue) {
          return
        }
        const key = propName(keyValue[1]);
        if (!key) {
          return
        }
        port[key] = propVal(key, keyValue[2]);
      }
    });

    lines.on('finish', () => resolve(ports));
  })
}

var linuxList = listLinux;

const { promisify } = util$2;
const binding = bindings_1('bindings.node');





const { wrapWithHiddenComName } = legacy;

const defaultBindingOptions = Object.freeze({
  vmin: 1,
  vtime: 0,
});

const asyncOpen = promisify(binding.open);
const asyncClose = promisify(binding.close);
const asyncUpdate = promisify(binding.update);
const asyncSet = promisify(binding.set);
const asyncGet = promisify(binding.get);
const asyncGetBaudRate = promisify(binding.getBaudRate);
const asyncDrain = promisify(binding.drain);
const asyncFlush = promisify(binding.flush);

/**
 * The linux binding layer
 */
class LinuxBinding extends lib$9 {
  static list() {
    return wrapWithHiddenComName(linuxList())
  }

  constructor(opt = {}) {
    super(opt);
    this.bindingOptions = { ...defaultBindingOptions, ...opt.bindingOptions };
    this.fd = null;
    this.writeOperation = null;
  }

  get isOpen() {
    return this.fd !== null
  }

  async open(path, options) {
    await super.open(path, options);
    this.openOptions = { ...this.bindingOptions, ...options };
    const fd = await asyncOpen(path, this.openOptions);
    this.fd = fd;
    this.poller = new poller(fd);
  }

  async close() {
    await super.close();
    const fd = this.fd;
    this.poller.stop();
    this.poller.destroy();
    this.poller = null;
    this.openOptions = null;
    this.fd = null;
    return asyncClose(fd)
  }

  async read(buffer, offset, length) {
    await super.read(buffer, offset, length);
    return unixRead_1({ binding: this, buffer, offset, length })
  }

  async write(buffer) {
    this.writeOperation = super.write(buffer).then(async () => {
      if (buffer.length === 0) {
        return
      }
      await unixWrite_1({ binding: this, buffer });
      this.writeOperation = null;
    });
    return this.writeOperation
  }

  async update(options) {
    await super.update(options);
    return asyncUpdate(this.fd, options)
  }

  async set(options) {
    await super.set(options);
    return asyncSet(this.fd, options)
  }

  async get() {
    await super.get();
    return asyncGet(this.fd)
  }

  async getBaudRate() {
    await super.get();
    return asyncGetBaudRate(this.fd)
  }

  async drain() {
    await super.drain();
    await this.writeOperation;
    return asyncDrain(this.fd)
  }

  async flush() {
    await super.flush();
    return asyncFlush(this.fd)
  }
}

var linux = LinuxBinding;

var lib$6 = createCommonjsModule(function (module) {
const debug = browser('serialport/bindings');

switch (process.platform) {
  case 'win32':
    debug('loading WindowsBinding');
    module.exports = win32;
    break
  case 'darwin':
    debug('loading DarwinBinding');
    module.exports = darwin;
    break
  default:
    debug('loading LinuxBinding');
    module.exports = linux;
}
});

const { Transform: Transform$4 } = stream;

/**
 * Emit data every number of bytes
 * @extends Transform
 * @param {Object} options parser options object
 * @param {Number} options.length the number of bytes on each data event
 * @summary A transform stream that emits data as a buffer after a specific number of bytes are received. Runs in O(n) time.
 * @example
const SerialPort = require('serialport')
const ByteLength = require('@serialport/parser-byte-length')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new ByteLength({length: 8}))
parser.on('data', console.log) // will have 8 bytes per data event
 */
class ByteLengthParser extends Transform$4 {
  constructor(options = {}) {
    super(options);

    if (typeof options.length !== 'number') {
      throw new TypeError('"length" is not a number')
    }

    if (options.length < 1) {
      throw new TypeError('"length" is not greater than 0')
    }

    this.length = options.length;
    this.position = 0;
    this.buffer = Buffer.alloc(this.length);
  }

  _transform(chunk, encoding, cb) {
    let cursor = 0;
    while (cursor < chunk.length) {
      this.buffer[this.position] = chunk[cursor];
      cursor++;
      this.position++;
      if (this.position === this.length) {
        this.push(this.buffer);
        this.buffer = Buffer.alloc(this.length);
        this.position = 0;
      }
    }
    cb();
  }

  _flush(cb) {
    this.push(this.buffer.slice(0, this.position));
    this.buffer = Buffer.alloc(this.length);
    cb();
  }
}

var lib$5 = ByteLengthParser;

const { Transform: Transform$3 } = stream;

/**
 * Parse the CCTalk protocol
 * @extends Transform
 * @summary A transform stream that emits CCTalk packets as they are received.
 * @example
const SerialPort = require('serialport')
const CCTalk = require('@serialport/parser-cctalk')
const port = new SerialPort('/dev/ttyUSB0')
const parser = port.pipe(new CCtalk())
parser.on('data', console.log)
 */
class CCTalkParser extends Transform$3 {
  constructor(maxDelayBetweenBytesMs = 50) {
    super();
    this.array = [];
    this.cursor = 0;
    this.lastByteFetchTime = 0;
    this.maxDelayBetweenBytesMs = maxDelayBetweenBytesMs;
  }
  _transform(buffer, _, cb) {
    if (this.maxDelayBetweenBytesMs > 0) {
      const now = Date.now();
      if (now - this.lastByteFetchTime > this.maxDelayBetweenBytesMs) {
        this.array = [];
        this.cursor = 0;
      }
      this.lastByteFetchTime = now;
    }

    this.cursor += buffer.length;
    // TODO: Better Faster es7 no supported by node 4
    // ES7 allows directly push [...buffer]
    // this.array = this.array.concat(Array.from(buffer)) //Slower ?!?
    Array.from(buffer).map(byte => this.array.push(byte));
    while (this.cursor > 1 && this.cursor >= this.array[1] + 5) {
      // full frame accumulated
      // copy command from the array
      const FullMsgLength = this.array[1] + 5;

      const frame = Buffer.from(this.array.slice(0, FullMsgLength));
      // Preserve Extra Data
      this.array = this.array.slice(frame.length, this.array.length);
      this.cursor -= FullMsgLength;
      this.push(frame);
    }
    cb();
  }
}

var lib$4 = CCTalkParser;

const { Transform: Transform$2 } = stream;

/**
 * Emits data if there is a pause between packets for the specified amount of time.
 * @extends Transform
 * @param {Object} options parser options object
 * @param {Number} options.interval the period of silence in milliseconds after which data is emited
 * @param {Number} options.maxBufferSize the maximum number of bytes after which data will be emited. Defaults to 65536.
 * @summary A transform stream that emits data as a buffer after not receiving any bytes for the specified amount of time.
 * @example
const SerialPort = require('serialport')
const InterByteTimeout = require('@serialport/parser-inter-byte-timeout')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new InterByteTimeout({interval: 30}))
parser.on('data', console.log) // will emit data if there is a pause between packets greater than 30ms
 */

class InterByteTimeoutParser extends Transform$2 {
  constructor(options) {
    super();
    options = { maxBufferSize: 65536, ...options };
    if (!options.interval) {
      throw new TypeError('"interval" is required')
    }

    if (typeof options.interval !== 'number' || Number.isNaN(options.interval)) {
      throw new TypeError('"interval" is not a number')
    }

    if (options.interval < 1) {
      throw new TypeError('"interval" is not greater than 0')
    }

    if (typeof options.maxBufferSize !== 'number' || Number.isNaN(options.maxBufferSize)) {
      throw new TypeError('"maxBufferSize" is not a number')
    }

    if (options.maxBufferSize < 1) {
      throw new TypeError('"maxBufferSize" is not greater than 0')
    }

    this.maxBufferSize = options.maxBufferSize;
    this.currentPacket = [];
    this.interval = options.interval;
    this.intervalID = -1;
  }
  _transform(chunk, encoding, cb) {
    clearTimeout(this.intervalID);
    for (let offset = 0; offset < chunk.length; offset++) {
      this.currentPacket.push(chunk[offset]);
      if (this.currentPacket.length >= this.maxBufferSize) {
        this.emitPacket();
      }
    }
    this.intervalID = setTimeout(this.emitPacket.bind(this), this.interval);
    cb();
  }
  emitPacket() {
    clearTimeout(this.intervalID);
    if (this.currentPacket.length > 0) {
      this.push(Buffer.from(this.currentPacket));
    }
    this.currentPacket = [];
  }
  _flush(cb) {
    this.emitPacket();
    cb();
  }
}

var lib$3 = InterByteTimeoutParser;

const { Transform: Transform$1 } = stream;

/**
 * A transform stream that waits for a sequence of "ready" bytes before emitting a ready event and emitting data events
 * @summary To use the `Ready` parser provide a byte start sequence. After the bytes have been received a ready event is fired and data events are passed through.
 * @extends Transform
 * @example
const SerialPort = require('serialport')
const Ready = require('@serialport/parser-ready')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new Ready({ delimiter: 'READY' }))
parser.on('ready', () => console.log('the ready byte sequence has been received'))
parser.on('data', console.log) // all data after READY is received
 */
class ReadyParser extends Transform$1 {
  /**
   *
   * @param {object} options options for the parser
   * @param {string|Buffer|array} options.delimiter data to look for before emitted "ready"
   */
  constructor(options = {}) {
    if (options.delimiter === undefined) {
      throw new TypeError('"delimiter" is not a bufferable object')
    }

    if (options.delimiter.length === 0) {
      throw new TypeError('"delimiter" has a 0 or undefined length')
    }

    super(options);
    this.delimiter = Buffer.from(options.delimiter);
    this.readOffset = 0;
    this.ready = false;
  }

  _transform(chunk, encoding, cb) {
    if (this.ready) {
      this.push(chunk);
      return cb()
    }
    const delimiter = this.delimiter;
    let chunkOffset = 0;
    while (this.readOffset < delimiter.length && chunkOffset < chunk.length) {
      if (delimiter[this.readOffset] === chunk[chunkOffset]) {
        this.readOffset++;
      } else {
        this.readOffset = 0;
      }
      chunkOffset++;
    }
    if (this.readOffset === delimiter.length) {
      this.ready = true;
      this.emit('ready');
      const chunkRest = chunk.slice(chunkOffset);
      if (chunkRest.length > 0) {
        this.push(chunkRest);
      }
    }
    cb();
  }
}

var lib$2 = ReadyParser;

const { Transform } = stream;

/**
 * A transform stream that uses a regular expression to split the incoming text upon.
 *
 * To use the `Regex` parser provide a regular expression to split the incoming text upon. Data is emitted as string controllable by the `encoding` option (defaults to `utf8`).
 * @extends Transform
 * @example
const SerialPort = require('serialport')
const Regex = require('@serialport/parser-regex')
const port = new SerialPort('/dev/tty-usbserial1')
const parser = port.pipe(new Regex({ regex: /[\r\n]+/ }))
parser.on('data', console.log)
 */
class RegexParser extends Transform {
  constructor(options) {
    const opts = {
      encoding: 'utf8',
      ...options,
    };

    if (opts.regex === undefined) {
      throw new TypeError('"options.regex" must be a regular expression pattern or object')
    }

    if (!(opts.regex instanceof RegExp)) {
      opts.regex = new RegExp(opts.regex);
    }
    super(opts);

    this.regex = opts.regex;
    this.data = '';
  }

  _transform(chunk, encoding, cb) {
    const data = this.data + chunk;
    const parts = data.split(this.regex);
    this.data = parts.pop();

    parts.forEach(part => {
      this.push(part);
    });
    cb();
  }

  _flush(cb) {
    this.push(this.data);
    this.data = '';
    cb();
  }
}

var lib$1 = RegexParser;

var parsers = {
  ByteLength: lib$5,
  CCTalk: lib$4,
  Delimiter: lib$8,
  InterByteTimeout: lib$3,
  Readline: lib$7,
  Ready: lib$2,
  Regex: lib$1,
};

/**
 * @type {AbstractBinding}
 */
lib$a.Binding = lib$6;

/**
 * @type {Parsers}
 */
lib$a.parsers = parsers;

var lib = lib$a;

/* Created by Fry on 7/11/16.
//
//On Mac, to see serial ports, open Terminal app and enter: ls /dev/tty.* or ls /dev/cu.*
// https://learn.sparkfun.com/tutorials/terminal-basics/all  geared toward windows, but servicable.
//for devices, mac and linux have both tty and cu for full duplex. windows only has tty.
//Macintosh problems
//sparkfun RedBoard is an arduino Uno, what james loaned me.
//didn't work for uploading programs to the board.
//Arduino Micro and Leonado have something special ie "mouse and kbd support
//that allows them to work on Mac.  I got Arduino Leonardo because
//arduino mciro can't take shields.
//Mike says some ardino boards don't work on mac, get a micro-arduino from Microcenter.
    // http://www.meetup.com/Cambridge-Hackspace/ tues 6:30PM union sq somerville
    //https://www.arduino.cc/en/Reference/Firmata  a Kketch for prototcol
    //that interfaces to javascript via https://github.com/firmata/firmata.js?utm_source=buffer&utm_medium=twitter&utm_campaign=Buffer&utm_content=buffer52691
//firmata provides the sketch for arduino and protolcoe. firmata .js is a way to use it
//from js, johnny 5 and cylon use firmata underneath and build on top of it.
//to make a "compiled" file of a arduino sketch, edit the sketch, then use File menu/Sketch/export compiled binary
//gort: CLI that can upload .hex files into an arduino board. for mac, win. linux
 The ATmega32U4 on the Micro comes preprogrammed with a bootloader that allows you to upload new code to it without the use of an external hardware programmer. It communicates using the AVR109 protocol.
 You can also bypass the bootloader and program the microcontroller through the ICSP (In-Circuit Serial Programming) header using Arduino ISP or similar; see these instructions for details.
temboo IOT js connectivity requires setting up a local js server to use.
// http://www.penvon.com/b/robotics-projects-github-cm596 johnny5 has 3 times the github stars as cylon
    // ie 6K vs 2K July, 2016


//strategy: sandbox never has to know connectionIDs, just paths.
//keep map between them on the UI side
*/


var serial_port_path_to_info_map = {};


//serial_path_to_info_map is deprecated in PatchDDE
//var serial_path_to_info_map = serial_port_path_to_info_map
//module.exports.serial_path_to_info_map = serial_path_to_info_map

function serial_port_path_to_info(port_path){
    return serial_port_path_to_info_map[port_path]
}


//only cleared by relaunching DDE on purpose.
//a given port_path only gets a port made for it once.
var serial_port_path_to_port_map = {};

function serial_get_or_make_port(port_path, port_options, open_callback){
    let port = serial_port_path_to_port_map[port_path];
    if(!port) {
        port = new lib(port_path, port_options, open_callback);
        serial_port_path_to_port_map[port_path] = port;
    }
    else {
        for(let key in port_options){
           let val = port_options[key];
           port.settings[key] = val;
        }
        if(!port.isOpen){
            port.open(open_callback);
            //open_callback.call(port, null, port_path)
        }
    }
    return port
}


//called by serial_connect AND Serial.send
function serial_init_one_info_map_item(port_path, port_options, simulate=null, capture_n_items=1, item_delimiter="\n",
                                       trim_whitespace=true,
                                       parse_items=true, capture_extras="error"){
    let sim_actual = Robot.get_simulate_actual(simulate);
    serial_port_path_to_info_map[port_path] =
           {port_path:            port_path, //Needed because sometimes we get the info without having the port_path thru serial_path_to_connection_id
            simulate:        sim_actual,
            capture_n_items: capture_n_items,
            item_delimiter:  item_delimiter,
            trim_whitespace: trim_whitespace,
            parse_items:     parse_items,
            capture_extras:  capture_extras,
            pending_input:   ""};

}

//called from robot.js
function serial_connect(port_path, port_options, simulate=null, capture_n_items=1, item_delimiter="\n",
                        trim_whitespace=true,
                        parse_items=true, capture_extras="error", job_instance){ //"ignore", "capture", "error"
    const sim_actual = Robot.get_simulate_actual(simulate);
    serial_init_one_info_map_item(port_path, port_options, simulate, capture_n_items, item_delimiter,
        trim_whitespace, parse_items, capture_extras);
    if(sim_actual === true){ //if its "both" we let the below handle it. Don't want to call serial_new_socket_callback twice when sim is "both"
        serial_new_socket_callback(port_path, job_instance); //don't need to simulate socket_id for now
    }
    if ((sim_actual === false) || (sim_actual == "both")){
        const port = serial_get_or_make_port(port_path, port_options); //new SerialPort(port_path, port_options)
        port.on('open', function(err){
            if (err) {
                 dde_error("new SerialPort to port_path: " + port_path + " errored with; " + err);
            }
            else {
                out("Serial connection made to: " + port_path);
                serial_port_path_to_info_map[port_path].port = port;
                serial_new_socket_callback(port_path, job_instance);
                let the_path = port_path; //needed for closed over var below
                port.on('data',  function(data) { serial_onReceiveCallback(data, the_path); } );
                port.on('error', function(data) { onReceiveErrorCallback(data, the_path); } );
            }
        });
    }
}

function serial_new_socket_callback(port_path, job_instance){
    console.log("serial_new_socket_callback passed port_path: " + port_path);
    Serial.set_a_robot_instance_socket_id(port_path, job_instance);
}

function convertStringToArrayBuffer(str) {
    var buf=new ArrayBuffer(str.length);
    var bufView=new Uint8Array(buf);
    for (var i=0; i<str.length; i++) {
        bufView[i]=str.charCodeAt(i);
    }
    return buf;
}


//content is a string
function serial_send(instruction_array, port_path, simulate=null, sim_fun) {
    let ins_str = instruction_array[Serial.INSTRUCTION_TYPE + 1];
    //out("top of serial_send about to send: " + ins_str)
    let robot_status = instruction_array.slice(0, Serial.DATA0); //Make a copy. don't include any fields for data coming back. We'll push onto this if need be.
    let info = serial_port_path_to_info(port_path);
    let the_path = port_path; //because JS closures sometimes don't close over para variables
    info.robot_status = robot_status; //save this so that onReceive can get it later
    info.robot_status[Serial.ERROR_CODE] = 0; //we haven't errored yet so pretend like its going to work
    //set the error code, and maybe call serial_on_done_with_sending
    info.robot_status[Serial.START_TIME] =  Date.now();
    const sim_actual = Robot.get_simulate_actual(simulate);
    if ((sim_actual === true) || (sim_actual === "both")){
        setTimeout(function(){
                        serial_send_simulate(ins_str, sim_fun, port_path, sim_actual);
                    }, 300);
    }
    if ((sim_actual === false) || (sim_actual === "both")){
        if (info.port){
            //out("just before serial send of: " + ins_str)
            info.port.write(ins_str, //convertStringToArrayBuffer(ins_str),
                function(error){ //can't rely on this getting called before onReceived so mostly pretend like its not called, except in error cases
                    if (error){
                        dde_error("In serial_send callback to port_path: " + the_path +
                                  " got the error: " + send_info.error);
                    }
                    else {
                        out("serial write just sent: " + ins_str);
                    }
                });
            if (info.capture_n_items === 0){ //everything ok just no robot_status to collect.
                serial_on_done_with_sending(info.robot_status);
            }
        }
        else {
            let err = "In serial_send, attempt to send to port_path: " + the_path +
                      " which doesn't have a port.";
            info.robot_status[Serial.ERROR_CODE] = err;
            serial_on_done_with_sending(info.robot_status);
        }
    }
}


function serial_send_simulate(ins_str, sim_fun, port_path, sim_actual){
    let result = sim_fun.call(null, ins_str);
    let info_from_board = {buffer: convertStringToArrayBuffer(result)};
    out("in serial_send_simulate with ins_str: " + ins_str + " and info_from_board: " + info_from_board);
    if (sim_actual === true) { //but NOT "both", since we let the hardware side take it from here if its "both".
        serial_onReceiveCallback(info_from_board, port_path);
    }
}

//_______receive data from serial_________
//getting data from serial: when info comes in from ANY port,
//onReceieveCallback gets called.

//might return a negative number if we are allowed to capture extras
function left_to_capture(info){
    let already_captured = info.robot_status.length - Serial.DATA0;
    let result = info.capture_n_items - already_captured;
    return result
}

function serial_onReceiveCallback(info_from_board, port_path) { //if there's an error, onReceiveErrorCallback will be called instead
    //out("top of serial_onReceiveCallback")
    if (info_from_board.length) { //info.connectionId == expectedConnectionId &&
        //let str = convertArrayBufferToString(info_from_board.buffer, info_from_board.length); //note that if aruino program
        let str = info_from_board.toString();
        //str should now have in it the NEW chars sent from the serial port.

        //has Serial.println("turned off1"); int foo = 2 + 3; Serial.println("turned off2");
        //then this is ONE call to serial_onReceiveCallback with a string "turned off1\r\nturned off2\t\n"
        //so that 1 string should count for 2 items from the board from the dde standpoint.
        //maybe the board software batches up the 2 strings and maybe chrome receive does.
        //whichever, I need to handle it.
        //Note 2: when simulating, often info_from_board.length will return undefined.
        //this is ok as convertArrayBufferToString will just go with the length of the
        //info_from_board.buffer, which will usually be correct for the content.
        out("serial_onReceiveCallback got " + info_from_board.length + " byte string: '" + str + "'.");
        let info = serial_port_path_to_info_map[port_path];
        if (!info) {
           warning("serial_onReceiveCallback got port_path: " + port_path + " that's not a known DDE connected port_path which is possibly OK if you've got other serial devices sending in data.");
        }
        else {
            info.robot_status[Serial.ERROR_CODE] = 0; //since onReceivedErrorCallback wasn't called in place of this,
	    //we know it didn't error. Can't rely on send callback getting called so do this here.
            //first process the returned string
            let delim = info.item_delimiter; //can be multi_character.
            if ((delim === "") || (delim === 0)) { //str holds exactly one item. we never put a substr in pending
                if (left_to_capture(info) > 0) {
                    serial_store_str_in_rs(str, info);
                    if (left_to_capture(info) == 0){
                        serial_on_done_with_sending(info.robot_status, info.port_path);
                    }
                    else { out("waiting for more strings from robot."); } 
			//beware, they might never come in which case the job is just hanging.
			//TODO: Add a timeout option which continues anyway.
                    //the job has status_code "running" but is really paused waiting for response.
                }
                else if (info.capture_extras == "capture"){
                    serial_send_extra_item_to_job(str, info.port_path, false, info); //false means everything ok
                }
                else if (info.capture_extras == "error"){
                    serial_send_extra_item_to_job(str, info.port_path, true, info); //true means job should error
                }
                else if (info.capture_extras == "ignore") ;
                else { dde_error("serial_onReceiveCallback got invalid capture_extras value of: " + info.capture_extras); }
            }
            else if (typeof(delim) == "string"){
                if (str === "") ;//we do have a real delimiter, but no delimiter in the input str and no chars so this is a no_op
                else {
                    info.pending_input += str;
                    while(true) {
                        let delim_index = info.pending_input.indexOf(delim);
                        if(delim_index == -1) { break; } 
				// no "full" items in the pending input so break now and wait for more data from the serial port
                        else { //at least one more full item in pending_input. grab it!
                            let item = info.pending_input.substring(0, delim_index);
                            info.pending_input = info.pending_input.substring(delim_index + delim.length);
                            if (info.trim_whitespace) { item = item.trim(); }
                            if (left_to_capture(info) > 0) {
                                serial_store_str_in_rs(item, info);
                                if (left_to_capture(info) == 0){
                                    serial_on_done_with_sending(info.robot_status, info.port_path);
                                }
                                else { out("waiting for more strings from robot."); } 
					//beware, they might never come in which case the job is just hanging.
					//TODO: Add a timeout option which continues anyway.
                            //the job has status_code "running" but is really paused waiting for response.
                            }
                            else if (info.capture_extras == "capture"){
                                serial_send_extra_item_to_job(item, info.port_path, false, info); //false means everything ok
                            }
                            else if (info.capture_extras == "error"){
                                serial_send_extra_item_to_job(item, info.port_path, true, info); //true means job should error
                            }
                            else if (info.capture_extras == "ignore") ;
                            else { dde_error("serial_onReceiveCallback got invalid capture_extras value of: " + info.capture_extras); }
                        }
                    }
                }
            }
            else if (typeof(delim) == "number"){
                str = info.pending_input + str; //pending_input will never contain a delim
                info.pending_input = ""; //we're using it, so makes this empty, just so there's no using pending twice.
                if (str === "") ;//we do have a real delimter, but no delimiter in the input str and no chars so this is a no_op
                else {
                    while(true){
                        if (str.length >= delim){
                            let item = str.substr(0, delim); //the item this time in the loop
                            str = str.slice(delim); //get ready for the NEXT iteration
                            if (left_to_capture(info) > 0) {
                                serial_store_str_in_rs(item, info);
                                if (left_to_capture(info) == 0){
                                    serial_on_done_with_sending(info.robot_status, info.port_path);
                                }
                                else { out("waiting for more strings from robot."); } 
					//beware, they might never come in which case the job is just hanging.
					//TODO: Add a timeout option which continues anyway.

                                //the job has status_code "running" but is really paused waiting for response.
                            }
                            else if (info.capture_extras == "capture"){
                                serial_send_extra_item_to_job(item, info.port_path, false, info); //false means everything ok
                            }
                            else if (info.capture_extras == "error"){
                                serial_send_extra_item_to_job(item, info.port_path, true, info); //true means job should error
                            }
                            else if (info.capture_extras == "ignore") ;
                            else { dde_error("serial_onReceiveCallback got invalid capture_extras value of: " + info.capture_extras); }
                        }
                        else {
                            info.pending = str; //might be "" and that's ok
                            break;
                        }
                    }
                }
            }
            else {
                dde_error("serial_onReceiveCallback got an item_delimiter of: " + delim + " which is not valid because its not a string or an integer.");
            }
        }
    }
}

function serial_parse_string_maybe(str, info){
    if (info.parse_items) {
        try {
            str = JSON.parse(str);
        }
        catch(e) {}
    }
    return str
}

function serial_store_str_in_rs(str, info){
    str = serial_parse_string_maybe(str, info);
    info.robot_status.push(str);
}

function onReceiveErrorCallback(info_from_board, port_path) {
    //let id = info_from_board.connectionId
    let errnum = info_from_board.error;
    let error_codes = ["disconnected", "timeout", "device_lost", "break", "frame_error", "overrun",
                        "buffer_overflow", "parity_error", "system_error"]; //beware,
        //it wouldn't surprise me if "disconnected" was really error_code 1 instead of 0.
        //but this is what https://developer.chrome.com/apps/serial#event-onReceive sez.
    let info = serial_port_path_to_info_map[port_path];
    let rs = info.robot_status;
    out("onReceiveErrorCallback called with port_path: " + info.port_path, "red");
    rs[Serial.ERROR_CODE] = error_codes[errnum];
    serial_on_done_with_sending(rs, info.port_path);
}

//like socket on_receive
function serial_on_done_with_sending(robot_status, port_path){
    robot_status[Serial.STOP_TIME] = Date.now();
    out("serial_on_done_with_sending with rs: " + robot_status);
    let job_id       = robot_status[Serial.JOB_ID];
    let job_instance = Job.job_id_to_job_instance(job_id);
    let ins_id = robot_status[Serial.INSTRUCTION_ID];
    let ins = ((ins_id >= 0) ? job_instance.do_list[ins_id] : null);
    let rob;
    if (ins && ins.robot) { rob = ins.robot; } //used when instruction src code has a subject of a robot isntance
    else                  { rob = job_instance.robot; } //get the default robot for the job
    rob.robot_done_with_instruction(robot_status);
}

function serial_send_extra_item_to_job(string_from_robot, port_path, is_error=false, info){ //info only needed on UI side.
    string_from_robot = serial_parse_string_maybe(string_from_robot, info); //after this, might not be a string anymore
    let job_instance = Serial.get_job_with_robot_path(port_path);
    if (job_instance){
        job_instance.robot.robot_status.push(string_from_robot); //just add to the current robot_status. Might not be right.
        if (is_error){
            job_instance.stop_for_reason("errored", "Serial robot returned unexpected extra string: " + string_from_robot);
        }
    }
}


//with an arduino connected, this disconnects but then immdiately afterwards,
//a new connection is automatically made with 1 higher port number and same port_path.
/*function serial_disconnect(port_path){
    let info = serial_port_path_to_info_map[port_path]
    if (info){
        if((info.simulate === false) || (info.simulate === "both")) {
            //info.port.close(out)
            //serial_flush(port_path) //perhaps unnecessary
            try { //serial_flush(port_path) //perhaps unnecessary
                  info.port.drain(function(err){
                        try { info.port.close(function(err){out(port_path + " closed. " + err)}) }
                        catch(err) { out("serial port error: " + err.message) }
                  //info.port.close(out)
            }
            catch(err) { out ("serial port already closed.") }
        }
        delete serial_port_path_to_info_map[port_path]
    }
}*/
//James N new version oct 20 , 2020
function serial_disconnect(port_path){
    let info = serial_port_path_to_info_map[port_path];
    if (info){
        if((info.simulate === false) || (info.simulate === "both")) {
            //info.port.close(function(err){out("closed"+err)})
            try {
              info.port.drain(function(err){
                    try { info.port.close(function(err){
                                             out(port_path + " closed. " + err);
                                          }); }
                    catch(err) {
                        out("Error closing serial port: " + err.message);
                    }
                });
            }
            catch(err) {
                out ("serial port already closed.");
            }
            out("closing: " + port_path);
        }
        delete serial_port_path_to_info_map[port_path];
        out("deleted: " + port_path);
    }
    else {
        out("no serial port found at " + port_path);
    }
}


function serial_disconnect_all(){
  for(let port_path of Object.keys(serial_port_path_to_info_map)){
      serial_disconnect(port_path);
  }
}

//Coordinate System 

var Coor$1 = newObject({prototype: Root$1, name: "Coor"}); //, pose: Vector.make_pose()})


Coor$1.init = function(){
    Coor$1.pose = Vector$1.make_pose();
    var Table = Coor$1.create_child(Vector$1.make_pose(), "Table");
    var L0 = Table.create_child(Vector$1.make_pose(), "L0");
    var L1 = L0.create_child(Vector$1.make_pose(), "L1");
    var L2 = L1.create_child(Vector$1.make_pose(), "L2");
    var L3 = L2.create_child(Vector$1.make_pose(), "L3");
    var L4 = L3.create_child(Vector$1.make_pose(), "L4");
    L4.create_child(Vector$1.make_pose(), "L5");
};

Coor$1.create_child = function(pose, name){
	if(pose === undefined){
    	pose = Vector$1.make_pose();
    }
    if (!Vector$1.is_pose(pose)){
    		dde_error("pose is not constructed properly");
    	}
	var old_child = this[name];
	if(Object.isNewObject(old_child)){
    	old_child.set_pose(pose);
        return old_child
    }else if(name){
		return newObject({prototype: this, pose: pose, name: name})
    }else {
		return newObject({prototype: this, pose: pose})
    }
	
};


Coor$1.get_pose = function(reference_coordinate_system){
	let obj_elt, base_idx, ref_idx;
    let base = this;
    let ref = reference_coordinate_system;
	if (ref === undefined || this === ref){
    	return base.pose
    }else {
        let base_path = base.ancestors();
        base_path.push(base);
        let ref_path = ref.ancestors();
        ref_path.push(ref);
        let common = Object.lowestCommonAncestor(base, ref);
        
        for(let i = 1; i < base_path.length; i++){
        	if (common === base_path[i]){
            	base_idx = i;
                break
            }
        }
        let common_to_base = Vector$1.make_pose();
        for(let i = base_idx; i < base_path.length; i++){
        	obj_elt = base_path[i];
        	common_to_base = Vector$1.matrix_multiply(common_to_base, obj_elt.pose);
        }
        //common_to_base = Vector.matrix_multiply(common_to_base, base.pose)
        
        for(let i = 1; i < ref_path.length; i++){
        	if (common === ref_path[i]){
            	ref_idx = i;
                break
            }
        }
        let common_to_ref = Vector$1.make_pose();
        for(let i = ref_idx; i < ref_path.length; i++){
        	obj_elt = ref_path[i];
        	common_to_ref = Vector$1.matrix_multiply(common_to_ref, obj_elt.pose);
        }
        //common_to_ref = Vector.matrix_multiply(common_to_ref, ref.pose)
        
        return Vector$1.matrix_divide(common_to_base, common_to_ref)
    }
};

Coor$1.get_position = function(reference_coordinate_system){
	let result;
    if(reference_coordinate_system === undefined){
    	result = Vector$1.pull(this.pose, [0, 2], 3);
    }else {
    	let pose = this.get_pose(reference_coordinate_system);
        result = Vector$1.pull(pose, [0, 2], 3);
    }
    return Vector$1.transpose(result)
};

Coor$1.get_orientation = function(reference_coordinate_system){
    let result;
    if(reference_coordinate_system === undefined){
    	result = Vector$1.pull(this.pose, [0, 2], [0, 2]);
    }else {
    	let pose = this.get_pose(reference_coordinate_system);
        result = Vector$1.pull(pose, [0, 2], [0, 2]);
    }
    return result
};

Coor$1.get_xy_plane_direction = function(reference_coordinate_system){
	let pose = this.get_pose(reference_coordinate_system);
	return Vector$1.multiply(-1, Vector$1.pull(pose, [0, 2], 2))
};

Coor$1.get_xz_plane_direction = function(reference_coordinate_system){
	let pose = this.get_pose(reference_coordinate_system);
	return Vector$1.multiply(-1, Vector$1.pull(pose, [0, 2], 1))
};

Coor$1.get_yz_plane_direction = function(reference_coordinate_system){
	let pose = this.get_pose(reference_coordinate_system);
	return Vector$1.multiply(-1, Vector$1.pull(pose, [0, 2], 0))
};

Coor$1.set_pose = function(pose, reference_coordinate_system){
	let result;
    let ref = reference_coordinate_system;
    if(reference_coordinate_system === undefined){
    	this.pose = pose;
        result = pose;
    }else {
    	let base_ancestors = this.ancestors();
        let parent = base_ancestors[base_ancestors.length-1];
        result = Vector$1.matrix_multiply(pose, ref.get_pose(parent));
    	this.pose = result;
    }
    return result
};


Coor$1.set_position = function(position, reference_coordinate_system){
	let result, current_pose;
    let ref = reference_coordinate_system;
    if(reference_coordinate_system === undefined){
    	current_pose = this.pose; 
        current_pose[0][3] = position[0];
        current_pose[1][3] = position[1];
        current_pose[2][3] = position[2];
    	this.pose = current_pose;
        result = current_pose;
    }else {
    	let base_ancestors = this.ancestors();
        let parent = base_ancestors[base_ancestors.length-1];
        let temp_position = Vector$1.transpose(Vector$1.matrix_multiply(ref.get_pose(parent), Vector$1.properly_define_point(position)));
        temp_position.pop();
        this.pose = Vector$1.make_pose(temp_position, this.get_orientation());
    	result = this.pose;
    }
    return result
};


Coor$1.set_orientation = function(orientation, reference_coordinate_system){
	let result;
    let ref = reference_coordinate_system;
    if(reference_coordinate_system === undefined){
    	this.pose = Vector$1.make_pose(this.get_position(), orientation);
        result = this.pose;
    }else {
    	let base_ancestors = this.ancestors();
        let parent = base_ancestors[base_ancestors.length-1];
        let temp_orientation = Vector$1.matrix_multiply(ref.get_orientation(parent), orientation);
        this.pose = Vector$1.make_pose(this.get_position(), temp_orientation);
    	result = this.pose;
    }
    return result
};
Coor$1.move_points_to_coor = function(points, destination_coordinate_system, reference_coordinate_system){
	let dest = destination_coordinate_system;
    let ref = reference_coordinate_system;
    
    if(ref === undefined){
    	ref = Coor$1.Table;
    }else if(dest === undefined){
    	dest = Coor$1.Table;
    }
    let trans = dest.get_pose(ref);
    let result = points.slice();
    let dim = Vector$1.matrix_dimensions(points);
    if(dim[0] == 1){
    	result = Vector$1.transpose(Vector$1.matrix_multiply(trans, Vector$1.properly_define_point(points)));
        result = result.slice(0, 3);
    }else if(dim[1] == 3){
    	for(let i = 0; i < dim[0]; i++){
    		result[i] = Vector$1.transpose(Vector$1.matrix_multiply(trans, Vector$1.properly_define_point(points[i])));
    	}
        result = Vector$1.pull(result, [0, dim[0] - 1], [0, 2]);
    }
    
    return result
};

Coor$1.move_vectors_to_coor = function(vectors, destination_coordinate_system, reference_coordinate_system){
	let dest = destination_coordinate_system;
    let ref = reference_coordinate_system;
    
    if(ref === undefined){
    	ref = Coor$1.Table;
    }else if(dest === undefined){
    	dest = Coor$1.Table;
    }
    let trans = dest.get_pose(ref);
    let result = vectors.slice();
    let dim = Vector$1.matrix_dimensions(vectors);
    if(dim[0] == 1){
    	result = Vector$1.transpose(Vector$1.matrix_multiply(trans, Vector$1.properly_define_vector(vectors)));
        result = result.slice(0, 3);
    }else if(dim[1] == 3){
    	for(let i = 0; i < dim[0]; i++){
    		result[i] = Vector$1.transpose(Vector$1.matrix_multiply(trans, Vector$1.properly_define_vector(vectors[i])));
    	}
        result = Vector$1.pull(result, [0, dim[0] - 1], [0, 2]);
    }
    
    return result
};



/*
var board = Coor.Table.create_child(Vector.make_pose([0, 0, 1000], [0, 0, 324000]), "board")
var points = [[1, 2, 3], [4, 5, 6]]
debugger
var result = Coor.move_points_to_coor(points, board)
*/

Coor$1.rotate = function(axis_of_rotation, angle, point_of_rotation, reference_coordinate_system){
	let pose, result;
    let ref = reference_coordinate_system;
    if(ref === undefined){
    	pose = this.get_pose();
        if(point_of_rotation == undefined){
        	point_of_rotation = this.get_position();
        }
        pose = Vector$1.rotate_pose(pose, axis_of_rotation, angle, point_of_rotation);
        this.set_pose(pose);
        result = this.pose;
    }else {
    	pose = this.get_pose(ref);
        if(point_of_rotation == undefined){
        	point_of_rotation = [0, 0, 0];
        }
        pose = Vector$1.rotate_pose(pose, axis_of_rotation, angle, point_of_rotation);
        this.set_pose(pose, ref);
        result = this.pose;
    }
    return result
};




/*
Table = Coor.create_child(Vector.make_pose(), "Table")
J0 = table.create_child(Vector.make_pose(), "J0")
J1 = J0.create_child(Vector.make_pose([10, 0, 0]), "J1")
J2 = J1.create_child(Vector.make_pose([0, 0, 20]), "J2")
J3 = J2.create_child(Vector.make_pose([0, 0, 20]), "J3")
cube = table.create_child(Vector.make_pose([15, 10, 5], [0, 0, Convert.degrees_to_arcseconds(0)]), "cube")
debugger
J3.set_pose([[ 0.707, 0.707, 0, 15], [-0.707, 0.707, 0, 10],[0, 0, 1, 5],[0, 0, 0, 1]])
J3.set_pose([[1, 0, 0, 10], [0, 1, 0, 10],[0, 0, 1, 10],[0, 0, 0, 1]])
J3.set_pose([[1, 0, 0, 10], [0, 1, 0, 10],[0, 0, 1, 10],[0, 0, 0, 1]], table)
J3.set_position([10, 10, 10])
J3.set_position([10, 10, 10], table)
debugger
J3.set_orientation(Convert.angles_to_DCM([0, 0, Convert.degrees_to_arcseconds(90)]))
J3.set_orientation([[-1, 0, 0], [0, 0, 1], [0, 0, 1]])
J3.set_orientation([[-1, 0, 0], [0, 0, 1], [0, 0, 1]], cube)
J3.get_pose()
J3.get_pose(table)
cube.get_pose()
J3.get_pose(cube)
cube.get_pose(J3)
cube = table.create_child(Vector.make_pose([15, 10, 5], [0, 0, Convert.degrees_to_arcseconds(45)]), "cube")
J3.get_pose(cube)
cube.get_pose(J3)
J3.get_position()
J3.get_position(cube)
J3.get_orientation()
J3.get_orientation(cube)
*/

//__________out  and helper fns_______

//______show_window_____
//output the "vals" to inspector or stdout.
//this use to be the default show_window callback
//good for debugging
function show_window_values(vals){
    if(platform == "dde") { inspect(vals); }
    else {
        let str = JSON.stringify(vals);
        write_to_stdout(str);
    }
}
global.show_window_values = show_window_values;

//after using this fn to define a global constant,
var _arcsec$1   = 1/3600;
var _um$1       = 0.000001;

//[123, 456].micron() => [0.000123, 0.000456]
//assumes input array has numbers in microns, and converts
//those numbers to meters.
Array.prototype.micron = function(){
    let result = [];
    for(let elt of this) {
       if (typeof(elt) === "number") {
           elt = elt*_um$1;
       }
       result.push(elt);
    }
    return result
};

//input array is in arcseconds, converts its angles to degrees.
Array.prototype.arcsec = function(){
    if(//Instruction.is_oplet_array(this) && //unnecessary.
    // we know its an array or this method wouldn't be called.
    //and if array is too short, a lookup returns undefined
        ["a", "P"].includes(this[Instruction$1.INSTRUCTION_TYPE])){
        let result = this.slice(); //make copy
        for(let i = Instruction$1.INSTRUCTION_ARG0;
            i <= Instruction$1.INSTRUCTION_ARG4; i++){
            let orig_val = this[i];
            if (orig_val !== undefined){
                result[i] = orig_val * _arcsec$1;
            }
        }
        return result
    }
    else {
        let result = [];
        for(let elt of this) {
            if (typeof(elt) === "number") {
                elt = elt*_arcsec$1;
            }
            result.push(elt);
        }
        return result
    }
};

let messages = [
"NOERROR 0 No error",
"EPERM 1 Operation not permitted",
"ENOENT 2 No such file or directory",
"ESRCH 3 No such process",
"EINTR 4 Interrupted system call",
"EIO 5 Input/output error",
"ENXIO 6 No such device or address",
"E2BIG 7 Argument list too long",
"ENOEXEC 8 Exec format error",
"EBADF 9 Bad file descriptor",
"ECHILD 10 No child processes",
"EAGAIN 11 Resource temporarily unavailable",
"ENOMEM 12 Cannot allocate memory",
"EACCES 13 Permission denied",
"EFAULT 14 Bad address",
"ENOTBLK 15 Block device required",
"EBUSY 16 Device or resource busy",
"EEXIST 17 File exists",
"EXDEV 18 Invalid cross-device link",
"ENODEV 19 No such device",
"ENOTDIR 20 Not a directory",
"EISDIR 21 Is a directory",
"EINVAL 22 Invalid argument",
"ENFILE 23 Too many open files in system",
"EMFILE 24 Too many open files",
"ENOTTY 25 Inappropriate ioctl for device",
"ETXTBSY 26 Text file busy",
"EFBIG 27 File too large",
"ENOSPC 28 No space left on device",
"ESPIPE 29 Illegal seek",
"EROFS 30 Read-only file system",
"EMLINK 31 Too many links",
"EPIPE 32 Broken pipe",
"EDOM 33 Numerical argument out of domain",
"ERANGE 34 Numerical result out of range",
"EDEADLK 35 Resource deadlock avoided",
"ENAMETOOLONG 36 File name too long",
"ENOLCK 37 No locks available",
"ENOSYS 38 Function not implemented",
"ENOTEMPTY 39 Directory not empty",
"ELOOP 40 Too many levels of symbolic links",
"EWOULDBLOCK 11 Resource temporarily unavailable",
"ENOMSG 42 No message of desired type",
"EIDRM 43 Identifier removed",
"ECHRNG 44 Channel number out of range",
"EL2NSYNC 45 Level 2 not synchronized",
"EL3HLT 46 Level 3 halted",
"EL3RST 47 Level 3 reset",
"ELNRNG 48 Link number out of range",
"EUNATCH 49 Protocol driver not attached",
"ENOCSI 50 No CSI structure available",
"EL2HLT 51 Level 2 halted",
"EBADE 52 Invalid exchange",
"EBADR 53 Invalid request descriptor",
"EXFULL 54 Exchange full",
"ENOANO 55 No anode",
"EBADRQC 56 Invalid request code",
"EBADSLT 57 Invalid slot",
"EDEADLOCK 35 Resource deadlock avoided",
"EBFONT 59 Bad font file format",
"ENOSTR 60 Device not a stream",
"ENODATA 61 No data available",
"ETIME 62 Timer expired",
"ENOSR 63 Out of streams resources",
"ENONET 64 Machine is not on the network",
"ENOPKG 65 Package not installed",
"EREMOTE 66 Object is remote",
"ENOLINK 67 Link has been severed",
"EADV 68 Advertise error",
"EPROTO 71 Protocol error",
"EMULTIHOP 72 Multihop attempted",
"EDOTDOT 73 RFS specific error",
"EBADMSG 74 Bad message",
"EOVERFLOW 75 Value too large for defined data type",
"ENOTUNIQ 76 Name not unique on network",
"EBADFD 77 File descriptor in bad state",
"EREMCHG 78 Remote address changed",
"ELIBACC 79 Can not access a needed shared library",
"ELIBBAD 80 Accessing a corrupted shared library",
"ELIBSCN 81 .lib section in a.out corrupted",
"ELIBMAX 82 Attempting to link in too many shared libraries",
"ELIBEXEC 83 Cannot exec a shared library directly",
"EILSEQ 84 Invalid or incomplete multibyte or wide character",
"ERESTART 85 Interrupted system call should be restarted",
"ESTRPIPE 86 Streams pipe error",
"EUSERS 87 Too many users",
"ENOTSOCK 88 Socket operation on non-socket",
"EDESTADDRREQ 89 Destination address required",
"EMSGSIZE 90 Message too long",
"EPROTOTYPE 91 Protocol wrong type for socket",
"ENOPROTOOPT 92 Protocol not available",
"EPROTONOSUPPORT 93 Protocol not supported",
"ESOCKTNOSUPPORT 94 Socket type not supported",
"EOPNOTSUPP 95 Operation not supported",
"EPFNOSUPPORT 96 Protocol family not supported",
"EAFNOSUPPORT 97 Address family not supported by protocol",
"EADDRINUSE 98 Address already in use",
"EADDRNOTAVAIL 99 Cannot assign requested address",
"ENETDOWN 100 Network is down",
"ENETUNREACH 101 Network is unreachable",
"ENETRESET 102 Network dropped connection on reset",
"ECONNABORTED 103 Software caused connection abort",
"ECONNRESET 104 Connection reset by peer",
"ENOBUFS 105 No buffer space available",
"EISCONN 106 Transport endpoint is already connected",
"ENOTCONN 107 Transport endpoint is not connected",
"ESHUTDOWN 108 Cannot send after transport endpoint shutdown",
"ETOOMANYREFS 109 Too many references: cannot splice",
"ETIMEDOUT 110 Connection timed out",
"ECONNREFUSED 111 Connection refused",
"EHOSTDOWN 112 Host is down",
"EHOSTUNREACH 113 No route to host",
"EALREADY 114 Operation already in progress",
"EINPROGRESS 115 Operation now in progress",
"ESTALE 116 Stale file handle",
"EUCLEAN 117 Structure needs cleaning",
"ENOTNAM 118 Not a XENIX named type file",
"ENAVAIL 119 No XENIX semaphores available",
"EISNAM 120 Is a named type file",
"EREMOTEIO 121 Remote I/O error",
"EDQUOT 122 Disk quota exceeded",
"ENOMEDIUM 123 No medium found",
"EMEDIUMTYPE 124 Wrong medium type",
"ECANCELED 125 Operation canceled",
"ENOKEY 126 Required key not available",
"EKEYEXPIRED 127 Key has expired",
"EKEYREVOKED 128 Key has been revoked",
"EKEYREJECTED 129 Key was rejected by service",
"EOWNERDEAD 130 Owner died",
"ENOTRECOVERABLE 131 State not recoverable",
"ERFKILL 132 Operation not possible due to RF-kill",
"EHWPOISON 133 Memory page has hardware error",
];
function linux_error_message(error_code){
   if((error_code >= 0) && (error_code < messages.length)){
          return messages[error_code]
   }
   else { return "UNKNOWN " + error_code + " unknown linux error." }
}

//see doc: https://nodejs.org/api/readline.html

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});


//examples of input:
// 'Job.myJob.stop_for_reason("interrupted", "user stopped the job")'
// 'Job.define_and_start_job("/srv/samba/share/dde_apps/myjob.js")'
// 'Job.myjob.color_job_button()'
// 'Job.myjob.server_job_button_click()'
rl.on('line', function(input) {
    //onsole.log("<br/>stdin got line: " + input)
    out("(out call) stdin got line: " + input + "\n");
    eval(input);
});

//https://stackoverflow.com/questions/4976466/difference-between-process-stdout-write-and-console-log-in-node-js
function write_to_stdout$1(str){
    if(str.trim() == "") ; //do nothing
    else {
        //if(str.startsWith("<for_server>")){
          //console.log("write_to_stdout got: " + str)
        //}
        process.stdout.write(str); //"<br/>" + str) //same as console.log ???
    }
}


function close_readline(){
    rl.close();
}

/**Created by Fry on 2/5/16. */

class Job$1{
    constructor({name="",
                 robot=Robot$1.dexter0,
                 do_list=[],
                 keep_history=true,
                 show_instructions=true,
                 inter_do_item_dur=0.01,
                 user_data={},
                 default_workspace_pose=null,
                 program_counter=0,
                 ending_program_counter="end",
                 initial_instruction=null,
                 data_array_transformer="P",
                 start_if_robot_busy=false,
                 if_robot_status_error   = Job$1.prototype.if_robot_status_error_default,
                 if_instruction_error    = Job$1.prototype.if_instruction_error_default,
                 if_dexter_connect_error = Job$1.prototype.if_dexter_connect_error_default,
                 when_do_list_done = "run_when_stopped", //other possible value: "wait" (for another instruction)
                 when_stopped = "stop",
                 when_stopped_conditions = true, //{completed: true,
                                                // errored: true,
                                                //errored_from_dexter: true,
                                                //errored_from_dexter_connect, false, but this is always false and actually its value doesn't matter
                                                                             //but we set it to false just to indicate to users that
                                                                             //dexter_connect errors never run the when_stopped instruction
                                                //interrupted: true,
                                                //interrupted_by_stop_button: true
                                                //},
                 callback_param = "start_object_callback"} = {}){
    if (Job$1[name] && Job$1[name].is_active()) { //we're redefining the job so we want to make sure the
        /*//previous version is stopped.
        //if (Job[name].robot instanceof Dexter) {Job[name].robot.empty_instruction_queue_now() }
        Job[name].stop_for_reason("interrupted", "User is redefining this job.")
        let orig_args = arguments[0]
        setTimeout(function(){ new Job (orig_args) }, 200)
        return ["While attempting to define Job." +  name + ", there already is a Job with that name running<br/>" +
        "It is being stopped. Shortly the new Job will be defined."]
        //note this string must be wrapped in an array, because if a non-object is returned
        //from a JS constructor, it is ignored and an instance of the class is returned instead.
        //horrible JS design. https://javascript.info/constructor-new
        */
        //new, don't stop job algorithm
        warning("You have attempted to redefine the already running Job." + name +
                "<br/>If you want to redefine it, you must first stop it.<br/>" +
                "(click the Job's button)");
        return null //returning null minimizes, but doesn't eliminate, the inspector view of the new job.
                    //we want to minimze the inspector view because the warning ins printed in the out
                    //pane before the inspect of the job and we don't want to "hide" that warning
                    //fron the user.
    }

    for(let key in arguments[0]){
        if(!Job$1.job_default_params.hasOwnProperty(key)) {
            dde_error("Attempt to create a job with an invalid key of: " + key + "<br/>" +
                      "Click on 'Job' to see its valid argument names.");
        }
    }

    //default_workspace_pose=null, //Coor.Table,
    //data_array_transformer="P", //"P" is more efficient than Dexter.pid_move_all_joints, as uses make_ins & 1/2 the do_list items
    //start_if_robot_busy=false,  //if false and robot.is_busy() is true, Job.start is halted early
    //program_counter is the counter of the next instruction that should be executed.
    //so since we're currently "executing" 1 instruction, and after its done,
    //we'll be incrementing the pc, then internally we decriment the
    //passed in program_counter. If its negative, it means
    //compute it from the end, ie -1 means when set_next_do is called,
    //it will set the pc to the length of the do_list, hence we'll be done
    //with the job. -2 means we want to execute the last instruction of the
    //job next, etc.
    //save the args
    if (default_workspace_pose == null) {
          default_workspace_pose=Job$1.job_default_params.default_workspace_pose;
    }
    if (!Array.isArray(do_list)){
        open_doc(job_param_do_list_doc_id);
        dde_error("While defining <code style='color:black;'>Job." + name + "</code><br/>" +
                  "the <b style='color:black;'>do_list</b> must be an array, but instead is: <br/>" +
                  "<code style='color:black;'>" + do_list + "</code>");
        return
    }
    try { do_list = Job$1.flatten_do_list_array(do_list); }
    catch(err){
        open_doc(job_param_do_list_doc_id);
        dde_error("While defining Job." + name + "<br/>" + err.message);
        return
    }
    if((typeof(data_array_transformer) == "function") ||
        Robot$1.is_oplet(data_array_transformer)) ; //ok
    else {
        dde_error("Attempt to define Job." + name + " with a data_array_transformer of:<br/>" +
            data_array_transformer +
            "<br/>which not a function or an oplet.");
    }
    if (name === "") ; //ok as a name, it will be computed.
    else if(!is_string_an_identifier(name)){ //not ok as a name
        dde_error('You have attempted to make a new Job with an invalid name of: "' + name + '".<br/>Job names should start with a letter and be followed by only letters, digits or underscores.');
    }
    if (!Job$1.is_plausible_when_stopped_value(when_stopped)) {
        dde_error("new Job passed: " + when_stopped + " but that isn't a valid value.");
    }
    if(!Job$1.is_when_stopped_conditions_valid(when_stopped_conditions)){
        dde_error("While defining Job." + name + " when_stopped_conditions is not valid.<br/>" +
                   "Valid values are true, false, and a literal object containing one or more of the properties:<br/>" +
                   Job$1.when_stopped_conditions_property_names);
    }
    if (!(robot instanceof Robot$1)){
        if (!Robot$1.dexter0){
            dde_error("Attempt to create Job." + name + " with no valid robot instance.<br/>" +
                " Note that Robot.dexter0 is not defined<br/> " +
                " but should be in your file: Documents/dde_apps/dde_init.js <br/>" +
                " after setting the default ip_address and port.<br/> " +
                " To generate the default dde_init.js file,<br/>" +
                " rename your existing one and relaunch DDE.");
        }
        else {
            dde_error("Attempt to create Job." + name + " with no valid robot instance.<br/>" +
                "You can let the robot param to new Job default, to get a correct Robot.dexter.0");
        }
    }
    else if(!["run_when_stopped", "wait"].includes(when_do_list_done)){
        dde_error('Attempt to create Job.' + name + ' with invalid value for when_do_list_done of: "' + when_do_list_done +
                 '"<br/>Valid values are: ' + '"run_when_stopped" and "wait".');
    }

    else {
        this.orig_args =   {do_list: do_list,
                            robot: robot,
                            keep_history: keep_history,
                            show_instructions: show_instructions,
                            inter_do_item_dur: inter_do_item_dur,
                            user_data: user_data,
                            default_workspace_pose: default_workspace_pose,
                            program_counter: program_counter,
                            ending_program_counter: ending_program_counter,
                            initial_instruction: initial_instruction,
                            data_array_transformer: data_array_transformer,
                            start_if_robot_busy: start_if_robot_busy,
                            if_robot_status_error: if_robot_status_error,
                            if_instruction_error:  if_instruction_error,
                            if_dexter_connect_error: if_dexter_connect_error,
                            when_do_list_done: when_do_list_done,
                            when_stopped: when_stopped,
                            when_stopped_conditions: when_stopped_conditions,
                            callback_param: callback_param};
        //setup name
        Job$1.job_id_base       += 1;
        this.job_id            = Job$1.job_id_base;
        if ((name == null) || (name == "")){ this.name = Job$1.generate_default_name(); }//"job_" + this.job_id }
        else                               { this.name = name; }
        this.robot = robot;
        this.user_data       = user_data; //needed in case we call to_source_code before first start of the job
                                         //this also has the desirable property, that if we define the job,
                                         //then set a user data variable in it ie Job.my_job.user_data.foo = 2,
                                         //that that will get into the org_args.user_data.foo and then
                                         //when we start the job, the "copying out of the user data from orig_args will
                                         //have the user_data.foo2, and start will pick that up and set Job.my_job.user_data
                                         //to the obj with foo = 2 at the start of the job.
                                         //now if during the course of the job,we eval  Job.my_job.user_data.bar=3, ok
                                         //that bar is in the user data for the rest of the job and when it ends.
                                         //NOW if we restart that same job, it will have in user data ONLY foo=2,
                                         //not bar=3. This is good as we want to reinit the job, but foo=2 is really
                                         //"part of the def". (until we redefine the job from its source!
                                         //Messaging.set_variable takes advantage of this if Job is not running when
                                         //Messaging.set_variable is called.
        this.program_counter = program_counter; //this is set in start BUT, if we have an unstarted job, and
                             //instruction_location_to_id needs access to program_counter, this needs to be set
        this.highest_completed_instruction_id = -1; //same comment as for program_counter above.
        this.sent_from_job_instruction_queue  = []; //will be re-inited by start, but needed here
          //just in case some instructions are to be inserted before this job starts.
        Job$1[this.name]         = this; //beware: if we create this job twice, the 2nd version will be bound to the name, not the first.
        Job$1.remember_job_name(this.name);
        this.set_status_code("not_started");//see Job.status_codes for the legal values
                                           //if no button yet, this call doesn't errur
        this.add_job_button_maybe(); //always calls color_job_button, even if a button isn't added
    }
    } //end constructor



    static generate_default_name(){
        for(let i = 2; i < 1000000; i++){
            let candidate = "job" + i;
            if (!Job$1[candidate])  { return candidate }
        }
        dde_error("Job.generate_default_name has found a million job names in use. Seems unlikely.");
    }

    static class_init(){ //inits the Job class as a whole. called by ready
        this.job_default_params =
               {name: null,
                robot: Robot$1.dexter0,
                do_list: [],
                keep_history: true,
                show_instructions: true,
                inter_do_item_dur: 0.01,
                user_data:{},
                default_workspace_pose: Coor$1.Table, //null, //error on loading DDE if I use: Coor.Table, so we init this in Job.constructor
                program_counter:0,
                ending_program_counter:"end",
                initial_instruction: null,
                data_array_transformer: "P",
                start_if_robot_busy: false,
                if_robot_status_error: Job$1.prototype.if_robot_status_error_default,
                if_instruction_error: Job$1.prototype.if_instruction_error_default,
                if_dexter_connect_error: Job$1.prototype.if_dexter_connect_error_default,
                when_do_list_done: "run_when_stopped",
                when_stopped: "stop", //also can be any do_list item
                when_stopped_conditions: true,
                callback_param: "start_object_callback"};
    }

    //return an array of job instances that are defined in path_name.
    //warning might be a empty array
    static instances_in_file(path_name){
        let base_id_before_new_defs = Job$1.job_id_base;
        let result = [];
        try{ load_files$1(path_name); }
        catch(err) {
            dde_error("In Job.instances_in_file, evaling the content of path name: " + path_name +
                      " errored with: " + err.message);
        }
        for(let i = base_id_before_new_defs + 1; true; i++){
            let inst_maybe = Job$1.job_id_to_job_instance(i);  //returns null if no exist
            if(inst_maybe) { result.push(inst_maybe); }
            else { break; }
        }
        return result
    }

    toString() { return "Job." + this.name }

    show_progress_maybe(){
        //out("top of show_progress_maybe for job: " + this.name + " of: " + this.show_instructions)
        if(this.show_instructions === true) { this.show_progress(); }
        else if(typeof(this.show_instructions) === "function") {
            this.show_instructions.call(this);
        }
        //else do nothing
    }

    show_progress(){
        //out("top of show_progress for job: " + this.name + " of: " + this.show_instructions)
        var html_id = this.name + this.start_time.getTime();
        var cur_instr = this.current_instruction();
        if (this.program_counter >= this.do_list.length) { cur_instr = "Done."; }
        else { cur_instr = "Last instruction sent: "  + Instruction$1.to_string(cur_instr); }
        var content = "Job: " + this.name + " pc: "   + this.program_counter +
            " <progress style='width:100px;' value='" + this.program_counter +
                      "' max='" + this.do_list.length + "'></progress>" +
            " of " +  this.do_list.length + ". " +
            cur_instr +
            "&nbsp;&nbsp;<button onclick='inspect_out(Job." + this.name + ")'>Inspect</button>";

        out(content, "#5808ff", html_id);
    }

    show_progress_and_user_data(){
        //out("top of show_progress_and_user_data for job: " + this.name + " of: " + this.show_instructions)
        var html_id = this.name + this.start_time.getTime();
        var cur_instr = this.current_instruction();
        if (this.program_counter >= this.do_list.length) { cur_instr = "Done."; }
        else { cur_instr = "Last instruction sent: "  + Instruction$1.to_string(cur_instr); }
        var content = "Job: " + this.name + " pc: "   + this.program_counter +
            " <progress style='width:100px;' value='" + this.program_counter +
            "' max='" + this.do_list.length + "'></progress>" +
            " of " +  this.do_list.length + ". " +
            cur_instr +
            "&nbsp;&nbsp;<button onclick='inspect_out(Job." + this.name + ")'>Inspect</button>" +
            "<br/>";
        let has_user_data = false;
        for(let prop_name in this.user_data){
            if(!has_user_data) { //first iteration only
                content += "<b>user_data: </b> ";
                has_user_data = true;
            }
            content += "<i>" + prop_name + "</i>: " + this.user_data[prop_name] + "&nbsp;&nbsp;";
        }
        if(!has_user_data) { content += "<i>No user data in this job.</i>"; }
        out(content, "#5808ff", html_id);
    }

    /*obsolete version coded before Job.instances_in_file, and
       it starts the LAST job defined in the file, not the first
     static define_and_start_job(job_file_path){
        let starting_job_id_base = Job.job_id_base
        try { load_files(job_file_path)}
        catch(err){
            console.log("Could not find Job file: " + job_file_path + "  " + err.message)
            return
        }
        if(starting_job_id_base == Job.job_id_base){
            console.log("apparently there is no job definition in " + job_file_path)
        }
        else {
            let latest_job = Job.job_id_to_job_instance(Job.job_id_base)
            if(latest_job instanceof Job){
                latest_job.start()
            }
            else {
                console.log(job_file_path + " appears to contain a valid job definition.")
            }
        }
    }*/

    // todo starts the first job defined in the file, if any
    // beware: if all the jobs defined in the file are defined and active, then
    //Job.instances_in_file will return [] because new Job has to shut down
    //same named jobs that are active before redefining the job and that requires
    //a set timeout meaning the initial call to "new Job" won't actually make the
    //new job and thus won't increment the job_id. So Job.instances_in_file fails.
    //So a lously work-around is to make sure all the jobs in the file are
    //non-active. the problem is, the caller of define_and_start_job (and Job.instances_in_file)
    // often doesn't know what jobs are in the file, and that's why they're calling Job.instances_in_file
    //in the first place. So Job.instances_in_file and define_and_start_job really should take
    //a callback, but that causes some problems with where these fns are used. ARGGG
    //relavent in Messaging, dexter_user_interface2, instruction start_job, and maybe a few more places.
    static define_and_start_job(job_file_path){
        let job_instances = Job$1.instances_in_file(job_file_path);
        if(job_instances.length == 0) {
            warning("Could not find a Job definition in the file: " + job_file_path);
            if((platform === "node") && !window.keep_alive_value){
                warning("Closing the process of loading: " + job_file_path +
                        "<br/>If you want to keep the process up,<br/>check <b>keep_alive</b> before clicking the Job button.");
                close_readline(); //causes the process running this job to finish.
            }
        }
        else {
            job_instances[0].start();
        }
    }

    static start_and_monitor_dexter_job(job_src){
        let base_id_before_new_def = Job$1.job_id_base;
        try { window.eval(job_src); }
        catch(err) {dde_error("While evaling the job definition to send to Dexter,<br/>" +
                              "got error: " + err.message);
        }
        if(Job$1.job_id_base == base_id_before_new_def) {
            dde_error("Before transfering Job file to Dexter,<br/>" +
                      "could not find a Job definition in the selected source.");
        }
        else {
            let dde_monitor_job_instance = Job$1.job_id_to_job_instance(base_id_before_new_def + 1);
            //we "hollow out" this job that is being sent to dexter by
            //replacing its do_list with something that monitors the
            //running of the job on Dexter.
            //we use the same name for that dexter-running job as this
            //monitoring job running in DDE.
            //by using start with do_list, we preserve orig_args.do_list
            //in the DDE job instance
            //which will be useful for user to inspect.
            //user_data:job_src set so that RESTARTING this job by clicking its button will use the orig selected src to restart the job
            dde_monitor_job_instance.start({
                user_data: {stop_job_running_on_dexter: false,
                            already_handled_stop_job:false,
                            dexter_log:undefined,
                            job_src:job_src}, //the presence of this user data prop is how we tell that this job is a dde_shadow_job_instance.
                inter_do_item_dur: 0.005, //we don't need to have fast communication with Dexter. Minimize traffic
                do_list:[
                        Dexter$1.write_file("job/run/" + dde_monitor_job_instance.name + ".dde", job_src),
                        Control.loop(true,
                            function(){
                                if(this.user_data.dexter_log !== undefined) { //got a dexter log meaning the monitored job is over.
                                    return Control.break()
                                }
                                else if ((this.user_data.stop_job_running_on_dexter) &&
                                         (!this.user_data.already_handled_stop_job))  { //set by clicking the job button
                                         this.user_data.already_handled_stop_job = true;
                                         this.user_data.stop_job_running_on_dexter = false;
                                        return Dexter$1.write_file("job/run/killjobs", "")
                                        //now next time in this loop, the first clause should hit
                                }
                                else { return Dexter$1.read_file("job/logs/" + dde_monitor_job_instance.name + ".dde.log", "dexter_log")} //the
                                       //log file is only present once the job has stopped
                            }),
                        function(){
                           let content;
                           if(typeof(this.user_data.dexter_log) == "string") { content = this.user_data.dexter_log; }
                           else { content = "Sorry, no log."; }
                           out("Running Job." + this.name + " on Dexter." + this.robot.name + " produced the log of:<br/><pre><code>" +
                                content + "</code></pre>");
                        }
                        ]
            });
        }
    }


    //Called by user to start the job and "reinitialize" a stopped job
    start(options={}){  //sent_from_job = null
        //out("Top of Job." + this.name + ".start()")
        let the_active_job_with_robot_maybe = Job$1.active_job_with_robot(this.robot); //could be null.
            //must do this before setting status_code to "starting".
            //there can only be one Job trying to use a Dexter. (at least as the Job's main robot.)
        if((this.robot instanceof Dexter$1) && the_active_job_with_robot_maybe) {
            this.stop_for_reason("errored", "Dexter." + this.robot.name +
                                 " already running Job." + the_active_job_with_robot_maybe.name);
            dde_error("Attempt to start Job." + this.name + " with Dexter." + this.robot.name +
                      ",<br/>but that Dexter is already running Job." + the_active_job_with_robot_maybe.name +
                      ",<br/>so Job." + this.name + " was automatically stopped.");
        }
        if(this.wait_until_this_prop_is_false) { this.wait_until_this_prop_is_false = false; } //just in case previous running errored before it could set this to false, used by start_objects
        if (["starting", "running", "stopping", "running_when_stopped", "suspended", "waiting"].includes(this.status_code)){
            //does not run when_stopped instruction.
            dde_error("Attempt to restart job: "  + this.name +
                      " but it has status code: " + this.status_code +
                      " which doesn't permit restarting.");
        }
        else if (["not_started", "completed", "errored", "interrupted"].includes(this.status_code)){
            this.orig_args.robot;
            if(options.hasOwnProperty("robot")) ;
            //if(early_robot instanceof Dexter)   { early_robot.remove_from_busy_job_array(this) }
            Dexter$1.remove_from_busy_job_arrays(this);
        }
        //active jobs & is_busy checking
        let early_start_if_robot_busy = this.orig_args.start_if_robot_busy;
        if (options && options.hasOwnProperty("start_if_robot_busy")) { early_start_if_robot_busy = options.start_if_robot_busy; }
        if((this.robot instanceof Dexter$1) &&  //can 2 jobs use a Robot.Serial? I assume so for now.
           !early_start_if_robot_busy &&
           this.robot.is_busy()) {
                let one_active_job = this.robot.busy_job_array[0];
                let but_elt = window[one_active_job.name + "_job_button_id"];
                this.stop_for_reason("errored", "Another job: " + one_active_job.name +
                                      " is using robot: " + this.robot.name);
                if(but_elt){
                    let bg = but_elt.style["background-color"];
                    dde_error("Job." + this.name + " attempted to use: Dexter." + this.robot.name +
                        "<br/>but that robot is in use by Job." + one_active_job.name +
                        "<br/>Click the <span style='color:black; background-color:" + bg + ";'> &nbsp;" +
                        one_active_job.name + " </span>&nbsp; Job button to stop it, or<br/>" +
                        "create Job." + this.name + " with <code>start_if_robot_busy=true</code><br/>" +
                        "to permit it to be started.");
                }
                else {
                    dde_error("Job." + this.name + " attempted to use: Dexter." + this.robot.name +
                        "<br/>but that robot is in use by Job." + one_active_job.name + "<br/>" +
                        "Create Job." + this.name + " with <code>start_if_robot_busy=true</code><br/>" +
                        "to permit it to be started.");
                }
                return
        }
        //init from orig_args
            this.set_status_code("starting"); //before setting it here, it should be "not_started"
            this.wait_until_instruction_id_has_run = null; //needed the 2nd time we run this job, init it just in case it didn't get set to null from previous job run
            //this.init_do_list(options.do_list)
            this.do_list                 = this.orig_args.do_list;
            this.callback_param          = this.orig_args.callback_param;
            this.keep_history            = this.orig_args.keep_history;
            this.show_instructions       = this.orig_args.show_instructions;
            this.inter_do_item_dur       = this.orig_args.inter_do_item_dur;
            this.user_data               = shallow_copy_lit_obj(this.orig_args.user_data);
            this.default_workspace_pose  = this.orig_args.default_workspace_pose;
            this.program_counter         = this.orig_args.program_counter; //see robot_done_with_instruction as to why this isn't 0,
                                           //its because the robot.start effectively calls set_up_next_do(1), incrementing the PC
            this.ending_program_counter  = this.orig_args.ending_program_counter;
            this.initial_instruction     = this.orig_args.initial_instruction;
            this.data_array_transformer  = this.orig_args.data_array_transformer;
            this.start_if_robot_busy     = this.orig_args.start_if_robot_busy;
            this.if_robot_status_error   = this.orig_args.if_robot_status_error;
            this.if_instruction_error    = this.orig_args.if_instruction_error;
            this.if_dexter_connect_error = this.orig_args.if_dexter_connect_error;
            this.when_do_list_done       = this.orig_args.when_do_list_done;
            this.when_stopped            = this.orig_args.when_stopped;
            this.when_stopped_conditions = ((typeof(this.orig_args.when_stopped_conditions) == "boolean") ?
                                             this.orig_args.when_stopped_conditions :
                                             Object.assign({}, this.orig_args.when_stopped_conditions)); //make a copy in case it was munged in the previous running of the job

            //first we set all the orig (above), then we over-ride them with the passed in ones
            for (let key in options){
                if (options.hasOwnProperty(key)){
                    let new_val = options[key];
                    //if (key == "program_counter") { new_val = new_val - 1 } //don't do. You set the pc to the pos just before the first instr to execute.
                    //if      (key == "do_list")    { continue; } //flattening & setting already done by init_do_list
                    if      (key == "user_data")  { new_val = shallow_copy_lit_obj(new_val); }
                    else if (key == "name")       ; //don't allow renaming of the job
                    else if ((key == "when_stopped") &&
                             !Job$1.is_plausible_when_stopped_value(new_val)) {
                        dde_error("Job.start called with an invalid value for 'when_stopped' of: " +
                                  new_val);
                        return
                    }
                    this[key] = new_val;
                }
                else if (!Job$1.job_default_params.hasOwnProperty(key)){
                    warning("Job.start passed an option: " + key + " that is unknown. This is probably a mistake.");
                }
            }
            this.init_do_list();

            let maybe_symbolic_pc = this.program_counter;
            this.program_counter = 0; //just temporarily so that instruction_location_to_id can start from 0
            const job_in_pc = Job$1.instruction_location_to_job(maybe_symbolic_pc, false);
            if ((job_in_pc != null) && (job_in_pc != this)) {
                dde_error("Job." + this.name + " has a program_counter initialization<br/>" +
                          "of an instruction_location that contains a job that is not the job being started. It shouldn't.");
                return
            }
            this.program_counter = this.instruction_location_to_id(maybe_symbolic_pc);

            //this.robot_status      = []  use this.robot.robot_status instead //only filled in when we have a Dexter robot by Dexter.robot_done_with_instruction or a Serial robot
            this.rs_history        = []; //only filled in when we have a Dexter robot by Dexter.robot_done_with_instruction or a Serial robot
            this.sent_instructions = [];
            this.sent_instructions_strings = [];

            this.start_time        = new Date();
            this.stop_time         = null;
            this.stop_reason       = null;

            this.wait_reason       = null; //not used when waiting for instruction, but used when status_code is "waiting"
            this.wait_until_instruction_id_has_run = null;
            this.highest_completed_instruction_id  = -1;



            //this.iterator_stack    = []
            if (this.sent_from_job_instruction_queue.length > 0) { //if this job hasn't been started when another job
                 // runs a sent_to_job instruction to insert into this job, then that
                 //instruction is stuck in this job's sent_from_job_instruction_queue,
                 //so that it can be inserted into this job when it starts.
                 //(but NOT into its original_do_list, so its only inserted the first time this
                 //job is run.
                Job$1.insert_instruction(this.sent_from_job_instruction_queue, this.sent_from_job_instruction_location);
            }
            this.sent_from_job_instruction_queue = []; //send_to_job uses this. its on the "to_job" instance and only stores instructions when send_to_job has
                                                  //where_to_insert="next_top_level", or when this job has yet to be starter. (see above comment.)
            this.sent_from_job_instruction_location = null;
            if (this.initial_instruction) { //do AFTER the sent_from_job_instruction_queue insertion.
                Job$1.insert_instruction(this.initial_instruction, {job: this, offset: "program_counter"});
            }
            //must be after insert queue and init_instr processing
            if ((this.program_counter == 0) &&
                (this.do_list.length  == 0) &&
                ((this.when_do_list_done == "wait") || (typeof(this.when_stopped) == "function"))) ; //special case to allow an empty do_list if we are waiting for an instruction or have a callback.
            else if (this.do_list.length == 0) {
                warning("While starting job: " + this.name + ", the do_list is empty.<br/>" +
                         "The job still requests the status of Dexter, but does not cause it to move.");
            }
            else if (this.program_counter >= this.do_list.length){ //note that maybe_symbolic_pc can be "end" which is length of do_list which is valid, though no instructions would be executed in that case so we error.
                dde_error("While starting job: " + this.name +
                    "<br/>the program_counter is initialized to: " + this.program_counter +
                    "<br/>but the highest instruction ID in the do_list is: " +  (this.do_list.length - 1));
            }
            Job$1.last_job           = this;
            this.go_state          = true;

            this.already_started_when_stopped = false;
            this.final_status_code = null;
            this.condition_when_stopped = null;

            this.show_progress_maybe();
            //console.log('calling robot.start from job.start')
            //out("Bottom of Job." + this.name + ".start() calling " + this.robot.name + ".start()")
            this.robot.start(this); //the only call to robot.start
            return this
    }
    //action for the Eval & start Job  menu item on Jobs menu.
    static start_job_menu_item_action() {
        let full_src               = Editor.get_javascript();
        let selected_src           = Editor.get_javascript(true);
        let sel_start_pos          = Editor.selection_start();
        let sel_end_pos            = Editor.selection_end();
        let start_of_job_maybe     = Editor.find_backwards(full_src, sel_start_pos, "new Job");
        let start_of_job_pos;
        let end_of_job_pos;
        let job_src = null; //if this is not null, we've got a valid job surrounds (or is) the selection.
        let sel_is_instructions = false;
        if(start_of_job_maybe !== null){
            [start_of_job_pos, end_of_job_pos] = Editor.select_call(full_src, start_of_job_maybe);
        }
        if(end_of_job_pos && (end_of_job_pos > sel_start_pos)){ //sel is within a job, but we don't know if its
            //instruction selection or just within the job yet.
            job_src = full_src.substring(start_of_job_pos, end_of_job_pos);
            let do_list_start_pos = full_src.indexOf("do_list:", start_of_job_pos);
            if((do_list_start_pos === -1) || (do_list_start_pos > end_of_job_pos)) ; //weird, looks like Job has no do_list,
              //but ok, we just have the whole Job to execute.
            else if (do_list_start_pos < sel_start_pos) { //our selected_src should be instructions in the do_list
                sel_is_instructions = true;
            }
        }
        if (job_src === null) { //no job def so we're going to make our own.
            //warning("There's no Job definition surrounding the cursor.")
            var selection = Editor.get_javascript(true).trim();
            if (selection.endsWith(",")) { selection = selection.substring(0, selection.length - 1); }
            if (selection.length > 0){
                //if (selection.startsWith("[") && selection.endsWith("]")) {} //perhaps user selected the whole do_list. but
                //bue we can also have a single instr that can be an array.
                //since it's ok for a job to have an extra set of parens wrapped around its do_list,
                //just go ahead and do it.
                //else {
                //plus
                selection = "[" + selection + "]";
                sel_start_pos = sel_start_pos - 1;
                //}
                var eval2_result = eval_js_part2(selection);
                if (eval2_result.error_type) ; //got an error but error message should be displayed in output pane automatmically
                else if (Array.isArray(eval2_result.value)){ //got an array, but is it a do_list of multiple instructions?
                   let do_list;
                   if(!Instruction$1.is_instructions_array(eval2_result.value)){ //might never hit, but its an precaution
                       do_list = [eval2_result.value];
                   }
                   if (Job$1.j0 && Job$1.j0.is_active()) {
                        Job$1.j0.stop_for_reason("interrupted", "Start Job menu action stopped job.");
                        setTimeout(function() {
                                       Job$1.init_show_instructions_for_insts_only_and_start(sel_start_pos, sel_end_pos,
                                                                                           do_list, selection);},
                                    (Job$1.j0.inter_do_item_dur * 1000 * 2) + 10); //convert from seconds to milliseconds
                    }
                    else {
                        Job$1.init_show_instructions_for_insts_only_and_start(sel_start_pos, sel_end_pos,
                                                                            eval2_result.value, selection);
                    }
                }
                else {
                    shouldnt$1("Selection for Start job menu item action wasn't an array, even after wrapping [].");
                }
            }
            else {
                warning("When choosing the Eval&Start Job menu item<br/>" +
                        "with no surrounding Job definition,<br/>" +
                        "you must select exactly those instructions you want to run.");
            }
        }
        //we have a job.
        else {
            const eval2_result = eval_js_part2(job_src);
            if (eval2_result.error_type) ; //got an error but error message should be displayed in Output pane automatically
            else {
                let job_instance = eval2_result.value;
                if(!sel_is_instructions){
                    job_instance.start();
                }
                else if (selected_src.length > 0){ //sel is instructions
                    let do_list_result = eval_js_part2("[" + selected_src + "]"); //even if we only have one instr, this is still correct, esp if that one starts with "function().
                           //if this wraps an extra layer of array around the selected_src, that will still work pretty well.
                    if (do_list_result.error_type) ; //got an error but error message should already be displayed
                    else {
                        job_instance.start({do_list: do_list_result.value});
                    }
                }
                else { //no selection, so just start job at do_list item where the cursor is.
                    const [pc, ending_pc]  = job_instance.init_show_instructions(sel_start_pos, sel_end_pos, start_of_job_pos, job_src);
                    job_instance.start({show_instructions: true, inter_do_item_dur: 0.5, program_counter: pc, ending_program_counter: ending_pc});
                }
            }
        }
    }

    //all the below logic about whether to make a job with Dexter.default or a brain
    //is heuristic, and not infallable, but likely to be OK.
    static init_show_instructions_for_insts_only_and_start(start_cursor_pos, end_cursor_pos, do_list_array, selection){
        let has_start_job_instruction = false;
        let start_job_job = null;
        let has_defaulting_dexter_instruction = false;
        for(let instr of do_list_array) {
            if(instr instanceof Instruction$1.start_job) { //Control.start_job doesn't work here.
                has_start_job_instruction = true; //because its likely (but not guarenteed) that the job being started will have a default robot of a dexter (as in recordings, etc. and we can't have 2 active jobs both using the same dexter.
                if(instr.job_name instanceof Job$1) {
                    start_job_job = instr.job_name;
                }
                else if(typeof(instr.job_name) == "string"){
                    if(Job$1[instr.job_name] instanceof Job$1){
                        start_job_job = Job$1[instr.job_name];
                    }
                }
                else {
                    dde_error("Control.start_job has a name that is not a Job or a string.");
                }
            }
            else if ((instr instanceof Instruction$1.Dexter) &&
                      !instr.robot) { //meaning use the Job's default robot
                has_defaulting_dexter_instruction = true;
            }
        }
        let rob;
        if(has_start_job_instruction && has_defaulting_dexter_instruction){
                if(start_job_job.robot &&
                  (start_job_job.robot === Dexter$1.default)){
                    dde_error("You've selected an instruction using the Job's default dexter robot and <br/>" +
                              "a start_job instruction to a Job that uses Dexter.default.<br/>" +
                              "This violates 2 active Jobs both having a robot of the same Dexter.<br/>" +
                              "To separate these, wrap the selected instructions in a Job but<br/>" +
                              "make the Dexter instructions have a subject of a Dexter instance,<br/>" +
                              'such as Dexter.dexter0 and give the Job a <code>new Brain({name: "some_name"})</code> robot.'
                    );
                }
                else { //has as start_job but its not to a job that is using Dexter.default so use Dexter.default
                       //as its needed for the Dexter class instructions
                    rob = Dexter$1.default;
                }
        }
        else if (has_start_job_instruction) { //does not have has_defaulting_dexter_instruction
                rob = new Brain({name: "b0"});
        }
        else { //maybe has dexter instructions, maybe not, but doesn't have start_job so...
            rob =  Dexter$1.default;
        }
        const job_instance = new Job$1({name: "j0", robot: rob, do_list: do_list_array});
        //const begin_job_src = 'new Job ({name: "j0", do_list: '
        //const job_src = begin_job_src + selection + "})"
        //const start_of_job = start_cursor_pos - begin_job_src.length//beware, could be < 0
        //job_instance.init_show_instructions(start_cursor_pos, end_cursor_pos, start_of_job, job_src)
        job_instance.start({show_instructions: true});
    }

    init_show_instructions(start_cursor_pos, end_cursor_pos, start_of_job, job_src){
        this.job_source_start_pos = start_of_job; //necessary offset to range positions that are in the syntax tree
        const syntax_tree = esprima$1.parse(job_src, {range: true});
        const job_props_syntax_array = syntax_tree.body[0].expression.arguments[0].properties;
        for (var prop_syntax of job_props_syntax_array){
            if (prop_syntax.key.name == "do_list"){
                this.do_list_syntax_array = prop_syntax.value.elements;
                return this.instruction_ids_at_selection(start_cursor_pos, end_cursor_pos, start_of_job, syntax_tree)
            }
        }
        dde_error("Job." + this.name + " apparently has no do_list property.");
    }

    //returns pc to set for starting job that cursor is in, or 0, start at begining,
    instruction_ids_at_selection(start_cursor_pos, end_cursor_pos, start_of_job, syntax_tree) {
        var start_cursor_pos_in_job_src = start_cursor_pos - start_of_job;
        var end_cursor_pos_in_job_src   = end_cursor_pos   - start_of_job;
        var result_start = null;
        var result_end   = "end";
        for(let i = 0; i <  this.do_list_syntax_array.length; i++) {
            var do_list_item_syntax = this.do_list_syntax_array[i];
            //var inst_start_pos = do_list_item_syntax.range[0]
            do_list_item_syntax.range[0];
            var inst_end_pos   = do_list_item_syntax.range[1];
            if (result_start === null){
                if (start_cursor_pos_in_job_src <= (inst_end_pos + 1)){ //comma at end still in the instr
                    result_start = i; //first time through, cursor before do_list, just start at 0
                    if (start_cursor_pos == end_cursor_pos) { //no selection
                        result_end = "end";
                        break;
                    }
                    else if (end_cursor_pos_in_job_src <= (inst_end_pos + 1)){ //there's a selection, but it starts and ends in just one instruction
                        result_end = i + 1;
                        break;
                    }
                }
            }
            else { //looking for result_end
                if (end_cursor_pos_in_job_src <= (inst_end_pos + 1)){ //comma at end still in the instr
                    result_end = i + 1;
                    break;
                }
            }
        }
        return [result_start, result_end]
    }

    select_instruction_maybe(cur_do_item){
        if(this.show_instructions && this.do_list_syntax_array){
            console.log("    now processing instruction: " + stringify_value(cur_do_item));
            const orig_instruction_index = this.orig_args.do_list.indexOf(cur_do_item);
            if(orig_instruction_index != -1){
                const range = this.instruction_text_range(orig_instruction_index);
                Editor.select_javascript(range[0], range[1]);
            }
        }
    }
    instruction_text_range(orig_instruction_index){
        const array_elt_syntax_tree = this.do_list_syntax_array[orig_instruction_index];
        return [array_elt_syntax_tree.range[0] + this.job_source_start_pos,
                array_elt_syntax_tree.range[1] + this.job_source_start_pos]
    }
    //end show_instruction in editor
    //Job BUTTONS______
    get_job_button_id(){ return this.name + "_job_button_id"}

    get_job_button_wrapper_id(){ return this.name + "_job_wrapper_button_id"}

    get_job_button(){
        const the_id = this.get_job_button_id();
        var but_elt = window[the_id];
        return but_elt
    }

    get_job_button_wrapper(){
        const the_id = this.get_job_button_wrapper_id();
        var but_elt = window[the_id];
        return but_elt
    }

    add_job_button_maybe(){
      if(window.platform == "dde") {
        let but_elt = this.get_job_button();
        if (!but_elt){
            const job_name = this.name;
            const the_id = this.get_job_button_id();

            const the_button_html = '<button style="margin-left:0px; vertical-align:50%;" id="' + the_id + '">'+ job_name +
                                    '</button>';
            //$("#jobs_button_bar_id").append(the_html)
            let wrapper = document.createElement('div');
            wrapper.id = this.get_job_button_wrapper_id();
            wrapper.style.display = "inline-block";
            let close_on_click_fn_src = "Job." + job_name + ".undefine_job()";
            let inspect_on_click_fn_src =  "inspect(Job." + job_name + ")";
            wrapper.innerHTML = the_button_html +
                                "<div style='display:inline-block;margin-right:10px;'><span style='cursor:pointer;' onclick='" +
                                close_on_click_fn_src +
                                "' title='Undefine this job'>X</span><br/><span style='cursor:pointer; padding-left:2px;' onclick='" +
                                inspect_on_click_fn_src +
                                "' title='Inspect this job'>&#9432;</span></div>";
            jobs_button_bar_id.append(wrapper); //.firstChild)

            but_elt = window[the_id];
            but_elt.onclick = function(event){
                if(window["Metrics"]) { Metrics.increment_state("Job button clicks"); }
                event.target.blur(); //gets rid of dark border around button and because its
                //not focused, pressing the space or ENTER key doesn't do something strange
                //like an extra button click.
                const job_instance = Job$1[job_name];
                console.log("Job button clicked when status was: " + job_instance.status_code);
                if (job_instance.status_code == "suspended"){
                    if(but_elt.title.includes("Make Instruction")) { job_instance.stop_for_reason("interrupted", "User stopped job."); }
                    else { job_instance.unsuspend(); }
                }
                else if (job_instance.user_data.stop_job_running_on_dexter !== undefined) { //ie this job is MONITORING a job running on Dexter
                    //if (job_instance.user_data.stop_job_running_on_dexter === false){
                    //    job_instance.user_data.stop_job_running_on_dexter = true
                        job_instance.color_job_button(); //keep this call
                    //}
                    if(job_instance.is_active()){
                        //if (job_instance.robot instanceof Dexter) { job_instance.robot.empty_instruction_queue_now() }
                        job_instance.stop_for_reason("interrupted", "User stopped job", false);
                    }
                    else { //restart this job on Dexter
                        Job$1.start_and_monitor_dexter_job(job_instance.user_data.job_src);
                        return //let the start color the job button as race condition between that and the below color_job_button
                    }
                }
                else if(job_instance.is_active()){
                    if (job_instance.robot instanceof Dexter$1) {
                         //job_instance.robot.empty_instruction_queue_now() //causes DexRun to error.
                         if (job_instance.robot.waiting_for_flush_ack) {
                             if(job_instance.status_code === "stopping");
                             else { //first time user clicked button while job was running.
                                job_instance.set_status_code("stopping");
                                return //we don't want to call stop_for_reason until the ack for the "F"
                                    // comes back to Dexter.protype.robot_done_with_instruction
                             }
                         }
                    }
                    job_instance.stop_for_reason("interrupted", "User stopped job", false);
                }
                else {
                    job_instance.start();
                }
            };
        }
      }
      this.color_job_button(); //do regardless of dde or node and regardless of
           //whether there's already a button or not becuase if we
           //define a new job of the same name that already has a button,
           //we want to change the buttons' color.
           //add_job_button_maybe is ONLY called by Job constructor.
    }
    static extract_job_name_from_file_path(file_path){
        let job_name_start_pos = file_path.lastIndexOf("/");
        if (job_name_start_pos == -1) { job_name_start_pos = 0; }
        else { job_name_start_pos += 1; } //move to after the slash
        let job_name_end_pos = file_path.lastIndexOf(".");
        if(job_name_end_pos == -1) { job_name_end_pos = file_path.length; }
        let job_name = file_path.substring(job_name_start_pos, job_name_end_pos);
        return job_name
    }
    //called by httpd.js when keep_alive_value == true
    static maybe_define_and_server_job_button_click(job_file_path){
        let job_name = Job$1.extract_job_name_from_file_path(job_file_path);
        let job_instance = Job$1[job_name];
        if(job_instance) {
            job_instance.server_job_button_click(); //might bre first time starting job, or stopping running job, or 2nd time starting
        }
        else { //no defined job of that name, so load its file and start it.
           Job$1.define_and_start_job(job_file_path); //starts first Job in file,
           //regardless of its name, but we still expect it to be named the job_name,
           //otherwise, if the job is running, we load it again and redefine it while
           //its running! Not good.
        }
    }
    //similar to the add_job_button_maybe inner job button click function
    server_job_button_click(){
        let job_instance = this;
        if (job_instance.status_code == "suspended"){
           job_instance.unsuspend();
        }
        else if(job_instance.is_active()){
            //if (job_instance.robot instanceof Dexter) { job_instance.robot.empty_instruction_queue_now() }
            job_instance.stop_for_reason("interrupted", "User stopped job", false);
        }
        else {
            job_instance.start();
        }
    }

    remove_job_button(){
        var elt = this.get_job_button_wrapper(); //this.get_job_button()
        if(elt){
            elt.remove();
        }
    }
    //if we're in dde and there's no button, then this does nothing and doesn't error.
    color_job_button(){
        let bg_color = null;
        let tooltip  = "";
        switch(this.status_code){
            case "not_started":
                bg_color = "rgb(204, 204, 204)";
                tooltip  = "This Job has not been started since it was defined.\nClick to start this Job.";
                break; //defined but never started.
            case "starting":
                bg_color = "rgb(210, 255, 190)";
                tooltip  = "This Job is in the process of starting.\nClick to stop it.";
                break;
            case "running":
                if((this.when_do_list_done == "wait") &&
                   (this.program_counter == this.instruction_location_to_id(this.ending_program_counter))) {
                    bg_color = "rgb(255, 255, 102)"; //pale yellow
                    tooltip  = 'This Job is waiting for a new last instruction\nbecause it has when_do_list_done="wait".\nClick to stop this job.';
                }
                else if(this.user_data.stop_job_running_on_dexter === true) {
                    bg_color = "#ffcdb7"; //pale orange
                    tooltip  = "This job is in the process of stopping";
                }
                else {
                    const cur_ins = this.do_list[this.program_counter];
                    let oplet = null;
                    if (Instruction$1.is_oplet_array(cur_ins)){
                        oplet = cur_ins[Dexter$1.INSTRUCTION_TYPE];
                    }
                    if(oplet === "z") {
                        let dur_in_seconds = cur_ins[Instruction$1.INSTRUCTION_ARG0];
                        bg_color = "rgb(255, 255, 102)"; //pale yellow
                        tooltip  = "Now running instruction " + this.program_counter +
                                   ', sleep (oplet "z") for ' + dur_in_seconds + " second(s).";
                    }
                    else {
                        bg_color = "rgb(136, 255, 136)";
                        tooltip  = "This Job is running instruction " + this.program_counter +
                                   ".\nClick to stop this job.";
                    }
                }
                break;
            case "stopping":
               bg_color = "rgb(225, 169, 107)"; //"#db8622" //brown
               tooltip = "The job is running a\nDexter.empty_instruction_queue instruction\nand will stop when that's complete.";
               break;
            case "running_when_stopped":
                bg_color = "#00a600"; //dark green
                tooltip = "This job is running its when_stopped instruction.";
                break;
            case "suspended":
                bg_color = "rgb(255, 255, 17)"; //bright yellow
                if(this.wait_reason.includes("Make Instruction")){
                    tooltip  = "This Job is suspended at instruction: " + this.program_counter +
                               " because\n" +
                               this.wait_reason + "\n" +
                               "To stop this Job, click this button.";
                }
                else {
                    tooltip  = "This Job is suspended at instruction: " + this.program_counter +
                               " because\n" +
                               this.wait_reason + "\n" +
                               "Click to unsuspend it.\nAfter it is running, you can click to stop it.";
                }
                break; //yellow
            case "waiting":
                bg_color = "rgb(255, 255, 102)"; //pale yellow
                tooltip  = "This Job is at instruction " + this.program_counter +
                            ", waiting for:\n" + this.wait_reason + "\nClick to stop this job.";
                break; //yellow
            case "completed":
                if((this.program_counter === this.do_list.length) &&
                    (this.when_do_list_done === "wait")){
                    bg_color = "rgb(255, 255, 102)"; //pale yellow
                    tooltip  = 'This Job is waiting for a new last instruction\nbecause it has when_do_list_done="wait".\nClick to stop this job.';
                }
                else {
                    bg_color = "rgb(230, 179, 255)"; // purple. blues best:"#66ccff"  "#33bbff" too dark  //"#99d3ff" too light
                    tooltip  = "This Job has successfully completed.\nClick to restart it.";
                }
                break;
            case "errored":
                bg_color = "rgb(255, 68, 68)";
                let reason = this.stop_reason;
                reason = replace_substrings(reason, "<br/>", "\n");
                tooltip  = "This Job errored at instruction: " + this.program_counter +
                " with:\n" + reason + "\nClick to restart this Job.";
                break;
            case "interrupted":
                bg_color = "rgb(255, 123, 0)"; //orange
                tooltip  = "This Job was interrupted at instruction " + this.program_counter +
                " by:\n" + this.stop_reason + "\nClick to restart this Job.";
                break;
        }
        if(window.platform == "dde"){
            const but_elt = this.get_job_button();
            if(!but_elt){ return }
            if (but_elt.style.backgroundColor !== bg_color) { //cut down the "jitter" in the culor, don't set unnecessarily
                but_elt.style.backgroundColor = bg_color;
                if((this.name === "rs_update") && window.robot_status_run_update_job_button_id){
                    robot_status_run_update_job_button_id.style.backgroundColor = bg_color;
                }
            }
            if(this.user_data.stop_job_running_on_dexter !== undefined) {
                tooltip  += "\nThis job monitors a job running on Dexter.";
            }
            but_elt.title = tooltip;
        }
        else { //job engine
           let data = {kind: "show_job_button", job_name: this.name, status_code: this.status_code, button_color: bg_color, button_tooltip: tooltip};
           write_to_stdout$1("<for_server>" + JSON.stringify(data) + "</for_server>");
        }
    }
    //end of jobs buttons

    //not passing reason means don't change it.
    //if status_code is "waiting"  or "suspeneded" then reason is for job_instance.wait_reason
    //else if status_code is,"errored", "interrupted", "completed" then reason is for job_instance.stop_reason
    set_status_code(status_code, reason){
        if(status_code === this.status_code) ; //no change, do nothing
        else if (Job$1.status_codes.includes(status_code)){ //valid status code
            this.status_code = status_code;
            if (["waiting", "suspended"].includes(status_code)) {
                if(reason !== undefined){
                    this.wait_reason = reason;
                }
                this.stop_reason = null;
            }
            else if (this.is_done()) {
                if(reason !== undefined){
                    this.wait_reason = null;
                    this.stop_reason = reason;
                }
            }
            else if (status_code === "stopping") ;
            else if (status_code === "running_when_stopped");
            else { //"not_started", "starting", "running"
                   //these status codes don't have reasons so any passed in reason is ignored.
                this.wait_reason = null;
                this.stop_reason = null;
            }
            this.color_job_button(); //the main call to color_job_button
        }
        else {
            shouldnt$1("set_status_code passed illegal status_code of: " + status_code +
                "<br/>The valid status codes are:</br/>" +
                Job$1.status_codes);
        }
    }

    //the job has run at least once and is now done
    //not quite the opposite of is_active because a job could be
    //not_started and would not qualify as is_active OR is_done
    is_done(){
        return ["completed", "errored", "interrupted"].includes(this.status_code)
    }

    is_active(){
        //return ((this.status_code != "not_started") && (this.stop_reason == null))
       return ["starting", "running", "stopping", "running_when_stopped", "suspended", "waiting"].includes(this.status_code)
    }
    static active_jobs(){
        let result = [];
        for(let a_job of Job$1.all_jobs()){
            if (a_job.is_active()){
                result.push(a_job);
            }
        }
        return result
    }

    //returns the active job that has robot as its default robot OR null if none.
    static active_job_with_robot(robot){
        for(let a_job of Job$1.all_jobs()){
            if (a_job.is_active()){
                if(a_job.robot === robot) {
                    return a_job
                }
            }
        }
        return null
    }

    //returns an array of jobs that either have "robot" as their default robot,
    //OR the job's PC is pointing at an instruction that is using "robot".
    static active_jobs_using_robot(robot){
        result = [];
        this.active_jobs();
        for(let job_instance of adctive_jobs){
            if(job_instance.robot === robot) { result.push(job_instance); }
            else {
                let instr = job_instance.do_list[job_instance.program_counter];
                if(instr){
                    let rob = instr.robot; //this is the best we can do if there's a robot indincated in the instr
                    if(rob === robot) {
                        result.push(job_instance);
                    }
                }
            }
        }
        return result
    }

    //called in utils stringify_value    used for original_do_list
    static non_hierarchical_do_list_to_html(a_do_list){
        var result = "<table><tr><th title='The instruction_id is the order of the instruction in the do_list.\nSame as the program counter at send time.'>ID</th>" +
                                "<th title='The instruction type and its arguments'>Instruction</th></tr>";
        for(var i = 0; i < a_do_list.length; i++){
            result +=  "<tr><td>" + i + "</td><td>" + stringify_value(a_do_list[i]) + "</td><td></tr>";
        }
        result += "</table>";
        return "<details><summary>original do_list</summary>" + result + "</details>"
    }

    do_list_to_html(){
        Job$1.do_list_to_html_set_up_onclick();
        return "<details style='display:inline-block'><summary></summary>" +
                this.do_list_to_html_aux(0, 1) +
                "</details>"
    }

    static do_list_to_html_set_up_onclick(){
        if(window.platform == "dde"){
            setTimeout(function(){
                let elts = document.getElementsByClassName("do_list_item");
                for (let i = 0; i < elts.length; i++) { //more clever looping using let elt of elts breaks but only on windows deployed DDE
                    let elt = elts[i];
                    elt.onclick = Job$1.do_list_item_present_robot_status; }
            }, 500);
        }
    }
    //runs in UI
    static do_list_item_present_robot_status(event){
       event.stopPropagation();
            let elt = event.target;
            let [job_name, instruction_id] = elt.dataset.do_list_item.split(" ");
            Job$1.show_robot_status_history_item(job_name, parseInt(instruction_id));
    }

    instruction_id_to_rs_history_item(id){
        for (let item of this.rs_history){
            if (item[Dexter$1.INSTRUCTION_ID] == id) { return item }
        }
        if (this.keep_history){
            shouldnt$1("Job.instruction_id_to_rs_history_item passed id: " + id + " but couldn't be found in rs_history: " + this.rs_history);
        }
        else { return null }
    }

    current_instruction(){
        return this.do_list[this.program_counter]
    }

    //warning: this will be wrong if user puts two eq items on do_list, such as a fn
    //or a Instruction instance that was first bound to a var, then that var was used
    //twice on the do_list
    is_top_level_do_item(do_item){
        return this.orig_args.do_list.includes(do_item)
    }

    at_sync_point(sync_point_name){
        let ins = this.current_instruction();
        return ((ins instanceof Instruction$1.sync_point) &&
                (ins.name == sync_point_name))
    }

    at_or_past_sync_point(sync_point_name){ //presumes that the THIS job HAS an instuction with the named sync point
        if(!this.do_list) { return false} //before this job has started so its definately not past any of its sync points.
        for(let a_pc = this.program_counter; a_pc >= 0; a_pc--){
            let ins = this.do_list[a_pc];
            if ((ins instanceof Instruction$1.sync_point) &&
                (ins.name == sync_point_name)) { return true }
        }
        return false
    }

    static show_robot_status_history_item(job_name, instruction_id){
        let job_instance    = Job$1[job_name];
        let rs_history_item = job_instance.instruction_id_to_rs_history_item(instruction_id);
        if (rs_history_item) {
            let table_html      = Dexter$1.robot_status_to_html_table(rs_history_item);
            show_window({content: table_html,
                         title: "Robot status for " + job_name + ", instruction: " + instruction_id,
                         width:  800,
                         height: 380});
        }
        else {
            out("Robot: " + job_instance.robot.name + " in job: " + job_instance.name +
                " has not kept robot_status for instruction: "    + instruction_id + "." +
                "<br/>Job " + job_instance.name + " keep_history is: " + job_instance.keep_history,
                "red");
        }
    }

    do_list_to_html_aux(id_to_start_from = 0, indent_level = 0, sub_item_count){
        if (!sub_item_count) {
            if (this.do_list) { sub_item_count = this.do_list.length;}
            else { sub_item_count = 0; }
        }
        let result = "";
        let sub_sub_items_processed = 0;
        for(let sub_item_index = 0; sub_item_index < sub_item_count; sub_item_index++){
            let id = id_to_start_from + sub_item_index + sub_sub_items_processed;
            if (id >= this.do_list.length) {return result}
            let item = this.do_list[id];
            let new_sub_item_count = this.added_items_count[id];
            let class_html = "class='do_list_item' ";
            let rs_button = "";
            if (Instruction$1.is_oplet_array(item)) { rs_button = " <button data-do_list_item='" + this.name + " " + id + "' + title='Show the robot status as it was immediately after this instruction was run.'" + class_html + ">RS</button> ";}
            let item_text =  ((id == this.program_counter) ? "<span style='border-style:solid; border-width:2px;'> ": "") +
                             "<span title='instruction_id'>id=" + id +
                             "</span>&nbsp;<span title='Number of sub_instructions&#13;added by this instruction below it.'> si=" + new_sub_item_count + "</span>" +
                             rs_button +
                             "&nbsp;" + Instruction$1.text_for_do_list_item(item) + //core of the_item
                             ((id == this.program_counter) ? "</span>" : "" );
            let html_indent = 'style="margin-left:' + (indent_level * 20) + 'px; background-color:' + Instruction$1.instruction_color(item) + ';"';

            let actual_sub_items_grabbed_this_iter;
            if (new_sub_item_count > 0) {
                item_text = "<details " + html_indent + "><summary>" + item_text + "</summary>";
                let sub_items_text = this.do_list_to_html_aux(id + 1, indent_level + 1, new_sub_item_count);
                item_text = item_text + sub_items_text + "</details>";
                actual_sub_items_grabbed_this_iter = (sub_items_text.match(/<div|<details/g) || []).length;
                sub_sub_items_processed += actual_sub_items_grabbed_this_iter;
            }
            else {
                item_text = "<div " + html_indent + ">" + item_text + "</div>";
                actual_sub_items_grabbed_this_iter = 0;
              }

            result += item_text;
        }
        return result
    }
    time_to_string(a_time){
        if (a_time){
            return a_time.getHours() + ":" + a_time.getMinutes() + ":" + a_time.getSeconds()
        }
        else { return "null" }
    }
    stringify(){
        let stat_code = this.status_code;
        if (stat_code == "completed") { stat_code = "<span style='color:#00b300;'>completed</span>"; }
        else if ((stat_code === "errored") || (stat_code === "interrupted")) {
            stat_code = "<span style='color:#cc0000;'>" + stat_code + "</span>";
        }
        let dur_string = milliseconds_to_human_string(this.stop_time - this.start_time);
        let result = "Job <i>name</i>: "        + this.name                  + ", <i>job_id</i>: " + this.job_id + ", <i>simulate</i>: " + this.robot.simulate + "<br/>" +
                     "<i>start_time</i>: "      + this.time_to_string(this.start_time) +
                     ", <i>stop_time</i>:  "    + this.time_to_string(this.stop_time)  +
                     ", <i>dur</i>: "           + dur_string + "<br/>" +
                     "<i>program_counter</i>: " + this.program_counter       + ", <i>status_code</i>: " + stat_code + ",<br/>" +
                     "<i>stop_reason</i>: "     + this.stop_reason           + ", <i>wait_reason</i>: " + this.wait_reason + "<br/>" +
                     "<i>wait_until_instruction_id_has_run</i>: " + this.wait_until_instruction_id_has_run + "<br/>" +
                     "<i>highest_completed_instruction_id</i>: " + this.highest_completed_instruction_id + "<br/>" +
                     "<i>user_data</i>: " + stringify_value(this.user_data) + ",<br/>" +
                      Job$1.non_hierarchical_do_list_to_html(this.orig_args.do_list) +
                      this.do_list_to_html() +
                      Dexter$1.sent_instructions_to_html(this.sent_instructions) +
                      Dexter$1.make_show_rs_history_button_html(this.job_id)     +
                      "<fieldset style='background-color:#EEEEEE;'><legend>Robot</legend>" + this.robot.stringify() + "</fieldset>";

        return result
    }

    //takes nested items in array and makes flattened list where the elts are
    //a dexter instruction array, a fn, or something else that can be a do_item.
    //removes no_op instructions from the returned array.
    static flatten_do_list_array(arr, result=[]){
       for(let i = 0; i < arr.length; i++){
           let elt = arr[i];
           if      (Instruction$1.is_no_op_instruction(elt))   ; //get rid of it, including empty nested arrays
           else if (Instruction$1.is_oplet_array(elt))         { result.push(elt); }
           else if (Instruction$1.is_data_array(elt))          { result.push(elt); } //do not flatten!
           else if (Array.isArray(elt))                      { Job$1.flatten_do_list_array(elt, result); }
           else if (elt instanceof Instruction$1)              { result.push(elt); }
           else if (typeof(elt) === "string")                { result.push(elt); }
           else if (typeof(elt) === "function")              { result.push(elt); }
           else if (is_iterator(elt))                        { result.push(elt); }
           else if (Instruction$1.is_start_object(elt))        { result.push(elt); }
           else { throw(TypeError("Invalid do_list item at index: " + i + "<br/>of: " + elt)) }
       }
       return result
    }

    suspend(reason = "suspended") {
        this.set_status_code("suspended", reason); //makes job button yellow, causes set_up_next_do to just retrunn without calling do_next_item
    }
    //can't be an instruction, must be called from a method
    //unsuspend is like start, ie it calls start_after_connected which calls send get status
    // which calls robot_done_with_instruction which calls set_up_next_do(1)
    //if stop_reason is not false, we "unsuspend but immediately stop the job.
    unsuspend(stop_reason=false){
        if (this.status_code == "suspended"){
            if(stop_reason){
                this.stop_for_reason("interruped", stop_reason);
                this.set_up_next_do(0);
            }
            else {
                this.set_status_code("running");
                this.set_up_next_do(1);
            }
        }
    }

    //returns true if success, false if not, undefined if this.keep_history is false,
    //but no callers care.
    record_sent_instruction_stop_time(ins_id, stop_time){
        if (this.keep_history){
            for(let ins of this.sent_instructions){
                if (typeof(ins) == "string") ; //forget about it. can't store a stop time
                else if(ins[Instruction$1.INSTRUCTION_ID] === ins_id){
                     ins[Instruction$1.STOP_TIME] = stop_time;
                     return true
                }
            }
            return false //would happen if the instruction is a string, OR if there's a shouldn't type error, but can't distinguish between the tow so just let it go
                   //shouldnt("a_job.record_sent_instruction_stop_time  passed ins_id: " + ins_id +
                    // " but couldn't find an instruction with that id in Job." + this.name + ".sent_instructions")
        }
    }
}

//used by Job.prototype.to_source_code. Keep in sync with Job.constructor!
Job$1.job_default_params = null;

Job$1.status_codes = [//normal starting up
                    "not_started", "starting", "running",
                    "stopping",  //user clicked button to stop while Job was running Dexter.empty_instruction_queue.
                                 //so wait until the ack for Dexter.empty_instruction_queue comes back to DDE,
                                 //THEN stop the job.
                    "running_when_stopped",
                    //paused while running
                    "suspended", "waiting",   //(wait_until, sync_point)
                    //below mean how runnning the job was stopped.
                    "errored",
                    "interrupted", //user stopped manually,
                    "completed"    //normal OK completion
                    ];

Job$1.global_user_data = {};
Job$1.job_id_base = 0; //only used for making the job_id.
Job$1.all_names = []; //maintained in both UI and sandbox/ used by replacement series job names

//note that once we make 1 job instance with a name, that binding of
//Job.the_name never goes away, and that name will always be in the
//the all_names list. But if you redefine a Job (with the same name)
//the old value of that name is gc'd.
Job$1.remember_job_name = function(job_name){
    if (!Job$1.all_names.includes(job_name)){
        Job$1.all_names.push(job_name);
    }
};

Job$1.forget_job_name = function(job_name){
    let i = Job$1.all_names.indexOf(job_name);
    if (i != -1){
        Job$1.all_names.splice(i, 1);
    }
};

//we can't send to sandbox or UI, this has to work in both.
//that's why we have Job.remember_job_name().
//used by series replacement
Job$1.is_job_name = function(a_string){
    return Job$1.all_names.includes(a_string)
};

Job$1.all_jobs = function(){
    let result = [];
    for(let name of Job$1.all_names){
        result.push(Job$1[name]);
    }
    return result
};

Job$1.job_id_to_job_instance = function(job_id){
    for(let name of Job$1.all_names){
        if (Job$1[name].job_id === job_id) {return Job$1[name]}
    }
    return null
};

//returns the latest defined job or null if there are no defined jobs
Job$1.latest_defined_job = function() {
    return Job$1.job_id_to_job_instance(Job$1.job_id_base)
};

/*Job.job_id_to_job_instance = function(job_id){
    let str = job_id.toString()
    let str_of_int = str.substring(0, str.indexOf("."))
    if(str_of_int == -1) { str_of_int = str}
    let the_int = parseInt(str_of_int)
    return Job.job_id_to_job_instance_aux(the_int)
}*/
Job$1.last_job = null;

//called when user clicks the stop button (stop sign button)
Job$1.stop_all_jobs = function(){
    var stopped_job_names = [];
    for(var j of Job$1.all_jobs()){
        //if (j.robot instanceof Dexter) { j.robot.empty_instruction_queue_now() }
        if ((j.stop_reason == null) && (j.status_code !== "not_started")){
            j.stop_for_reason("interrupted_by_stop_button", "User stopped all jobs.", false);
            stopped_job_names.push(j.name);
        }
       // j.robot.close() //does not delete the name of the robot from Robot, ie Robot.mydex will still exist, but does disconnect serial robots
          //this almost is a good idea, but if there's a job that's stopped but for some reason,
          //its serial port is still alive, better to call serial_disconnect_all()
        if (j.robot instanceof Dexter$1) { j.robot.close_robot(); } //needed when wanting to start up again, exp with dexter0
    }
    serial_disconnect_all();
    if (stopped_job_names.length == 0){
        out("There are no active jobs to stop.");
    }
    else {
       out("Stopped jobs: " + stopped_job_names);
    }
};

Job$1.prototype.undefine_job = function(){
    if(this.robot instanceof Dexter$1) { Dexter$1.remove_from_busy_job_arrays(this); }
    delete Job$1[this.name];
    Job$1.forget_job_name(this.name);
    this.remove_job_button();
};

Job$1.clear_stopped_jobs = function(){
    var cleared_job_names = [];
    for(var j of Job$1.all_jobs()){
        if ((j.stop_reason != null) || (j.status_code == "not_started")){
            j.undefine_job();
            cleared_job_names.push(j.name);
            if (j == Job$1.last_job) { Job$1.last_job = null; }
        }
    }
    if ((Job$1.last_job === null) && (Job$1.all_names.length > 0)){
        Job$1.last_job = last(Job$1.all_names); //not technically the last job created since
        //that was deleted
        //and might not even be the last job "redefined".
        //but its pretty close and the use of last_job isn't really sensitve to
        //being precise so this is pretty good.
    }
    if (cleared_job_names.length == 0){
        out("There are no stopped jobs to clear.");
    }
    else { out("Cleared jobs: " + cleared_job_names); }
};

//used in making robot_status_history window.
/* this functionality doesn't match its name, and its never called so don't have it!
Job.prototype.highest_sent_instruction_id = function(){
    if (this.sent_instructions.length > 0){
        return this.sent_instructions[0]
    }
    else { return null }
}*/

Job$1.report = function(){
        if (Job$1.all_names.length == 0){
            out("Either no jobs have been created in this session,<br/>" +
                "or all the jobs have been cleared.<br/>" +
                "See the <button>Jobs&#9660;</button> <b>Insert example</b> menu item<br/>" +
                "for help in creating a job.");
        }
        else {
            var result  = "<table style='border: 1px solid black;border-collapse: collapse;'><tr style='background-color:white;'><th>Job Name</th><th>ID</th><th>Robot</th><th>Start Time</th><th>Stop Time</th><th>Status</th></tr>";
            for (var j of Job$1.all_jobs()){
                var start_time = "Not started";
                var stop_time = "";
                if (j.start_time){
                    start_time = j.start_time.getHours()   + ":" +
                        j.start_time.getMinutes() + ":" +
                        j.start_time.getSeconds() + ":" +
                        j.start_time.getMilliseconds();
                    stop_time = "ongoing";
                }
                if (j.stop_time){
                    stop_time = j.stop_time.getHours()   + ":" +
                        j.stop_time.getMinutes() + ":" +
                        j.stop_time.getSeconds() + ":" +
                        j.stop_time.getMilliseconds();
                }
                var action = 'Job.print_out_one_job,,' + j.name;
                //var name = "<a href='#' title='Click for details on this job.' class='onclick_via_data' data-onclick='" + action + "'>" + j.name + "</a>"
                var job_name = "<a href='#' title='Click for details on this job.' class='onclick_via_data' data-onclick='" + action + "'>" + j.name + "</a>";

                result += "<tr/><td>" + job_name + "</td><td>" + j.job_id + "</td><td>" + j.robot.name + "</td><td>" + start_time + "</td><td>" + stop_time + "</td><td>" + j.status() + "</td><tr>";
            }
            result += "</table>";
            out(result);
            SW.install_onclick_via_data_fns();
        }
};

//called by make_dde_status_report for emails. Should not contain html.
Job$1.active_jobs_report = function(){
    let jobs = Job$1.active_jobs();
    if(jobs.length == 0) { return "There are no active Jobs." }
    else {
        let result = "";
        for(let job_instance of jobs) {
            let cur_instr = job_instance.do_list[job_instance.program_counter];
            let pc = job_instance.program_counter;
            let instr_src;
            if(pc < 0) { instr_src = "At beginning of job."; }
            else if (pc >= job_instance.do_list.length) {
                         instr_src = "At end of job.";
            }
            else {       instr_src = to_source_code({value: cur_instr}); }
            result += "Name: Job." + job_instance.name +
                      "\nStatus: " + job_instance.status_code +
                      "\nProgram Counter: " + pc;
            result += "\nCurrent Instruction source: " + instr_src + "\n\n";
        }
        return result
    }
};

Job$1.prototype.print_out = function(){
    out(this.stringify());
    //setTimeout(function(){install_onclick_via_data_fns()}, 200) //needs to let the html render.
};

Job$1.print_out_one_job = function(job_name){
        var j = Job$1[job_name];
        j.print_out();
};

Job$1.prototype.status = function (){
    if (this.stop_reason)      { return this.status_code + ": " + this.stop_reason }
    else if (this.wait_reason) { return this.status_code + ": " + this.wait_reason}
    else {
       let len = this.orig_args.do_list.length;
       if ( this.do_list) { len = this.do_list.length; }
       let pc = 0;
       if (this.program_counter) { pc = this.program_counter; }
       return this.status_code + ", pc: " + pc + " of " + len
    }
};

//placed on the do_list if there's a robot status error.
Job$1.prototype.if_robot_status_error_default = function(){
    let robot_status = this.robot.robot_status;
    let msg = this.rs_to_error_message(robot_status);
    warning("Dexter robot_status error: " + msg);
    let rob = this.robot;
    if(rob instanceof Dexter$1){
        let sim_actual = Robot$1.get_simulate_actual(rob.simulate);
        if((sim_actual === false) || (sim_actual === "both")){
            try{ let path = "Dexter." + rob.name + ":/srv/samba/share/errors.log";
                 read_file_async(path, undefined, function(err, content){
                         if(err) {warning("Could not find: " + path);}
                         else {
                            if((typeof(content) != "string") ||
                                (content.length == 0)){
                                content == "<i>errors.log is empty</i>";
                            }
                            else {
                             content = replace_substrings(content, "\n", "<br/>");
                             content = "Content of " + path + "<br/><code>" + content + "</code>";
                             setTimeout(function(){write_file_async(path, "");},
                                        400); //give the read_file job a chance to finish properly
                            }
                            out(content);
                        }
                 });
               }
            catch(err) {warning("In Job.prototype.if_robot_status_error_default, could not get the errors.log file<br/>" +
                                  " for " + "Dexter." + rob.name); }
        }
    }
    return Control.error(msg)
    //this default method stops the job but allows the when_stopped instruction to run.
};

Job$1.prototype.if_instruction_error_default = function(){
    let pc_of_error_instruction = this.program_counter - 1;
    let erroring_instruction = this.do_list[pc_of_error_instruction];
    let instr_src = to_source_code(erroring_instruction);
    let msg = "Error in instruction of Job." + this.name + " at do_list program counter of: " + pc_of_error_instruction +
              "<br/>" + instr_src;
    //warning(msg) //redundant. Let Control.error print the msg.
    return Control.error(msg)
    //this default method stops the job but allows the when_stopped instruction to run.
};

//unlike the others, the job won't proceed from this.
Job$1.prototype.if_dexter_connect_error_default = function(robot_name){
    let rob = Dexter$1[robot_name];
    let msg = "Error in connecting to Dexter." + robot_name +
              " at ip_address: " + rob.ip_address +
              " for Job." + this.name +
              "<br/>If Dexter." + robot_name + " is unconnected, you can still use the simulator." +
              "<br/>In the Misc pane header, click the <b>simulate</b> radio button.";
    warning(msg);
    return null // this default method allows the job to proceed, unlike
                // Dexter.stop_job(undefined, msg) or Control.error instruction
};

//from James N
Job$1.prototype.rs_to_error_message = function(robot_status){
    let error_code = robot_status[Dexter$1.ERROR_CODE];
    let oplet_error_code = error_code & 0xFF; //lower 8 bits
    let msg = "error_code: " + error_code;
    let oplet = robot_status[Dexter$1.INSTRUCTION_TYPE];
    if (error_code > 0) {
        if((oplet == "r") || (oplet == "w")) {
            let linux_msg = linux_error_message(oplet_error_code);
            msg += "Error on oplet 'r' (read_file) with Linux error of: " + linux_msg;
        }
        else {
            if      (oplet_error_code == 1)  {msg += " oplet:"    + oplet + " is unknown to Dexter. Please upgrade Dexter firmware and gateware.<br/>";}
            else if (oplet_error_code == 2)  {msg += " on oplet:" + oplet + " communication error.<br/>";}
            else                             {msg += " on oplet:" + oplet + " Unknown error.<br/>";}
        }
        if(error_code & (1 << 10)) {msg+=" Firmware - Gateware Mismatch. Update system. Fatal error.<br/>";}
        if(error_code & (1 << 27)) {msg+=" SPAN Servo, Joint 7. r 0 errors.log <br/>";}
        if(error_code & (1 << 28)) {msg+=" ROLL Servo, Joint 6. r 0 errors.log <br/>";}
        if(error_code & (1 << 30)) {msg+=" Joint Monitor. r 0 errors.log <br/>";}
    }
    return msg
};


//if the job errored, the robot is a dexter, and the error code is in the 600's,
//and we're not simulating, then try to show the user the Dexter's errors.log file
//in the output pane.
Job$1.prototype.show_error_log_maybe = function(){
    let rob = this.robot;
    if(rob instanceof Dexter$1){
        const sim_actual = Robot$1.get_simulate_actual(rob.simulate);
        if ((sim_actual === false) || (sim_actual === "both")) {
            if((this.status_code == "errored") &&
                (rob.rs.error_code() >= 600) &&
                (rob.rs.error_code() < 700)){
            let path = rob.name + ":" + "../errors.log";
            read_file_async(path,
                undefined,
                function(err, content){
                    if(err) {
                        warning("Could not get " + path + "<br/>Error: " + err);
                    }
                    else {
                        content = replace_substrings(content, "\n", "<br/>");
                        out("<b>" + rob_name + ":/srv/samba/share/errors.log</b> content:<br/>" + content);
                    }
                });
            }
        }
    }
};

//status_code can also be a when_stopped condition, ie
// errored, errored_from_dexter, errored_from_dexter_connect, interrupted, interrupted_by_stop_button. completed
Job$1.prototype.stop_for_reason = function(condition_when_stopped, //"errored", "interrupted", "completed"
                                         reason) { //a string
    if(!Job$1.when_stopped_conditions_property_names.includes(condition_when_stopped)){
        shouldnt$1("Job." + this.name + ".stop_for_reason called with invalid first arg condition_when_stopped of:<br/>" +
            condition_when_stopped + "<br/>Valid values are: " + Job$1.when_stopped_conditions_property_names);
    }
    else {
        this.condition_when_stopped = condition_when_stopped;
        let pos_of_underscore = condition_when_stopped.indexOf("_");
        if(pos_of_underscore > 0) {
            this.set_status_code(condition_when_stopped.substring(0, pos_of_underscore),
                reason);
        }
        else { this.set_status_code(condition_when_stopped, reason); }
        if (this.robot.heartbeat_timeout_obj) { clearTimeout(this.robot.heartbeat_timeout_obj); }
        this.stop_time    = new Date();
        //this.current_instruction().init_instruction() //needed by at least wait_until and loop. now done in Job.start
        if(condition_when_stopped == "errored_from_dexter_connect"){ //the do list isn't running, so we can't simply wait for that to happen
            let fn = this.if_dexter_connect_error;
            if(fn) {
                let job_instance = this;
                setTimeout(function() {
                              fn.call(job_instance, job_instance.robot.name);
                           }, //beware, might be some other robot
                           200); //we give the job a chance to finish. the job is not expected to be running the do_list
            }
        }
        else if((this.name == "dex_read_file") && (this.status_code == "errored") && window.Editor){
            //this special case needed because if we attempt to Dexter.read_file with sim= real and
            // we're not connected to the Dexter, we get a connection error, which
            // will call stop_for_reason but not finish.
            // window.Editor will be undefined in Node, so ok to have this code when running job engine on dexter.
            Editor.set_files_menu_to_path(); //restore files menu to what it was before we tried to get the file off of dexter.
        }
    }
};

Job$1.when_stopped_conditions_property_names = ["completed", "errored", "errored_from_dexter", "errored_from_dexter_connect",
                                               "interrupted", "interrupted_by_stop_button" ];

Job$1.is_when_stopped_conditions_valid = function(when_stopped_conditions){
    if(typeof(when_stopped_conditions) == "boolean") { return true }
    else if(typeof(when_stopped_conditions) == "object") {
       for(let key in when_stopped_conditions){
           if(!Job$1.when_stopped_conditions_property_names.includes(key)){
               return false
           }
           let val = when_stopped_conditions[key];
           if (key == "errored_from_dexter_connect") {
               if (val !== false){
                   warning("The value for Job param when_stopped_conditions, property: errored_from_dexter_connect<br/>" +
                           " is: " + val + " but only a value of false is valid.<br/>" +
                           "Use Job param if_dexter_connect_error to supply a method to call<br/>" +
                           "when there's a dexter connection error.");
                   return false
               }
           }
           else if(typeof(val) !== "boolean") {
               return false
           }
       }
       return true
    }
    else { return false }
};

Job$1.prototype.ok_to_run_when_stopped = function(){
    if(this.when_stopped == "stop") { return false }
    //else if(this.when_do_list_done == "wait") { return false } //whether this val is "wait" or "run_when_stopped" its ok, so this prop isn't a factor in what ok_to_run_when_stopped returns
    else if (this.when_stopped_conditions === true ) { return true }
    else if (this.when_stopped_conditions === false) { return false }
    else {
       let cond = this.when_stopped_conditions[this.condition_when_stopped];
       if(cond === undefined) { return true }
       else if (this.condition_when_stopped == "errored_from_dexter_connect") { return true } //was false, as this usually happens at very beginnig of job  efore its really started, but new  jun 2021 idea is, try hard to always run the when_stopped instruction
       else { return cond } //better be true or false. //this should never arrise as if this.when_stopped_conditions is a boolean, it will be caught above.
    }
};

//adds when_stopped instruction to the do_list if it hasn't already been run,
//and if it has, ends the job.
Job$1.prototype.finish_job = function(){
      if(this.status_code == "errored")  { //todo avoid printing twice but we want to print before starting the when_stopped action
        let failed_instruction = this.do_list[this.program_counter];
        let mess = to_source_code({value: failed_instruction});
        out("Job." + this.name + " failed instruction " + this.program_counter + ": " + mess, "red");
      }
      if (!this.ok_to_run_when_stopped()||     // never run the when_stopped instruction
           this.already_started_when_stopped){ // we've already run the when_stopped instruction
          if(["errored", "interrupted"].includes(this.status_code)); //leave status_code as is, even if there is a final_status_code,
               //because maybe it errored or was interruopted while running the when_stopped fn,
               //in which case we want the final job status to be errored or interrupted regardless
               //of its status upon completed the orig do_list
          else if(this.final_status_code) { //happens when the status_code was set to "running_when_stopped "
              this.status_code = this.final_status_code;
          } //does not hit in the all defaults case
          this.robot.finish_job();
          //if(this.robot instanceof Dexter) { this.robot.remove_from_busy_job_array(this)} //sometimes a job might be busy and the user clicks its stop button. Let's clean up after that!
          Dexter$1.remove_from_busy_job_arrays(this); //remove from ALL Dexters' busy_job_arrays.
          this.color_job_button(); //possibly redundant but maybe not and just called on finishing job so leave it in
          this.show_progress_maybe();
          out("Done with Job." + this.name + ", for reason: " + this.stop_reason);
          if(window.platform === "node") { //only calls close_readline to end process, or doesn't
            if(window.keep_alive_value) ; //keep the process alive
            else {
                let the_active_jobs = Job$1.active_jobs();
                //the below a bit tricky as the 'this' job is in the process of finishing
                // and might or might not be "active".
                console.log("In finish_job for job: " + this.name + " id: " + this.job_id);
                //onsole.log("active_jobs length: " + the_active_jobs.length)
                if(the_active_jobs.length == 1) {
                    console.log("In finish_job just one active job with first job: " + the_active_jobs[0].name + " job_id: " + the_active_jobs[0].job_id);
                }
                if( (the_active_jobs.length == 0) ||
                   ((the_active_jobs.length == 1) &&
                    (the_active_jobs[0].job_id === this.job_id)
                   )
                ) { //don't close the readline if there's a job that still wants to use it.
                    //as our orig job might have launched a 2nd job, so keep it open
                    //until all are done.
                    console.log("finish job calling close_readline");
                    close_readline(); //causes the process running this job to finish.
                }
            }
          }
          //this.show_error_log_maybe() //I'm already doing this when
          //a robot_status comes back with a non-zero error code.
      }
      /*else if((this.when_do_list_done === "wait") && (this.status_code === "running")){ //even if we somehow stopped in the middle of the do_list,
        // we are going to wait for a new instruction to be added
        //beware, maybe race condition here with adding a new instruction.
        this.set_status_code("running")
        this.program_counter = this.do_list.length
        this.set_up_next_do(0)
      }*/
      else { //perform the when_stopped action
          this.already_started_when_stopped = true;
          this.final_status_code = this.status_code;
          this.status_code = "running_when_stopped";
          if (Instruction$1.is_do_list_item(this.when_stopped)){ //careful, it might be an array of instructions. If so, we want to stick that array on the do_list as one item.
              this.program_counter = this.do_list.length - 1; //do before the insert so we insert at the end
              this.insert_single_instruction(this.when_stopped, false); //2nd arg false means Not a sub-instruction
              this.ending_program_counter = "end"; //because we got here due to ending_program_counter being early, and
                 //one way that can happen is if Control.stop_job is run, which sets the ending_program_counter
                 //to get the job to stop at that instruction, but then, we add more instructions
                 //so we have to get rid of that early end and allow the new when_stopped instruction to run
              this.when_do_list_done = "run_when_stopped"; //before setting, this might be "wait", but when finish_job
                 //is called, we are no longer going to wait for an instruction.
              this.when_stopped = "stop"; //ie we've already "used up" the when_stopped instruction, so stop when its done.
              this.set_up_next_do(); //advance to the inserted instruction.
          }
          else if (Job$1.is_plausible_instruction_location(this.when_stopped)){ //obsolete
              this.stop_for_reason("errored",
                                    "You have a job when_stopped value of a location:<br/>" +
                                    to_source_code(this.when_stopped) +
                                    "<br/>but 'when_stopped' can no longer be a location.<br/>" +
                                    'It must be: "stop", or a valid do_list item like a function.');
              this.set_up_next_do(0);
          }
          else {
              this.stop_for_reason("errored",
                  "You have a job when_stopped value of:<br/>" +
                  to_source_code(this.when_stopped) +
                  "<br/>that is invalid<br/>" +
                  'It must be: "stop", or a valid do_list item like a function.');
              this.set_up_next_do(0);
          }
    }
};

Job$1.go_button_state = true;

Job$1.set_go_button_state = function(bool){
    pause_id.checked = !bool;
    Job$1.go_button_state = bool;
};

Job$1.go = function(){
    //if(window.dui2 && dui2.instances.length > 0) { dui2.go_button_click_action()}
    if (Job$1.go_button_state){
        let any_active_jobs = false;
        for(let a_job of Job$1.all_jobs()){
            if (a_job.is_active()){
                any_active_jobs = true;
                if (a_job.go_state) ; //user hit go button with go_button_state true  and a_job go true. let it run
                    //a_job.set_up_next_do(a_job.pause_next_program_counter_increment, false)
                else { //go_button state is true but a_job go_state is false so turn it on an run
                    a_job.go_state = true;
                    a_job.set_up_next_do(a_job.pause_next_program_counter_increment, false);
                }
            }
        }
        if (!any_active_jobs) { warning("There are no active jobs.", true); }
    }
    else { //go_button_state is false
        let any_active_jobs = false;
        for(let a_job of Job$1.all_jobs()){
            if (a_job.is_active()){
                any_active_jobs = true;
            //if (a_job.go_state) {
                a_job.set_up_next_do(a_job.pause_next_program_counter_increment, true); //allow once
            //}
            //else {} //go_button_state is false and a_job go is false, already paused,  do nothing
            }
        }
        if (!any_active_jobs) { warning("There are no active jobs.", true); }
    }
    return "dont_print"
};

//in EVERY call, as of mar 7, 2016 the arg is 1. So probably should just get rid of the arg.
//nope: we need it to be 0 when we have a fn that is "looping" checking for some
//condition to be true, in which case it moves on to increment by 1, like "sleep" or something.
//this is important because send_to_job  might do insert of its instruction "after_pc"
//and we want that to be in a "good" spot, such that the inserted insetruction
//will run next. So we want to keep the incrementing of the PC to be
//in the setTimeout so that when we do a insert "after_pc",
//that inserted instruction is run next.
Job$1.prototype.set_up_next_do = function(program_counter_increment = 1, allow_once=false){ //this was removed as it is never called in DDE, inter_do_item_dur=this.inter_do_item_dur){ //usual arg is 1 but a few control instructions that want to take a breath call it with 0
    //out("set_up_next_do with job: " + this.name)
    var job_instance = this;
    if (this.status_code == "suspended") { return } //don't call do_next_item
    else if (Job$1.go_button_state || allow_once){ //Job.go_button_state being true is the normal case
        if ((this.status_code == "errored") || (this.status_code == "interrupted")){
            program_counter_increment = 0; //don't increment because we want pc and highest_completed_instruction_id
                                          // to be the instruction that errored when the job finishes.
        }
        if ((program_counter_increment > 0) && //if this is 0, it means we haven't completed its associated (PC) instr yet.
                                               //if this is < 0, we're backing up so don't change highest_completed_instruction_id
            (job_instance.program_counter > job_instance.highest_completed_instruction_id) && //if these were the same, setting highest_completed_instruction_id would just bre to its same value
            (job_instance.program_counter < job_instance.do_list.length))   //NEW mar 23, 2019: in case pc goes off the end, we don't want to set highest_completed_instruction_id off the end
            {
            job_instance.highest_completed_instruction_id = job_instance.program_counter;
        }
        if(this.modify_program_counter_increment_fn) { //needs to be after we've set highest_completed_instruction_id for the prev instruction
            program_counter_increment = this.modify_program_counter_increment_fn.call(null, this, program_counter_increment);
            //but be wary. What is the actual subject in the modify_program_counter_increment_fn call???
            //if the method we want is something like someClass.some_meth, can we get someClass to be
            //the "this" of the call?
            if (program_counter_increment === null) { return } //don't keep running these instructions.
                //we're not stopping the job, just effectively suspending it.
            else if (typeof(program_counter_increment) != "number") {
                dde_error("in Job.set_up_next_do,<br/>" +
                    this.modify_program_counter_increment_fn + "<br/> returned: " + program_counter_increment +
                    "<br/>which is invalid because it isn't a number and it isn't null.");
            }
        }
        job_instance.program_counter += program_counter_increment;
        let job_inter_do_item_dur = this.inter_do_item_dur;
        let processed_inter_do_item_dur = job_inter_do_item_dur;
        if(job_instance.do_list.length > job_instance.program_counter){ //there are more instructions
            let next_item = job_instance.do_list[job_instance.program_counter];
            if(Instruction$1.is_oplet_array(next_item, "S") ||
                (typeof(next_item) == "function") ||
               Control.is_control_instruction(next_item)) {
                processed_inter_do_item_dur = 0;
            }
        }
        //in order from fastests and most dangerous to slowest and most safe.
        if(job_inter_do_item_dur === -3){
            return job_instance.do_next_item()
        }
        else if(job_inter_do_item_dur === -2){
            return browserRaw(function() {
                job_instance.do_next_item();
            })
        }
        else if(job_inter_do_item_dur === -1){
            return browserAsap(function() {
                job_instance.do_next_item();
            })
        }
        else {
            setTimeout(function(){
                            job_instance.do_next_item();
                        },
                       processed_inter_do_item_dur * 1000); //convert from seconds to milliseconds
        }
    }
    else { //the stepper output
        job_instance.pause_next_program_counter_increment = program_counter_increment;
        job_instance.go_state = false;
        let suffix = "";
        if          (job_instance.program_counter == -1) { suffix = " (initing robot status)"; }
        else if     (job_instance.program_counter == 0)  { suffix = " (your first instruction)"; }
        else if     (job_instance.program_counter == job_instance.do_list.length - 1) { suffix = " (last instruction)"; }
        else if     (job_instance.program_counter == job_instance.do_list.length - 2) { suffix = " (2nd to last instruction)"; }
        let out_text = job_instance.name + " paused after program_counter=" + job_instance.program_counter + " of " +
                       job_instance.do_list.length + suffix + "<br/>";
        if(job_instance.program_counter >= 0) {
           let instr = this.do_list[job_instance.program_counter];
           if(instr) { //this may be undefined if using dui2 and you check the pause_id checkbox
                out_text +=  "Prev ins: " + Instruction$1.text_for_do_list_item_for_stepper(instr);
           }
        }
        else { out_text +=  "Prev ins: None"; }
        out_text += "<br/> Next ins: ";
        if ((job_instance.program_counter + 1) >= job_instance.do_list.length){
            out_text +=  "None";
        }
        else {
            out_text +=  Instruction$1.text_for_do_list_item_for_stepper(this.do_list[job_instance.program_counter + 1]);
        }
        out(out_text, "brown", true);
    }
};

//run the instruction at the pc. The pc has been adjusted by set_up_next_do to normally increment the pc.
//with a bunch of exceptions for determining that the job is over at the top of this method.
Job$1.prototype.do_next_item = function(){ //user calls this when they want the job to start, then this fn calls itself (via set_up_next_do until done
    //this.program_counter += 1 now done in set_up_next_do
    //if (this.show_instructions){ onsole.log("Top of do_next_item in job: " + this.name + " with PC: " + this.program_counter)}
    //onsole.log("top of do_next_item with pc: " + this.program_counter)
    //out(this.name + " do_next_item top ")
    if(window["js_debugger_checkbox_id"] && js_debugger_checkbox_id.checked) {
        //the print help statements are here so that they get called both when
        //the user checks the checkbox, AND when Control.debugger instruction is run.
        out("To stop debugging, Eval: <code>undebug_job()</code> in Dev Tools console and click the big blue arrow.");
        debugger; //LEAVE THIS IN RELEASED CODE
        console.log("To stop debugging, Eval:   undebug_job()   and click the big blue arrow, ");
    }
    let ending_pc = this.instruction_location_to_id(this.ending_program_counter); //we end BEFORE executing the ending_pcm we don't execute the instr at the ending pc if any

    if (["completed", "errored", "interrupted"].includes(this.status_code)){//put before the wait until instruction_id because interrupted is the user wanting to halt, regardless of pending instructions.
        this.finish_job();
        return
    }
    else if (this.wait_until_instruction_id_has_run || (this.wait_until_instruction_id_has_run === 0)){ //the ordering of this clause is important. Nothing below has to wait for instructions to complete
        //wait for the wait instruction id to be done
        //the waited for instruction coming back thru robot_done_with_instruction will call set_up_next_do(1)
        //so don't do it here. BUT still have this clause to block doing anything below if we're waiting.
        return
    }
    else if (this.stop_reason && (this.status_code !== "running_when_stopped")){ //maybe never hits as one of the above status_codes is pobably set
         this.finish_job();
        return
    } //must be before the below since if we've
    //already got a stop reason, we don't want to keep waiting for another instruction.
    else if (this.wait_until_this_prop_is_false) {
        this.set_up_next_do(0);
        return
    }
    else if (this.instr_and_robot_to_send_when_robot_unbusy) {
        let [inst, robot] = this.instr_and_robot_to_send_when_robot_unbusy;
        if(robot.is_busy()) ; //loop around again
        else {
            this.robot_and_instr_to_send_when_robot_unbusy = null;
            this.send(inst, robot);
        }
        return
    }
    else if (this.hasOwnProperty("insert_last_instruction_index") &&
            (this.when_do_list_done == "wait") &&
            (this.program_counter <= this.insert_last_instruction_index)){
        delete this.insert_last_instruction_index;
        //allow this to fall through to the code after this if...else if
        //unlike all the other clauses
    }

    else if (this.program_counter >= ending_pc) {  //this.do_list.length
             //the normal stop case
        if (this.when_do_list_done == "wait") { //we're in a loop waiting for the next instruction.
            //this.color_job_button() //too expensive and unnecessary as color set elsewhere
            if((this.status_code === "waiting") &&
               (this.wait_reason === "more instructions.")) ;
            else {
                this.set_status_code("waiting", "more instructions."); //do not call unnecessarily, wastes processor time in dde and really bad for job engine browser interface
            }
            this.set_up_next_do(0);
        }
        else if (ending_pc < this.do_list.length) { //we're ending in the middle of the ob. Don't do the final g cmd, as too confusing
            let stop_reason = "Stopped early due to ending_program_counter of: " + this.ending_program_counter;
            this.stop_for_reason("completed", stop_reason);
            this.finish_job();
        }
        /* adds final "g" instruction but this is superfluous.
          else if ((this.robot instanceof Dexter) &&
            ((this.do_list.length == 0) ||
            (last(this.do_list)[Dexter.INSTRUCTION_TYPE] != "g"))){
            //this.program_counter = this.do_list.length //probably already true, but just to make sure.
            //this.do_list.splice(this.program_counter, 0, Dexter.get_robot_status()) //this final instruction naturally flushes dexter'is instruction queue so that the job will stay alive until the last insetruction is done.
                //this.added_items_count(this.program_counter, 0, 0)
            //this.added_items_count.splice(this.program_counter, 0, 0)

            this.insert_single_instruction(Dexter.get_robot_status(), false, true) //2nd arg false says making this new instruction a top level (not sub) instruction
            //3rd arg true says even if we're running a MakeInstruction job and disallowing insertions,
            //allow the insertion anyway.
            //this.added_items_count[this.program_counter] += 1 //hmm, the final g instr isn't reallyy "nested" under the last item, just a top level expr
                //but its not an orig top level one either. so maybe nest it.
                //jun 9, 2018: No consider the new g a top level cmd with 0 subinstructions
            this.set_up_next_do(0)
        }*/
        else if (!this.stop_reason){
            let reason = "Finished all " + this.do_list.length + " do_list items.";
            this.stop_for_reason("completed", reason);
            this.finish_job();
        }
        else { this.finish_job(); }
        return
    }
    //body of the fn.
    //regardless of whether we're in an iter or not, do the item at pc. (might or might not
    //have been just inserted by the above).
      if((this.status_code === "waiting") &&
          (this.wait_reason === "more instructions.")){ //we WERE waiting for more instructions, but
            // we must have gotten more because (this.program_counter >= ending_pc)
            //is not true (from "else if" above). So while we have more, set status to running
          this.set_status_code("running");
      }
      let cur_do_item = this.current_instruction();
      try {
        //out(this.name + " do_next_item cur_do_item: " + cur_do_item)
        this.show_progress_maybe();
        this.select_instruction_maybe(cur_do_item);
        if (this.program_counter >= this.added_items_count.length) { this.added_items_count.push(0);} //might be overwritten further down in this method
        else if (this.added_items_count[this.program_counter] > 0) { //will only happen if we go_to backwards,
           //in which case we *might* call an instruction twice that makes some items that it adds to the to_do list.
           //so we want to get rid of those items and "start over" with that instruction.
            this.remove_sub_instructions_from_do_list(this.program_counter);
        }

        if (Instruction$1.is_no_op_instruction(cur_do_item)){ //nothing to do, just skip it.
            this.set_up_next_do(1);
        }
        else if ((this.sent_from_job_instruction_queue.length > 0) &&
                 this.is_top_level_do_item(cur_do_item)){
            //bad, inserts after pc not AT pc this.insert_instructions(this.sent_from_job_instruction_queue) //all items on queue are next_top_level, so just insert them all.
            this.do_list.splice(this.program_counter, 0, ...this.sent_from_job_instruction_queue);
            let added_items_for_insert = new Array(this.sent_from_job_instruction_queue.length);
            added_items_for_insert.fill(0);
            this.added_items_count.splice(this.program_counter, 0, ...added_items_for_insert);


            //note we're inserting sent_from_job instructions, not the REAL instruction we want to execute.
            //that's because in the hierarchical do_list display, we want to see where those REAL instructions came from for debugging purposes.
            this.sent_from_job_instruction_queue = [];

            let is_top_array = new Array(this.sent_from_job_instruction_queue.length);
            is_top_array.fill(true);
            this.is_do_list_item_top_level_array.splice(this.program_counter, 0, ...is_top_array);
            this.set_up_next_do(0);
        }
        else if (typeof(cur_do_item) === "string"){
            //out("<i>Job." + this.name + ", Instruction " + this.program_counter + ":</i> " + cur_do_item)
            this.send(cur_do_item);
        }
        else if (cur_do_item instanceof Instruction$1.loop){
            let ins = cur_do_item.get_instructions_for_one_iteration(this);
            if (ins === null) { } //done with loop
            else {
                let flatarr = Job$1.flatten_do_list_array(ins);
                this.insert_instructions(flatarr);
            }
            this.set_up_next_do(1);
        }
        else if (cur_do_item instanceof Instruction$1){
            cur_do_item.do_item(this);
        }
        else if (Instruction$1.is_oplet_array(cur_do_item)){
            this.wait_until_instruction_id_has_run = this.program_counter;
            this.send(cur_do_item);
        }
        else if (Instruction$1.is_data_array(cur_do_item)){
            let new_do_item = this.transform_data_array(cur_do_item);
            if(Instruction$1.is_no_op_instruction(new_do_item)) { this.set_up_next_do(1); }
            else if(Instruction$1.is_sendable_instruction(new_do_item)){
                this.wait_until_instruction_id_has_run = this.program_counter;
                this.send(new_do_item); //we know we have a sendable, so send it.
            }
            else if(Instruction$1.is_data_array(new_do_item)){
                    this.stop_for_reason("errored", "The instruction: " + cur_do_item +
                    "<br/>resolved to: " + new_do_item +
                    "<br/>which is a data_array but we've already performed data_array transformation." +
                    "<br/>Fix Job." + this.name + ".data_array_transformer" +
                    "<br/>to not return another data_array or" +
                    "<br/>change: " + JSON.stringify(cur_do_item));
                    this.set_up_next_do(0);
            }
            else if(Instruction$1.is_do_list_item(new_do_item)){
                    this.insert_single_instruction(new_do_item);
                    this.set_up_next_do(1);
            }
        }
        else if (Array.isArray(cur_do_item)){
            this.handle_function_call_or_gen_next_result(cur_do_item, cur_do_item);
            //note that a user normally wouldn't directly put an array on the do_list,
            //but Job.insert_instruction very likely would to put > 1 instruction on
        }
        else if (is_iterator(cur_do_item)){ //generator. must be before "function" because an iterator is also of type "function".
            var next_obj = cur_do_item.next();
            var do_items = next_obj.value;
            let have_item_to_insert;
            if      (do_items === null)       { have_item_to_insert = false; }
            else if (do_items === undefined)  { have_item_to_insert = false; }
            else if (Array.isArray(do_items) && (do_items.length == 0)) { have_item_to_insert = false; }
            else have_item_to_insert = true;

            if (have_item_to_insert) {
                if (next_obj.done){ //run the one last instruction from this gen
                    this.insert_single_instruction(do_items);
                    this.set_up_next_do(1);
                }
                else  { //not done so we must insert the cur_do_item
                    if (Instruction$1.is_oplet_array(do_items) || !Array.isArray(do_items)) {
                       do_items = [do_items, cur_do_item]; }
                    else  { //do_items is already an array
                        do_items = do_items.slice(0); //copy the do_items just in case user is hanging on to that array, we don't want to mung it.
                        do_items.push(cur_do_item);
                    }
                    this.insert_instructions(do_items);
                    this.set_up_next_do(1);

                }
            }
            else { //no items to insert
                if (next_obj.done){ this.set_up_next_do(1); } //done with this generator
                else              { this.set_up_next_do(0); } //keep generator alive
            }
        }
        else if (typeof(cur_do_item) == "function"){
            //try{
                var do_items = cur_do_item.call(this); //the fn is called with "this" of this job
                //onsole.log("do_next_item with function that returned: " + do_items)
                this.handle_function_call_or_gen_next_result(cur_do_item, do_items); //take the result of the fn call and put it on the do_list
            //}
           // catch(err){
            //    warning("Job " + this.name + " errored executing instruction with id: " + this.program_counter + "<br/>" +
            //             cur_do_item.toString() + "<br/>" +
            //             err.message)
            //    this.stop_for_reason("errored", "Calling function at instruction id: " + this.program_counter + " errored.")
            //    this.set_up_next_do(1)
            // }
        }
        else if (Instruction$1.is_start_object(cur_do_item)){
            this.handle_start_object(cur_do_item);
        }
        else {
            this.stop_for_reason("errored", "Job: " + this.name + " got illegal do_item on do_list of: " +
                                            stringify_value(cur_do_item));
            //It's over, Jim, So don't take a breath, by calling set_up_next_do(0),
            //just kill it quickly before anything else can happen.
            //we don't want to increment the pc,
            this.set_up_next_do(0);
        }
    }
    catch(err){ //this can happen when, for instance a fn def on the do_list is called and it contains an unbound var ref
       //this.stop_for_reason("errored", err.message) //let do_next_item loop around and stop normally
       //this.set_up_next_do(0)
        warning("Error running instruction: " + this.program_counter +
            " with source: " + to_source_code({value: cur_do_item}) +
            " in Job." + this.name +
            " of:<br/>" + err.message);
        if(this.if_instruction_error){ //this will hut unless Job author explcitly set if_instruction_error to null or undefined.
            //note if_instruction_error can be a single instruction or an array
            //of instructions. If its an array, we insert it as just one instruction,
            //and that will cause all to be run.
            //it has a default that prints out a message.
            this.insert_single_instruction(this.if_instruction_error);
        }
        this.set_up_next_do();
    }
};

///also called by Make Instruction for creating string to save.
Job$1.prototype.transform_data_array = function(data_array){
        let transformer = this.data_array_transformer;
        if(transformer === undefined) {  //this meth may be called after the job_innstance is defined,
                                         //but before start is called, so it wouldn't have this
                                         //copied over to the instance yet.
            transformer = this.orig_args.data_array_transformer;
        }
        if(Robot$1.is_oplet(transformer)) { //ie "P"
            let args = data_array.slice(); //make a copy of the data array
            args.unshift(transformer);  //push the oplet on the front of the array
            return make_ins$1.apply(null, args)  //do the "tranformation" to make a oplet_array
            //this.wait_until_instruction_id_has_run = this.program_counter
            //this.send(new_do_item) //we know we have a sendable, so send it.
        }
        else {
            return transformer.apply(this, data_array)
        }
};



/*cur_do_item is the fn, do_items is the val returned from calling it.
 cur_do_item merely for error message. the real item to do is do_items which might be an array of items

 A do_list function on the do_list can return:
 - an instruction_array (1 letter op_let)  stick it on the do_list and send it.
 - an array of items to stick on the do_list.
 - another function. stick it on the do_list and next time call it.\
 - a generator function
 - an iterator 
 Stick them all (except for iterator) on the do_list and execute them.
 */
Job$1.prototype.handle_function_call_or_gen_next_result = function(cur_do_item, do_items){
    if (do_items == "dont_call_set_up_next_do");
    else if (Instruction$1.is_no_op_instruction(do_items)){ //ok, just nothing to insert
        this.set_up_next_do(1);
    }
    else if (Array.isArray(do_items)){
        if(Instruction$1.is_oplet_array(do_items) ||
           Instruction$1.is_data_array(do_items)){
           this.insert_single_instruction(do_items);
           this.set_up_next_do(1);
        }
        else { //must be an instructions_array
            Job$1.flatten_do_list_array(do_items);
            this.insert_instructions(do_items);
            this.set_up_next_do(1);
        }
    }
    else if (Instruction$1.is_do_list_item(do_items)){
        this.insert_single_instruction(do_items);
        this.set_up_next_do(1);
    }
    else {
        this.stop_for_reason("errored", "do_item function: " + stringify_value(cur_do_item) +
            " returned invalid value: "     + stringify_value(do_items));
        //its over. Don't take a breath with set_up_next_do, kill it off.
        //don't increment pc
        this.do_next_item();
    }
};

//cur_do_item guarenteed to have a start method when this fn is called.
Job$1.prototype.handle_start_object = function(cur_do_item){
        //the below gets around having to require("test_suite.js") because that would
        //violate what the job_engine code has access too, but still allows
        //including a test suite instance in a job that is run in DDE.
        if(cur_do_item.constructor && (cur_do_item.constructor.name == "TestSuite")){
            cur_do_item.constructor.set_state_and_resume({suites: [cur_do_item]});
        }
        else {
            let user_data_variable = cur_do_item.user_data_variable;
            let job_instance = this;
            let the_inst_this = cur_do_item.start_this;
            if (!the_inst_this) { the_inst_this = cur_do_item; }
            else if (the_inst_this == "job_instance") { the_inst_this = job_instance; }
            let start_args = cur_do_item.start_args;
            let cb_param = cur_do_item.callback_param;
            if(cb_param) {
                job_instance.wait_until_this_prop_is_false = "waiting for start object callback to run";
                let cb_fn = function(...args) {
                    if (user_data_variable){
                        job_instance.user_data[user_data_variable] =  args;
                    }
                    job_instance.wait_until_this_prop_is_false = false;
                };
                if(typeof(cb_param) === "number") { //must be a non-neg int
                    if ((start_args === undefined) || (start_args === null)) {start_args = [];}
                    if (Array.isArray(start_args)) {
                         start_args = start_args.slice(); //copy
                         start_args[cb_param] = cb_fn;
                    }
                    else { dde_error("For Job: " + job_instance.name +
                        " pc: " +  job_instance.program_counter +
                        "<br/>got data structure instruction: " + cur_do_item +
                        "<br/> which has a cb_param of a number but the start_args " +
                        "is not an array.");
                    }
                }
                else if (typeof(cb_param) === "string") {
                    if ((start_args === undefined) || (start_args === null)) { start_args = {}; }
                    if (typeof(start_args) == "object") {
                       start_args =  jQuery.extend({}, start_args); //shallow copy
                       start_args[cb_param] = cb_fn;
                    }
                    else {
                       dde_error("For Job: " + job_instance.name +
                                " pc: " +  job_instance.program_counter +
                                "<br/>got data structure instruction: " + cur_do_item +
                                '<br/> which has a cb_param of a string, "' + cb_param + '", but the start_args ' +
                                "is not an object.");
                    }
                }
            }
            else if(cur_do_item.dur) {
                this.insert_single_instruction(Control.wait_until(cur_do_item.dur));
            }
            if (!start_args)                    { cur_do_item.start.apply(the_inst_this); }
            else if (Array.isArray(start_args)) { cur_do_item.start.apply(the_inst_this, start_args); }
            else                                { cur_do_item.start.call(the_inst_this, start_args); }
        }
        this.set_up_next_do(1);
};

//only ever passed an instrution_array or a "raw" string to send directly to dexter.
//if a raw string, it starts with the oplet and has to have
//the prefix added to it.
Job$1.prototype.send = function(oplet_array_or_string, robot){ //if remember is false, its a heartbeat
    if(typeof(oplet_array_or_string) == "string") {
        //a string can't contain the robot so just use what is passed in to SEND, or the job's robot.
        if(!robot) { robot = this.robot; } //use the job's default robot
    }
    else { //oplet_array_or_string is an oplet_array
        //if there's both a passed in robot, and one in the oplet_array, prefer
        //the one in the oplet array
        let last_elt = last(oplet_array_or_string);
        if (last_elt instanceof Robot$1) {
            robot = last_elt;
            oplet_array_or_string = oplet_array_or_string.slice(0, oplet_array_or_string.length - 1); //don't use "pop" because
            //we need the orig do list item that contains the robot  because
            //Socket.find_dexter_instance_from_robot_status needs it. So make a COPY of the array,
            //removing that last elt of a robot, as the socket code doesn't want a robot on the end of the array.
        }
        else if (!robot)                                  { robot = this.robot; } //use the job's default robot
    }
    if(robot instanceof Dexter$1){
        if (robot.is_busy()){
        //    this.instr_and_robot_to_send_when_robot_unbusy = [oplet_array_or_string, robot]
        //    return
        //}
         robot.add_to_busy_job_array(this); //the only place this is called (err besides 5 lines below)
         return //we're not sending the instruction, leave the PC on the current instruction
               //Dexter.prototype.robot_done_with_instruction will call set_up to execute it.
        }
        else {
           robot.add_to_busy_job_array(this);  //keep sending this one inst to the dexter.
        }
    }
    let instruction_id;
    const oplet = Instruction$1.extract_instruction_type(oplet_array_or_string);
    if(oplet == "h") { //op_let is first elt UNTIL we stick in the instruction id
        //instruction_id = -1 //heartbeat always has instruction id of -1
        shouldnt$1('Job.send passed "h" instruction (heartbeat) but that shouldnt happen as heartbeat is handled lower level by Dexter robot');
    }
    else if (this.status_code == "not_started"){ //instuction_array should be a Job.get_robot_status
        instruction_id = -3; //looked at by robot_done_with_instruction
    }
    else if (this.status_code == "starting"){ //instuction_array should be a Job.get_robot_status
        instruction_id = -1; //looked at by robot_done_with_instruction
    }
    else {
        instruction_id = this.program_counter;
    }
    if(typeof(oplet_array_or_string) == "string") {
        let prefix = this.job_id + " " + instruction_id + " " + Date.now() + " undefined ";
        oplet_array_or_string = prefix + oplet_array_or_string;
        if(last(oplet_array_or_string) != ";") { oplet_array_or_string += ";"; }

    }
    else {
        oplet_array_or_string[Instruction$1.JOB_ID]         = this.job_id;
        oplet_array_or_string[Instruction$1.INSTRUCTION_ID] = instruction_id;
        oplet_array_or_string[Instruction$1.START_TIME]     = Date.now();
    }

    if (this.keep_history){
        this.sent_instructions.push(oplet_array_or_string); //for debugging mainly
    }
    if(oplet === "z"){
        this.color_job_button(); //colors job button yellow, even though status is "running" because
        //cur instruction is "z"
    }
    //if(oplet === "a") { out("snd J2: " + oplet_array_or_string[6]) } //debugging statement only
    if(robot instanceof Dexter$1){
        this.wait_until_instruction_id_has_run = instruction_id;
    }
    robot.send(oplet_array_or_string);
};

//"this" is the from_job
// params is the instance of Instruction.send_to_job
//send_to_job_receive_done is kinda like Serial and Dexter.robot_done_with_instruction
//but used only with send_to_job and only when the from_job is waiting for the
//to_job to complete the ins it was sent before allowing the from_job to continue.
Job$1.prototype.send_to_job_receive_done = function(params){
    if (this.wait_until_instruction_id_has_run === params.from_instruction_id){
        this.highest_completed_instruction_id  = params.from_instruction_id;
        this.wait_until_instruction_id_has_run = null;
        //below is done in Instruction.destination_send_to_job_is_done.do_item
        //for (var user_var in params){
        //    if (Instruction.send_to_job.param_names.indexOf(user_var) == -1){
        //        var val = params[user_var]
        //        this.user_data[user_var] = val
        //    }
        //}
        this.user_data[params.status_variable_name] = "done";
        this.set_up_next_do(1);
    }
    else {
        shouldnt$1("In job: " + this.name + " send_to_job_receive_done got params.from_instruction_id of: " +
            params.from_instruction_id +
            " but wait_until_instruction_id_has_run is: " + this.wait_until_instruction_id_has_run);
    }
};



//used in go_to, wait_until at least.
Job$1.instruction_location_to_job = function (instruction_location, maybe_error=true){
    var the_job_elt = instruction_location;
    if (Array.isArray(instruction_location)){
        if (instruction_location.length === 0){
            if (maybe_error) {
                dde_error("Job.instruction_location_to_job passed empty array.<br/>" +
                          " It must have at least 1 item in it,<br/>" +
                          'with the first of format: {job: "some_job"}');
            }
            else {return null}
        }
        else { the_job_elt = instruction_location[0]; }
    }
    if (the_job_elt){
        if (the_job_elt.job) {
            let the_job = the_job_elt.job;
            if (typeof(the_job) == "string"){
                const the_job_name = the_job;
                the_job = Job$1[the_job];
                if (!the_job) {
                    if (maybe_error) {
                        dde_error("Attempt to find instruction_location: " + instruction_location +
                        "<br/>but the specified job: " + the_job_name +
                        "<br/>isn't a defined job.");
                    }
                    else { //if we get a string, but that's not a defined job, that's kinda suspicious, so I warning
                      warning("instruction_location_to_job passed: " + instruction_location +
                              "<br/>which contains a name for a job: " + the_job_name +
                              "<br/>but a job with that name is not defined.");
                      return null
                    }
                }
            }
            return the_job
        }
        else {
            if (maybe_error) {
                dde_error("Job.instruction_location passed " + instruction_location +
                          '<br/> which does not have an element of format: {job:"some_job"}');
            }
            else { return null }
        }
    }
    else {
        if (maybe_error) {
            dde_error("Job.instruction_location passed a location: " + instruction_location +
                      "<br/> that doesn't have a job in it.");
        }
        else { return null }
    }
};
//instruction_location can be 5, {offset: 5}, [{offset: 5}}, {job: "myjob", offset:5}
// [{job:myjob}, {offset:5}], then throw in process attribute.
//getting a job makes it hold for the rest of the il, any there should be at most
//one job and it should be in the first element.
//offset and process DON'T carry forward to become defaults for later array elts.
//if the first offset is negative, it is added to the job's do_list length to
//get the resulting instruction id.
Job$1.prototype.instruction_location_to_id = function(instruction_location, starting_id=null, orig_instruction_location=null, use_orig_do_list=false){
    let job_instance = this;
    let do_list_length = (use_orig_do_list ?
                            job_instance.orig_args.do_list.length :
                            job_instance.do_list.length);
    if (orig_instruction_location == null) { orig_instruction_location = instruction_location;} //used for error messages
    let inst_loc = instruction_location;
    let process = "forward_then_backward"; //process ignored for integer inst_loc's.
    if ((typeof(inst_loc) == "object") && !Array.isArray(inst_loc)){
        if (instruction_location.job) {
            job_instance = instruction_location.job;
            if (typeof(job_instance) == "string") { job_instance = Job$1[job_instance]; }
            if (!(job_instance instanceof Job$1)) {
                dde_error("instruction_location_to_id passed: " +  orig_instruction_location +
                          "<br/> passed an invalid job of: " + job_instance);
            }
        }
        //an object might have just a job, just an offset, or both
        if(instruction_location.offset || (instruction_location.offset === 0)) {
            inst_loc = instruction_location.offset;
            if (instruction_location.process) {
                process = instruction_location.process;
            }
        }
        else {
            dde_error("In instruction_location_to_id, got an object: " + instruction_location +
                      "<br/>that did not have an offset field,<br/>" +
                      "in the original_instruction_location: " + orig_instruction_location);
        }
    }
    if (Number.isInteger(inst_loc)){
        if (starting_id == null){
            if (inst_loc >= 0) { starting_id = 0; }
            else { starting_id = do_list_length; } // an initial negative inst_loc means count from the end, with -1 pointin at the last instruction
        }
        let result = starting_id + inst_loc;
        if ((result < 0) || (result > do_list_length)){
              dde_error("instruction_location_to_id passed: " + instruction_location +
                        "<br/>but that finds an instruction outside the range of<br/>" +
                        " valid ids: 0 through " + do_list_length +
                        "<br/>in the original_instruction_location: " + orig_instruction_location);

        }
        else { return result }
    }
    else if (typeof(inst_loc) == "string"){
        if      (inst_loc == "program_counter")        { return job_instance.program_counter }
        else if (inst_loc == "before_program_counter") { return job_instance.program_counter - 1 }
        else if (inst_loc == "after_program_counter")  { return job_instance.program_counter + 1 }
        else if (inst_loc == "end")                    { return do_list_length } //bad for go_to but ok for insert instruction, ie a new last instruction
        else if (inst_loc == "next_top_level")         { return "next_top_level" } //used only by insert_instruction
        else if (inst_loc == "highest_completed_instruction") {
            const hci = job_instance.highest_completed_instruction_id;
            if(!hci || (hci <= 0)) { return 0 }
            else { return hci }
        }
        else if (inst_loc == "highest_completed_instruction_or_zero") {
            const hci = job_instance.highest_completed_instruction_id;
            if(!hci || (hci <= 0) || (hci >= (do_list_length - 1)))  { return 0 }
             //for the last cause above: if we completed the job the last time through, then start over again at zero
            else { return hci } //else we are resuming at
              //the highest completed instruction. But beware, you *might* not want
              //to do that instruction twice, in which case the instruction_location should be
              // ["zero_or_highest_completed_instruction", 1]
        }
        else { // a label or a sync_point name search pc, then after, then before pc
           if (starting_id == null) { starting_id = this.program_counter; }
           if      (process == "forward_then_backward") { return job_instance.ilti_forward_then_backward(inst_loc, starting_id, orig_instruction_location, use_orig_do_list) }
           else if (process == "backward_then_forward") { return job_instance.ilti_backward_then_forward(inst_loc, starting_id, orig_instruction_location, use_orig_do_list) }
           else if (process == "forward")               { return job_instance.ilti_forward( inst_loc, starting_id, orig_instruction_location, use_orig_do_list) }
           else if (process == "backward")              { return job_instance.ilti_backward(inst_loc, starting_id, orig_instruction_location, use_orig_do_list) }
           else {
               dde_error("instruction_location_to_id passed process: " + process +
                   "<br/>but the only valid processes are:<br/>" +
                   '"forward_then_backward", "backward_the_forward", "forward", "backward".' +
                   "<br/>in the original_instruction_location: " + orig_instruction_location);
           }
        }
    }
    else if (Array.isArray(inst_loc)){
        let result = starting_id; //will be null on first call
        for(let item of inst_loc){
            if (item.job){
                if(result == null){ //we're on the first elt of the array. so ok for it to have a job
                    job_instance = item.job;
                    if (typeof(job_instance) == "string") {
                        job_instance = Job$1[job_instance];
                        if (!job_instance) { dde_error("In instruction_location_to_id got undefined job name: " + job_inst);}
                    }
                }
                else {
                    dde_error("In instruction_location_to_id got a non-first item<br/>" +
                             " that has job in it, which is invalid. That invalid job is: " + item.job +
                             "<br/>in the original_instruction_location: " + orig_instruction_location);
                }
            }
            result = job_instance.instruction_location_to_id(item, result, orig_instruction_location, use_orig_do_list);
        }
        return result
    }
    else {dde_error("Job." + this.name + " doesn't contain a location named: " + inst_loc +
                    " in the original_instruction_location: " + orig_instruction_location);}
};

Job$1.prototype.ilti_forward_then_backward = function(inst_loc, starting_id, orig_instruction_location, use_orig_do_list=false){
    let the_do_list = (use_orig_do_list ? this.orig_args.do_list : this.do_list);
    for(let id = starting_id; id < the_do_list.length; id++){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //gets label, sync_point and fn name
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    for(let id = starting_id - 1; id >= 0; id--){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //finds both label and sync_point instructions with "name" of inst_loc
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    dde_error("Job." + this.name + " doesn't contain a location named: " + inst_loc +
        "<br/>in the original_instruction_location: " + orig_instruction_location);
};

Job$1.prototype.ilti_backward_then_forward = function(inst_loc, starting_id, use_orig_do_list=false){
    let the_do_list = (use_orig_do_list ? this.orig_args.do_list : this.do_list);
    for(let id = starting_id - 1; id >= 0; id--){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //finds both label and sync_point instructions with "name" of inst_loc
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    for(let id = starting_id; id < the_do_list.length; id++){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //gets label, sync_point and fn name
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    dde_error("Job." + this.name + " doesn't contain a location named: " + inst_loc +
        "<br/>in the original_instruction_location: " + orig_instruction_location);
};

Job$1.prototype.ilti_forward = function(inst_loc, starting_id, use_orig_do_list=false){
    let the_do_list = (use_orig_do_list ? this.orig_args.do_list : this.do_list);
    for(let id = starting_id; id < this.do_list.length; id++){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //gets label, sync_point and fn name
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    dde_error("Job." + this.name + " doesn't contain a location named: " + inst_loc +
        "<br/>in the original_instruction_location: " + orig_instruction_location);
};

Job$1.prototype.ilti_backward = function(inst_loc, starting_id, use_orig_do_list=false){
    let the_do_list = (use_orig_do_list ? this.orig_args.do_list : this.do_list);
    for(let id = starting_id - 1; id >= 0; id--){
        let ins = the_do_list[id];
        if (ins.name === inst_loc) {return id} //finds both label and sync_point instructions with "name" of inst_loc
        else if (ins instanceof Instruction$1){
            if (ins.constructor.name === inst_loc) { return id }
        }
        else if (Instruction$1.is_oplet_array(ins)){
            if (ins[Instruction$1.INSTRUCTION_TYPE] ===  inst_loc) { return id }
        }
    }
    dde_error("Job." + this.name + " doesn't contain a location named: " + inst_loc +
              "<br/>in the original_instruction_location: " + orig_instruction_location);
};

//functions for managing adding and removal from do_list
// (and keeping added_items_count in sync).
//see also Job.insert_instruction and Job.prototype.do_list_to_html_aux

//called by Job.start
Job$1.prototype.init_do_list = function(){
    this.do_list           = Job$1.flatten_do_list_array(this.do_list); //make a copy in case the user passes in an array that they will use elsewhere, which we wouldn't want to mung
    for(let instr of this.do_list) {
        if (instr instanceof Instruction$1) {
            instr.init_instruction();   //needed for wait_until and loop at least
        }
    }
    this.added_items_count = new Array(this.do_list.length); //This array parallels and should be the same length as the run items on the do_list.
    this.added_items_count.fill(0); //stores the number of items "added" by each do_list item beneath it
    //if the initial pc is > 0, we need to have a place holder for all the instructions before it
    //see total_sub_instruction_count_aux for explanation of added_items_count
    this.is_do_list_item_top_level_array = new Array(this.do_list.length);
    this.is_do_list_item_top_level_array.fill(true);
};

Job$1.prototype.remove_sub_instructions_from_do_list = function(instr_id){
    if(!this.disable_modify_do_list) {
        const sub_items_count = this.total_sub_instruction_count(instr_id);
        this.do_list.splice(instr_id + 1, sub_items_count); //cut out all the sub-instructions under instr_id
        this.added_items_count.splice(instr_id + 1, sub_items_count);
        this.added_items_count[instr_id] = 0; //because we just deleted all of ites subitems and their descendents
        this.is_do_list_item_top_level_array.splice(instr_id + 1, sub_items_count);
    }
};

Job$1.prototype.total_sub_instruction_count = function(id_of_top_ins){
    return total_sub_instruction_count_aux(id_of_top_ins, this.added_items_count)
};

/*
added_items_count is the way in which the do_list can be considered to be a
hierarchy such that an instruction that adds more instuctions under it,
those new insturctions will be considered sub-instrustions.
This is important for presenting the do_list as a hierarchy
(as the Inspect does, but also necessary to remove previous do_list items
from the do_list when we start an loop iteration or perform a backwards go_to.

added_items_count is an array that is maintained to always be the same
length as the do_list, and contains a non-neg integer for each do_list_item saying
how many sub-instructions the instruction at that array index
has beneath it *when they are first added*
If a subinstruction, when it is run, returns more instructions to
insert the orig instruction sub-instruction count is NOT increased,
its just left alone, but the orig subinstrution's item-count is
incremented by the new sub-sub-instructions added.
This makes computing how many actual instructons are underneath
a given instruction tricky, as it may well be more than its
added_items_count indicates.
(If the added_items_count is 0, it has no sub-instructions but
if it is more than 0, it might be that number or more.)
The job of total_sub_instruction_count_aux is to figure out
total sub)instructions. It walks down the  added_items_count
from the given index until it "runs out" of sub-insructions,
and returns the count. The sub-instructions count excludes the
instruction at the given index. See the test suite for
total_sub_instruction_count_aux for examples.
*/

function total_sub_instruction_count_aux(id_of_top_ins, aic_array){
    let result = 0; //this.added_items_count[id_of_top_ins]
    let tally  = 1; //this.added_items_count[id_of_top_ins]
    for(let i = id_of_top_ins; true ; i++){
        let aic_for_i = aic_array[i]; //this.added_items_count[i]
        if (aic_for_i === undefined) {
            shouldnt$1("total_sub_instruction_count_aux got undefined from aic_array: " + aic_array);
        }
        result += aic_for_i; //often this is adding 0
        tally  += aic_for_i - 1;
        if (tally == 0) { break; }
        else if (tally < 0) { shouldnt$1("in total_sub_instruction_count got a negative tally"); }
    }
    return result
}

//--------top level do_list item_____
Job$1.prototype.top_level_instruction_id_array = null;

//perform whenever do_list item changes, if you care about
//computing top levelness.
// Warning: expensive to compute the first one after decaching.
Job$1.prototype.decache_top_level_instruction_id_array = function(){
    this.top_level_instruction_id_array = null;
};


//shoves into this.top_level_instruction_id_array, an array that is of the job's do_list length
// (not the orig_args.do_list!
//that has values of true or false. true if the instruction at that index is top level,
//ie was not inserted by running the job.
//You might think that the number of elts in top_level_instruction_id_array that are true should be
//the same as orig_args.do_list.length
//But this is not true due to flattening of arrays on the orig do_list during job.start
//and inserting each elt of an array into the do_list at top level.
//See also comment at: Job.prototype.insert_instructions

/*Obslete with new makae as you go Job.prototyp.is_do_list_item_top_level_array
Job.prototype.make_top_level_instruction_id_array = function(){
    let result = []
    let prev_top_level_accum = 0
    for(let i = 0; i < this.do_list.length; i++){
        if(prev_top_level_accum == 0) {
            result.push(true)
            prev_top_level_accum = this.added_items_count[i]
        }
        else {
            result.push(false)
            prev_top_level_accum += this.added_items_count[i]
            prev_top_level_accum -= 1 //subtract one for yourself
        }
    }
    this.top_level_instruction_id_array = result
}*/

Job$1.prototype.is_top_level_do_list_item = function (id) {
   //if(this.top_level_instruction_id_array == null){
   //    this.make_top_level_instruction_id_array()
  // }
  if(this.is_do_list_item_top_level_array) {
    return this.is_do_list_item_top_level_array[id] //this.top_level_instruction_id_array[id]
  }
  else { return true } //because we're working off orig_args.do_list, all of whose items are top level
};

//returns id itself if id is top level, if not, returns an id less than the passed in id.
//works only on the job's do_list, NOT its orig_args.do_list
Job$1.prototype.find_top_level_instruction_id_for_id = function(id){
    //if(this.top_level_instruction_id_array == null){
    //    this.make_top_level_instruction_id_array()
    //}
    for(let i = id; i >= 0; i--){
        if(this.is_top_level_do_list_item(i)) { return i }
    }
    shouldnt$1("Job.find_top_level_instruction_id_for_id couldn't find answer for id: " + id);
};

//returns the index of the next top level instruction after the passed in id.
//If id itself is a top level item, doesn't matter.
//Still finds the top level id AFTER the passed in id.
//If id refers to the last instruction in the do_list, returns null,
// i.e. there is no next top level item.
Job$1.prototype.find_next_top_level_instruction_id_for_id = function(id){
    //if(this.top_level_instruction_id_array == null){
    //    this.make_top_level_instruction_id_array()
    //}
    for(let i = id + 1; i < this.do_list.length; i--){
        if(this.is_top_level_do_list_item(i)) { return i }
    }
    return null //happens when i is the last elt in the do_list
};
//-----end of top level do_list item_____


//These 2 fns take care of inserting into added_items_count array,
//slots for the new items they are inserting
//Both of these fns always insert right after the pc
//force_allow is only true when we are adding the final "g" instruction to a job

//note this DOESN'T insert each new item "below" the pc, and boost the added_items_count
//of the pc by array_of_do_items.length. If we did that,
//it would work, and we'd have the hierarchical modularity that would
//help in debugging. BUT, it would add a round_trip to the do_next_item loop,
//and it means that when we're grabbing the "top level" items for job defs to insert for MakeInstruction,
//we would have reduced granularity in what we capture so the "snipets" grbbed would be
//"lower resolution and not as good.
//See also Job.protptype.make_top_level_instruction_id_array()
Job$1.prototype.insert_instructions = function(array_of_do_items, are_sub_instructions=true){
    if(!this.disable_modify_do_list) {
        this.do_list.splice(this.program_counter + 1, 0, ...array_of_do_items);
        let added_items_to_insert = new Array(array_of_do_items.length);
        added_items_to_insert.fill(0);
        this.added_items_count.splice(this.program_counter + 1, 0, ...added_items_to_insert);
        let is_top_array = new Array(array_of_do_items.length);
        if(are_sub_instructions) {
            this.added_items_count[this.program_counter] += added_items_to_insert.length;
            is_top_array.fill(false);
        }
        else { //top level
            is_top_array.fill(true);
        }
        this.is_do_list_item_top_level_array.splice(this.program_counter + 1, 0, ...is_top_array);
    }
};

//insert instruction right after the pc
Job$1.prototype.insert_single_instruction = function(instruction_array, is_sub_instruction=true, force_allow=false){
    if(force_allow || !this.disable_modify_do_list) {
        this.do_list.splice(this.program_counter + 1, 0, instruction_array);
        this.added_items_count.splice(this.program_counter + 1, 0, 0); //added oct 31, 2017
        if (is_sub_instruction) {
            this.added_items_count[this.program_counter] += 1;
            this.is_do_list_item_top_level_array.splice(this.program_counter + 1, 0, false); //false for is NOT top_level
        }
        else {
            this.is_do_list_item_top_level_array.splice(this.program_counter + 1, 0, true); //true for is_top_level
        }
    }
};

//expect to call when job is when_do_list_done: "wait" and
//the job is running and probably waiting for another instruction.
//we want to replace the LAST instruction that we inserted using this fn,
//and any follow on instructions it generated, with a new instruction.
Job$1.prototype.insert_last_instruction_overwrite = function(instruction, force_allow=false){
    if(this.do_list === undefined) {
        dde_error("Job." + this.name + " is not running,<br/>" +
                  " so calling insert_last_instruction_overwrite doesn't make sense.");
    }
    else if(force_allow || !this.disable_modify_do_list) {
        if(this.program_counter === this.do_list.length) { //hopefully the normal case. We're going to replace that last
            //inst (and its generated kids) with the past in instruction so first
            //delete all the ustrictions from the last instr inserted by insert_last_instruction_overwrite
            //thru all kids generated by it.
            if(this.hasOwnProperty("insert_last_instruction_index")){ //get rid of old instruction from insert_last_instruction_index and higher
                this.do_list.splice(this.insert_last_instruction_index); //delete all elts from the given arg to the end. add none
                this.added_items_count.splice(this.insert_last_instruction_index);
                this.is_do_list_item_top_level_array.splice(this.insert_last_instruction_index);
            }
            this.insert_last_instruction_index = this.do_list.length;
            Job$1.insert_instruction(instruction, {job: this, offset: this.insert_last_instruction_index}, false);
            this.program_counter = this.insert_last_instruction_index;
        }
        else if(this.hasOwnProperty("insert_last_instruction_index")) {//we've had this fn called before and had an instruction,
          //but haven't completed the instructions in the last insertion, so just add them to the end.
            Job$1.insert_instruction(instruction, {job: this, offset: this.do_list.length}, false);
        }
        else {//First time this fn is called, but are still running other instructions in the job
              //so initialize insert_last_instruction_index and add the new instruction
              //to the end of the do_list
            this.insert_last_instruction_index = this.do_list.length;
            Job$1.insert_instruction(instruction, {job: this, offset: this.do_list.length}, false);
        }
    }
};

//rarely called. usually call insert_single_instruction
//is_sub_instruction default of "auto" is the behavior before is_sub_instruction was added as a possibility.
//it can also be true, or false. false is what insert_last_instruction_overwrite uses
//to get the new insruction to be at top level.
Job$1.insert_instruction = function(instruction, location, is_sub_instruction="auto"){
    const job_instance = Job$1.instruction_location_to_job(location);
    if (job_instance){
        if(!job_instance.disable_modify_do_list) {
            const index = job_instance.instruction_location_to_id(location);
            if ((index === "next_top_level") ||
                ["not_started", "completed", "errored", "interrupted"].includes(job_instance.status_code)){
                job_instance.sent_from_job_instruction_queue.push(instruction);
                job_instance.sent_from_job_instruction_location = location;
                    //if a job isn't running, then we stick it on the ins queue so that
                    //the next time is DOES run (ie its restarted), this
                    //inserted instruction will make it in to the do_list.
            }
            else { job_instance.do_list.splice(index, 0, instruction);
                   job_instance.added_items_count.splice(index, 0, 0); //added oct 31, 2017
                   //unlike the instance method cousins of this static method,
                        //this meth must do the added_items_count increment because
                        //the caller of this meth doesn't know the index of the instr to increment
                        //the added_items_count of.
                        //job_instance.added_items_count[this.program_counter] += 1 //isn't right that pc has its added_items count incremented. Maybe should be something else, or no increment at all
                   if(location.offset == "end"){ //always at top level
                       job_instance.is_do_list_item_top_level_array.splice(index, 0, true);
                   }
                   else if (is_sub_instruction === "auto") {
                        let did_increment = job_instance.increment_added_items_count_for_parent_instruction_of(index); //false means we're at top level
                        job_instance.is_do_list_item_top_level_array.splice(index, 0, !did_increment);
                   }
                   else {
                       job_instance.is_do_list_item_top_level_array.splice(index, 0, is_sub_instruction);
                   }
            }
        }
    }
    else {
        dde_error("insert_instruction passed location: " + insert_instruction +
                  " which doesn't specify a job. Location should be an array with" +
                  "a first element of a literal object of {job:'some-job'}");
    }
};

//returns true if it did do an increment, false if it didn't
//it doesn't do an increment only if the item inserted is at top level,
//so returning false means the inserted item is inserted at top level.
Job$1.prototype.increment_added_items_count_for_parent_instruction_of = function(instr_id){
    if(instr_id <= 0) { return false } //must be at top level, so there is no parent to increment. This is ok
    else {
        let par_id_maybe = instr_id - 1;
        let par_instr = this.do_list[par_id_maybe];
        if(par_instr instanceof Instruction$1.go_to) { //below code is hairy but very rarely if ever called
            let location = par_instr.instruction_location;
            let par_loc_job_inst = Job$1.instruction_location_to_job(location);
            let par_loc_index = this.instruction_location_to_id(location);
            if((par_loc_job_inst === this) &&
               (type_of(par_loc_index) == "number") &&
               (par_loc_index < this.program_counter)) { //backwards goto in same job
               let loop_inst_maybe = this.do_list[par_loc_index];
               if(loop_inst_maybe instanceof Control.loop){ //shoot, we can't make the inserted instruction a sub_object of a loop's go_to
                    //so we've got to climb up the tree and increment the next instr that has a positive added_items_count
                    //but that aic must "contain" the instr_id of the added instruction
                   for(let maybe_par_id = par_loc_index - 1; maybe_par_id >= 0; maybe_par_id--){
                       //assumes go_to of a loop instr won't have a positive added_items_count which should be right
                       if(this.added_items_count[maybe_par_id] > 0) {
                           let sub_items_count = this.total_sub_instruction_count(maybe_par_id);
                           let last_instruction_id_under_maybe_par = maybe_par_id + sub_items_count;
                           if (instr_id <= (last_instruction_id_under_maybe_par + 1)){ //even if our new instr is one beyond the current scope of our maybe_par_id, consider that we're adding to the end of that maybe_par's sub_instructions. The alternative is to keep going up but this is good enough.
                               this.added_items_count[maybe_par_id] += 1;
                               return true
                           }
                       }
                   }
                   return false //didn't find a parent that included instr_id so it must be at top level,
                          //in which case, no need to increment any par instr aic
               }
            }
        }
        //the case that applies nearly all of the time
        //do not make this an else as the inner if's above need to fall through to here.
        this.added_items_count[instr_id - 1] += 1; //fairly dumb but usually right. Just make it the sub_instruction of the instruction above it.
        return true
    }
};

//end do_list management fns

//returns true if the argument is the right type to be an
///instruction location. Note it might not actually BE an instruction location,
//but at least it coforms to the bare minimum of a type
//called from Job constructor for use in finish_job
Job$1.is_plausible_instruction_location = function(instruction_location){
    return Number.isInteger(instruction_location) ||
           (typeof(instruction_location) === "string") ||
            //array check must be before object check because typeof([]) => "object"
            (Array.isArray(instruction_location) &&
                (instruction_location.length > 0) &&
                Job$1.is_plausible_instruction_location(instruction_location[0])
            ) ||
           ((typeof(instruction_location) === "object") &&
            (   instruction_location.offset ||
                instruction_location.job    ||
                instruction_location.process
            ))
};

Job$1.is_plausible_when_stopped_value = function(val){
    return ((val === "stop") ||
            Instruction$1.is_do_list_item(val)
            )
};

//retruns an array of arrays, with the outer array having 3 inner arrays,
//one for x, y and z.
Job$1.prototype.three_d_points_for_plotting = function(which="auto"){ //can also be "orig_do_list" or "sent"
    if((which === "auto") && this.sent_instructions) {
        which = "sent";
    }
    else { which = "orig_do_list"; }
    let xarr=[], yarr=[], zarr=[];
    if(which === "orig_do_list") {
       let do_list = this.orig_args.do_list;
       for(let instr of do_list){
           let xyz = null;
           if((instr instanceof Instruction$1.Dexter) && instr.array_of_angles) {
              let angs = instr.array_of_angles;
              if(angs.length < 5) { //todo imperfect!
                  angs = angs.slice();
                  for(let i = 0; i < 5; i++){
                      if(i === angs.length) {
                          angs.push(0); //todo hack to get around not having 5 angles because Kin.J_angles_to_xyz will error if we don't
                          //but really less than 5 should mean "keep that angle in its same position
                          //see src for move_all_joints
                      }
                  }
              }
              xyz = Kin.J_angles_to_xyz(angs)[0];
           }
           else if((instr instanceof Instruction$1.Dexter) && instr.xyz) {
               xyz = instr.xyz;
           }
           else if(Instruction$1.is_oplet_array(instr, "a")){
               let angs = Instruction$1.extract_args(instr);
               if(angs.length < 5) { //todo imperfect!
                   angs = angs.slice();
                   for(let i = 0; i < 5; i++){
                       if(i === angs.length) {
                           angs.push(0); //todo hack to get around not having 5 angles because Kin.J_angles_to_xyz will error if we don't
                           //but really less than 5 should mean "keep that angle in its same position
                           //see src for move_all_joints
                       }
                   }
               }
               xyz = Kin.J_angles_to_xyz(angs)[0];
           }
           if(xyz){
               xarr.push(xyz[0]);
               yarr.push(xyz[1]);
               zarr.push(xyz[2]);
           }
       }
    } // end which === "orig_do_list"
    else { //we have which = "sent"
       let instrs = this.sent_instructions;
        for(let instr of instrs){
            let xyz = null;
            if(Instruction$1.is_oplet_array(instr, "a")){
                let angs = Instruction$1.extract_args(instr);
                if(angs.length < 5) { //todo imperfect!
                    angs = angs.slice();
                    for(let i = 0; i < 5; i++){
                        if(i === angs.length) {
                            angs.push(0); //todo hack to get around not having 5 angles because Kin.J_angles_to_xyz will error if we don't
                            //but really less than 5 should mean "keep that angle in its same position
                            //see src for move_all_joints
                        }
                    }
                }
                xyz = Kin.J_angles_to_xyz(angs)[0];
            }
            if(xyz){
                xarr.push(xyz[0]);
                yarr.push(xyz[1]);
                zarr.push(xyz[2]);
            }
        }
    } //end which == "sent"
    return [xarr, yarr, zarr]
};

Job$1.prototype.to_source_code = function(args={}){
    if(!args.indent) { args.indent = ""; }
    let props_indent = args.indent + "         ";
    let result = 'new Job({name: "' + this.name + '",\n';
    if (this.robot !== Robot$1.dexter0){
        result += props_indent + 'robot: '  + this.robot.to_path() + ',\n';
    }
    let prop_names = [ //name, robot  handled above
                       "keep_history",
                       "show_instructions",
                       "inter_do_item_dur",
                       "user_data",
                       "default_workspace_pose",
                       "program_counter",
                       "ending_program_counter",
                       "initial_instruction",
                       "data_array_transformer",
                       "start_if_robot_busy",
                       "if_robot_status_error",
                       "if_instruction_error",
                       "if_dexter_connect_error",
                       "when_stopped",
                       "when_stopped_conditions",
                       "callback_param"
                       // do_list  // handled below
                       ];
    let props_container = ((args.job_orig_args || !this.do_list) ? this.orig_args : this);

    for(let prop_name of prop_names){ //if job has never been run, do_list will be undefined,
                                      //in which case use orig_args even if orig_args arg is false
       let prop_val = props_container[prop_name];
       if (!similar(prop_val, Job$1.job_default_params[prop_name])){ //I could *almost* use == instead pf similar but doesn't work for user_data of an empty lit obj
            let prop_args = jQuery.extend({}, args);
            prop_args.value = prop_val;
            let user_data_val_prefix = "";
            if (prop_name == "user_data") {
                prop_args.indent = props_indent + "    ";
                user_data_val_prefix = "\n";
            }

            let comma = ",";
            //if (prop_name == last(prop_names)) { comma = "" }
            if (prop_name == "robot") {
                result += props_indent + prop_name + ": " + "Robot." + this.robot.name +
                          comma + "\n";
            }
            else { result += props_indent + prop_name + ": " +
                      user_data_val_prefix + to_source_code(prop_args) +
                      comma + "\n";
            }
       }
    }
    result += props_indent + "do_list: [";
    let do_list_val = props_container.do_list;
    if (!args.job_orig_args){
        let last_instr  = last(do_list_val);
        if (Instruction$1.is_oplet_array(last_instr) &&
            last_instr[Instruction$1.INSTRUCTION_TYPE] == "g") { //don't print the auto_added g instr at end of a run job
            do_list_val = do_list_val.slice(0, (do_list_val.length - 1));
        }
    }
    let on_first = true;
    for(let i = 0; i < do_list_val.length; i++){
       let on_last = (i == do_list_val.length - 1);
       let prop_args = jQuery.extend({}, arguments[0]);
       prop_args.value = do_list_val[i];
       prop_args.indent = (on_first ? "" : props_indent + "          ");
       let instr_src = to_source_code(prop_args);
       result += instr_src + (on_last ? "" : ",") + "\n";
       on_first = false;
    }
    result += props_indent + "         " + "]\n" + args.indent + "})";
    return result
};

/* the queue is an array of 16 "a" instruction arrays.
   pos 0 is the "front" of the queue, the currently being executed instruction
   by the FPGA. instructions are removed at the end of the queue.
   The last elt in the queue is the latests "sent" instruction.
   It is pushed onto the end of the queue when the Job "executes" the instruction.

   J6 and J7: although its good for "whole instruction display purposes" to have
   J6 and j7 in an instruction, they aren't put in the queue.
   As soon as Dextrun gets an "a" instruction with a J6 and/or J7,
   or a set_parameter("EERoll") (J6) or "EESpan" (J7) it starts
   executing it, bypassing the queue. thus they are out of sequence
   with the movement of J1 thru 5, unless the queue is empty.
   They have their own "speed" (not variable) and generally take much shorter time
   to execute than a j1 thru 5 long move. ie j 6 or 7 long move
   might take 0.5 sec or less.
   Also, J6 and J7 aren't coordinated with each other like the
   j1 thru 5 are in an "a" cmd.
   Also, if a move for j7 comes in WHILE another move
   for J7 is going on, that ongoing move is aborted, and
   the new commanded angle takes over before finishing the old move.
   (same for J6). So there's no special "queue" for J6/J7.

   Sleep (z oplet) have times in microseconds (as their dexter units).
   When one comes in to dexrun, ack_reply is not sent,
   but a countdown for the dur starts as soon as it get to dexrun,
   and when the dur is up, the ack_reply is sent.
   A sleep instruction does not affect exiting items in queue,
   but does prevent DDE from sending more instructions until
   the sleep dur is up.

   So we really have up to 4 different independent "processes" going on.
   1. Moving j1 thru j5, all the joints can move simulaneously.
          // the fastest joint takes the top speed, and the others
          //all move slower such that all 5 joints start and end together.
   2. Moving j6
   3. Moving j7
   4. Sleep
   j1 thru 5 are similar to each other.
   J6 & J7 are similar to each other.

   Despite the fact that j6 & j7 and sleep aren't in the queue, this
   file processes them anyway for modularity and
   because a move_all_joints has its first 5 joints processes
   here, so this code strips off the j6 and 7 and handles them
   separately.
*/

var Simqueue$1 = class Simqueue{
    static queue_max_length = 16
    constructor(sim_instance){
        this.sim_instance = sim_instance;
        this.queue = []; //new Array of 16 fails because length will == 16, and first push pushes to index 16  new Array(Simqueue.queue_max_length)
        this.queue_blocking_instruction = null; //set when F cmd comes in, to that F instruction_array
        this.sleep_dur_us = 0;   //microseconds
        this.queue_dom_elt_id_string_prefix         = this.sim_instance.robot_name + "_queue_";
        this.queue_dom_elt_status_string            = this.queue_dom_elt_id_string_prefix + "status_id";
        this.queue_dom_elt_instruction_table_string = this.queue_dom_elt_id_string_prefix + "instruction_table_id";
        this.latest_sent_queued_instruction = null; //every time a cmd is added to the queue, this var is set to it.
         //we can't just pull the last item off the queue because,
         //at the beginning. this is null, and if the queue is emptied, the lasteset wouldn't be on the queue.
         //so we need this state var. J1 thru 5 make up the "SENT" robot_status row.
        this.instr_to_param_map = {}; //keys are an instruction array. Values are an array of a set param name (string) and its new value
                                     //to be set in sim_inst.parameters whenever the instr is done executing (ie when removed from queue
        this.joint_number_to_j6_plus_status_map = {6: "stopped at " + sim_instance.angles_dexter_units[5],
                                                   7: "stopped at " + sim_instance.angles_dexter_units[6]
                                                  };
        this.joint_number_to_render_j6_plus_frame_call_map = {};
        this.show_degrees = false;
    }

    //called by test suite
    is_simulator_running(){
        return (!this.is_queue_empty() || (this.sleep_dur_us > 0))
    }
    
    is_queue_full(){
      return (this.queue.length === Simqueue.queue_max_length)
    }
    
    is_queue_empty(){ 
    	return (this.queue.length === 0)
    }
    
    //returns an instruction_array or null if the queue is empty
    newest_instruction_in_queue() {
       if(this.is_queue_empty()) { return null }
       else return this.queue[this.queue.length - 1]
    }

    current_instruction_in_queue(){
        if(this.is_queue_empty()) { return null }
        else return this.queue[0]
    }

    
    ok_to_add_to_queue(){
        if(this.is_queue_full()) { return false }
        else if(this.queue_blocking_instruction) { return false }
        else { return true }
    }
    
    is_valid_instruction_for_queue(instruction_array){
        let oplet = instruction_array[Dexter.INSTRUCTION_TYPE];
        return  ["a", "P"].includes(oplet)
    }

    simple_instruction_array_test(instruction_array){
        for(let i = 0; i < instruction_array.length; i++){
            let val = instruction_array[i];
            let type = typeof(val);
            if(!["number", "string", "undefined"].includes(type)) {
                dde_error("Simulator passed invalid instruction arg at index " + i +
                    " of : " + val +
                    " in instruction array: " + instruction_array);
            }
        }
    }

    add_to_queue(instruction_array){
        this.simple_instruction_array_test(instruction_array);
        if(this.is_queue_full()){
            shouldnt("Simqueue is full so can't be added to.");
        }
        else {
            let queue_was_empty = this.is_queue_empty();
            this.queue.push(instruction_array);
            this.latest_sent_queued_instruction = instruction_array;
            this.update_show_queue_if_shown();
            if(queue_was_empty) {
                this.start_running_instruction_if_any();
            }
            let j6_du = instruction_array[Instruction.INSTRUCTION_ARG5];
            if(j6_du !== undefined) { //if it is undefined, no change so do nothing
                this.start_running_j6_plus_instruction(6, j6_du);
            }
            let j7_du = instruction_array[Instruction.INSTRUCTION_ARG6];
            if(j7_du !== undefined) {
                this.start_running_j6_plus_instruction(7, j7_du);
            }
        }
    }

    //called when graphics simulator is done executing the now-running instruction.
    //dont set params in here because remove_from_queue is called by
    //empty_instruction_queue which we DON'T want to set_params.
    remove_from_queue(){ //takes off of front of queue, returns the removed instruction
        this.queue.shift();
        if(this.is_queue_empty()) {
            this.unset_queue_blocking_instruction_maybe();
        }
    }

    done_with_instruction(){
        let cur_inst = this.current_instruction_in_queue();
        this.remove_from_queue();
        let param_names_and_values = this.instr_to_param_map[cur_inst];
        if(param_names_and_values){
            for(let param_name in param_names_and_values){
                let param_value = param_names_and_values[param_name];
                this.sim_instance.parameters[param_name] = param_value;
                this.sim_instance.simout("set_parameter: " + param_name + " to " + param_value);
            }
        }
        delete this.instr_to_param_map[cur_inst]; //not needed anymore
        this.unblock_from_unfull_maybe();
        this.update_show_queue_if_shown();
        let queue_instance = this;
        setTimeout(function(){
                    queue_instance.start_running_instruction_if_any();
                   }, 1); //even if 0, its probably a good idea to give JS chance to run other stuff between instructions.
    }

    //do not remove the front instruction from the queue until AFTER its done running
    start_running_instruction_if_any(){
        if(this.is_queue_empty()) {
            this.sim_instance.simout("queue is empty.");
        }
        else {
            let instruction_array = this.current_instruction_in_queue();
            this.render_instruction(instruction_array);
        }
    }

    //implements  the "E" oplet
    empty_instruction_queue(){
        while (this.queue.length) { this.remove_from_queue();  }
        this.update_show_queue_if_shown();
    }

    //implements the "F" oplet. called from DexterSim
    set_queue_blocking_instruction(f_instruction_array) {
        if(this.queue_blocking_instruction) { //yikes we got an F cmd before the prev F cmd was finished.
          //we need to ack_reply to the first one so DDE will know that one was handled.
          //but that doesn't mean DDE can expect its other instructions from
          //getting handled because this call returns on blocking.
          //But maybe this never happens because if DDE can't send ANY instructions
          //to Dexter after an "F" until the block is cleared, then maybe this clause
          //never happens.
           let instr = this.queue_blocking_instruction;
           this.queue_blocking_instruction = f_instruction_array;
           this.update_show_queue_if_shown(); //probably not necessary because queue is already blocked
           this.sim_instance.ack_reply(instr);
        }
        else if(this.is_queue_empty()){ //since the queue is already empty,
        //this instruction is basically a no-op. Don't set this.queue_blocking_instruction
        //just ack_reply
            this.sim_instance.ack_reply(f_instruction_array);
        }
        else { //normal case
            this.queue_blocking_instruction = f_instruction_array;
            this.update_show_queue_if_shown();
        }
    }

    unset_queue_blocking_instruction_maybe(){
        if(this.queue_blocking_instruction){
            let instr = this.queue_blocking_instruction;
            this.queue_blocking_instruction = null;
            this.sim_instance.ack_reply(instr);
        }
    }

    //called by done_with_instruction just after the cur instruction is removed from the queue.
    unblock_from_unfull_maybe(){
        if(this.queue.length === (Simqueue.queue_max_length - 1)){
          let newest_instr = this.newest_instruction_in_queue();
          this.sim_instance.ack_reply(newest_instr); //because its ack_reply wasn't called when it first came in and filled the queue
        }
    }

    actions_for_instruction(instruction_array){
        return this.instr_to_param_map[instruction_array]
    }

    //called from DexSim.send, "P" clause for MaxSpeed, & friends and from the  "z" clause
    set_instruction_done_action(param_name, param_value){
        let newest = this.newest_instruction_in_queue();
        if(newest){
           let actions = this.actions_for_instruction(newest);
           if(!actions) {  //might not be any action yet.
              actions = {};
              this.instr_to_param_map[newest] = actions;    
           }
           //beware, there can be more than one action, and
           //we might even have a do_list that attempts to set
           //the same param more than once. We want to keep the LATEST of them,
           //an this data structure will do that by overwriting previous same param_name values.
           actions[param_name] = param_value;
        }
        else { //queue is empty so just set params immediately and don't put them in instr_to_param_map
               this.sim_instance.parameters[param_name] = param_value;
               this.sim_instance.simout("set_parameter: " + param_name + " to " + param_value);
        }
    }

    //J6_plus
    start_running_j6_plus_instruction(joint_number, new_angle_in_dexter_units){
        let ds_instance = this.sim_instance;
        let dur_in_ms = ds_instance.predict_j6_plus_instruction_dur_in_ms(new_angle_in_dexter_units, joint_number);
        if(dur_in_ms === 0) ; //the joint is already at the commanded angle so nothing to do. This is a big optimization for a common case.
        else if (SimUtils.is_simulator_showing()){
            let val_for_show = (this.show_degrees ? Socket.dexter_units_to_degrees(new_angle_in_dexter_units, joint_number) : new_angle_in_dexter_units);
            val_for_show = (Number.isInteger(val_for_show) ? val_for_show : val_for_show.toFixed(3));
            this.joint_number_to_j6_plus_status_map[joint_number] = "moving to " + val_for_show;
            this.update_j6_plus_status_if_shown(joint_number);
            let robot_name = ds_instance.robot_name;
            SimUtils.render_j6_plus(ds_instance, new_angle_in_dexter_units, robot_name, dur_in_ms, joint_number);
        }
    }

    //just sets j6_plus status and updates
    done_with_j6_plus_instruction(joint_number){
        let du = this.sim_instance.angles_dexter_units[joint_number - 1];
        let val_for_show = (this.show_degrees ? Socket.dexter_units_to_degrees(du, joint_number) : du);
        val_for_show = (Number.isInteger(val_for_show) ? val_for_show : val_for_show.toFixed(3));
        this.joint_number_to_j6_plus_status_map[joint_number] = "stopped at " + val_for_show;
        this.update_j6_plus_status_if_shown(joint_number);
    }

    start_sleep(instruction_array_in_us) {
        this.sleep_dur_us = instruction_array_in_us[Instruction.INSTRUCTION_ARG0];
        let sleep_instruction = instruction_array_in_us; //for closure
        this.update_show_queue_status_if_shown();
        let sleep_dur_ms = this.sleep_dur_us / 1000;
        let queue_instance = this;
        setTimeout(function(){ //end sleep
                     queue_instance.sleep_dur_us = 0; //must do before update_show_queue_status
                     queue_instance.update_show_queue_status_if_shown();
                     queue_instance.sim_instance.ack_reply(sleep_instruction);
                    }, sleep_dur_ms);
    }


    //______Render instruction ________
    //called at the start of rendering an instruction
    render_instruction(instruction_array){
        let ins_args  = instruction_array.slice(Instruction.INSTRUCTION_ARG0, Instruction.INSTRUCTION_ARG7);
        let dur_in_ms = this.sim_instance.predict_a_instruction_dur_in_ms(ins_args);
        //out("render_instruction passed instruction_array: " + instruction_array)
        //let job_id    = instruction_array[Instruction.JOB_ID]
        //let job_instance = Job.job_id_to_job_instance(job_id)
        //I use to pass job name to render_multi, but it doesn't really need it.
        //I took it out because in the testsuite or ref man, if you have 2 job defs of the same
        //name next to each other, then the 2nd one removes the first one.
        //but if the first one has instructions in the queue, they belong to a
        //non_exisitant job so getting the job_id out of the instruction array and
        //looking it up to find the job def will fail, causing an error.
        //so just avoid that. Dexter (and by extension the simulator) don't
        //know about Jobs and don't care. Useful for debugging perhaps, but
        //causes problems as in above.
        let rob_name  = this.sim_instance.robot_name;
        if(SimUtils.is_simulator_showing()) { //window.platform == "dde") //even if we're in dde, unless the sim pane is up, don't attempt to render
            SimUtils.render_multi(this.sim_instance, ins_args, rob_name, dur_in_ms);
        }
        else {
            warning('To see a graphical simulation,<br/>choose from the Misc pane menu: "Simulate" then select: "Simulate."');
            let the_job = this.sim_instance.job_of_last_instruction_sent();

            this.render_once_node(instruction_array, the_job.name, rob_name); //renders after dur, ie when the dexter move is completed.
        }
    }
    render_once_node(instruction_array, job_name, rob_name, dur_in_ms){
        this.sim_instance.simout("For Job." + job_name +
               "<br/>Starting to similate instruction: " + instruction_array, "green");
          let queue_instance = this;
          setTimeout(function(){
              queue_instance.sim_instance.simout("Done simulating instruction: <span style='margin-right;40px;'/>" + instruction_array, "green");
              queue_instance.done_with_instruction();
          }, dur_in_ms);
    }


    //________show_queue_______
    queue_status(){
        if(this.is_queue_full())                  { return "full" }
        else if (this.sleep_dur_us > 0)           { return "sleep" } //put before blocked as robot can sleep even when blocked
        else if (this.queue_blocking_instruction) { return "blocked" }
        else if (this.is_queue_empty())           { return "empty" }
        else                                      { return "accepting" }
    }

    queue_status_color(){
        let q_status = this.queue_status();
        if      (q_status === "accepting") { return "#aaf1aa" } //green
        else if (q_status === "blocked")   { return "#ff7e79" } //pale red/orange
        else if (q_status === "empty")     { return "#76cdf1" } //blue
        else if (q_status === "full")      { return "#da7900" } //brown
        else if (q_status === "sleep")     { return "#ffff00" } //yellow
        else { shouldnt("In Simqueue.queue_status_color got invalid status: " + status);}
    }
    queue_is_shown(){
        if(window[this.queue_dom_elt_status_string]){
            return true
        }
        else { return false }
    }

    //top level show called from clicking the "Show Queue" button in Sim header.
    // Simqueue.show_queue_for_default_dexter()
    static show_queue_for_default_dexter(){
        if(misc_pane_menu_selection !== "Simulate Dexter"){
            show_in_misc_pane("Simulate Dexter"); //if Simulate Dexter is not shown when queue is shown, we'll get an error
        }
        let rob_name = Dexter.default.name;
        let sim_inst = (DexterSim.robot_name_to_dextersim_instance_map ?
                         DexterSim.robot_name_to_dextersim_instance_map[rob_name] :
                         null);
        if(!sim_inst){ //create one, even before we actually send any instructions.
                       //then we can at least show an empty version of the queue.
            let connect_success_cb = function(){
                //has to be an out, not a simout because sim_inst isn't available to make the cb.
                out("show_queue_for_default_dexter initialized DexterSim instance for Dexter." + rob_name);
            };
            DexterSim.create_or_just_init(rob_name, true, connect_success_cb);
            sim_inst = DexterSim.robot_name_to_dextersim_instance_map[rob_name];
        }
        sim_inst.queue_instance.show_queue();
    }

    static show_queue_cb(vals){
        let sim_inst = DexterSim.robot_name_to_dextersim_instance_map[vals.robot_name];
        if(!sim_inst) { warning("The simulator has not yet been initialized. Run a Job."); }
        else if(vals.clicked_button_value === "show_instructions") {
           Simqueue.show_instructions(vals.robot_name);
       }
       else if(vals.clicked_button_value === "show_parameters"){
           Simqueue.show_parameters(vals.robot_name);
       }
       else if (vals.clicked_button_value === "show_fpga_reg"){
           Simqueue.show_fpga_reg(vals.robot_name);
       }
       else if (vals.clicked_button_value === "init"){
            Simqueue.init(vals.robot_name);
       }
       else if (vals.clicked_button_value === "show_degrees"){
           sim_inst.queue_instance.show_degrees = vals.show_degrees;
           sim_inst.queue_instance.done_with_j6_plus_instruction(6);
           sim_inst.queue_instance.done_with_j6_plus_instruction(7);
           sim_inst.queue_instance.update_show_queue_if_shown();
       }
    }

    show_queue(){
        if(!this.queue_is_shown()) {
            let content = '<div>\n' +
                          this.make_show_queue_status() +
                          this.make_show_queue_instructions_table() +
                          '\n</div>';
            show_window({title: "Queue simulation for Dexter:" + this.sim_instance.robot_name,
                         content: content,
                         x:520, y:0, width:600, height: 400,
                         callback: "Simqueue.show_queue_cb"});
        }
        else {
            this.sim_instance.simout("simqueue is already shown.");
        }
        this.update_show_queue_if_shown();
    }
    make_show_queue_status(){
        let rob_name = this.sim_instance.robot_name;
        return  '<input type="hidden" name="robot_name" value="' + rob_name + '"/>\n' +

                `<input type="button" name="show_instructions" ` +
                `title="Show the instructions sent\nto the simulated Dexter." ` +
                `value="&#9432; instructions"/>&nbsp;&nbsp;` +

                `<input type="button" name="show_parameters" ` +
                `title="Show the simulated set_parameters\nand their values." ` +
                `value="&#9432; params">&nbsp;&nbsp;` +

                `<input type="button" name="show_fpga_reg" ` +
                `title="Show the simulated FGPA register\naddresses, names and values." ` +
                `value="&#9432; FPGA reg">&nbsp;&nbsp;`+

                `<input type="button" name="init" ` +
                `title="Initialize the simulator for Dexter.` + rob_name + `\nThis simulates turning Dexter off and on." ` +
                `value="init">`+

                `<span title="Unchecked shows&#013;Joints 1 thru 5 in arcseconds and&#013;Joints 6 & 7 in Dynamixel units."> ` +
                    `<input name="show_degrees" style="margin-left:15px;" type="checkbox" data-onchange='true' ` +
                    `/>Show degrees` +
                 `</span>` +
                 `<div style="margin-top:4px;"><i>Status </i>` +
                 '<b>Queue:</b> <div style="display:inline-block; padding-left:10px; padding-bottom:3px; padding-top:2px; width:80px;" id="' + this.queue_dom_elt_status_string + '"></div> ' +
                 '<b>J6:   </b> <div style="display:inline-block; padding-left:10px; padding-bottom:3px; padding-top:2px; width:150px;" id="sim_j6_dom_elt_status_id"></div> ' +
                 '<b>J7:   </b> <div style="display:inline-block; padding-left:10px; padding-bottom:3px; padding-top:2px; width:150px;" id="sim_j7_dom_elt_status_id"></div> ' +
                 '</div>'
    }

    update_show_queue_if_shown(){
        if(this.queue_is_shown()){
            this.update_show_queue_status_if_shown();
            this.update_show_queue_instructions_table();
            this.update_j6_plus_status_if_shown();
        }
    }

    update_show_queue_status_if_shown(){
        if(this.queue_is_shown()){
            let elt = window[this.queue_dom_elt_status_string];
           /* let html = '<span id="' + this.queue_dom_elt_status_string + '" '  +
                       'style="background-color:' + this.queue_status_color()        + ';">&nbsp;' +
                       this.queue_status() +
                       '&nbsp;</span>'*/
            let q_stat = this.queue_status();
            if(q_stat === "sleep"){
                q_stat += " " + (this.sleep_dur_us/1000000).toFixed(1);
            }
            elt.innerHTML = q_stat;
            elt.style["background-color"] = this.queue_status_color();
            //elt.outerHTML = html
            if(this.sleep_dur_us > 0){
                let queue_instance = this;
                setTimeout(function(){
                             queue_instance.sleep_dur_us -= 100000; //subtract 100 ms
                             if (queue_instance.sleep_dur_us <= 0) { //we're done with the sleep
                                 queue_instance.sleep_dur_us = 0;
                             }
                             //even if we're now at 0, n
                             queue_instance.update_show_queue_status_if_shown(); //updates the sleep time left display

                           }, 100);
            }
        }
    }

    static show_instructions(robot_name){
        let sim_inst = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
        let the_job = sim_inst.job_of_last_instruction_sent();
        if(!the_job) {
            warning("No instructions sent to Dexter." + sim_inst.robot_name);
        }
        else {
            let title = "<b>Job." + the_job.name + ".sent_instructions</b>";
            let html = Dexter.sent_instructions_to_html(the_job.sent_instructions);
            let start_pos = html.indexOf("<table>");
            let end_pos   = html.indexOf("</table>") + 7;
            html = html.substring(start_pos, end_pos);
            sim_inst.simout(title + html);
        }
    }
    
    static show_parameters(robot_name){
      let sim_inst = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
      let title = " <b>set_parameters</b>";
      let html = "<table>";
      let params_obj = sim_inst.parameters;
      let param_names = Object.getOwnPropertyNames(params_obj);
      param_names.sort();
      for(let param_name of param_names){
          html += "<tr><td>" + param_name + "</td><td>" + params_obj[param_name] + "</td></tr>";
      }
        html += "</table>";
        sim_inst.simout(title + html);
    }
    
    static show_fpga_reg(robot_name){
      let sim_inst = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
      let fr_arr = sim_inst.fpga_register;
      let display_html = "<table><tr><th>Address</th><th>Address Name</th><th>Value</th></tr>\n";
      for(let i = 0; i < fr_arr.length; i++) {
         let val = fr_arr[i];
         let row = "<tr><td>"  + i + 
                   "</td><td>" + Instruction.w_address_names[i] +
                   "</td><td>" + val + 
                   "</td></tr>";
         display_html += row;
      }
      display_html += "</table>";
        sim_inst.simout("<b> Simulated FPGA Registers </b>" + display_html);
    }

    static init(robot_name){
        let sim_inst = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
        let rob = Dexter[robot_name];
        let sim_actual = Robot.get_simulate_actual(rob.simulate); //true, false, or "both"
        if(sim_actual === false) { sim_actual = true; } //we know we're simulating
        sim_inst.init(sim_actual);
        sim_inst.simout("initialized.");
    }


    
    make_show_queue_instructions_table(){
        let result = '<table id="' + this.queue_dom_elt_instruction_table_string + '" style="margin-top:5px;">\n' +
                     this.make_show_queue_instruction_labels();
        for(let inst_queue_index = 0; inst_queue_index < Simqueue.queue_max_length; inst_queue_index++){
            let instr = this.queue[inst_queue_index];
            let row_html;
            if(instr === undefined) {
                row_html = "<tr><td  class='simqueue_td'>" + inst_queue_index + "</td></tr>\n";
            }
            else {
                row_html = this.make_show_queue_instruction_data(inst_queue_index);
            }
            result += row_html;
        }
        result += "</table>";
        return result
    }

    make_show_queue_instruction_labels(){
        let columns_labels = ["Q&nbsp;Pos", "JOB", "INSTR#", "Joint&nbsp;1", "Joint&nbsp;2", "Joint&nbsp;3", "Joint&nbsp;4", "Joint&nbsp;5", "Joint&nbsp;6", "Joint&nbsp;7"];
        let result = "<tr>";
        for(let i = 0; i < columns_labels.length; i++) {
            let header_label = columns_labels[i];
            if((i === 8) || (i === 9)) {
                let joint_number = i - 2;
                header_label = "<span style='color:blue;' " +
                               "title='" +
`These values are sent directly to the J` + joint_number + ` motor
 when they are first added to the queue.
 They do not wait until their instruction is at
 the front of the queue (Q Pos=0)
 to start moving the motor. 
 J1 thru J5 do wait.` +
                               "'>" + header_label + "</span>";
            }
            result += "<th>" + header_label + "</th>";
        }
        result += "</tr>\n";
        return result
    }

    //returns one row of data for one instruction_array
    make_show_queue_instruction_data(inst_queue_index){
        let instruction_array = this.queue[inst_queue_index];
        let data_labels   = ["Q Pos", "JOB_ID", "INSTRUCTION_ID", "INSTRUCTION_ARG0", "INSTRUCTION_ARG1","INSTRUCTION_ARG2","INSTRUCTION_ARG3","INSTRUCTION_ARG4","INSTRUCTION_ARG5","INSTRUCTION_ARG6"];
        let result = "<tr>";
        let job_name;
        let instruction_id;
        for(let q_pos = 0; q_pos < data_labels.length; q_pos++) {
            let data_val;
            if(q_pos === 0) { data_val = inst_queue_index; }
            else {
               let data_label = data_labels[q_pos];
               let instr_elt_index = Instruction[data_label];
               data_val = instruction_array[instr_elt_index];
               if(data_label === "JOB_ID") { //data_val is a job_id
                    let job_instance = Job.job_id_to_job_instance(data_val);
                    if(job_instance) {
                        job_name = job_instance.name;
                        data_val = job_name; //job_name also used below for set_params
                    }
                    //else //rarely, the job_id doesn't find a job. In that case don't error. just show the job_id in place of the job name
               }
               else if(data_label === "INSTRUCTION_ID") {
                   instruction_id = data_val;
               }
               else if (this.show_degrees) { //we only get INSTRUCTION_ARG0 and up in this clause
                   let joint_number = q_pos - 2;
                   data_val = Socket.dexter_units_to_degrees(data_val, joint_number);
               }
            }
            result += "<td class='simqueue_td'>" + data_val + "</td>";
        }
        result += "</tr>\n";
        let actions = this.actions_for_instruction(instruction_array);
        if(actions) {
            let actions_string = "" + "set_parameters: " + JSON.stringify(actions);
            result +=  "<tr><td class='simqueue_td'>"  + (inst_queue_index + 0.5) +
                      "</td><td class='simqueue_td'>" + job_name +
                      "</td><td class='simqueue_td'>" + (instruction_id + 1) +  //because there could be multiple set params, all of them at instruction id's higher than instruction_id variable. Just go with instruction_id as a simplification
                      "</td><td class='simqueue_td'colspan='7'>" + actions_string + "</td></tr>";
        }
        return result
    }

    update_show_queue_instructions_table(){
        let table_elt        = window[this.queue_dom_elt_instruction_table_string];
        table_elt.outerHTML  = this.make_show_queue_instructions_table();
    }

    update_j6_plus_status_if_shown(joint_number){
        if(this.queue_is_shown()){
            if(!joint_number) {
                this.update_j6_plus_status_if_shown(6);
                this.update_j6_plus_status_if_shown(7);
            }
            else {
                let status = this.joint_number_to_j6_plus_status_map[joint_number];
                let elt_id = "sim_j" + joint_number + "_dom_elt_status_id";
                let elt = window[elt_id];
                elt.innerHTML = status;
                let color = (status.startsWith("stopped") ? "#76cdf1" : //blue
                                                            "#aaf1aa"); //green
                elt.style["background-color"] = color;
            }
        }
    }
};

/* Created by Fry on 3/30/16.*/

var DexterSim$1 = class DexterSim{
    constructor(robot_name){ //called once per DDE session per robot_name by create_or_just_init
        this.robot_name = robot_name;
        this.robot      = Robot$1[robot_name]; //mostly used by predict_move_dur
        DexterSim.robot_name_to_dextersim_instance_map[robot_name] = this;
        this.angles_dexter_units = [0,0,0,0,0,
                                   Socket$1.degrees_to_dexter_units(0, 6), //different from the others because for the others, 0 deg is also 0 dexter units, but not for j6
                                   50];  //50 which is the new HOME angle so that j7 doesn't overtorque.
        this.pid_angles_dexter_units = [0,0,0,0,0,0,0];  //last 2 angles are always zero.
    }

    compute_measured_angles_dexter_units(){
        return Vector$1.add(this.angles_dexter_units, this.pid_angles_dexter_units)
    }

    compute_measured_angles_degrees(){
        let ma_du = this.compute_measured_angles_dexter_units();
        return Socket$1.dexter_units_to_degrees_array(ma_du)
    }

    compute_measured_angle_degrees(joint_number){ //joint is 1 thru 7
        let ma_du = this.angles_dexter_units[joint_number - 1];
        let ma_deg = Socket$1.dexter_units_to_degrees(ma_du, joint_number);
        return ma_deg
    }

    static is_simulator_running(){
        for(let rob_name in DexterSim.robot_name_to_dextersim_instance_map){
            let sim_instance = DexterSim.robot_name_to_dextersim_instance_map[rob_name];
            if(sim_instance.queue_instance.is_simulator_running()){
                return true
            }
        }
        return false
    }

    simout(string){
       let sim_html = '<span style="color:black; background-color:#ab99ff;"> &nbsp;Simulator: </span> &nbsp;&nbsp;';
        let rob_name = "Dexter." + this.robot_name;
        out(sim_html + rob_name + " " + string);
    }

    //sim_actual passed in is either true or "both"
    //called by Socket.init. This is the top level initializer for the simulator
    static create_or_just_init(robot_name, sim_actual = "required"){
        if (!DexterSim.robot_name_to_dextersim_instance_map){
            DexterSim.init_all();
        }
        var sim_inst = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
        if(!sim_inst) {
            sim_inst = new DexterSim(robot_name);
            sim_inst.init(sim_actual);
        }
        else {
            sim_inst.sim_actual = sim_actual;
        }
        //if (sim_actual === true) { //do not call new_socket_callback if simulate is "both" because we don't want to call it twice
        //    Socket.new_socket_callback(robot_name)
        //}
    }

    static init_all(){ //called once per DDE session (normally)
        DexterSim.robot_name_to_dextersim_instance_map = {};
        //DexterSim.set_interval_id = setInterval(DexterSim.process_next_instructions, 10)
    }

    init(sim_actual){
        this.sim_actual = sim_actual;
        this.queue_instance = new Simqueue$1(this);

        //these should be in dexter_units
        this.parameters = { //set_params. see Socket.js instruction_array_degrees_to_arcseconds_maybe
            Acceleration:  0.0001,        // in _nbits_cf units
            MaxSpeed:     30 * _nbits_cf, // in _nbits_cf units
            StartSpeed:    0 * _nbits_cf  // in _nbits_cf units
        };
        this.status_mode = 0; //can also be 1, set by "g" command.
        this.fpga_register = new Array(Instruction$1.w_address_names.length); //the make_ins("w", index, val) instructions stored here. //write fpga register
        this.fpga_register.fill(0);
        this.write_file_file_name = null;
        this.write_file_file_content = ""; //grows as "m" instructions come in
        this.last_instruction_sent = null;

        // not used  this.pid_angles_arcseconds      = [0,0,0,0,0,0,0]
        this.velocity_arcseconds_per_second = [0,0,0,0,0,0,0];
    }

    static array_buffer_to_string(arr_buff, terminating_char=";"){
        let str = arr_buff.toString();
        let end_index = str.indexOf(terminating_char);
        return str.substring(0, end_index)
    }


    static array_buffer_to_oplet_array(arr_buff){
        let str = this.array_buffer_to_string(arr_buff);
        let split_str = str.split(" ");
        let oplet_array = [];
        let oplet;
        for(let i = 0; i <  split_str.length; i++) {
            let substr = split_str[i];
            if(i == Instruction$1.INSTRUCTION_TYPE) { oplet = substr;}
            else if ((oplet == "W") && (i == Instruction$1.INSTRUCTION_ARG2)) { //this is the payload of Dexter.write_file
                let raw_string = arr_buff.toString(); //can't use str because that ends at first semicolon, and payload might have semicolons in it.
                let ending_semicolon_pos = raw_string.lastIndexOf(";"); //note that the payload might have semicolons in it so don't choose those by using LASTindexOf
                let W_pos = raw_string.indexOf(" W ");
                let start_payload_length_pos = W_pos + 5; //5 skips over the "W f " (oplet and write_kind letter and spaces)
                //but now we must skip over the payload length, which is an int of variable length
                let start_payload_pos = raw_string.indexOf(" ", start_payload_length_pos) + 1; //skip over palyoad length and the space after it
                let payload = raw_string.substring(start_payload_pos, ending_semicolon_pos); //excludes final semicolon
                oplet_array.push(payload);
                break;
            }
            if(substr == "")               ; //ignore. this is having more than one whitespace together. Just throw out
            else if(substr == "undefined") { oplet_array.push(undefined); }
            else if (substr == "NaN")      { oplet_array.push(NaN); }
            else {
                let num_maybe = parseFloat(substr); //most are ints but some are floats
                if(Number.isNaN(num_maybe)) { oplet_array.push(substr); } //its a string
                else                        { oplet_array.push(num_maybe); } //its an actual number
            }
        }
        return oplet_array
    }

    //used in Simqueue for showing sent instructions
    job_of_last_instruction_sent() {
        let instr = this.last_instruction_sent;
        if(!instr) { return null }
        else {
            let job_id = instr[Instruction$1.JOB_ID];
            return Job.job_id_to_job_instance(job_id)
        }
    }

    //called from Socket.send
    //typically adds instruction to ds_instance.instruction_queue
    static send(robot_name, arr_buff){
        let instruction_array = this.array_buffer_to_oplet_array(arr_buff); //instruction_array is in dexter_units
        //out("Sim.send passed instruction_array: " + instruction_array + " robot_name: " + robot_name)
        let ds_instance = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
        /*if(!ds_instance) {
            let rob = Dexter[robot_name]
            rob.instruction_to_send_on_connect = instruction_array
            const sim_actual = Robot.get_simulate_actual(rob.simulate)
            this.create_or_just_init(robot_name, sim_actual)
            return
        }*/
        ds_instance.last_instruction_sent = instruction_array;
        let ins_args = Instruction$1.args(instruction_array); //in dexter_units
        let oplet  = instruction_array[Dexter$1.INSTRUCTION_TYPE];
        switch(oplet){
            case "a":
                ds_instance.queue_instance.add_to_queue(instruction_array);
                ds_instance.ack_reply_maybe(instruction_array);
                break;
            case "e": //cause an error. Used for testing only
                //not needed as ack_reply pulls the error_code out of instruction_array for "e" oplets. let the_error_code = instruction_array[Instruction.INSTRUCTION_ARG0]
                ds_instance.ack_reply_maybe(instruction_array);
                break;
            case "E": //not implemented on Dexter Mar 13, 2021 but should be. Requires FPGA programming
                ds_instance.queue_instance.empty_instruction_queue(); //this will call ack_reply IFF the queue is blocked (by a previous "F" cmd
                break;
            case "F": //empty_instruction_queue. blocks adding to queue until its empty.
                ds_instance.queue_instance.set_queue_blocking_instruction(instruction_array);
                //do not ack_reply! That happens when all items removed from the queue.
                break;
            case "g":
                let inst_status_mode = instruction_array[Instruction$1.INSTRUCTION_ARG0];
                if((inst_status_mode === null) || (inst_status_mode === undefined)){ ds_instance.status_mode = 0;} //helps backwards compatibility pre status modes.
                else { ds_instance.status_mode = inst_status_mode; }
                ds_instance.ack_reply(instruction_array);
                break;
            /*case "G": //deprecated. get immediate. The very first instruction sent to send should be  "G",
                                     //so let it be the first call to process_next_instruction & start out the setTimeout chain
                ds_instance.add_instruction_to_queue(instruction_array) //stick it on the front of the queue so it will be done next
                break;*/
            case "h": //doesn't go on instruction queue, just immediate ack
                ds_instance.ack_reply(instruction_array);
                break;
            case "P": //does not go on queue  //ds_instance.queue_instance.add_to_queue(instruction_array)
                //pid_move_all_joints for j6 and 7 are handled diffrently than J1 thru 5.
                //IF we get a pid_maj for j6 and/or j7, just treat it like
                // an maj for j6 and j7, ie just more the joints to those locations.
                //pid_move_all_joints can construct an istruction array that has less than 7 joint angles.
                //IF a j6 or j7 is NOT present, then don't do anything with j6 and j7 ie don't set it to zero.
                let pid_ang_du = Instruction$1.extract_args(instruction_array); //probably will be 5 long but could be 7
                for(let i = 0; i < pid_ang_du.length; i++){
                    let new_ang = pid_ang_du[i];
                    if(i < 5) {
                        ds_instance.pid_angles_dexter_units[i] = new_ang;
                    }
                    else {
                        ds_instance.angles_dexter_units[i] = new_ang; //j6 & J7.
                    }
                }
                ds_instance.compute_measured_angles_degrees();
                //let angle_degrees_array = Socket.dexter_units_to_degrees_array(ds_instance.angles_dexter_units)
                //let pid_angle_degrees_array = Socket.dexter_units_to_degrees_array(ds_instance.pid_angles_dexter_units)
                //let sum_degrees_array = Vector.add(angle_degrees_array, pid_angle_degrees_array).slice(0, 5)
                if(SimUtils.is_simulator_showing()) {
                    SimUtils.render_j1_thru_j5(ds_instance); //todo this just jumps to the new angles, not move smoothly as it should
                    if(pid_ang_du.length > 5) {
                        SimUtils.render_j6(ds_instance);
                    }
                    if(pid_ang_du.length > 6) {
                        SimUtils.render_j7(ds_instance); //don't bother to pass xyz and robot.pose as that's only used by simBuild.
                    }
                }
                ds_instance.ack_reply(instruction_array);
                break;
            case "r": //Dexter.read_file. does not go on queue
                let payload_string_maybe = ds_instance.process_next_instruction_r(instruction_array);
                ds_instance.ack_reply(instruction_array, payload_string_maybe);
                break;
            case "S":
                let param_name = ins_args[0];
                let param_val  = ins_args[1];
                if(["Acceleration", "MaxSpeed", "StartSpeed"].includes(param_name)) {
                    ds_instance.queue_instance.set_instruction_done_action(param_name, param_val);
                }
                //EERoll & EESpan *ought* to go on queue but Dexter Mar 19, 2021 does them immediately
                //so the simulator follows suit.
                //Also, the belwo sets the peasured angles immediately to the commanded angle
                //bit really should "animate" it based on the speed of these motors
                //though they're much faster than j1 thru 5.
                //Note that if the robot has 320 motors vs 430, the speed will vary.
                //So this is a cheap simulation.
                else {
                    if(param_name === "EERoll") { //joint 6
                        //ds_instance.measured_angles_dexter_units[5] = param_val
                        ds_instance.queue_instance.start_running_j6_plus_instruction(6, param_val);
                    }
                    else if(param_name === "EESpan") { //joint 7
                        //ds_instance.measured_angles_dexter_units[6] = param_val
                        ds_instance.queue_instance.start_running_j6_plus_instruction(7, param_val);
                    }
                    //else if(param_name === "RebootServo"){
                       //we don't need special processing for RebootServo. After it will be
                       //a "z" oplet instruction (Dexter.sleep) that will cause Sim queue to show "sleep"
                    //}
                    else {
                        ds_instance.parameters[param_name] = param_val;
                        ds_instance.simout("set parameter: " + param_name + " to " + param_val);
                    }
                }
                ds_instance.ack_reply(instruction_array);
                break;
            case "T":
                let angles_dexter_units = ds_instance.convert_T_args_to_joint_angles_dexter_units(ins_args);
                let new_instruction_array = instruction_array.slice(0, Instruction$1.INSTRUCTION_ARG0);
                new_instruction_array[Instruction$1.INSTRUCTION_TYPE] = "a"; //change from "T" to "a"
                new_instruction_array.concat(angles_dexter_units);
                ds_instance.queue_instance.add_to_queue(instruction_array); //just like "a" for now

            case "w": //write fpga register
                const write_location = ins_args[0];
                if (write_location < ds_instance.fpga_register.length) {
                    let new_val = ins_args[1];
                    ds_instance.fpga_register[write_location] = new_val;
                    let reg_name = Instruction$1.w_address_names[write_location];
                    ds_instance.simout("FPGA Register: " + reg_name + " ( " + write_location + " )  set to: " + new_val);
                    ds_instance.ack_reply(instruction_array);
                }
                else { shouldnt$1('DexterSim.fpga_register is too short to accommodate "w" instruction<br/> with write_location of: ' +
                    write_location + " and value of: " + ins_args[1]); 
                }  
                 break;
            case "W": //write file
                ds_instance.process_next_instruction_W(ins_args);
                ds_instance.ack_reply(instruction_array);
                break;
            case "z": //sleep, first arg holds microseconds dur
                //all sleep does is wait for the dur, (starting when the instruction is received
                // by the robot) and then return the ack_reply.
                //so it just holds up DDE sending more instructions.
                //Any ongoing queued instructions just keep running as they would
                //without the sleep.
                //When the dur is up, the queue_instance takes care of sending the ack_reply.
                ds_instance.queue_instance.start_sleep(instruction_array);
                break;
            default:
                warning("In DexterSim.send, got instruction not normally processed: " + oplet);
                ds_instance.ack_reply(instruction_array);
                break;
        }
    }

    //this is called by "a" and "P" instructions only, ie only
    //instuctions that add to the queue.
    ack_reply_maybe(instruction_array, payload_string_maybe){
        if(this.queue_instance.is_queue_full()) {
            this.simout("queue is full.<br/>There will be no reply until the current instruction completes.");
        }
        else {
            this.ack_reply(instruction_array, payload_string_maybe);
        }
    }

    //hacked to now create and pass to on_receive a full robot status
    //payload_string_maybe might be undefined, a string payload or an error number positive int.
    ack_reply(instruction_array, payload_string_maybe){
        let robot_status_array = Dexter$1.make_default_status_array_g_sm(this.status_mode);
        let rs_inst = new RobotStatus({robot_status: robot_status_array});
        let opcode = instruction_array[Instruction$1.INSTRUCTION_TYPE];
        robot_status_array[Dexter$1.JOB_ID]            = instruction_array[Instruction$1.JOB_ID];
        robot_status_array[Dexter$1.INSTRUCTION_ID]    = instruction_array[Instruction$1.INSTRUCTION_ID];
        robot_status_array[Dexter$1.START_TIME]        = instruction_array[Instruction$1.START_TIME]; //Date.now()
        robot_status_array[Dexter$1.STOP_TIME]         = Date.now();
        robot_status_array[Dexter$1.INSTRUCTION_TYPE]  = opcode; //leave this as a 1 char string for now. helpful for debugging
        if((opcode === "r")   &&
            (typeof(payload_string_maybe) == "number") &&
            (payload_string_maybe > 0)){
            robot_status_array[Dexter$1.ERROR_CODE] = payload_string_maybe;
        }
        else if(opcode === "e"){
            robot_status_array[Dexter$1.ERROR_CODE] = instruction_array[Dexter$1.ERROR_CODE];
        }
        if(rs_inst.supports_measured_angles()) {
            let ma_du = this.compute_measured_angles_dexter_units();
            rs_inst.set_measured_angles(ma_du, true); //we want to install arcseconds, as Socket is expected arcseconds and will convert to degrees
        }

        if(this.status_mode === 0){
           robot_status_array[Dexter$1.J1_ANGLE] = this.angles_dexter_units[0];
           robot_status_array[Dexter$1.J2_ANGLE] = this.angles_dexter_units[1];
           robot_status_array[Dexter$1.J3_ANGLE] = this.angles_dexter_units[2];
           robot_status_array[Dexter$1.J4_ANGLE] = this.angles_dexter_units[3];
           robot_status_array[Dexter$1.J5_ANGLE] = this.angles_dexter_units[4];
           //there are no slots in robot_status_array g0 for j6 and j7 angles
           let latest = this.queue_instance.latest_sent_queued_instruction;
           let j1_5_arcsecs;
           if(latest) {
              j1_5_arcsecs = [latest[Instruction$1.INSTRUCTION_ARG0], 
                              latest[Instruction$1.INSTRUCTION_ARG1], 
                              latest[Instruction$1.INSTRUCTION_ARG2], 
                              latest[Instruction$1.INSTRUCTION_ARG3], 
                              latest[Instruction$1.INSTRUCTION_ARG4]];  
           }
           else { j1_5_arcsecs = [0,0,0,0,0]; }
           robot_status_array[Dexter$1.J1_SENT] = j1_5_arcsecs[0];
           robot_status_array[Dexter$1.J2_SENT] = j1_5_arcsecs[1];
           robot_status_array[Dexter$1.J3_SENT] = j1_5_arcsecs[2];
           robot_status_array[Dexter$1.J4_SENT] = j1_5_arcsecs[3];
           robot_status_array[Dexter$1.J5_SENT] = j1_5_arcsecs[4];
           //unfortunately g0 doesn't support J6_SENT or J7_SENT
        } 
         
        if (this.sim_actual === true){
            let dexter_instance = this.robot;  //for closure variable
            setTimeout(function(){
                        Socket$1.on_receive(robot_status_array, payload_string_maybe, dexter_instance);
                        }, 1);
        }
    }

    //from https://stackoverflow.com/questions/15761790/convert-a-32bit-integer-into-4-bytes-of-data-in-javascript/24947000
    //not called mar 18, 2021
    /*toBytesInt32 (num) {
        arr = new ArrayBuffer(4); // an Int32 takes 4 bytes
        view = new DataView(arr);
        view.setUint32(0, num, false); // byteOffset = 0; litteEndian = false
        return arr;
    }*/

    //when we're running the simulator on Dexter
    static render_once_node(ds_instance, job_name, robot_name, force_render=true){ //inputs in arc_seconds
         //note that SimUtils.render_once has force_render=false, but
         //due to other changes, its best if render_once_node default to true
         rs_inst = ds_instance.robot.rs;
        if (force_render){
            let j1 = rs_inst.measured_angle(1); //joint_number)robot_status[Dexter.J1_MEASURED_ANGLE]
            let j2 = rs_inst.measured_angle(2);
            let j3 = rs_inst.measured_angle(3);
            let j4 = rs_inst.measured_angle(4);
            let j5 = rs_inst.measured_angle(5);
            let j6 = rs_inst.measured_angle(6);
            let j7 = rs_inst.measured_angle(7);
            j1 = j1; //* -1 //fix for j1 wrong sign
            j5 = j5 * -1; //fix for j5 wrong sign
            out("DexterSim " + job_name + " " + robot_name + " J1: " + j1 + ", J2: " + j2 + ", J3: " + j3 + ", J4: " + j4 + ", J5: " + j5 + ", J6: " + j6 + ", J7: " + j7,
                "#95444a", //brown,
                true); //temp output
        }
    }

    // also called by process_next_instruction_T()
    /*process_next_instruction_a(angles_dexter_units){
        //predict needs its angles in degrees but ins_args are in arcseconds
        const orig_angles_in_deg = Socket.dexter_units_to_degrees_array(this.measured_angles_dexter_units)  //Socket.dexter_units_to_degrees(this.measured_angles_dexter_units) //this.measured_angles_dexter_units.map(function(ang) { return ang / 3600 })
        const angles_in_deg  = Socket.dexter_units_to_degrees_array(angles_dexter_units) //ns_args.map(function(ang)    { return ang / 3600 })
        //ins_args_in_deg[5] = Socket.dexter_units_to_degrees(ins_args[5], 6) //joint 6
        //ins_args_in_deg[6] = Socket.dexter_units_to_degrees(ins_args[6], 7) //joint 7

        //predict_move_dur takes degrees in and returns seconds
        let dur_in_seconds = Math.abs(Kin.predict_move_dur(orig_angles_in_deg, angles_in_deg, this.robot))
        let dur_in_milliseconds = dur_in_seconds * 1000
        return dur_in_milliseconds
    }*/

    //same as the above. just better named for its functionality
    predict_a_instruction_dur_in_ms(angles_dexter_units){
        if(angles_dexter_units === this.angles_dexter_units) { //an optimization for this common case of no change
            return 0
        }
        else {
            //predict needs its angles in degrees but ins_args are in arcseconds
            const orig_angles_in_deg = Socket$1.dexter_units_to_degrees_array(this.angles_dexter_units);  //Socket.dexter_units_to_degrees(this.measured_angles_dexter_units) //this.measured_angles_dexter_units.map(function(ang) { return ang / 3600 })
            const angles_in_deg  = Socket$1.dexter_units_to_degrees_array(angles_dexter_units); //ns_args.map(function(ang)    { return ang / 3600 })
            //ins_args_in_deg[5] = Socket.dexter_units_to_degrees(ins_args[5], 6) //joint 6
            //ins_args_in_deg[6] = Socket.dexter_units_to_degrees(ins_args[6], 7) //joint 7

            //predict_move_dur takes degrees in and returns seconds
            //let dur_in_seconds = Math.abs(Kin.predict_move_dur(orig_angles_in_deg, angles_in_deg, this.robot))
            let dur_in_seconds = Math.abs(Kin$1.predict_move_dur_5_joint(orig_angles_in_deg, angles_in_deg, this.robot));
            //use 5 joint as j6 and j7 aren't part of this path.
            let dur_in_milliseconds = dur_in_seconds * 1000;
            return dur_in_milliseconds
        }
    }

    predict_j6_plus_instruction_dur_in_ms(new_angle_in_dexter_units, joint_number){
        let orig_angle_in_dexter_units = this.angles_dexter_units[joint_number -1];
        let diff_du = new_angle_in_dexter_units - orig_angle_in_dexter_units;
        let diff_deg = Socket$1.dexter_units_to_degrees(diff_du, joint_number);
        let dur_in_seconds = Math.abs(diff_deg) / Kin$1.dynamixel_320_degrees_per_second;
        let dur_in_ms = dur_in_seconds * 1000;
        return dur_in_ms
    }

    /*
    process_next_instruction_T(ins_args){ //ins_args xyz in microns
        let xyz_in_microns = [ins_args[0], ins_args[1], ins_args[2]]
        let J5_direction   = [ins_args[3], ins_args[4], ins_args[5]]
        let config         = [ins_args[6], ins_args[7], ins_args[8]]
        let j6_angle       = ins_args[11]
        let j7_angle       = ins_args[12]
        let pose           = undefined //its not in the ins_args, and defaults just fine

        let xyz_in_meters = [xyz_in_microns[0] / 1000000,
                             xyz_in_microns[1] / 1000000,
                             xyz_in_microns[2] / 1000000]
        let angles_in_degrees = Kin.xyz_to_J_angles(xyz_in_meters, J5_direction, config, pose)
        let angles_in_dexter_units = Socket.degrees_to_dexter_units(angles_in_degrees)
        angles_in_dexter_units.push(j6_angle)
        angles_in_dexter_units.push(j7_angle)
        return this.process_next_instruction_a(angles_in_dexter_units)
    }*/

    convert_T_args_to_joint_angles_dexter_units(ins_args){ //ins_args contains xyz in microns
        let xyz_in_microns = [ins_args[0], ins_args[1], ins_args[2]];
        let J5_direction   = [ins_args[3], ins_args[4], ins_args[5]];
        let config         = [ins_args[6], ins_args[7], ins_args[8]];
        let j6_angle       = ins_args[11];
        let j7_angle       = ins_args[12];
        let pose           = undefined; //its not in the ins_args, and defaults just fine

        let xyz_in_meters = [xyz_in_microns[0] / 1000000,
            xyz_in_microns[1] / 1000000,
            xyz_in_microns[2] / 1000000];
        let angles_in_degrees = Kin$1.xyz_to_J_angles(xyz_in_meters, J5_direction, config, pose);
        let angles_in_dexter_units = Socket$1.degrees_to_dexter_units(angles_in_degrees);
        angles_in_dexter_units.push(j6_angle);
        angles_in_dexter_units.push(j7_angle);
        return angles_in_dexter_units //this.process_next_instruction_a(angles_in_dexter_units)
    }

    process_next_instruction_r(instruction_array) {
        let hunk_index = instruction_array[Instruction$1.INSTRUCTION_ARG0];
        let source     = instruction_array[Instruction$1.INSTRUCTION_ARG1];
        let whole_content;
        try { whole_content = read_file(source); }//errors if path in "source" doesn't exist
        catch(err){
            return 2 //return the error code
        }
        let start_index = hunk_index * Instruction$1.Dexter.read_file.payload_max_chars;
        let end_index = start_index + Instruction$1.Dexter.read_file.payload_max_chars;
        let payload_string = whole_content.substring(start_index, end_index); //ok if end_index is > whole_cotnent.length, it just gets how much it can, no error
        return payload_string
    }
    //Dexter.write_file
    process_next_instruction_W(ins_args, rob){
        let kind_of_write  = ins_args[0];
        ins_args[1];
        let payload        = ins_args[2];
        let robot_name     = this.robot_name;
        let dde_computer_file_system_start = "dexter_file_systems/" + robot_name + "/";
        switch(kind_of_write){
            case "f": //payload is file name to write to. Just one of these to start with
                this.write_file_file_name = payload;
                this.write_file_file_content = "";
                break;
            case "m": //middle, ie a content instruction, many of these
                this.write_file_file_content += payload;
                break;
            case "e":   //end, just one of these
                this.write_file_file_content += payload;
                let last_slash_pos = this.write_file_file_name.lastIndexOf("/");
                let folders_string = "";
                if(last_slash_pos != -1) { folders_string = this.write_file_file_name.substring(0, last_slash_pos + 1); }
                let folder_path;
                if(folders_string.startsWith("/")) {
                    folder_path = folders_string;
                }
                else {
                    folder_path = dde_computer_file_system_start + folders_string; //ends with slash
                }
                folder_path = make_full_path(folder_path);
                make_folder(folder_path);
                let full_path = dde_computer_file_system_start + this.write_file_file_name;
                full_path = make_full_path(full_path);
                //fs.mkdirSync(path, options-recursive???)
                write_file(full_path, this.write_file_file_content);
                break;
            default:
              dde_error('The "W" write_file instruction received<br/>' +
                        'a "kind_of-write" letter of "' + kind_of_write + "<br/>" +
                        'but the only valid letters are "f", "m" and "e".');
        }
        return 0 //dur
    }
    //The corresponding fn for Dexter causes DexRun to crash, so we've commented out all calls to it.
    //When FPGA is updated to support it, we can re_instate it as a regular function.
    static empty_instruction_queue_now(robot_name){
        if(DexterSim.robot_name_to_dextersim_instance_map) {
            let ds_instance = DexterSim.robot_name_to_dextersim_instance_map[robot_name];
            if(ds_instance) {
                ds_instance.queue_instance.empty_instruction_queue();
            }
        }
    }
    
};

DexterSim$1.robot_name_to_dextersim_instance_map = {};
DexterSim$1.set_interval_id      = null;

/* Created by Fry on 2/4/16. */
//import {_nbits_cf, _arcsec, _um} = from "./units.js" //don't do this. These units and all the rest are
//already global vars.

//never create an instance
var Socket$1 = class Socket{
    //returns a net_soc_inst or null if none in Socket.robot_name_to_soc_instance_map
    //this is reverse lookup in robot_name_to_soc_instance_map
    static net_soc_inst_to_robot_name(net_soc_inst){
        for(let robot_name in Socket.robot_name_to_soc_instance_map){
            let a_net_soc_inst = Socket.robot_name_to_soc_instance_map[robot_name];
            if (a_net_soc_inst === net_soc_inst) { return robot_name }
        }
        return null
    }

    //when a job starts, it calls robot.start, which calls start_aux, which (for Dexter's)
    //calls Socket.init, which for sim, calls DexterSim.create_or_just_init
    static init(robot_name, job_instance, instruction_to_send_on_connect=null){
       //out(job_instance.name + " Socket.init passed: " + robot_name + " " + instruction_to_send_on_connect)
       if(!job_instance.is_active()) {
            warning(job_instance.name + " Attempt to Socket.init with inactive status: " + job_instance.status_code);
            return
        }
        let rob = Robot$1[robot_name];
        const sim_actual = Robot$1.get_simulate_actual(rob.simulate); //true, false, or "both"
        if (sim_actual === true){ //when we are ONLY simulating
            DexterSim$1.create_or_just_init(robot_name, sim_actual);
            //out("socket for Robot." + robot_name + ". is_connected? " + Robot[robot_name].is_connected)
            Socket.new_socket_callback(robot_name, job_instance, instruction_to_send_on_connect);
        }
        else if ((sim_actual === false) || (sim_actual == "both")) {
            if(sim_actual == "both"){
                DexterSim$1.create_or_just_init(robot_name, sim_actual); //harmless if done a 2nd time. returns without callbaack
            }
            let net_soc_inst = Socket.robot_name_to_soc_instance_map[robot_name];
            if(net_soc_inst && (net_soc_inst.readyState === "closed")) { //we need to init all the "on" event handlers
                this.close(robot_name, true);
                net_soc_inst = null;
            }
            if(!net_soc_inst){
                //out(job_instance.name + " Socket.init net_soc_inst for " + robot_name + " doesn't yet exist or is closed.")
                try {
                    net_soc_inst = new net.Socket();
                    net_soc_inst.setKeepAlive(true);
                    //out(job_instance.name + " Just after created, net_soc_inst.readyState: " + net_soc_inst.readyState)
                    /* on error *could* be called, but its duration from a no-connection is
                       highly variable so I have below a setTimeout to kill the connection
                       after a second. But then both on error and the setTimeout method
                       *could* get called so I take pains to kill off the setTimeout
                       so that only one will get called.

                    */
                }
                catch(err){
                    console.log(job_instance.name + " Socket.init catch clause with err: " + err.message);
                    dde_error("Error attempting to create socket to Dexter." + robot_name + " at ip_address: " + rob.ip_address + " port: " + rob.port + err.message);
                    this.close(robot_name, true);
                }
                // I must define the below just once (on actual new socket init, because  calling
                // net_soc_inst.on("data", function(data) {...} actually gives the socket 2 versions of the callback
                // and so each will be called once, giving us a duplication that causes a difficult to find bug.
                net_soc_inst.on("data", function(data) {
                    Socket.on_receive(data, undefined, rob);
                });
                net_soc_inst.on("connect", function(){
                    out(job_instance.name + " Succeeded connection to Dexter: " + robot_name + " at ip_address: " + rob.ip_address + " port: " + rob.port, "green");
                    //clearTimeout(st_inst)
                    Socket.robot_name_to_soc_instance_map[robot_name] = net_soc_inst;
                    //the 3 below closed over vars are just used in the one call to when this on connect happens.
                    Socket.new_socket_callback(robot_name, job_instance, instruction_to_send_on_connect);
                });
                net_soc_inst.on("error", function(err){
                    console.log("Probably while running " + job_instance.name + " Socket.init on error while waiting for ack from instruction: " + instruction_to_send_on_connect  +
                        " with err: " + err.message);
                    //clearTimeout(st_inst)
                    let rob_name = Socket.net_soc_inst_to_robot_name(net_soc_inst);
                    if (rob_name == null) { rob_name = "unknown"; } //should be rare if at all.
                    let rob_maybe = (rob_name ? Dexter[rob_name] : null);
                    if (rob_maybe) {
                        //warning("in Socket.init on error callback, could not find Dexter." + rob_name)
                        rob = rob_maybe;
                    } //let rob "default" to the closed over "rob" because can't find anything else
                    //if(st_inst || (st_inst == 0)){ clearTimeout(st_inst) } //st_inst is just a non-neg int.
                    //Socket.close(robot_name, true) //true, means force_close, needed if job is still active becuse that will remove the soc from the robot_name_to_soc_instance_map and get init to really work.
                    if (rob.resend_count && (rob.resend_count >= 4)) {  //give up retrying and error
                        let active_jobs_using_rob = Job.active_jobs_using_robot(rob);
                        rob.resend_count = 0;
                        for(let job_inst of active_jobs_using_rob) {
                            job_inst.stop_for_reason("errored_from_dexter", "can't connect to Dexter." + rob_name);
                        }
                        return
                    }
                    else { //we've got a rob, keep trying
                        if(!rob.resend_count) {
                            rob.resend_count = 1;
                        }
                        else { rob.resend_count += 1; }
                        Socket.close(robot_name, true);
                        let timeout_dur = Math.pow(10, rob.resend_count);
                        setTimeout(function(){
                            console.log("re-initing Socket to Dexter." + rob_name);
                            //in the below, for the 3 closed over vars, its possible that these aren't
                            //the right closed over vars, because multiple jobs can send to a given robot.
                            //but if we're only running one robot, or in 2 or more jobs hitting a robot,
                            //maybe these are right, so worth a shot. Not sure what else to do.
                            Socket.prepare_for_re_init(robot_name);
                            Socket.init(rob_name, job_instance, instruction_to_send_on_connect);
                        }, timeout_dur);
                    }
                }); //end of on("error"
                setTimeout(function() {
                    if(!net_soc_inst) ; //presume the job completed and so nothing to do
                    else if (job_instance.is_done()) ; //presume the job completed and so nothing to do
                    else if(net_soc_inst.readyState === "open") ; //connection worked, leave it alone
                    else { //connection failed
                        job_instance.stop_for_reason("errored_from_dexter_connect", "Connection to Dexter." + robot_name +
                                                     "\n failed after 2 seconds.");
                    }
                }, 2000);
                net_soc_inst.connect(rob.port, rob.ip_address);
            } //ending the case where we need to make a new net_soc_inst

            /*out(job_instance.name + "Socket.init before connect, net_soc_inst.readyState: " + net_soc_inst.readyState)
            if (net_soc_inst.readyState === "closed") {
                 st_inst = setTimeout(function(){
                    out(job_instance.name + " in Socket.init, setTimout of st_inst")
                    if(net_soc_inst.readyState !== "open") { //still trying to connect after 1 sec, so presume it never will. kill it
                        Socket.close(robot_name, true)
                        rob.resend_count = 0
                        if(!job_instance.is_done()){
                            job_instance.stop_for_reason("errored_from_dexter", " socket timeout while connecting to Dexter." + rob.name)
                        }
                    }
                    else {
                        Socket.new_socket_callback(robot_name, job_instance, instruction_to_send_on_connect)
                    }
                }, Socket.connect_timeout_seconds * 5000)
                out(job_instance.name + " Now attempting to connect to Dexter." + robot_name + " at ip_address: " + rob.ip_address + " port: " + rob.port + " ...", "brown")
                net_soc_inst.connect(rob.port, rob.ip_address) //the one call to .connect()
            } */
            else { //net_soc_inst already existed and is open
                Socket.new_socket_callback(robot_name, job_instance, instruction_to_send_on_connect);
            }
        }
        //out(job_instance.name + " Socket.init, very bottom")
    }

    //called from both above socket code and from dexsim
    static new_socket_callback(robot_name, job_instance, instruction_to_send_on_connect){
        Dexter.set_a_robot_instance_socket_id(robot_name);
        let rob = Robot$1[robot_name];
        if(instruction_to_send_on_connect) { //usually this clause hits. happens for initial g oplet for a job
              //and when connection is dropped and we need to resetablish connection and resend.
              //ok to call this even if we were already connected.
            let inst_id = instruction_to_send_on_connect[1];
            if((inst_id === undefined) || (inst_id === -1)) { //we have the initial "g" instr for a job, that has yet to get filled out by Job.prototype.send
                //out("new_socket_callback with initial g instruction.")
                job_instance.send(instruction_to_send_on_connect, rob);
            }
            else {
                rob.send(instruction_to_send_on_connect);
            }
        }
        else {
            warning("In new_socket_callback without instruction to send.");
        }
    }

    static oplet_array_or_string_to_array_buffer(oplet_array_or_string){
        let str = this.oplet_array_or_string_to_string(oplet_array_or_string);
        return this.string_to_array_buffer(str)
    }

    static oplet_array_or_string_to_string(oplet_array_or_string) {
        if (typeof(oplet_array_or_string) == "string") { return oplet_array_or_string }
        else { //oplet_array_or_string is an array
            let str = "";
            for(var i = 0; i < oplet_array_or_string.length; i++){
                let suffix = ((i == (oplet_array_or_string.length - 1))? ";": " ");
                //let elt = oplet_array_or_string[i] + suffix
                let elt = oplet_array_or_string[i];
                if (Number.isNaN(elt)) { elt = "NaN"; } //usually only for "a" instructions and only for elts > 4
                  //looks like this is never used now because I convert from NaN to the prev val
                  //in the the higher level code so only numbers get passed to DexRun.
                elt = elt + suffix;
                str += elt;
            }
            return str
        }
    }

    static string_to_array_buffer(str){
        var arr_buff = Buffer.alloc(128); //dexter code expecting fixed length buf of 128
        //var view1    = new Uint8Array(arr_buff)
        for(var i = 0; i < str.length; i++){
            let char = str[i];
            let code = char.charCodeAt(0);
            arr_buff[i] = code;
        }
        return arr_buff
    }

    static degrees_to_dexter_units_array(arr){
        let new_array = [];
        for(let index = 0; index < arr.length; index++){
            let joint_number = index + 1;
            new_array.push(this.degrees_to_dexter_units(arr[index], joint_number));
        }
        return new_array
    }

    static dexter_units_to_degrees_array(arr){
        let new_array = [];
        for(let index = 0; index < arr.length; index++){
            let joint_number = index + 1;
            new_array.push(this.dexter_units_to_degrees(arr[index], joint_number));
        }
        return new_array
    }

    static degrees_to_dexter_units(deg, joint_number){
        if(joint_number == 6) {
            return Math.round(deg / Socket.DEGREES_PER_DYNAMIXEL_320_UNIT) +
                              Socket.J6_OFFSET_SERVO_UNITS //512
        }
        else if (joint_number == 7) {
            return Math.round(deg / Socket.DEGREES_PER_DYNAMIXEL_320_UNIT)
        }
        else {
            return Math.round(deg * 3600)  //convert to arcseconds
        }
    }

    static dexter_units_to_degrees(du, joint_number){
        if(joint_number == 6) {
            let ang_deg = (du - Socket.J6_OFFSET_SERVO_UNITS ) *
                       Socket.DEGREES_PER_DYNAMIXEL_320_UNIT;
            return ang_deg
        }
        else if (joint_number == 7) {
              let ang_deg = du * Socket.DEGREES_PER_DYNAMIXEL_320_UNIT;
              return ang_deg
        }
        else { return du / 3600 }
    }

    static instruction_array_degrees_to_arcseconds_maybe(instruction_array, rob){
        if(typeof(instruction_array) == "string") { return instruction_array} //no conversion needed.
        const oplet = instruction_array[Dexter.INSTRUCTION_TYPE];
        let number_of_args = instruction_array.length - Instruction$1.INSTRUCTION_ARG0;
        if ((oplet === "a") || (oplet === "P")){
            //take any number of angle args
            let instruction_array_copy = instruction_array.slice();
            instruction_array_copy.length - Instruction$1.INSTRUCTION_ARG0;
            for(let i = 0; i < number_of_args; i++) {
                let index = Instruction$1.INSTRUCTION_ARG0 + i;
                let arg_val = instruction_array_copy[index];
                let converted_val = this.degrees_to_dexter_units(arg_val, i + 1);
                instruction_array_copy[index] = converted_val;
            }
            return instruction_array_copy
        }
        else if (oplet === "S") {
            const name = instruction_array[Instruction$1.INSTRUCTION_ARG0];
            const args = instruction_array.slice(Instruction$1.INSTRUCTION_ARG1, instruction_array.length);
            const first_arg = args[0];
            //first convert degrees to arcseconds
            if(["MaxSpeed", "StartSpeed", "Acceleration",
                "AngularSpeed", "AngularSpeedStartAndEnd", "AngularAcceleration",
                "CartesianPivotSpeed", "CartesianPivotSpeedStart", "CartesianPivotSpeedEnd",
                "CartesianPivotAcceleration", "CartesianPivotStepSize" ].includes(name)){
                let instruction_array_copy = instruction_array.slice();
                instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] = Math.round(first_arg * _nbits_cf);
                return instruction_array_copy
            }
            else if (name.includes("Boundry")) { //the full name is  J1BoundryHigh thru J5BoundryHigh, or J1BoundryLow thru J5BoundryLow
                let instruction_array_copy = instruction_array.slice();
                let joint_number = parseInt(name[1]);
                instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] = this.degrees_to_dexter_units(first_arg, joint_number); //Math.round(first_arg * 3600) //deg to arcseconds
                                            //only expecting j1 thru J5, and since j1 thru j5 are to be converted the same, just pass joint 1
                return instruction_array_copy
            }
            else if (["CommandedAngles", "RawEncoderErrorLimits", "RawVelocityLimits"].includes(name)){
                let instruction_array_copy = instruction_array.slice();
                for(let i = Instruction$1.INSTRUCTION_ARG1; i <  instruction_array.length; i++){
                    let orig_arg = instruction_array_copy[i];
                    instruction_array_copy[i] = this.degrees_to_dexter_units(orig_arg, i + 1); // Math.round(orig_arg * 3600)
                }
                return instruction_array_copy
            }
            //dynamixel conversion
            else if (name == "EERoll"){ //J6 no actual conversion here, but this is a convenient place
                //to put the setting of robot.angles and is also the same fn where we convert
                // the degrees to dynamixel units of 0.20 degrees
                //val is in dynamixel units
                rob.angles[5] = this.dexter_units_to_degrees(first_arg, 6); //convert dynamixel units to degrees then shove that into rob.angles for use by subsequent relative move instructions
                return instruction_array
            }
            else if (name == "EESpan") { //J7
                rob.angles[6] = this.dexter_units_to_degrees(first_arg, 7);
                return instruction_array
            }
            //convert meters to microns
            else if ((name.length == 5) && name.startsWith("Link")){
                let instruction_array_copy = instruction_array.slice();
                let new_val = Math.round(first_arg / _um); //convert from meters to microns
                instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] = new_val;
                return instruction_array_copy
            }
            else if (["CartesianSpeed", "CartesianSpeedStart", "CartesianSpeedEnd", "CartesianAcceleration",
                "CartesianStepSize", ].includes(name)){
                let instruction_array_copy = instruction_array.slice();
                let new_val = Math.round(first_arg / _um); //convert from meters to microns
                instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] = new_val;
                return instruction_array_copy
            }
            else { return instruction_array }
        }
        else if (oplet == "T") { //move_to_straight
            let instruction_array_copy = instruction_array.slice();
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG0] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG0] / _um); //meters to microns
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG1] / _um); //meters to microns
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG2] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG2] / _um); //meters to microns
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG11] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG11] * 3600); //degrees to arcseconds
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG12] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG12] * 3600); //degrees to arcseconds
            return instruction_array_copy
        }
        else if (oplet == "z") { //sleep
            let instruction_array_copy = instruction_array.slice(); //instruction array contains dur in seconds, but Dexter expects microseconds
            instruction_array_copy[Instruction$1.INSTRUCTION_ARG0] =
                Math.round(instruction_array_copy[Instruction$1.INSTRUCTION_ARG0] * Socket.DEXTER_UNITS_PER_SECOND_FOR_SLEEP); //seconds to nanoseconds
            return instruction_array_copy
        }
        else { return instruction_array }
    }

    static send(robot_name, oplet_array_or_string){ //can't name a class method and instance method the same thing
        let rob = Robot$1[robot_name];
        let oplet_array_or_string_du = Socket.instruction_array_degrees_to_arcseconds_maybe(oplet_array_or_string, rob);
        let job_id = Instruction$1.extract_job_id(oplet_array_or_string);
        let job_instance = Job.job_id_to_job_instance(job_id);
        if(!job_instance){
            shouldnt("Socket.send passed: " + robot_name + " " + oplet_array_or_string +
                     "<br/>extracted job_id:" + job_id + " but no defined Job with that ID.");
        }
        //out(job_instance.name + " " + robot_name + " Socket.send passed oplet_array_or_string: " + oplet_array_or_string)

        const str =  Socket.oplet_array_or_string_to_string(oplet_array_or_string_du);
        if(Instruction$1.is_F_instruction_string(str)) {
            rob.waiting_for_flush_ack = true;
        }
        if(job_instance.keep_history) {
            job_instance.sent_instructions_strings.push(str);
        }
        const arr_buff = Socket.string_to_array_buffer(str);
        const sim_actual = Robot$1.get_simulate_actual(rob.simulate);
        if((sim_actual === true) || (sim_actual === "both")){
            let sim_inst = DexterSim$1.robot_name_to_dextersim_instance_map[robot_name];
            if(sim_inst) {
                setTimeout( function() { //eqiv to net_soc_inst.write(arr_buff) below.
                    DexterSim$1.send(robot_name, arr_buff);
                }, 1);}
            else {
                Socket.close(robot_name, true); //both are send args
                setTimeout(function(){
                    Socket.init(robot_name, job_instance, oplet_array_or_string);
                }, 100);
            }
        }
        if ((sim_actual === false) || (sim_actual === "both")) {
            let net_soc_inst = Socket.robot_name_to_soc_instance_map[robot_name];
            if(net_soc_inst && (net_soc_inst.readyState === "open")) {
                try {
                    //console.log("Socket.send about to send: " + str)
                    net_soc_inst.write(arr_buff); //if doesn't error, success and we're done with send
                    //console.log("Socket.send just sent:     " + str)
                    //this.stop_job_if_socket_dead(job_id, robot_name)
                    return
                }
                catch(err) {
                    console.log("Socket.send just after write in catch clause with err: " + err.message);
                    if (rob.resend_count && (rob.resend_count >= 4)) {  //give up retrying and error
                        rob.resend_count = 0;
                        job_instance.stop_for_reason("errored_from_dexter", "can't connect to Dexter");
                        //job_instance.color_job_button() //automatically done by job.prototype.finish
                        job_instance.set_up_next_do(0);  //necessary?
                        return
                    }
                    else { //keep trying
                        /*if(!rob.resend_count) {
                            rob.resend_count = 1
                        }
                        else { rob.resend_count += 1 }*/
                        Socket.close(robot_name, true);
                        let timeout_dur = Math.pow(10, rob.resend_count);
                        setTimeout(function(){
                            console.log("re-initing Socket to Dexter." + robot_name);
                            Socket.init(robot_name, job_instance, oplet_array_or_string);
                        }, timeout_dur);
                        return
                    }
                }
            }
            else { //maybe never hits. it only hits if there is no net_soc_inst in Socket.robot_name_to_soc_instance_map
                Socket.close(robot_name, true); //both are send args
                setTimeout(function(){
                    Socket.init(robot_name, job_instance, oplet_array_or_string);
                }, 100);
            }
        }
    } //end of send method
    /* apr 2019: sim calls on_receive now
    static on_receive_sim(robot_status_in_arcseconds, robot_name){ //robot_status_in_arcseconds might also be an ack_array, wbich doens't have any degrees, and won't be converted. or modified.
        let rob = Robot[robot_name]
        let sim_actual = Robot.get_simulate_actual(rob.simulate)
        if(sim_actual === true) { //don't include "both"
            Socket.convert_robot_status_to_degrees(robot_status_in_arcseconds) //modifies its input
            rob.robot_done_with_instruction(robot_status_in_arcseconds) //now robot_status_in_arcseconds is really in degrees
        }
        //else {} rob.simulate will be "both", so let the real Dexter supply the call to
        //rob.robot_done_with_instruction and the rs_status from Dexter, not the simulated one.
    }*/

    //called both from Dexter returning, and from Sim.
    //data should be a Buffer object. https://nodejs.org/api/buffer.html#buffer_buffer
    //payload_string_maybe is undefined when called from the robot,
    //and if called from sim and we have an "r" oplet, it is either a string (everything ok)
    //or a positive integer (1) when sim get file-not-found.
    //
    static on_receive(data, payload_string_maybe, dexter_instance){
        //data.length == 240 data is of type: Uint8Array, all values between 0 and 255 inclusive
        //console.log("Socket.on_receive passed data:        " + data)
        let robot_status;
        let oplet;
        if(Array.isArray(data)) {  //todo return from sim same data type as Dexter returns.   //a status array passed in from the simulator
            robot_status = data;
            oplet = robot_status[Dexter.INSTRUCTION_TYPE];
        }
        else { //a Uint8Array when called from the robot.
            let view1 = new Int32Array(data.buffer); //array_buff1.bytelength / 4); //weird google syntax for getting length of a array_buff1
            robot_status = [];
            for(var i = 0; i < view1.length; i++){
                var elt_int32 = view1[i];
                robot_status.push(elt_int32);
            }
            let opcode = robot_status[Dexter.INSTRUCTION_TYPE];
            oplet  = String.fromCharCode(opcode);
        }
        //console.log("Socket.on_receive passed DU robot status: " + robot_status)
        //the simulator automatically does this so we have to do it here in non-simulation
        //out("on_receive got back oplet of " + oplet)
        robot_status[Dexter.INSTRUCTION_TYPE] = oplet;
        if(oplet == "r"){ //Dexter.read_file
            if(typeof(payload_string_maybe) == "number") { //only can hit im sim.// should be 2 if it hits
                robot_status[Dexter.ERROR_CODE] = 0; //even though we got an error from file_not_found,
                //don't set the error in the robot status. Just let that error
                //be used in r_payload_grab_aux which passes it to got_content_hunk
                //which sets the user data to the error code and
                // read_file_instance.is_done = true
                //so the loop in read_file_instance terminates normally.
            }
            else if ((payload_string_maybe === undefined) && //real. not simulated
                     (robot_status[Dexter.ERROR_CODE] > 0)) { //got an error, probably file not found
                payload_string_maybe = robot_status[Dexter.ERROR_CODE];
                robot_status[Dexter.ERROR_CODE] = 0;
            }
            //now robot_status does NOT have an error code, but if there is an error,
            //payload_string_maybe is an int > 0
            //but if no error, payload_string_maybe is a string
            Socket.r_payload_grab(data, robot_status, payload_string_maybe);
        }
        else {
            Socket.convert_robot_status_to_degrees(robot_status);
        }

        //the below line became unnecessary, and too complex, too hieruasic once we
        //changed capturing the dexter_instance in the closure that is the wrapper
        //for the call to on_received, in Socket.init
        //let rob = this.find_dexter_instance_from_robot_status(robot_status) //= Dexter[robot_name]
        if (oplet === "F") {
            dexter_instance.waiting_for_flush_ack = false;
        }
        let job_id = robot_status[Dexter.JOB_ID];
        Job.job_id_to_job_instance(job_id);
        //out(job_instance.name + " " + rob.name + " bottom of Socket.on_receive with: " + robot_status)
        dexter_instance.robot_done_with_instruction(robot_status); //robot_status ERROR_CODE *might* be 1
    }

    //this is needed bacause we might have an instruction like Dexter.dexter2.move_all_joints()
    //the enclosing job might not have that dexter as its default robot,
    //or might not even have a Dexter instance as the Job robot at all.
    //so we want to first check the instruction to see if it has a robot.
    //if so. use it, if not, go for the default robot for the job and if that is an instance
    //of Dexter, use it, else error with shouldnt
    //uPDATE JUl 18, 2021
    //now unnecessary due to the Socket.init closure for on_receive capturiing the
    //dexter intstnace and passing it to on_receive,
    //BUT this code might come in handy some day
    /*
    static find_dexter_instance_from_robot_status(robot_status){
        let job_id       = robot_status[Dexter.JOB_ID]
        let job_instance = Job.job_id_to_job_instance(job_id)
        if(!job_instance){
            shouldnt("Socket.find_dexter_instance_from_robot_status passed: " + oplet_array_or_string +
                "<br/>extracted job_id:" + job_id + " but there is no defined Job with that ID.")
        }
        let instr_id     = robot_status[Dexter.INSTRUCTION_ID]
        let rob
        if(instr_id === -1) { //the initial g instruction, only sent when a Job has as its robot, a dexter
           rob = job_instance.robot
        }
        else {
            let instr = job_instance.do_list[instr_id]
            rob = instr.robot //this is the best we can do if there's a robot indicated in the instr
            if(!rob) {
                if(Array.isArray(instr)) {
                    let last_elt = last(instr)
                    if(last_elt instanceof Dexter){
                        rob = last_elt
                    }
                    else {
                        rob = job_instance.robot
                    }
                }
                else if(job_instance.robot instanceof Dexter) { //next best we can do
                    rob = job_instance.robot
                }
                else {
                    shouldnt("Socket.find_dexter_instance_from_robot_status 2 couldn't find robot from: " + robot_status +
                             "<br/>using Job.id: " + job_id + " Job.name: " + job_instance.name +
                             "<br/>instr id: " + instr_id + " instruction: " + instr)
                }
            }
        }
        return rob
    }*/

    static r_payload_grab(data, robot_status, payload_string_maybe) {
        if(payload_string_maybe === undefined) { //only in real, not in sim
            let payload_length = robot_status[Socket.PAYLOAD_LENGTH];
            let data_start = Socket.PAYLOAD_START;
            let data_end = data_start + payload_length;
            payload_string_maybe = data.slice(data_start, data_end).toString();
        }
        else if (payload_string_maybe instanceof Buffer) { //beware, sometimes payload_string_maybe is a buffer. This converts it to a string.
            payload_string_maybe = payload_string_maybe.toString();
        }
        //else { payload_string_maybe is normally a string, but could be an integer of > 0 if there's an error }
        Socket.r_payload_grab_aux(robot_status, payload_string_maybe);  //payload_string still might be an integer error code, ie 1 when file not found
    }

    //payload_string_maybe could be a string or an integer error code like 1 when no file found
    static r_payload_grab_aux(robot_status, payload_string_maybe){
        let job_id = robot_status[Dexter.JOB_ID];
        let ins_id = robot_status[Dexter.INSTRUCTION_ID];
        Instruction$1.Dexter.read_file.got_content_hunk(job_id, ins_id, payload_string_maybe);
    }

    static convert_robot_status_to_degrees(robot_status){
        let raw_status_mode = robot_status[Dexter.STATUS_MODE];
        //out("convert_robot_status_to_degrees got raw_status_mode of: " + raw_status_mode)
        if((raw_status_mode === null) || (raw_status_mode === 0) || (raw_status_mode === "0")){
            robot_status[Dexter.STATUS_MODE] = 0;
            if (robot_status.length == Dexter.robot_status_labels.length){
                robot_status[Dexter.J1_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J1_ANGLE], 1); //0.0002777777777777778 //this number === _arcsec
                robot_status[Dexter.J2_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J2_ANGLE], 2);
                robot_status[Dexter.J3_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J3_ANGLE], 3);
                robot_status[Dexter.J4_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J4_ANGLE], 4);
                robot_status[Dexter.J5_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J5_ANGLE], 5);

                robot_status[Dexter.J1_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J1_DELTA], 1);
                robot_status[Dexter.J2_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J2_DELTA], 2);
                robot_status[Dexter.J3_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J3_DELTA], 3);
                robot_status[Dexter.J4_DELTA] *= 0.00001736111111111111;   //todo get the "S" interpolation values from Defaults.make_ins instead  ie robot_status[Dexter.J4_DELTA] *= _arcsec / the_make_int_number
                robot_status[Dexter.J5_DELTA] *= 0.00001736111111111111;   //for this one too.

                robot_status[Dexter.J1_PID_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J1_PID_DELTA], 1);
                robot_status[Dexter.J2_PID_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J2_PID_DELTA], 2);
                robot_status[Dexter.J3_PID_DELTA] = Socket.dexter_units_to_degrees(robot_status[Dexter.J3_PID_DELTA], 3);
                robot_status[Dexter.J4_PID_DELTA] *= 0.00001736111111111111;  //for this one too.
                robot_status[Dexter.J5_PID_DELTA] *= 0.00001736111111111111;  //for this one too.

                robot_status[Dexter.J1_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J1_MEASURED_ANGLE], 1);
                robot_status[Dexter.J2_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J2_MEASURED_ANGLE], 2);
                robot_status[Dexter.J3_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J3_MEASURED_ANGLE], 3);
                robot_status[Dexter.J4_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J4_MEASURED_ANGLE], 4);
                robot_status[Dexter.J5_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J5_MEASURED_ANGLE], 5);
                robot_status[Dexter.J6_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J6_MEASURED_ANGLE], 6);
                robot_status[Dexter.J7_MEASURED_ANGLE] = Socket.dexter_units_to_degrees(robot_status[Dexter.J7_MEASURED_ANGLE], 7);

                robot_status[Dexter.J1_SENT] = Socket.dexter_units_to_degrees(robot_status[Dexter.J1_SENT], 1); //0.0002777777777777778 //this number === _arcsec
                robot_status[Dexter.J2_SENT] = Socket.dexter_units_to_degrees(robot_status[Dexter.J2_SENT], 2);
                robot_status[Dexter.J3_SENT] = Socket.dexter_units_to_degrees(robot_status[Dexter.J3_SENT], 3);
                robot_status[Dexter.J4_SENT] = Socket.dexter_units_to_degrees(robot_status[Dexter.J4_SENT], 4);
                robot_status[Dexter.J5_SENT] = Socket.dexter_units_to_degrees(robot_status[Dexter.J5_SENT], 5);

            }
        }
        //else not g0 so no conversion
    }

    static close(robot_name, force_close=false){
        let rob = Robot$1[robot_name];
        const sim_actual = Robot$1.get_simulate_actual(rob.simulate);
        if ((sim_actual === false) || (sim_actual === "both")){
           if((rob.active_jobs_using_this_robot().length == 0) || force_close){
                const net_soc_inst = Socket.robot_name_to_soc_instance_map[robot_name];
                if(net_soc_inst){
                    net_soc_inst.removeAllListeners();
                    net_soc_inst.destroy();
                    delete Socket.robot_name_to_soc_instance_map[robot_name];
                }
            }
        }
    }

    static prepare_for_re_init(robot_name){
            let rob = Robot$1[robot_name];
            const sim_actual = Robot$1.get_simulate_actual(rob.simulate);
            if ((sim_actual === false) || (sim_actual === "both")){
                 const net_soc_inst = Socket.robot_name_to_soc_instance_map[robot_name];
                 if(net_soc_inst){
                     net_soc_inst.removeAllListeners();
                     net_soc_inst.destroy();
                     delete Socket.robot_name_to_soc_instance_map[robot_name];
                 }
            }
    }

    /*this causes DexRun to crash. Ultimately we need to rewrite FPGA code to get this functionality.
    static empty_instruction_queue_now(robot_name){
        let rob = Robot[robot_name]
        const sim_actual = Robot.get_simulate_actual(rob.simulate)
        if ((sim_actual === true) || (sim_actual === "both")){ //simulation
            DexterSim.empty_instruction_queue_now(robot_name)
        }
        if ((sim_actual === false) || (sim_actual == "both")){
            const soc_inst = Socket.robot_name_to_soc_instance_map[robot_name]
            if(soc_inst && !soc_inst.destroyed){
                const oplet_array = make_ins("E") //don't expect to hear anything back from this.
                const arr_buff = this.oplet_array_or_string_to_array_buffer(oplet_array)
                try { soc_inst.write(arr_buff) } //band-aid for not knowing what's in Dexter's queue.
                                              //if the queue is empty we shouldn't do.
                                              //we should empty the queue whenever DDE detects an error,
                                              //but before closing the socket.
                catch(err) {
                    warning("Writing to the robot: " + robot_name +
                            " while emptying its queue failed, but that may be ok.")
                }
            }
        }
    }*/
};

//Socket.robot_is_waiting_for_reply = {} //robot_name to boolean map.
//Socket.max_dur_to_wait_for_reply_ms = 200

Socket$1.connect_timeout_seconds = 1;
Socket$1.PAYLOAD_START = 7 * 4; //7th integer array index, times 4 bytes per integer
Socket$1.PAYLOAD_LENGTH = 6; //6th integer array index

////Socket.resend_count = null

Socket$1.robot_name_to_soc_instance_map = {};
Socket$1.DEGREES_PER_DYNAMIXEL_320_UNIT = 0.29;   //range of motion sent is 0 to 1023
Socket$1.DEGREES_PER_DYNAMIXEL_430_UNIT = 360 / 4096;
Socket$1.J6_OFFSET_SERVO_UNITS = 512;
Socket$1.DEXTER_UNITS_PER_SECOND_FOR_SLEEP = 1000000; //ie microseconds

/*dexter0.joints = []
             joint_instances
                 motor_instance of a 2, 320, 430 or stepper
                        speed=30

                 min=-360
                 max=360
                 gear_ratio=1

                 convert_deg_to_dexter_units()
                 init() // ie like reboot_servo
                 set_indicator(val)   //ie turn on LED for J6
 */



//Socket.on_receive_added = false

/* Created by Fry on 3/29/16. */


var Robot$1 = class Robot {
    constructor (args){
       if(!is_string_an_identifier(args.name)) {
           dde_error('You have attempted to make a new Robot with an invalid name of: "' + args.name +
                     '".<br/>Robot names should start with a letter and be followed only by letters, digits, or underscores.');
       }
    }
    /*static robot_names(){
        var result = []
        for(var name in Robot){
            if (Robot[name] instanceof Robot){
                result.push(name)
            }
        }
        return result
    }
    */
    static all_robots(){
        let result = [];
        for(let robot_name of Robot.all_names) { result.push(Robot[robot_name]); }
        return result
    }
    //superclass can be a string name like "Dexter" or "Serial", OR it can be the class object.
    //returns true or false
    static is_valid_robot_class_name(robot_class_name) {
        return ["Brain", "Dexter", "Human", "Serial"].includes(robot_class_name)
    }
    static robot_instances_exist_for_running_instructions_of_superclass(superclass){
        let rob_class = ((typeof(superclass) == "string") ? value_of_path$1(superclass) : superclass);
        if ([Robot, Human].includes(rob_class)) { return true } //Robot and Human instructions can be run on any class of robot
        else { return rob_class.all_names.length > 0 }
    }

    //put the new item on the end, even if you have to remove it from the middle,
    //because we want the latest on the end for default_robot_name
    static set_robot_name(name, robot_instance){
        Robot[name] = robot_instance;
        //ensure name is on end of all_names
        let i = Robot.all_names.indexOf(name);
        if (i != -1){ Robot.all_names.splice(i, 1); }
        Robot.all_names.push(name);
        //for Make Instance dialog
        if ((i == -1) &&
             window["add_dexter_to_dexter_default_menu"] &&
            (robot_instance instanceof Dexter$1)) {
            add_dexter_to_dexter_default_menu(robot_instance);
        }
    }

    static get_simulate_actual(simulate_val){
        if      (simulate_val === true)   { return true   }
        else if (simulate_val === false)  { return false  }
        else if (simulate_val === "both") { return "both" }
        else if (simulate_val === null)   { return persistent_get$1("default_dexter_simulate") }
        else { shouldnt$1("get_simulate_actual passed illegal value: " + simulate_val); }
    }

    static simulate_or_both_selected(){
        if(persistent_get$1("default_dexter_simulate")) { return true} //persistent_get call returns true or "both"
        else { return false } //persistent_get call returns false
    }

    to_path(){ return "Robot." + this.name }

    jobs_using_this_robot(){
        let result = [];
        for (let j of Job$1.all_jobs()){
            if (j.robot === this){ result.push(j); }
        }
        return result
    }

    active_jobs_using_this_robot(){
        let result = [];
        for (let j of Job$1.all_jobs()){
            if ((j.robot === this) &&
                 j.is_active()){
                result.push(j);
            }
        }
        return result
    }

    //this is shadowed by Dexter, but all other robots are never busy.
    is_busy(){ return false }

    add_to_busy_job_array(a_job){ } //no-op. shadowed by Dexter.

    remove_from_busy_job_array(a_job){} //no-op. shadowed by Dexter.

    is_initialized(){ return true }

    //pretty weak. Only will work as long as Robots don't overlap in oplets
    //used in robot_history_status
    static instruction_type_to_function_name(ins_type){
        let fn_name = Dexter$1.instruction_type_to_function_name_map[ins_type];
        if (fn_name) {return "Dexter." + fn_name}
        fn_name = Serial$1.instruction_type_to_function_name_map[ins_type];
        if (fn_name) {return "Serial." + fn_name}
        return null
    }

    static is_oplet(oplet, known_oplet=false){
        if((typeof(oplet) === "string") && (oplet.length == 1)){
            if(known_oplet){
                if(Dexter$1.instruction_type_to_function_name_map[oplet]) {
                    return true
                }
                else { return false }
            }
            else { return true }
        }
        else { return false }
    }

    //Control Instructions
    static break(){ //stop a Control.loop
        return new Instruction$1.break()
    }
    static continue(){ //start next iteration of a Control.loop
        return new Instruction$1.continue()
    }
    static debugger(){
        return new Instruction$1.debugger()
    }
    static step_instructions(){
        return new Instruction$1.step_instructions()
    }
    static error(reason="Job stopped due to executing a Control.error instruction.",
                 perform_when_stopped=true){ //declare that an error happened. This will cause the job to stop.
        return new Instruction$1.error(reason, perform_when_stopped)
    }

    static go_to(instruction_location){
        return new Instruction$1.go_to(instruction_location)
    }

    static grab_robot_status(user_data_variable = "grabbed_robot_status",
                             starting_index = Serial$1.DATA0,
                             ending_index=null){
        return new Instruction$1.grab_robot_status(user_data_variable,
                                                         starting_index,
                                                         ending_index)
    }
    //very useful for grabbing rs from a preceeding instr in the do_list of my_serial.string_instruction("foo")
    grab_robot_status(user_data_variable = "grabbed_robot_status",
                      starting_index = Serial$1.DATA0,
                      ending_index=null){
        return new Instruction$1.grab_robot_status(user_data_variable,
                                                         starting_index,
                                                         ending_index,
                                                         this)
    }

    static if_any_errors(job_names=[], instruction_if_error=null){
        return new Instruction$1.if_any_errors(job_names, instruction_if_error)
    }
    static label(name="my_label"){
        return new Instruction$1.label(name)
    }

    static loop(boolean_int_array_fn=2, body_fn){
        return new Instruction$1.loop(boolean_int_array_fn, body_fn)
    }

    static out(val="", color="black", temp=false, print_job_info=false){
        return new Instruction$1.out(val, color, temp, print_job_info)
    }

    /* Warning the below is at least somewhat obsolete as of new arch Aug 25, 2016
    The workflow for sent_to_job.
     job.sent_to_job calls Instruction.Contol.sent_to_job as for all control instructions.
     That creates an instance to sent_to_job and sticks it on the source_job do_list.
     When that instruction is run, its do_item calls
     to_job_instance.destination_do_send_to_job(this) which sticks the
     do_list_item onto the destination job's do list,
     and, if the source job is going to wait for the instruction to be done,
     an additonal control instruction of type
     Instruction.destination_send_to_job_is_done is stuck on the do_list
     of the desitination job.
     Then the destination job runs those items
     and when the instruction destination_send_to_job_is_done is run,
     it calls the fns to get the values for the vars to set in from_instance,
     and calls from_job_instance.send_to_job_receive_done(this.params)
     passing those values to the from_instance.
     Then send_to_job_receive_done sets the user_data vars in the from job.
     */

    static send_to_job({do_list_item    = null,
                        where_to_insert = null,
                        wait_until_done = false, //if true, a_job.send_to_job_receive_done will be called when the do_list_item is done by the to_job
                        start           = false,
                        unsuspend       = false,
                        status_variable_name = null} = {}){
        return new Instruction$1.send_to_job(arguments[0])
    }

    //rarely used, but can be used to customize a job with additional do_list items at the start.
    static sent_from_job ({do_list_item        = null, //can be null, a single instruction, or an array of instructions
                           from_job_name       = null,
                           from_instruction_id = null,
                           where_to_insert     = "next_top_level", //just for debugging
                           wait_until_done     = false} = {}){
        return new Instruction$1.sent_from_job(arguments[0])
    }

    static set_inter_do_item_dur(dur, instructions_array){
        return new Instruction$1.set_inter_do_item_dur({dur: dur, instructions_array: instructions_array})
    }

    static start_job(job_name, start_options={}, if_started="ignore", wait_until_job_done=false){
        return new Instruction$1.start_job(job_name, start_options, if_started, wait_until_job_done)
    }

    static stop_job(instruction_location, reason, perform_when_stopped = true){
        return new Instruction$1.stop_job(instruction_location, reason, perform_when_stopped)
    }

    static include_job(job_name, start_loc=null, end_loc=null){
        return new Instruction$1.include_job(job_name, start_loc, end_loc)
    }

    static suspend(job_name = null, reason = ""){
        return new Instruction$1.suspend(job_name, reason)
    }
    //unsuspend is also instance meth on Job and should be!
    static unsuspend(job_name = "required", stop_reason=false){
        return new Instruction$1.unsuspend(job_name, stop_reason)
    }

    static sync_point(name, job_names=[]){
        return new Instruction$1.sync_point(name, job_names)
    }

    static wait_until(fn_date_dur=1){
        return new Instruction$1.wait_until(fn_date_dur)
    }

    //arg order is a bit odd because the headers come after the response_variable_name.
    //but the response_variable_name is takes the place of the primary callback,
    //and that's the order I have for get_page (headers on end) which very often
    //default to undefined.
    static get_page(url_or_options, response_variable_name="http_response"){
        if(url_or_options === undefined){
            dde_error("Control.get_page called with no <b>url_or_options</b> argument<br/>" +
                      "which is typically the string of a url.");
        }
        return new Instruction$1.Get_page(url_or_options, response_variable_name)
    }
    //static play(note_or_phrase){
    //    return new Instruction.play_notes(note_or_phrase)
    //}
    close_robot(){ //overridden in Serial and Dexter
    }

    static save_picture({canvas_id_or_mat="canvas_id",
                         path="my_pic.png"}={}) {
        return new Instruction$1.save_picture({canvas_id_or_mat: canvas_id_or_mat,
                                             path: path})
    }

    static show_picture({canvas_id="canvas_id", //string of a canvas_id or canvasId dom elt
                            content=null, //mat or file_path
                            title=undefined,
                            x=200, y=40, width=320, height=240,
                            rect_to_draw=null}={}) {
        return new Instruction$1.show_picture({canvas_id: canvas_id, //string of a canvas_id or canvas dom elt
                                                     content: content, //mat or file_path
                                                     title: title,
                                                     x: x,
                                                     y: y,
                                                     width: width,
                                                     height: height,
                                                     rect_to_draw: rect_to_draw})
    }

    static show_video({video_id="video_id", //string of a video_id or video dom elt
                        content="webcam", //"webcam" or file_path
                        title=undefined,
                        x=200, y=40, width=320, height=240,
                        play=true,
                        visible=true}={}) {
        return new Instruction$1.show_video({video_id: video_id, //string of a video_id or video dom elt
                                                    content: content, //mat or file_path
                                                    title: title,
                                                    x: x,
                                                    y: y,
                                                    width: width,
                                                    height: height,
                                                    play: play,
                                                    visible: visible})
    }
    static take_picture({video_id="video_id", //string of a video_id or video dom elt
                         camera_id=undefined,
                         width=320, height=240,
                         callback=Picture.show_picture_of_mat}={}) {
        return new Instruction$1.take_picture({video_id: video_id, //string of a video_id or video dom elt
                                             camera_id: camera_id,
                                             width: width,
                                             height: height,
                                             callback: callback})
    }
};
Robot$1.all_names = [];

Robot$1.robot_status_labels = []; //overridden by Serial and Dexter, needed by Show robot status history button

/*simulate vs non-simulate makes no difference so set simulate to false */
var Brain = class Brain extends Robot$1 { /*no associated hardware */
    constructor({name = "b1"}={}){
        super(arguments[0]);
        this.name = name;
        Robot$1.set_robot_name(this.name, this);
        let i = Brain.all_names.indexOf(this.name);
        if (i != -1) {  Brain.all_names.splice(i, 1); }
        Brain.all_names.push(this.name); //ensures the last name on the list is the latest with no redundancy
        Brain.last_robot = this;
        this.simulate = false;
        //the_job //a Robot can have at most 1 current job associated with it.
    }
    toString(){ return "Brain." + this.name }

    stringify(){
        return "Brain: <i>name</i>: " + this.name
    }
    start(job_instance) {
        job_instance.set_status_code("running");
        job_instance.set_up_next_do(0);
    }
    finish_job() {}

    send(inst_array_with_inst_id) {
        let job_id = inst_array_with_inst_id[Instruction$1.JOB_ID];
        var job_instance = Job$1.job_id_to_job_instance(job_id);
        var reason = "An instruction intended for a physical robot: " + inst_array_with_inst_id + "<br/>was sent to a Robot.Brain: " + this.name + ",<br/> which has no physical robot.";
        job_instance.stop_for_reason("errored", reason);
        out(reason, "red");
        throw new Error("send called on Robot.Brain, which has no physical robot.")
    }

    static eval_python(python_source, user_data_variable="python_value"){
        return [
            function() {
              let the_job = this;
              the_job.user_data[user_data_variable + "_python_source"] = python_source;
              Py.eval(python_source,
                function(json_obj){
                    the_job.user_data[user_data_variable] = json_obj.result;
                });
            },
            Control.wait_until(function() {
                      //out("this.user_data." + user_data_variable = ": " + this.user_data.[user_data_variable])
                      return this.user_data[user_data_variable] !== undefined})
            ]
    }
};

Brain.all_names = [];

var Human = class Human extends Brain { /*no associated hardware */
    constructor({name = "h1"}={}){
        super(arguments[0]);
        this.name = name;
        Robot$1.set_robot_name(this.name, this);
        let i = Human.all_names.indexOf(this.name);
        if (i != -1) {  Human.all_names.splice(i, 1); }
        Human.all_names.push(this.name); //ensures the last name on the list is the latest with no redundancy
        Human.last_robot = this;
        this.simulate = false;
        //the_job //a Robot can have at most 1 current job associated with it.
    }
    toString(){ return "Human." + this.name }

    stringify(){
        return "Human: <i>name</i>: " + this.name
    }
    start(job_instance) {
        job_instance.set_status_code("running");
        job_instance.set_up_next_do(0);
    }
    finish_job() {}
    send(inst_array_with_inst_id) {
        let job_id = inst_array_with_inst_id[Instruction$1.JOB_ID];
        var job_instance = Job$1.job_id_to_job_instance(job_id);
        var reason = "An instruction intended for a physical robot: " + inst_array_with_inst_id + "<br/>was sent to a Robot.Human: " + this.name + ",<br/> which has no physical robot.";
        job_instance.stop_for_reason("errored", reason);
        out(reason, "red");
        throw new Error("send called on Robot.Human, which has no physical robot.")
    }

    //the human instructions
    /*
    static recognize_speech ({title="Recognize Speech", prompt="",
                             only_once=true, click_to_talk=true,
                             width=430, height=270, x=400, y=200,
                             background_color="rgb(238, 238, 238)",
                             phrase_callback=recognize_speech_default_phrase_callback,
                             finish_callback=null,
                             finish_phrase="finish", //unused if only_once=true
                             user_data_variable_name="recognized_speech"
                             } = {}){ //
        let args = {title: title, prompt: prompt, only_once:only_once, click_to_talk: click_to_talk,
                    width:width, height: height, x: x, y: y,
                    background_color: background_color,  phrase_callback:  phrase_callback,
                    //finish_callback=null,   //unused if only_once=true does not have calLback on purpose
                    finish_phrase:"finish",
                    finish_callback: finish_callback,
                    user_data_variable_name: user_data_variable_name}
        return new Instruction.human_recognize_speech(args)
    }*/

    static speak ({speak_data = "hello", volume = 1.0, rate = 1.0, pitch = 1.0,
                     lang = "en_US", voice = 0, wait = true} = {}){ //does not have calLback on purpose
        if (arguments[0].length > 0){ speak_data = arguments[0]; }
        let args = {speak_data: speak_data, volume: volume, rate: rate, pitch: pitch,
                    lang: lang, voice: voice, wait: wait};
        return new Instruction$1.human_speak(args)
    }


    static task({task = "", dependent_job_names=[],
                 title, x=200, y=200, width=400, height=400,
                 background_color = "rgb(238, 238, 238)",
                 add_stop_button=true} = {}){
        return new Instruction$1.human_task(arguments[0])
    }

    static enter_choice({
        task = "",
        choices=[["Yes", true], ["No", false]],
        show_choices_as_buttons=false,
        one_button_per_line=false,
        user_data_variable_name="a_choice",
        dependent_job_names=[],
        add_stop_button=true,
        title,
        x=200, y=200, width=400, height=400,
        background_color = "rgb(238, 238, 238)"} = {}){
        return new Instruction$1.human_enter_choice(arguments[0])
    }

    static enter_filepath({task = "",
                           user_data_variable_name="a_filepath",
                           initial_value="",
                           add_stop_button = true,
                           dependent_job_names=[],
                           title, x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"} = {}){
        return new Instruction$1.human_enter_filepath(arguments[0])
    }

    static enter_instruction({task = "Enter a next instruction for this Job.",
        instruction_type = "Dexter.move_all_joints",
        instruction_args = "5000, 5000, 5000, 5000, 5000",
        add_stop_button=true,
        dependent_job_names = [],
        title, x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"}={}){
        return new Instruction$1.human_enter_instruction(arguments[0])
    }

    static enter_number({task="",
        user_data_variable_name="a_number",
        initial_value=0,
        min=0,
        max=100,
        step=1,
        add_stop_button = true,
        dependent_job_names=[],
        title, x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"}={}) {
        return new Instruction$1.human_enter_number(arguments[0])
    }

    static enter_position({task="Position Dexter&apos;s end effector<br/>to the position that you want to record,<br/>and click <b>Continue Job</b>.",
                           user_data_variable_name="a_position",
                           add_stop_button = true,
                           dependent_job_names=[],
                           title, x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"}={}) {
        return [Dexter$1.empty_instruction_queue,
               Dexter$1.set_follow_me,
               new Instruction$1.human_enter_position(arguments[0])
              ]
    }

    static enter_text({task="",
        user_data_variable_name="a_text",
        add_stop_button = true,
        initial_value="OK",
        line_count=1, //if 1, makes an input type=text. If > 1 makes a resizeable text area.
        dependent_job_names=[],
        title,
        close_same_titled_windows = false,
        x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"}={}){
        return new Instruction$1.human_enter_text(arguments[0])
    }

    static notify({task="",
        window=true,
        output_pane=true,
        beep_count=0,
        speak=false,
        add_stop_button=true,
        dependent_job_names=[],
        title,
        close_same_titled_windows = false,
        x=200, y=200, width=400, height=400,  background_color = "rgb(238, 238, 238)"
    }={}){
        return new Instruction$1.human_notify(arguments[0])
    }
    static show_window({content=`<input type="submit" value="Done"/>`,
                        title="DDE Information",
                        x=200, y=200, width=400, height=400,
                        background_color = "rgb(238, 238, 238)",
                        is_modal = false,
                        show_close_button = true,
                        show_collapse_button = true,
                        trim_strings = true,
                        add_stop_button=true,
                        callback = window.show_window_values,
                        user_data_variable_name="show_window_vals",
                        dependent_job_names=[]
    }={}){
        return new Instruction$1.human_show_window({
            content: content,
            title: title,
            x: x, y: y, width: width, height: height,
            background_color:        background_color,
            is_modal:                is_modal,
            show_close_button:       show_close_button,
            show_collapse_button:    show_collapse_button,
            trim_strings:            trim_strings,
            add_stop_button:         add_stop_button,
            callback:                callback,
            user_data_variable_name: user_data_variable_name,
            dependent_job_names:     dependent_job_names
    })
    }
};

Human.all_names = [];

var Serial$1 = class Serial extends Robot$1 {
    constructor({name = "s1", simulate = null, //get sim val from Jobs menu item check box.
                 sim_fun = return_first_arg, path = "required", connect_options={},
                 capture_n_items = 1, item_delimiter="\n", trim_whitespace=true,
                 parse_items = true, capture_extras = "error", /*"ignore", "capture", "error"*/
                 instruction_callback = Job$1.prototype.set_up_next_do }={}){
        super(arguments[0]);
        let keyword_args = {name: name, simulate: simulate, sim_fun: sim_fun, path: path, connect_options: connect_options,
                            capture_n_items: capture_n_items, item_delimiter: item_delimiter, trim_whitespace: trim_whitespace,
                            parse_items: parse_items, capture_extras: capture_extras,
                            instruction_callback: instruction_callback};
        this.make_new_robot_1(keyword_args);
        let old_same_named_robot = Robot$1[name];
        let old_same_path_robot  = Serial.get_robot_with_path(path);
        if (old_same_named_robot){
            if (old_same_named_robot.active_jobs_using_this_robot().length > 0){
                if(Serial.robots_equivalent(old_same_named_robot, this)){
                    warning("There's already a robot with the name: " + name +
                            ",<br/>that is a serial robot that has an active job " +
                            "<br/>so that's being used instead of a new Robot.Serial instance.<br/>" +
                            "Stop a job by clicking on its button in the Output pane's header.");
                    return old_same_named_robot
                }
                else { //same name, active jobs, different robot characteristics
                    dde_error("Attempt to create Robot.Serial with name: " + name +
                              "<br/>but there is already a robot with that name with different properties " +
                              "that is active.<br/>" +
                              "Stop a job by clicking on its button in the Output pane's header."
                              );
                }
            }
            else { //same name but no active jobs
                old_same_named_robot.close_robot();
                return this.make_new_robot_2()
            }
        }
        else if(old_same_path_robot) {
            if (old_same_path_robot.active_jobs_using_this_robot().length > 0){
                dde_error("There's already a robot named: " +  old_same_path_robot.name +
                        " that has an active job.");
            }
            else {
                old_same_path_robot.close_robot();
                return this.make_new_robot_2()
            }
        }
        else { //no same named or same pathed robot
            return this.make_new_robot_2()
        }
    }
    toString(){ return "Serial." + this.name }

    make_new_robot_1(keyword_args){
        this.name                  = keyword_args.name;
        this.path                  = keyword_args.path;
        this.connect_options       = keyword_args.connect_options;
        this.capture_n_items       = keyword_args.capture_n_items;
        this.item_delimiter        = keyword_args.item_delimiter;
        this.trim_whitespace       = keyword_args.trim_whitespace;
        this.parse_items           = keyword_args.parse_items;
        this.capture_extras        = keyword_args.capture_extras;
        this.simulate              = keyword_args.simulate;
        this.sim_fun               = keyword_args.sim_fun;
        this.instruction_callback  = keyword_args.instruction_callback;
    }
    make_new_robot_2(){
        this.is_connected          = false;
        this.connecting            = false;
        this.robot_status          = null;
        Robot$1.set_robot_name(this.name, this);
        let i = Serial.all_names.indexOf(this.name);
        if (i != -1) {  Serial.all_names.splice(i, 1); }
        Serial.all_names.push(this.name); //ensures the last name on the list is the latest with no redundancy
        Serial.last_robot = this;
        //if (this.simulate){
        //    let callback_number = cbr.store_callback(this.sim_fun)
        //    this.sim_fun_number  = callback_number
        //}
        return this
    }

    static robots_equivalent(rob1, rob2){
        if (rob1.constructor != rob2.constructor)          { return false }
        if (rob1.name            != rob2.name)             { return false }
        if (rob1.simulate        != rob2.simulate)         { return false }
        if (rob1.path            != rob2.path)             { return false }
        if (!similar(rob1.connect_options, rob2.connect_options))  { return false }
        if (rob1.capture_n_items != rob2.capture_n_items)  { return false }
        if (rob1.item_delimiter  != rob2.item_delimiter)   { return false }
        if (rob1.trim_whitespace != rob2.trim_whitespace)  { return false }
        if (rob1.parse_items     != rob2.parse_items)      { return false }
        if (rob1.capture_extras  != rob2.capture_extras)   { return false }
        if (!similar(rob1.instruction_callback, rob2.instruction_callback)) { return false }
        if (!similar(rob1.sim_fun, rob2.sim_fun))            { return false }
        return true
    }

    static get_robot_with_path(path){
        for(let robot_name of Serial.all_names){
            let rob = Robot$1[robot_name];
            if (rob.path == path) { return rob} //there should be at most 1
        }
        return null
    }

    static get_job_with_robot_path(path){
        for(let job_name of Job$1.all_names){
            let job_instance = Job$1[job_name];
            if (job_instance.robot.path == path) { return job_instance} //there should be at most 1
        }
        return null
    }

    is_initialized(){ return this.is_connected }

    start(job_instance) { //fill in initial robot_status
        if (this.is_initialized()) {
            //unlike the other set_a_robot_instance_socket_id methods, we must pass job_instance
            //as a 2nd arg.
            Serial.set_a_robot_instance_socket_id(this.path, job_instance); //we don't now actually use socket_id outside of serial.js
        }
        else {
            serial_connect(this.path, this.connect_options, this.simulate, this.capture_n_items, this.item_delimiter, this.trim_whitespace, this.parse_items, this.capture_extras, job_instance);
        }
    }

    init(job_instance){
            this.connecting = true;
            serial_connect(this.path, this.connect_options, this.simulate, this.capture_n_items, this.item_delimiter, this.trim_whitespace, this.parse_items, this.capture_extras, job_instance);
        /*serial_init_one_info_map_item(this.path,
                                        this.options,
                                        this.simulate,
                                        this.capture_n_items,
                                        this.item_delimiter,
                                        this.trim_whitespace,
                                        this.parse_items,
                                        this.capture_extras)*/
        //this.is_connected = true //do this only in set_a_robot_instance_socket_id
    }

    ///called from Serial.start
    static set_a_robot_instance_socket_id(path, job_instance){ //do I really need the socket_id of a serial?
        let rob          = Serial.get_robot_with_path(path);
        //rob.socket_id    = socket_id
        rob.connecting   = false; //connection and is_connected will never both be true
        rob.is_connected = true;
        out("Connected to serial port at: " + rob.path, undefined, true);
        //let job_instance = Serial.get_job_with_robot_path(path) //beware, this means only 1 job can use this robot!
        if(job_instance) {
            if (job_instance.status_code === "starting") {
                job_instance.set_status_code("running");
                job_instance.set_up_next_do(0); //we don't want to increment because PC is at 0, so we just want to do the next instruction, ie 0.
            }
            //before setting it should be "starting"
            else if (job_instance.status_code === "running") {
                rob.perform_instruction_callback(job_instance); //job_instance.set_up_next_do() //initial pc value is 0.
            }
        }
    }

    send(ins_array){
        Robot$1.get_simulate_actual(this.simulate);
        let job_id       = ins_array[Serial.JOB_ID];
        let job_instance = Job$1.job_id_to_job_instance(job_id);
        if (this.connecting) {
            job_instance.set_up_next_do(0);
            out("Connecting to serial port at: " + this.path, undefined, true);
        }
        else if (!this.is_connected){
            //this.start(job_instance)
            out("Initializing serial port at: " + this.path, undefined, true);
            this.init(job_instance);
            job_instance.set_up_next_do(0);
        }
        else if (this.is_connected) { // || (sim_actual === true) || (sim_actual === "both"))  {
            job_instance.wait_until_instruction_id_has_run = job_instance.program_counter; //we don't want to continue the job until this instr is done.
            serial_send(ins_array, this.path, this.simulate, this.sim_fun); //ok time to finally run the instruction!
        }
        else {
            const job_inst = Instruction$1.job_of_instruction_array(ins_array);
            job_inst.stop_for_reason("errored",
                                     "Series Robot: " + this.name +
                                     " was sent an instruction to execute on path: " + this.path +
                                     " but this robot is not connected");
        }
    }

    perform_instruction_callback(job_instance){
        if (this.instruction_callback) { this.instruction_callback.call(job_instance); }
    }

    robot_done_with_instruction(robot_status){ //called from UI sockets
        let stop_time    = Date.now(); //the DDE stop time for the instruction, NOT Dexter's stop time for the rs.
        let job_id       = robot_status[Serial.JOB_ID];
        let job_instance = Job$1.job_id_to_job_instance(job_id);
        if (job_instance == null){
            job_instance.stop_for_reason("errored",
                      "Serial.robot_done_with_instruction passed job_id: " + job_id +
                      " but couldn't find a Job instance with that job_id.");

        }
        robot_status[Serial.INSTRUCTION_TYPE];
        let ins_id = robot_status[Serial.INSTRUCTION_ID]; //-1 means the initiating status get, before the first od_list instruction
        //let ins = ((ins_id >= 0) ? job_instance.do_list[ins_id] : null)
        let rob = this;
        //if (ins && ins.robot) { rob = ins.robot } //used when instruction src code has a subject of a robot isntance
       // else                  { rob = job_instance.robot } //get the default robot for the job
        //let op_let = String.fromCharCode(op_let_number)
        job_instance.record_sent_instruction_stop_time(ins_id, stop_time);
        if (!rob.is_connected) ; //ignore any residual stuff coming back from Serial robot
        //we don't want to change robot_status for instance because that will confuse
        //debugging in the case that we've had an error and want to close.
        //on the other hand, we want accurate info. Hmm, maybe the "residual" is
        //only comming for simulation and not from read dexter.
        //else if (ins_id == -1) {}
        else if (!(Array.isArray(robot_status))) {
            job_instance.stop_for_reason("errored",
                              "Serial.robot_done_with_instruction received a robot_status array: " +
                               robot_status + " that is not an array.");
            if (job_instance.wait_until_instruction_id_has_run === ins_id){ //we've done it!
                job_instance.wait_until_instruction_id_has_run = null; //but don't increment PC
            }
            rob.perform_instruction_callback(job_instance);
            return
        }
        else if (robot_status.length < Serial.DATA0){
            job_instance.stop_for_reason("errored",
                "Serial.robot_done_with_instruction received a robot_status array: " +
                robot_status + "<br/> of length: " + robot_status.length +
                " that is less than the : " + (Serial.DATA0 - 1) + " required.<br/>" + stringify_value$1(robot_status));
            if (job_instance.wait_until_instruction_id_has_run === ins_id){ //we've done it!
                job_instance.wait_until_instruction_id_has_run = null; //but don't increment PC
            }
            rob.perform_instruction_callback(job_instance);
            return
        }
        else {
            //job_instance.highest_completed_instruction_id = ins_id //now always done by set_up_next_do
            //job_instance.robot_status = robot_status
            rob.robot_status          = robot_status; //thus rob.robot_status always has the latest rs we got from Dexter.
            if (job_instance.keep_history){
                job_instance.rs_history.push(robot_status);
            }
            var error_code = robot_status[Serial.ERROR_CODE];
            if (error_code != 0){ //we've got an error
                job_instance.stop_for_reason("errored", "Robot status got error: " + error_code);
                if (job_instance.wait_until_instruction_id_has_run === ins_id){ //we've done it!
                    job_instance.wait_until_instruction_id_has_run = null; //but don't increment PC
                }
                rob.perform_instruction_callback(job_instance); //job_instance.set_up_next_do()
            }
            else { //the normal, no error, not initial case
                if (job_instance.wait_until_instruction_id_has_run === ins_id){ //we've done it!
                    job_instance.wait_until_instruction_id_has_run = null;
                    if (ins_id == job_instance.program_counter) {
                        rob.perform_instruction_callback(job_instance);// job_instance.set_up_next_do() //note before doing this, pc might be on last do_list item.
                        //but that's ok. increment pc and call do_next_item.
                    }
                    else {
                        shouldnt$1("In job: " + job_instance.name +
                            " \n robot_done_with_instruction got ins_id: " + ins_id +
                            " \n which matched wait_until_instruction_id_has_run " +
                            " \n but the PC wasn't the same. Its: "  + job_instance.program_counter);
                    }
                }
                else { //instr coming back is not a wait for,
                    // so its just a non-last instr in a group, so we shouldn't call do_next_item for it
                    //and don't even set robot_status from it. May 2016 decided to set robot status
                    //and history ... see above. status and history should be consistent
                    //but still status can get into a race condition with user code so
                    //am not fond of setting it. ask kent.
                    rob.perform_instruction_callback(job_instance); //job_instance.set_up_next_do() //calling this is mostly a no-op, because
                    //job_instance.wait_until_instruction_id_has_run should be set to
                    //something higher than this instr coming back.
                    //BUT in case the user has stopped the job or another job does so,
                    //then calling do_next_item here would actually stop the job.
                    //so this call to do_next_item will at most get down to the
                    //this.wait_until_instruction_id_has_run clause but never further.
                }
            }
        }
    }

    close_robot(){
        serial_disconnect(this.path);
        this.is_connected = false;
    }

    //called when a job is finished.
    //returns true if no jobs are connected to this robot, false otherwise
    finish_job(){
        if(this.active_jobs_using_this_robot().length == 0) {
            this.close_robot(); //don't do as we may want to use this serial robot for some other job.
            return true        //nope. close_robot just like Dexter robot does.
                               //starting a job with this robot will reconnect the serial port
        }
        else { return false }
    }

    stringify(){
        return "Serial: <i>name</i>: "  + this.name           + ", " +
            ", <i>path</i>: "  + this.path  + ", <i>is_connected</i>: " + this.is_connected +
            Serial.robot_status_to_html(this.robot_status, " on robot: " + this.name)
    }

    static robot_status_to_html(rs, where_from){
        return where_from + " robot_status: " + rs
    }



}; //end Serial class
Serial$1.all_names = [];
Serial$1.last_name = null;

Serial$1.robot_status_labels = [
    "JOB_ID",              // 0
    "INSTRUCTION_ID",      // 1
    "START_TIME",          // 2 //ms since jan 1, 1970? From Dexter's clock
    "STOP_TIME",           // 3 //ms since jan 1, 1970? From Dexter's clock
    "INSTRUCTION_TYPE",    // 4 //"oplet"

    "ERROR_CODE",          // 5   0 means no error.
    "DATA0",               // 6  data coming back from the board
    "DATA1",
    "DATA2",
    "DATA3",
    "DATA4",
    "DATA5",
    "DATA6",
    "DATA7",
    "DATA8",
    "DATA9"
];

Serial$1.robot_status_index_labels = [];
//its inefficient to have effectively 3 lists, but the sans-index list is good for
//short labels used in tables, and the index is nice and explicit
//for robot.robot_status[Dexter.foo_index] access
//The explicit Dexter.robot_status_index_labels is needed for a series.
Serial$1.make_robot_status_indices = function(){
    for(var i = 0; i < Serial$1.robot_status_labels.length; i++){
        var label = Serial$1.robot_status_labels[i];
        var index_label = "Series." + label; //+ "_INDEX"
        Serial$1[label] = i;
        Serial$1.robot_status_index_labels.push(index_label);
    }
};

Serial$1.make_robot_status_indices();

Serial$1.instruction_type_to_function_name_map = {
    I:"string_instruction" // "S" is used by Dexter and I isn't so use I just in case it helps in debugging.
};

Serial$1.string_instruction = function(instruction_string){
    if (typeof(instruction_string) != "string") {
        instruction_string = JSON.stringify(instruction_string);
    }
    return make_ins$1("I", instruction_string)
};

Serial$1.prototype.string_instruction = function(instruction_string){
    return new Instruction$1.Serial.string_instruction(instruction_string, this)
};

/*anticipate classes for Dexter2, etc.
//the pose matrix includes info on position and orientation
* */
var Dexter$1 = class Dexter extends Robot$1 {
    constructor({name = null,
                 simulate = null,
                 ip_address = null,
                 port = null,
                 pose = Vector$1.identity_matrix(4),
                 enable_heartbeat=true,
                 instruction_callback = Job$1.prototype.set_up_next_do}={}){
        for(let key in arguments[0]){
            if(!["name", "simulate", "ip_address", "port", "pose", "enable_heartbeat", "instruction_callback"].includes(key)){
                dde_error("Attempt to create a Dexter with an invalid argument of: " + key +
                          "<br/>Click on 'Dexter' to see its valid argument names.");
            }
        }
        if(!name) {
            name = Dexter.generate_default_name();
        }
        if((name.length == 1) && (name >= "A") && (name <= "Z")){
           dde_error("While construction a Dexter robot named: " + name +
                     "<br/>Sorry, you can't name a Dexter with a single upper case letter.");
        }
        if(!ip_address) { ip_address = persistent_get$1("default_dexter_ip_address"); }
        if(!port)       { port       = persistent_get$1("default_dexter_port"); }

        let keyword_args = {name: name,
                            simulate: simulate,
                            ip_address: ip_address,
                            port: port,
                            pose: pose,
                            enable_heartbeat: enable_heartbeat,
                            instruction_callback: instruction_callback };
        let old_same_named_robot = Robot$1[name];
        if (old_same_named_robot){
           if ((old_same_named_robot.ip_address === ip_address) &&
               (old_same_named_robot.port       === port)){
               if (old_same_named_robot.active_jobs_using_this_robot().length > 0){
                    warning("There's already a robot with the name: " + name +
                             ", with same ip_address and port that has active jobs " +
                             " so that's being used instead of a new Dexter instance.");
                    return old_same_named_robot
               }
               else {
                   old_same_named_robot.close_robot();
                   super(keyword_args //arguments[0]
                   );
                   return this.make_new_robot(keyword_args)
               }
            }
            else {//old_same_named_robot is same_named but has different ip address
               if (old_same_named_robot.active_jobs_using_this_robot().length > 0){
                   dde_error("Attempt to create a robot named: " + name +
                            " but there is already robot with that name that has active jobs " +
                             " but a different ip_address and/or port.");
               }
               else {
                   old_same_named_robot.close_robot();
                   super(keyword_args //arguments[0]
                   );
                   return this.make_new_robot(keyword_args)
               }
           }
        }
        else {//there's no same-named robot
            let old_same_ip_address_robot = Dexter.get_robot_with_ip_address_and_port(ip_address, port);
            if (old_same_ip_address_robot){
                if (old_same_ip_address_robot.active_jobs_using_this_robot().length > 0){
                    dde_error("Attempt to create a robot named: " + name +
                            " but a robot named: " + old_same_ip_address_robot.name +
                            " is already using that ip_address and port and has active jobs.");
                }
                else {
                    old_same_ip_address_robot.close_robot();
                    super(keyword_args //arguments[0]
                     );
                    return this.make_new_robot(keyword_args)
                }
            }
            else {//different name, unused ip_address and port
                super(arguments[0]);
                return this.make_new_robot(keyword_args)
            }
        }
    }

    static generate_default_name(){
        for(let i = 1; i < 1000000; i++) {
           let candidate_name = "dexter" + i;
           if(!Dexter[candidate_name]) {
                return candidate_name
           }
        }
        dde_error("When making an instance of Dexter,<br/>the first million default names are used.<br/> Probably something wrong.");
    }

    static class_init(){  //inits Dexter class as a whole. called by ready
        this.dexter_default_params =
            {name: "dex1",
             simulate: null,
             ip_address: null,
             port: null,
             pose: Vector$1.identity_matrix(4),
             enable_heartbeat: true,
             instruction_callback: Job$1.prototype.set_up_next_do
        };
    }

    toString(){ return "Dexter." + this.name }

    dexter_filepath(){
        if (operating_system == "win"){
            return "//" + this.ip_address + "/share"
        }
        else if (operating_system == "mac"){
            return "//" + this.ip_address + "/share" //probably wrong
        }
        else { //presume linux
            return "//" + this.ip_address + "/share" //probably wrong
         }
    }

    make_new_robot(keyword_args){
        this.name                  = keyword_args.name;
        this.ip_address            = keyword_args.ip_address;
        this.port                  = keyword_args.port;
        this.pose                  = keyword_args.pose;

        this.simulate              = keyword_args.simulate;
        this.instruction_callback  = keyword_args.instruction_callback;
        this.robot_status          = null; //now contains the heartbeat rs
        this.is_connected          = false;

        this.enable_heartbeat      = keyword_args.enable_heartbeat;
        this.waiting_for_heartbeat = false;
        this.heartbeat_timeout_obj = null;

        this.angles     = [0, 0, 0, 0, 0, 0, 0]; //used by move_to_relative, set by move_all_joints, move_to, and move_to_relative
        this.pid_angles = [0, 0, 0, 0, 0, 0, 0];
        //this.processing_flush = false //primarily used as a check. a_robot.send shouldn't get called while this var is true
        this.busy_job_array = [];
        Robot$1.set_robot_name(this.name, this);
         //ensures the last name on the list is the latest with no redundancy
        let i = Dexter.all_names.indexOf(this.name);
        if (i != -1) {  Dexter.all_names.splice(i, 1); }
        Dexter.all_names.push(this.name);
        Dexter.last_robot = this;
        return this
    }

    start(job_instance){
        //out("top of Dexter.start() for "+ job_instance.name)
        //let sim_actual = Robot.get_simulate_actual(this.simulate)
        //let this_robot = this
        //let this_job   = job_instance
        //if ([false, "both"].includes(sim_actual)){ //runnig in "real" not simulated.
              /*let ping = require('ping') //https://www.npmjs.com/package/ping
                ping.sys.probe(this.ip_address,
                                function(isAlive, err){
                                    if (isAlive) {
                                        if(job_instance.name == "set_link_lengths") { //don't attempt to set link lengths again!
                                            this_robot.start_aux(job_instance)
                                        }
                                        else { setTimeout(function(){
                                                            this_robot.set_link_lengths(this_job)
                                                          },
                                                          500)} //in case dexster is booting up, give it a chance to complete boot cycle
                                        //this_robot.use_ping_proxy(job_instance)
                                    }
                                    else if (err){
                                        this_job.stop_for_reason("errored_from_dexter_connect", "Ping on robot: " + this_robot.name + " errored with: " + err.message)
                                    }
                                    else {
                                        this_job.stop_for_reason("errored_from_dexter_connect", "Could not connect to Dexter.\nIf it is because Dexter is initializing,\ntry again in a minute,\nor click Misc pane 'simulate' button.", true)
                                        //3rd arg is true so that we will run the stop method for dex_read_file job,
                                        //so that this error of "not connected" will reset the orig editor files menu item.
                                    }
                                },
                               {timeout: 10}
                               )*/
          //new strategy: just let the socket interface test Dexter connectivity because ping fails on Linux
          //run same code for sim and real
        if(job_instance.name === "set_link_lengths") { //don't attempt to set link lengths again!
            this.start_aux(job_instance);
        }
        else {
            this.set_link_lengths(job_instance); //eventually calls start_aux
        }
        /*}
        else { //running in simulation
            if(job_instance.name == "set_link_lengths") { //don't attempt to set link lengths again!
                this_robot.start_aux(job_instance)
            }
            else {
                this_robot.set_link_lengths(this_job)
            }
        } //no actual connection to Dexter needed as we're only simulating, BUT
                                 //to keep similation as much like non-sim. due the same timeout.
       */
    }

    start_aux(job_instance) { //fill in initial robot_status
        //give it a bit of time in case its in the process of initializing
        /*let connect_success_cb = function(){ //give robot a chance to get its socket before doing the initial "g" send.
                        const sim_actual = Robot.get_simulate_actual(this_robot.simulate)
                        if(!this_robot.is_initialized()){ //bad. stop the job
                            if (this_robot.simulate === true){
                                this_job.stop_for_reason("errored_from_dexter_connect", "The job: " + this_job.name + " is using robot: " + this_robot.name +
                                    "<br/>\nwith simulate=true, but could not connect with the Dexter simulator.")
                            }
                            else if ((this_robot.simulate === false) || (this_robot.simulate === "both")){
                                this_job.stop_for_reason("errored_from_dexter_connect", "The job: " + this_job.name + " is using robot: " + this_robot.name +
                                "<br/>but could not connect with a Dexter robot at: " +
                                this_robot.ip_address + " port: " + this_robot.port +
                                "<br/>You can change this robot to <code>simulate=true</code> and run it.")
                            }
                            else if (this_robot.simulate === null){
                                if ((sim_actual === false) || (sim_actual === "both")){
                                    this_job.stop_for_reason("errored_from_dexter_connect", "The job: " + this_job.name + " is using robot: " + this_robot.name +
                                    '<br/>with the Misc Pane "Simulate?" radio button being: ' + sim_actual  +
                                    "<br/>but could not connect with Dexter." +
                                    "<br/>You can use the simulator by clicking 'simulate' in the Misc Pane header. ")
                                    out("Could not connect to Dexter.", "red")
                                }
                                else {
                                    this_job.stop_for_reason("errored_from_dexter_connect", "The job: " + this_job.name + " is using robot: " + this_robot.name +
                                              "<br/>\nwith a Jobs menu, 'Simulate?' value of 'true', " +
                                              "<br/>\nbut could not connect with the Dexter simulator.")
                                }
                            }
                            else {
                                shouldnt("Dexter.start got invalid simulate value of: " + this_robot.simulate +
                                         '.<br/>\nThe value values are: true, false, "both" and null.')
                            }

                        }
                        else { //good. normal case
                            //this_job.send(Dexter.get_robot_status(), this_robot)
                        } //the initial g stareting off the job
        }*/
        /* not needed if pass job_instance into Socket.init
             let connect_error_cb = function(){
             this_job.stop_for_reason("errored_from_dexter_connect",
                 "The job: " + this_job.name + " could not connect to Dexter." + this_robot.name)
        }
        this_robot.connect_error_cb = connect_error_cb*/
        let instruction_to_send_on_connect = Dexter.get_robot_status(); //the inital g instr
        Socket$1.init(this.name, job_instance, instruction_to_send_on_connect);
    }

    static get_robot_with_ip_address_and_port(ip_address, port){
        for(let robot_name of Dexter.all_names){
            let dex = Robot$1[robot_name];
            if (dex.ip_address && //note: if we have 2 Dexter instances that have the default ip_address of null and port of 5000, then we DON'T want to call them "at the same ip_address"
               (dex.ip_address == ip_address) &&
               (dex.port == port)){
                return dex //there should be at most 1
            }
        }
        return null
    }

    //return true if it is, false if it isn't and null if can't tell
    is_calibrated(){
        let sim_actual = Robot$1.get_simulate_actual(this.simulate);
        if(sim_actual === true) { return true } //simulation is always calibrated
        else if(this.rs === undefined) { return null } //calibration unknown
        else if (this.rs.supports_measured_angles()) {
                for(let j_deg of this.rs.measured_angles()){ //gets joint angles 1 through 5
                    if(j_deg != 0) { return true } //is calibrated
                }
                return false //not calibrated, ie all joint angles are 0
        }
        else { return null }
    }

    //returns null if don't know (because no job yet run,
    //otherwise gets the latest robot status run on this dexter,
    //and sees if its pointing down and returns true or false.
    //so null (don't know) is presumed to be false,
    //which is good for Dexter UI's call to this fn.
    /*is_pointing_down(){
        if(!this.rs) { return null }
        let measured_angles = this.rs.measured_angles(7)
        let angles_to_make_dexter_point_down = Kin.point_down(measured_angles)
        for(let j = 0; j < 5; j++){
            if(measured_angles[j] !== angles_to_make_dexter_point_down[j]){
                return false
            }
        }
        return true
    }*/

    //returns null if don't know (because no job yet run,
    //otherwise gets the latest robot status run on this dexter,
    //and sees if its pointing in "direction" and returns true or false.
    is_direction(direction=[0, 0, -1], //pointing down
                 tolerance_in_deg=0.01){
        if(!this.rs) { return null } //meaning we don't know what direction its pointing
        else { return Kin$1.is_direction(this.rs.measured_angles(5)) }
    }

    //______phui_button processing
    is_phui_button_down(){
        if(!this.robot_status) { return false }
        else {
            return ((this.robot_status[Dexter.END_EFFECTOR_IO_IN] & 1) === 1)
        }
    }

    /* changed to an instance variable on Dexter instances, may 18, 2021
    waiting_for_flush_ack(){
        let rob = this
        let instr = rob.instruction_to_send_on_connect
        if(instr) {
            if(Array.isArray(instr)){
                if(instr[Instruction.INSTRUCTION_TYPE] === "F"){
                    return true }
                else { return false }
            }
            else if (typeof(instr) === "string") { //we have a string, pull the "F" out of the string.
               let str_parts = instr.split(" ")
               let oplet = str_parts[4]
               if(oplet.startsWith("F")) { //might have a semicolon in the oplet.
                    return true
               }
               else { return false }
            }
            else { return false }
        }
        else { return false }
    }*/

    set_robot_status(robot_status) {
        let old_robot_status_button_down = this.is_phui_button_down(); //do this first before setting robot_status
        this.robot_status = robot_status; //thus rob.robot_status always has the latest rs we got from Dexter.
        if(window.platform == "dde"){
            if(this.rs) { this.rs.robot_status = robot_status; }
            else {
                this.rs = new RobotStatus$1({robot_status: robot_status});
            }
        }
        let new_robot_status_button_down = this.is_phui_button_down(); //tricky. Not the same as 2 lines up!
        if((!old_robot_status_button_down) &&
            new_robot_status_button_down) {
            this.time_of_last_phui_button_click_ms = Date.now();
        }
    }
    clear_time_of_last_phui_button_click_ms(){
        this.time_of_last_phui_button_click_ms = null;
    }

    /*candidate names:
    //phui_button_clicked
    //was_phui_button_clicked
    //was_phui_button_down
    //phui_button_clicked_but_not_processed
    This is the main fn called by job authors.
    It returns true if the phui button was pressed down since the
    last time this fn was called. THUS its an async input,
    so that the job author doesn't "miss" calling is_phui_button_down
    by not calling it at exactly the right time.
    */
    was_phui_button_down(){
        if(this.time_of_last_phui_button_click_ms) {
            this.clear_time_of_last_phui_button_click_ms();
            return true
        }
        else { return false }
    }
    seconds_since_phui_button_clicked(){
        if(!this.time_of_last_phui_button_click_ms) {
            return null
        }
        else {
            return (Date.now() - this.time_of_last_phui_button_click_ms) / 1000
        }
    }
    //end phui button processing

    run_heartbeat(){
        let this_dex = this;
        this.heartbeat_timeout_obj =
          setTimeout(function(){
            if (this_dex.finish_job()) ;
            else if (this_dex.waiting_for_heartbeat){ //stop recursive timeout
                out("Dexter " + this_dex.name + " did not receive a response to the heartbeat. Stopping Job.");
                //this_dex.is_connected      = false //should be done by stop_for_reaason and next item
                //this_dex.socket_id         = null  //should be done by stop_for_reaason and next item
                for (let job_instance of this.active_jobs_using_this_robot()){
                    job_instance.stop_for_reason("errored_from_dexter", "No heartbeat response from dexter hardware.");
                    job_instance.do_next_item();
                }
            }
            else if (this_dex.enable_heartbeat) { //everything ok. Note: user might disable heartbeat during a job so check here.
                let h_ins = Dexter.get_robot_status_heartbeat();
                let job_instance = this_dex.active_jobs_using_this_robot()[0];
                h_ins[Instruction$1.JOB_ID] = job_instance.job_id;
                h_ins[Instruction$1.INSTRUCTION_ID] = -4;
                this_dex.send(h_ins); //heartbeat associated with the last job created using this robot as its robot.
                this.waiting_for_heartbeat = true;
                this_dex.run_heartbeat();
            }
        }, Dexter.heartbeat_dur);
    }

    //called when a job is finished.
    //returns true if no jobs are connected to this robot, false otherwise
    finish_job(){
        if(this.active_jobs_using_this_robot().length == 0) {
            this.close_robot();
            return true
        }
        else { return false }
    }

    close_robot(){
        //out("top of Dexter.close_robot")
        //setTimeout(function(){
        //out("top of timeout fn Dexter.close_robot")
        clearTimeout(this.heartbeat_timeout_obj); //looks like not working
        this.waiting_for_heartbeat = false;
        this.heartbeat_timeout_obj = null;
        this.is_connected          = false;
        Socket$1.close(this.name, false); //must be before setting socket_id to null
        // delete Dexter[this.name] //don't do this. If the robot is still part of a Job,
        //and that job is inactive, then we can still "restart" the job,
        //and as such we want that binding of Robot.this_name to still be around.
        //}, 5000)
    }

    /* causes DexRun to crash. re-inswtate when FPGA code rewriten to support this
    empty_instruction_queue_now(){
        Socket.empty_instruction_queue_now(this.name)
    }*/

    //ins_array can be an oplet array or a raw string
    send(oplet_array_or_string){
        //var is_heartbeat = ins_array[Instruction.INSTRUCTION_TYPE] == "h"
        //let oplet = Instruction.extract_instruction_type(oplet_array_or_string)
        /*if (oplet === "F") { this.processing_flush = true } //ok even if flush is already true. We can send 2 flushes in a row if we like, that's ok. essentially only 1 matters
        if (this.processing_flush && (oplet !== "F")) {
            shouldnt(this.name + ".send called with oplet: " + oplet +
                     ", but " + this.name + ".processing_flush is true so send shouldn't have been called.")
        }*/
        //note: we send F instructions through the below.
        Socket$1.send(this.name, oplet_array_or_string);
    }

    perform_instruction_callback(job_instance){
        if (this.instruction_callback) { this.instruction_callback.call(job_instance); }
    }
    stringify(){
        return "Dexter: <i>name</i>: "  + this.name           +
               ", <i>ip_address</i>: "  + this.ip_address     + ", <i>port</i>: "         + this.port         + ",<br/>" +
               "<i>socket_id</i> "      + this.socket_id      + ", <i>is_connected</i>: " + this.is_connected + ", <i>waiting_for_heartbeat</i>: " + this.waiting_for_heartbeat +
               Dexter.robot_status_to_html(this.robot_status, " on robot: " + this.name)
    }

    ///called from Socket in ui
    static set_a_robot_instance_socket_id(robot_name){
        let rob          = Dexter[robot_name];
        //rob.socket_id    = socket_id
        rob.is_connected = true;
        //out("bottom of set_a_robot_instance_socket_id with rob.name: " + rob.name + " rob.is_connected: " + rob.is_connected)
    }

    //is_initialized(){ return ((this.socket_id || (this.socket_id === 0)) ? true : false ) }

    is_initialized(){
        //out("is_initialized() returning: " + this.is_connected)
       return this.is_connected
    }

    //Class: Dexter
    //beware, robot_status could be an ack, can could be called by sim or real
    //but if sim is "both", will only be called by real (from socket)
    robot_done_with_instruction(robot_status){ //called from UI sockets
        let job_id       = robot_status[Dexter.JOB_ID];
        let job_instance = Job$1.job_id_to_job_instance(job_id);
        let ins_id       = robot_status[Dexter.INSTRUCTION_ID]; //-1 means the initiating status get, before the first od_list instruction
        let oplet        = robot_status[Dexter.INSTRUCTION_TYPE];
        let error_code   = robot_status[Dexter.ERROR_CODE];
        let rob          = this; //job_instance.robot
        if(oplet === "F") {
            rob.waiting_for_flush_ack = false;
        }
        if (!(Array.isArray(robot_status))) { //note: we have to error here because we can't get the job
            //so we can't call stop_for_reason
            job_instance.stop_for_reason("errored_from_dexter",
                                 "Dexter.robot_done_with_instruction received a robot_status array: " +
                                  robot_status + " that is not an array.");
            job_instance.wait_until_instruction_id_has_run = null;
            job_instance.set_up_next_do(0);
            return
        }
        //rob.robot_status = robot_status //beware, is possibly the wrong length, but if so we're going to error, so might as well have that bad robot_status accessible for debugging
        rob.set_robot_status(robot_status); //makes RobotStatus updated too
        if (job_instance == null){
            shouldnt$1("In robot_done_with_instruction, got job_id: " + job_id +
                     " which does not refer to a valid Job instance.<br/>" +
                     "robot_status: " + robot_status);
        }
        else if (robot_status.length < Dexter.robot_status_labels.length){ //allows when_stopped action to run if any
            //if its longer than 60, ie 120, then we got 2 robot status's back.
            //just use the first 60 from the array.
            job_instance.condition_when_stopped = "errored_from_dexter";
            job_instance.stop_for_reason("errored_from_dexter",
                "Dexter.robot_done_with_instruction received a robot_status array: " +
                robot_status + "<br/> of length: " + robot_status.length +
                " that is not the proper length of: " + Dexter.robot_status_labels.length);
            job_instance.wait_until_instruction_id_has_run = null;
            job_instance.set_up_next_do(0);
            return
        }
        else if (job_instance.wait_until_instruction_id_has_run !== ins_id){
            job_instance.stop_for_reason("errored_from_dexter",
                "Dexter.robot_done_with_instruction received a robot_status array with an instruction_id of: " + ins_id +
                "<br/> but expected: " + job_instance.wait_until_instruction_id_has_run);
            job_instance.wait_until_instruction_id_has_run = null;
            job_instance.set_up_next_do(0);
            return
        }
        else if((error_code !== 0) && (oplet !== "r")){ //we've got an error
                //job_instance.stop_for_reason("errored", "Robot status got error: " + error_code)
            job_instance.wait_until_instruction_id_has_run = null; //but don't increment PC
            let instruction_to_run_when_error = job_instance.if_robot_status_error; //.call(job_instance, robot_status)
            if(instruction_to_run_when_error){
                //note instruction_to_run_when_error can be a single instruction or an array
                //of instructions. If its an array, we insert it as just one instruction,
                //and that will cause all to be run.
                job_instance.insert_single_instruction(instruction_to_run_when_error);
            }
            rob.perform_instruction_callback(job_instance); //job_instance.set_up_next_do()
            return
        }

        job_instance.wait_until_instruction_id_has_run = null;
        let busy_job_array_copy = rob.busy_job_array.slice();
        rob.clear_busy_job_array(); //so that the other jobs that I call set_up_next_do, won't hang up because they are busy,
         //because they no longer should be busy, because we got back our ack from Dexter that was keeping them busy,
        for(let busy_job of busy_job_array_copy){
            if(busy_job === job_instance) ; //let this pass through to the below as the passed in robot_status is from this instrr and this job_instance
            else {
               busy_job.set_up_next_do(0); //now execute the instr at the PC in an OTHER job, without advancing it.
               return
            }
        }
        if ((error_code !== 0) && (oplet === "r")){ //we have an error but its "file not found" handled specially
             //Dexter.read_file errored, assuming its "file not found" so end the rfr loop and set the "content read" as null, meaning file not found
                //the below setting of the user data already done by got_content_hunk
                //let rfr_instance = Instruction.Dexter.read_file.find_read_file_instance_on_do_list(job_instance, ins_id)
                // job_instance.user_data[ins.destination] = null //usually means "file not found"
                //rfr_instance.is_done = true
                this.perform_instruction_callback(job_instance); //calls set_up_next_do(1) but we want 0, because we want to give the Dexter.read_file instance code a chance to clean up before ending its loop
                //job_instance.set_up_next_do(0)
                return
        }
        if (oplet === "h") { //we got heartbeat acknowledgement of reciept by phys or sim so now no longer waiting for that acknowledgement
            rob.waiting_for_heartbeat = false;
            return
        }
        let stop_time    = Date.now(); //the DDE stop time for the instruction, NOT Dexter's stop time for the rs.
        job_instance.record_sent_instruction_stop_time(ins_id, stop_time);
       // if (!rob.is_connected) {} //ignore any residual stuff coming back from dexter
        //we don't want to change robot_status for instance because that will confuse
        //debugging in the case that we've had an error and want to close.
        //on the other hand, we want accurate info. Hmm, maybe the "residual" is
        //only comming for simulation and not from read dexter.
        //else if (ins_id == -1) {}
     // else {
        if (job_instance.keep_history && (oplet == "g")){ //don't do it for oplet "G", get_robot_status_immediate
                job_instance.rs_history.push(robot_status);
        }
        if(window.platform === "dde"){
            RobotStatusDialog.update_robot_status_table_maybe(rob); //if the dialog isn't up, this does nothing
        }

        if (job_instance.status_code === "starting") { //at least usually ins_id is -1
            job_instance.set_status_code("running");
            //pass robot_status because we *might* not be keeping it in the history
            //rob.perform_instruction_callback(job_instance)
            //if(job_instance.dont_proceed_after_initial_g) {//used by MakeInstruction
            //    MiRecord.start_is_done_with_initial_g_and_paused(job_instance)
            //}
            job_instance.set_up_next_do(0);//we've just done the initial g instr, so now do the first real instr. PC is already pointing at it, so don't increment it.
        }
        else if ((job_instance.status_code === "stopping") && (oplet === "F")){
            job_instance.stop_for_reason("interrupted", "Completed Dexter.empty_instruction_queue after user stopped the Job.");
            rob.perform_instruction_callback(job_instance);
        }
        else if (ins_id == job_instance.program_counter) { //the normal case.
            rob.perform_instruction_callback(job_instance);// job_instance.set_up_next_do() //note before doing this, pc might be on last do_list item.
                    //but that's ok. increment pc and call do_next_item.
        }
        else {
            shouldnt$1("In job: " + job_instance.name +
                " \n robot_done_with_instruction got ins_id: " + ins_id +
                " \n which matched wait_until_instruction_id_has_run " +
                " \n but the PC wasn't the same. Its: "  + job_instance.program_counter);
        }
    }

    //Dexter busy
    clean_up_busy_job_array(){
       let result = [];
       for(let a_job of this.busy_job_array){
            if(a_job.is_active()) { //remove inactive jobs from busy_job_array by preserviong the still active ones
                if(!result.includes(a_job)) { //remove duplicates
                    result.push(a_job);
                }
            }
       }
       this.busy_job_array = result;
    }

    //returns true or false
    is_busy(){
        this.clean_up_busy_job_array();
        return (this.busy_job_array.length > 0)
    }

    add_to_busy_job_array(a_job){
        if(!this.busy_job_array.includes(a_job)){
            this.busy_job_array.push(a_job);
        }
    }

    remove_from_busy_job_array(a_job){
        let i = this.busy_job_array.indexOf(a_job);
        if(i >= 0) { this.busy_job_array.splice(i, 1); }
    }

    //called when a job is finished. Note that we might have a
    //job that has, say a brain default robot but has instructions that are sent to a Dexter,
    //and Job.send still adds its Job to the busy_job_array of a Dexter,
    //so we better remove it from all Dexters' busy_job_array
    static remove_from_busy_job_arrays(a_job) {
        for(let dex_name of Dexter.all_names){
            let dex = Dexter[dex_name];
            dex.remove_from_busy_job_array(a_job);
        }
    }

    clear_busy_job_array(){
        this.busy_job_array = [];
    }
    //end robot_busy

    //Robot status accessors (read only for users)
    joint_angle(joint_number=1){
        switch(joint_number){
            case 1: return this.robot_status[Dexter.J1_MEASURED_ANGLE]
            case 2: return this.robot_status[Dexter.J2_MEASURED_ANGLE]
            case 3: return this.robot_status[Dexter.J3_MEASURED_ANGLE]
            case 4: return this.robot_status[Dexter.J4_MEASURED_ANGLE]
            case 5: return this.robot_status[Dexter.J5_MEASURED_ANGLE]
            default:
                dde_error("You called Robot." + this.name + ".joint_angle(" + joint_number + ")" +
                          " but joint_number must be 1, 2, 3, 4, or 5.");
        }
    }

    joint_angles(){
        let rs = this.robot_status;
        return [rs[Dexter.J1_MEASURED_ANGLE], rs[Dexter.J2_MEASURED_ANGLE], rs[Dexter.J3_MEASURED_ANGLE], rs[Dexter.J4_MEASURED_ANGLE], rs[Dexter.J5_MEASURED_ANGLE]]
    }

    joint_xyz(joint_number=5){
        let xyzs = this.joint_xyzs(); //note the first elt is the pos of the base, defaulting to 0,0,0
        return xyzs[joint_number]
    }
    joint_xyzs(){ //todo ask James about this
        return Kin$1.forward_kinematics(this.joint_angles(), this.pose)[0]
    }

    move_all_joints_fn(angle_array=Dexter.HOME_ANGLES, set_default_speed_first = true){
        let is_home_angles = similar(angle_array, Dexter.HOME_ANGLES);
        let do_list = [];
        if(set_default_speed_first) { do_list.push(make_ins$1("S", "MaxSpeed", 25)); }
        do_list.push(Dexter.move_all_joints(angle_array));
        if(is_home_angles) {
            do_list.push(Dexter.pid_move_all_joints([0, 0, 0, 0, 0])); //only do 5 joints here. let the angle_array's version of j6 and j7 dictate their movvement.
            do_list.push(Dexter.empty_instruction_queue());
        }
        new Job$1({name: "job_00", robot: this,
                 do_list: do_list}).start();
    }

    move_to_fn(xyz=[0,0,0], set_default_speed_first = true){
        let job_00;
        if (set_default_speed_first) {
            job_00 = new Job$1({name: "job_00", robot: this,
                              do_list: [make_ins$1("S", "MaxSpeed", 25),
                                        Dexter.move_to(xyz)
                                        ]
                     });
        }
         else {
            job_00 = new Job$1({name: "job_00", robot: this,
                              do_list: [Dexter.move_to(xyz)]
                     });
         }
        job_00.start();
    }
    run_instruction_fn(instr){
        const job_00 = new Job$1({name: "job_00",
            robot: this,
            do_list: [instr]
        });
        job_00.start();
    }
    /* The below is a smarter version of run_instruction_fn that just defines job_00 once,
       leaves it running and just adds the instruction to it the 2nd through nth times
       its called. BUT this screws up if you are togglein between
       running an instruction and running a regular job because the job_oo uses up the robot.
       So to avoid that interferance, I've gone back to just
       defining job_00 each time this fn is called and starting the job as above.
    run_instruction_fn(instr){
        let the_job = Job.job_00
        if (!the_job) { //job has yet to be defined in this session of dde, so define it
            the_job = new Job({name: "job_00",
                               robot: this,
                               when_do_list_done: "wait"})
        }
        if (!the_job.is_active()) { //job is defined but is not running so start it. Might be brand new or might have just stopped
            the_job.start()
        }
        Job.insert_instruction(instr, //finally add in the instr to run.
                               {job: "job_00",
                                offset: "end"})
        //now job_00 is just waiting for another instruction to be passed to it.
    }*/
};

Dexter$1.all_names = [];
Dexter$1.last_robot = null; //last Dexter defined.

Dexter$1.heartbeat_dur = 100; //milliseconds

//_______series robot_config ______
Dexter$1.LEFT            = [0, null, null];
Dexter$1.LEFT_DOWN       = [0, 0,    null];
Dexter$1.LEFT_UP         = [0, 1,    null];
Dexter$1.LEFT_IN         = [0, null, 0];
Dexter$1.LEFT_OUT        = [0, null, 1];
Dexter$1.LEFT_DOWN_IN    = [0, 0,    0];
Dexter$1.LEFT_DOWN_OUT   = [0, 0,    1];
Dexter$1.LEFT_UP_IN      = [0, 1,    0];
Dexter$1.LEFT_UP_OUT     = [0, 1,    1];

Dexter$1.RIGHT           = [1, null, null];
Dexter$1.RIGHT_DOWN      = [1, 0,    null];
Dexter$1.RIGHT_UP        = [1, 1,    null];
Dexter$1.RIGHT_IN        = [1, null, 0];
Dexter$1.RIGHT_OUT       = [1, null, 1];
Dexter$1.RIGHT_DOWN_IN   = [1, 0,    0];
Dexter$1.RIGHT_DOWN_OUT  = [1, 0,    1];
Dexter$1.RIGHT_UP_IN     = [1, 1,    0];
Dexter$1.RIGHT_UP_OUT    = [1, 1,    1];

Dexter$1.DOWN            = [null, 0, null];
Dexter$1.DOWN_IN         = [null, 0, 0];
Dexter$1.DOWN_OUT        = [null, 0, 1];
Dexter$1.UP              = [null, 1, null];
Dexter$1.UP_IN           = [null, 1, 0];
Dexter$1.UP_OUT          = [null, 1, 1];

Dexter$1.IN              = [null, null, 0];
Dexter$1.OUT             = [null, null, 1];


//__________INSTRUCTIONS______________
//called only for testing purposes. Goes all the way through to the simulate
//or dexter, unlike Job.error
Dexter$1.make_ins = make_ins$1;
Dexter$1.capture_ad     = function(...args){ return make_ins$1("c", ...args) };
Dexter$1.prototype.capture_ad = function(...args){ args.push(this); return Dexter$1.capture_ad(...args) };

Dexter$1.capture_points           = function(...args){ return make_ins$1("i", ...args) };
Dexter$1.prototype.capture_points = function(...args){ args.push(this); return Dexter$1.capture_points(...args) };

Dexter$1.cause_error              = function(error_code=1){ return make_ins$1("e", error_code) }; //fry made up. useful for testing
Dexter$1.prototype.cause_error    = function(error_code=1){ return make_ins$1("e", error_code, this) };

Dexter$1.draw_dxf;   //set to DXF.dxf_to_instructions in ready.js
Dexter$1.prototype.draw_dxf; //set in ready.js

Dexter$1.dummy_move = function(){
    let CMD = [];
    CMD.push(function(){return Dexter$1.get_robot_status()});
    CMD.push(function(){
        let rs = this.robot.robot_status; //Dexter.my_dex.robot_status
        let J_angles = [rs[Dexter$1.J1_MEASURED_ANGLE], rs[Dexter$1.J2_MEASURED_ANGLE], rs[Dexter$1.J3_MEASURED_ANGLE], rs[Dexter$1.J4_MEASURED_ANGLE], rs[Dexter$1.J5_MEASURED_ANGLE]];
        return Dexter$1.move_all_joints(J_angles)
    });
    return CMD
};

Dexter$1.prototype.dummy_move = function(){
    let robot = this;
    let CMD = [];
    CMD.push(function(){return robot.get_robot_status()});
    CMD.push(function(){
        let rs = robot.robot_status; //Dexter.my_dex.robot_status
        let J_angles = [rs[Dexter$1.J1_MEASURED_ANGLE], rs[Dexter$1.J2_MEASURED_ANGLE], rs[Dexter$1.J3_MEASURED_ANGLE], rs[Dexter$1.J4_MEASURED_ANGLE], rs[Dexter$1.J5_MEASURED_ANGLE]];
        return robot.move_all_joints(J_angles)
    });
    return CMD
};

//Dexter.run_gcode_workspace_pose_default = Vector.make_pose([0, 0.5, 0.1], [0, 0, 0], _mm)

Dexter$1.prototype.run_gcode = function({gcode = "",
                                       filepath = null,
                                       workspace_pose = Vector$1.make_pose([0, 0.5, 0.1], [0, 0, 0], _mm)}){
    return Dexter$1.run_gcode({gcode: gcode,
                             filepath:filepath,
                             workspace_pose: workspace_pose,
                             robot: this})
};

Dexter$1.run_gcode      = function({gcode = "", filepath = null, workspace_pose = Vector$1.make_pose([0, 0.5, 0.1], [0, 0, 0], _mm), robot=Dexter$1}){
                            return function(){
                                return Gcode.gcode_to_instructions({gcode: gcode,
                                                                    filepath: filepath,
                                                                    workspace_pose: workspace_pose,
                                                                    robot: robot})
                            }
                        };

Dexter$1.dma_read           = function(...args){ return make_ins$1("d", ...args) };
Dexter$1.prototype.dma_read = function(...args){ args.push(this); return Dexter$1.dma_read(...args) };

Dexter$1.dma_write           = function(...args){ return make_ins$1("t", ...args) };
Dexter$1.prototype.dma_write = function(...args){ args.push(this); return Dexter$1.dma_write(...args) };

Dexter$1.exit           = function(...args){ return make_ins$1("x", ...args) };
Dexter$1.prototype.exit = function(...args){ args.push(this); return Dexter$1.exit(...args) };


Dexter$1.empty_instruction_queue_immediately = function(){
        //return make_ins("E")
        let num = Instruction$1.w_address_name_to_number("RESET_PID_AND_FLUSH_QUEUE");
        if(num >= 0) {
            return [ Dexter$1.write_fpga(num, 1), //this flushes the queue
                     Dexter$1.write_fpga(num, 0)  //this resets the ode to normal so Dexter can accept new instructions
                   ]
        }
        else {
            shouldnt$1("Dexter.empty_instruction_queue_immediately could not find w name: RESET_PID_AND_FLUSH_QUEUE.");
        }
};
Dexter$1.prototype.empty_instruction_queue_immediately = function(...args){ args.push(this); return Dexter$1.empty_instruction_queue_immediately(...args) };

Dexter$1.empty_instruction_queue           = function() { return make_ins$1("F") };
Dexter$1.prototype.empty_instruction_queue = function(...args){ args.push(this); return Dexter$1.empty_instruction_queue(...args) };

Dexter$1.find_index           = function(...args){ return make_ins$1("n", ...args) };
Dexter$1.prototype.find_index = function(...args){ args.push(this); return Dexter$1.find_index(...args) };


//dec 6, 2020: this gives us backwards compatibility of
//Dexter.get_robot_status()
//Dexter.get_robot_status(rob)
//and also allows for
//Dexter.get_robot_status(1)
//Dexter.get_robot_status(rob)
//Dexter.get_robot_status(1, rob)
//Dexter.get_robot_status(null, rob)
Dexter$1.get_robot_status = function(status_mode = null){
                                if(typeof(status_mode) === "number") {
                                    return make_ins$1("g", status_mode)
                                }
                                else if((status_mode === null) || (status_mode === undefined)) {
                                    return make_ins$1("g")
                                }
                                else {
                                    dde_error("Dexter.get_robot_status called with invalid status mode: " +
                                               status_mode +
                                               "<br/>The valid status_modes are null or non-negative integers, usually 0 or 1.");
                                }
};

//must be different from Dexter.get_robot_status. See commment in Instruction.Dexter.get_robot_statu
Dexter$1.prototype.get_robot_status = function(status_mode = null){
                                        if((typeof(status_mode) != "number") &&
                                            (status_mode !== null)){
                                            dde_error("Dexter.get_robot_status called with invalid status mode: " +
                                                       status_mode +
                                                       "<br/>The valid status_modes are null or non-negative integers, usually 0 or 1.");
                                        }
                                        else {
                                            return new Instruction$1.Dexter.get_robot_status(status_mode, this)
                                        }
};


    //this forces do_next_item to wait until robot_status is
    //updated before it runs any more do list items.
Dexter$1.get_robot_status_heartbeat           = function(){ return make_ins$1("h") };//never called by user do_list items. Only called by system
Dexter$1.prototype.get_robot_status_heartbeat = function(){ return Dexter$1.get_robot_status_heartbeat(this) };

Dexter$1.get_robot_status_immediately           = function(){ return make_ins$1("G") }; //deprecated
Dexter$1.prototype.get_robot_status_immediately = function(){ return Dexter$1.get_robot_status_immediately(this) }; //deprecated

//pass in an array of up to 5 elts OR up to 5 separate args.
//If an arg is not present or null, keep the value now in dexer_status unchanged.
//EXCEPT if no args passed in, set to home position.
Dexter$1.load_tables     = function(...args){ return make_ins$1("l", ...args) }; //
//loads the data created from calibration onto the SD card for persistent storage.
Dexter$1.prototype.load_tables = function(...args){ args.push(this); return Dexter$1.load_tables(...args) };


Dexter$1.joint_to_servo_number_map = {6: 3, 7: 1};
Dexter$1.joint_to_servo_number = function(joint_number){
    return Dexter$1.joint_to_servo_number_map[joint_number]
};
Dexter$1.servo_to_joint_number = function(servo_number){
    for(let a_joint_number in Dexter$1.joint_to_servo_number_map){
       let a_servo_number = Dexter$1.joint_to_servo_number_map[a_joint_number];
       if(a_servo_number === servo_number) { return parseInt(a_joint_number) }
    }
    return undefined
};
//the instruction
Dexter$1.reboot_joints = function(joint_number_array="all"){
   if(joint_number_array === "all") {
       joint_number_array = Object.getOwnPropertyNames(Dexter$1.joint_to_servo_number_map);
       for(let i = 0; i < joint_number_array.length; i++){
           joint_number_array[i] =  parseInt(joint_number_array[i]);
       }
   }
   let instrs = [];
   for(let joint_number of joint_number_array){
       instrs.push(
            Dexter$1.set_parameter("RebootServo", Dexter$1.joint_to_servo_number(joint_number)));
       instrs.push(Dexter$1.sleep(1)); //sleep for 1 sec to allow dynamixel bus to settle
   }
   return instrs
};

Dexter$1.prototype.reboot_joints = function(joint_number_array="all"){
    if(joint_number_array === "all"){
        joint_number_array = Object.getOwnPropertyNames(Dexter$1.joint_to_servo_number_map);
        for(let i = 0; i < joint_number_array.length; i++){
            joint_number_array[i] =  parseInt(joint_number_array[i]);
        }
    }
    let instrs = [];
    for(let joint_number of joint_number_array){
        instrs.push(
            this.set_parameter("RebootServo", Dexter$1.joint_to_servo_number(joint_number)));
        instrs.push(this.sleep(1)); //sleep for 1 sec to allow dynamixel bus to settle
    }
    return instrs
};

//the function
Dexter$1.prototype.reboot_joints_fn = function (){
    new Job$1({name: "reboot_joints",
        robot: new Brain({name: "brain_reboot_joints"}),
        do_list: [
            //Dexter.set_parameter("RebootServo", 1), //reset J7 SPAN
            //Dexter.sleep(1), //give the servo time to reset.
            //Dexter.set_parameter("RebootServo", 3), //reset J6 ROLL
            //Dexter.sleep(1) //give the servo time to reset.
            this.reboot_joints()
        ]
    }).start();
};



//Dexter.make_ins = make_ins this is below due to loading order issues

Dexter$1.prototype.make_ins = function(instruction_type, ...args){
    args = new Array(...args);
    args.unshift(instruction_type);
    args.push(this);
    return make_ins$1.apply(null, args)
};

Dexter$1.move_home = function(){ //move straight up
    return Dexter$1.move_all_joints(Dexter$1.HOME_ANGLES)
};
Dexter$1.prototype.move_home = function(){
    return this.move_all_joints(Dexter$1.HOME_ANGLES)
};

Dexter$1.check_joint_limits = false;

//similar to Kin.check_J_ranges except returns string if out of range,
//and false if in range whereas Kin.check_J_ranges returns true if
//in range and false otherwise.
Dexter$1.joints_out_of_range = function(J_angles, dexter_inst){
    if (!Dexter$1.check_joint_limits) { return false }
    else {
        let lower_limit;
        let upper_limit;
        if(dexter_inst instanceof Dexter$1) {
            lower_limit = [dexter_inst.J1_angle_min, dexter_inst.J2_angle_min, dexter_inst.J3_angle_min, dexter_inst.J4_angle_min, dexter_inst.J5_angle_min];
            upper_limit = [dexter_inst.J1_angle_max, dexter_inst.J2_angle_max, dexter_inst.J3_angle_max, dexter_inst.J4_angle_max, dexter_inst.J5_angle_max];
        }
        else {
            lower_limit = [Dexter$1.J1_ANGLE_MIN, Dexter$1.J2_ANGLE_MIN, Dexter$1.J3_ANGLE_MIN, Dexter$1.J4_ANGLE_MIN, Dexter$1.J5_ANGLE_MIN];
            upper_limit = [Dexter$1.J1_ANGLE_MAX, Dexter$1.J2_ANGLE_MAX, Dexter$1.J3_ANGLE_MAX, Dexter$1.J4_ANGLE_MAX, Dexter$1.J5_ANGLE_MAX];
        }
        for(var i = 0; i < J_angles.length; i++){
            let angle = J_angles[i];
            if(angle == null) ;
            else if (angle < lower_limit[i]){
                return "Joint " + (i + 1) + " with angle: " + angle + "\nis less than the minimum: " + lower_limit[i]
            }
            else if (angle > upper_limit[i]){
                return "Joint " + (i + 1) + " with angle: " + angle + "\nis more than the maximun: " + upper_limit[i]
            }
        }
        return false
    }
};

//take the actual args passed to maj (sans a possible robot at the end) and
//convert them into an array for further processing
//this always returns an array, and it is an array of angles (or nested array of 1 number for rel angle.
//array will be between 1 and  7 long inclusive.
//elts can be number or NaN
Dexter$1.convert_maj_angles = function(args_array, instruction_name=""){
      let result;
      if(args_array.length == 1){ //user is only setting J1.
          let first_elt = args_array[0];
          if(Array.isArray(first_elt)){ //This could POSSIBLY be user intending to pass one *relative* joint angle for j1
                                        //but lets presume not.
                                        //but if first_elt is a number or an array of 1 number,
                                        //that's ok, return turn it
              result = first_elt; //user passed in an array, use it as the array for the angles.
          }
          else { //only one arg and its not an array, (probably a number) so stick it in an array and we're done.
              result = [first_elt];
          }
      }
      else { // > 1 elt, so all those elts are in an array
          result =  args_array;
      }
      //get rid of undefineds and NaN's on the end down to joint 5.
      for(let i = result.length - 1; i > 4; i--){
            let ang = result[i];
            if ((ang === undefined) || Number.isNaN(ang)) {
                result.pop();
            }
       }
       if (result.length > 7){
          warning("You are creating a " + instruction_name + " instruction with more than 7 angles:<br/>" +
                   args_array + "<br/>" +
                  "Usually 7 is the maximum.");
       }
       return result
};

Dexter$1.prototype.move_all_joints = function(...array_of_angles) {
    let array_to_use = Dexter$1.convert_maj_angles(array_of_angles, "move_all_joints");
    return new Instruction$1.Dexter.move_all_joints(array_to_use, this)
};

Dexter$1.move_all_joints = function(...array_of_angles){
    let robot;
    if (last(array_of_angles) instanceof Dexter$1) {robot = pop(array_of_angles);}
    let array_to_use = Dexter$1.convert_maj_angles(array_of_angles, "move_all_joints");
    return new Instruction$1.Dexter.move_all_joints(array_to_use, robot)
};

//the same as move_all_joints but generates a "P" oplet

Dexter$1.prototype.pid_move_all_joints = function(...array_of_angles) {
    let array_to_use = Dexter$1.convert_maj_angles(array_of_angles, "pid_move_all_joints");
    return new Instruction$1.Dexter.pid_move_all_joints(array_to_use, this)
};

Dexter$1.pid_move_all_joints = function(...array_of_angles){
    let robot;
    if (last(array_of_angles) instanceof Dexter$1) {robot = pop(array_of_angles);}
    let array_to_use = Dexter$1.convert_maj_angles(array_of_angles, "pid_move_all_joints");
    return new Instruction$1.Dexter.pid_move_all_joints(array_to_use, robot)
};

Dexter$1.prototype.move_all_joints_relative = function(...array_of_angles) {
    let array_to_use = Dexter$1.convert_maj_angles(array_of_angles, "move_all_joints_relative");
    return new Instruction$1.Dexter.move_all_joints_relative(array_to_use, this)
};
Dexter$1.move_all_joints_relative = function(...delta_angles){
    let robot;
    if (last(delta_angles) instanceof Dexter$1) {robot = pop(delta_angles);}
    let array_to_use = Dexter$1.convert_maj_angles(delta_angles, "move_all_joints_relative");
    return new Instruction$1.Dexter.move_all_joints_relative(array_to_use, robot)
};



Dexter$1.is_position = function(an_array){
    return (Array.isArray(an_array)     &&
             (an_array.length == 3)     &&

             Array.isArray(an_array[0]) &&
            (an_array[0].length == 3)   &&

            Array.isArray(an_array[1])  &&
            (an_array[1].length == 3)   &&

             Array.isArray(an_array[2]) &&
            (an_array[2].length == 3)
    )
};
//warning: calling with no args to default everything will be out-of-reach because JS_direction is not straight up,
//params info:
// xyz New defaults are the cur pos, not straight up.
// J5_direction  = [0, 0, -1], //end effector pointing down
//warning: soe valid xyz locations won't be valid with the default J5_direction and config.
Dexter$1.prototype.move_to = function(xyz            = [],
                                    J5_direction   = [0, 0, -1],
                                    config         = Dexter$1.RIGHT_UP_OUT,
                                    workspace_pose = null, //will default to the job's default workspace_pose
                                    j6_angle       = [0],
                                    j7_angle       = [0]) {
    return Dexter$1.move_to(xyz,
                         J5_direction,
                         config,
                         workspace_pose,
                         j6_angle,
                         j7_angle,
                         this)
};

//note that a workspace_pose = null, will default to the job's default workspace_pose
Dexter$1.move_to = function(xyz            = [],
                          J5_direction   = [0, 0, -1],
                          config         = Dexter$1.RIGHT_UP_OUT,
                          workspace_pose = null,
                          j6_angle       = [0],
                          j7_angle       = [0],
                          robot
                         ){
       return new Instruction$1.Dexter.move_to(xyz, J5_direction, config, workspace_pose, j6_angle, j7_angle, robot)
};

//the same as move_to but generates a "P" oplet
Dexter$1.prototype.pid_move_to = function(xyz        = [],
                                    J5_direction   = [0, 0, -1],
                                    config         = Dexter$1.RIGHT_UP_OUT,
                                    workspace_pose = null, //will default to the job's default workspace_pose
                                    j6_angle       = [0],
                                    j7_angle       = [0]) {
    return Dexter$1.pid_move_to(xyz,
                              J5_direction,
                              config,
                              workspace_pose,
                              j6_angle,
                              j7_angle,
                              this)
};

Dexter$1.pid_move_to = function(xyz            = [],
                              J5_direction   = [0, 0, -1],
                              config         = Dexter$1.RIGHT_UP_OUT,
                              workspace_pose = null, //will default to the job's default workspace_pose
                              j6_angle       = [0],
                              j7_angle       = [0],
                              robot
                              ){
    return new Instruction$1.Dexter.pid_move_to(xyz, J5_direction, config, workspace_pose, j6_angle, j7_angle, robot)
};

Dexter$1.prototype.move_to_relative = function(delta_xyz = [0, 0, 0], workspace_pose=null,
                                             j6_delta_angle = 0, j7_delta_angle = 0){
    return Dexter$1.move_to_relative(delta_xyz, workspace_pose, j6_delta_angle, j7_delta_angle, this)
};
Dexter$1.move_to_relative = function(delta_xyz = [0, 0, 0], workspace_pose=null, j6_delta_angle=0, j7_delta_angle=0, robot){
    return new Instruction$1.Dexter.move_to_relative(delta_xyz, workspace_pose, j6_delta_angle, j7_delta_angle,  robot)
};

Dexter$1.prototype.move_to_straight = function({xyz           = "required",
                                             J5_direction   = [0, 0, -1],
                                             config         = Dexter$1.RIGHT_UP_OUT,
                                             workspace_pose = null,
                                             tool_speed     = 5*_mm / _s,
                                             resolution     = 0.5*_mm,
                                             j6_angle       = [0],
                                             j7_angle       = [0],
                                             single_instruction = false}) {
    return Dexter$1.move_to_straight({xyz: xyz,
                                    J5_direction: J5_direction,
                                    config: config,
                                    workspace_pose: workspace_pose,
                                    tool_speed: tool_speed,
                                    resolution: resolution,
                                    j6_angle: j6_angle,
                                    j7_angle: j7_angle,
                                    single_instruction: single_instruction,
                                    robot: this})
                            };

Dexter$1.move_to_straight = function({xyz          = "required",
                                   J5_direction  = [0, 0, -1],
                                   config        = Dexter$1.RIGHT_UP_OUT,
                                   workspace_pose = null,
                                   tool_speed    = 5*_mm / _s,
                                   resolution    = 0.5*_mm,
                                   j6_angle      = [0],
                                   j7_angle      = [0],
                                   single_instruction = false,
                                   robot}){
    if(xyz == "required") { dde_error("Dexter.move_to_straight was not passed the required 'xyz' arg.<br/>move_to_straight takes keyword args."); }
    return new Instruction$1.Dexter.move_to_straight({xyz: xyz,
                                                    J5_direction: J5_direction,
                                                    config: config,
                                                    workspace_pose: workspace_pose,
                                                    tool_speed: tool_speed,
                                                    resolution: resolution,
                                                    j6_angle: j6_angle,
                                                    j7_angle: j7_angle,
                                                    single_instruction: single_instruction,
                                                    robot: robot})
};

Dexter$1.record_movement           = function(...args){ return make_ins$1("m", ...args) };
Dexter$1.prototype.record_movement = function(...args){ args.push(this); return Dexter$1.record_movement(...args) };


Dexter$1.replay_movement           = function(...args){ return make_ins$1("o", ...args) };
Dexter$1.prototype.replay_movement = function(...args){ args.push(this); return Dexter$1.replay_movement(...args) };


Dexter$1.set_parameter   = function(name="Acceleration", ...values){
                              let first_arg = values[0];
                              if (name == "StartSpeed") {
                                  if (first_arg < 0){
                                      dde_error("Dexter.set_parameter called with StartSpeed of: " + first_arg +
                                                " but it must be greater than or equal to zero.");
                                  }
                              }
                              else if (name == "MaxSpeed") {
                                  if (first_arg <= 0){
                                      dde_error("Dexter.set_parameter called with MaxSpeed of: " + first_arg +
                                                " but it must be greater than zero.");
                                  }
                                  else if (first_arg < (1 / _nbits_cf)){
                                      warning("Dexter.set_parameter called with MaxSpeed of: " + first_arg +
                                      " which is too low.<br/>MaxSpeed set to the minimum permissible speed of: " + (1 / _nbits_cf));
                                  }
                              }
                              return make_ins$1("S", name, ...values)
                         };
Dexter$1.prototype.set_parameter = function(name="Acceleration", ...values){
                                    let first_arg = values[0];
                                    if (name == "StartSpeed") {
                                        if (first_arg < 0){
                                            dde_error("Dexter.set_parameter called with StartSpeed of: " + first_arg +
                                                " but it must be greater than or equal to zero.");
                                        }
                                    }
                                    else if (name == "MaxSpeed") {
                                        if (first_arg <= 0){
                                            dde_error("Dexter.set_parameter called with MaxSpeed of: " + first_arg +
                                                " but it must be greater than zero.");
                                        }
                                        else if (first_arg < (1 / _nbits_cf)){
                                            warning("Dexter.set_parameter called with MaxSpeed of: " + first_arg +
                                                " which is too low.<br/>MaxSpeed set to the minimum permissible speed of: " + (1 / _nbits_cf));
                                        }
                                    }
                                    return make_ins$1("S", name, ...values, this)
                                };


Dexter$1.sleep           = function(seconds){ return make_ins$1("z", seconds) };
Dexter$1.prototype.sleep = function(seconds){ return make_ins$1("z", seconds, this) };

Dexter$1.slow_move           = function(...args){ return make_ins$1("s", ...args) };
Dexter$1.prototype.slow_move = function(...args){ args.push(this); return Dexter$1.slow_move(...args) };

//address is a non-neg integer, probably below 82, value is an integer
Dexter$1.write_fpga           = function(address, value){ return make_ins$1("w", address, value) };
Dexter$1.prototype.write_fpga = function(address, value){ return make_ins$1("w", address, value, this) };

Dexter$1.socket_encode = function(char){
    let code = char.charCodeAt(0);
    if((0x00 == code) || (0x3B == code) || (0x25 == code)){
        return "%" + code.toString(16).toUpperCase()
    }
    else { return char }
};

Dexter$1.write_file = function(file_name=null, content=""){
    let max_content_chars = 62; //244 //252 //ie 256 - 4 for (instruction_id, oplet, suboplet, length
    //payload can be max_contect_chars + 2 long if last character is escaped
    let payload = "";
    let instrs = [];
    if (file_name){
        instrs.push(make_ins$1("W", "f", 0, file_name));
    }
    for(let char of content) {
        payload += Dexter$1.socket_encode(char);
        if (payload.length >= max_content_chars) {
            instrs.push(make_ins$1("W", "m", payload.length, payload));
            payload = "";
        }
    }
    instrs.push(make_ins$1("W", "e", payload.length, payload)); //close the file
    return instrs
};

//deprecated. Note reversed args from Dexter.write_file and default path adjustment
Dexter$1.write_to_robot = function(content="", file_name=null){
    file_name = Dexter$1.srv_samba_share_default_to_absolute_path(file_name);
    return Dexter$1.write_file(file_name, content)
};

Dexter$1.prototype.write_file = function(file_name=null, content=""){
    let max_content_chars = 62; //244 //252 //ie 256 - 4 for (instruction_id, oplet, suboplet, length
    //payload can be max_contect_chars + 2 long if last character is escaped
    let payload = "";
    let instrs = [];
    if (file_name){
        instrs.push(make_ins$1("W", "f", 0, file_name, this));
    }
    for(let char of content) {
        payload += Dexter$1.socket_encode(char);
        if (payload.length >= max_content_chars) {
            instrs.push(make_ins$1("W", "m", payload.length, payload, this));
            payload = "";
        }
    }
    instrs.push(make_ins$1("W", "e", payload.length, payload, this)); //close the file
    return instrs
};

//deprecated. Note reversed args from Dexter.write_file
Dexter$1.prototype.write_to_robot = function(content="", file_name=null){
    return this.write_file(file_name, content)
};

/*testing code
    var data = ""
//for (var i = 255; i > 0; i--) { //top to bottom
for (var i = 0; i < 256; i++) {  //bottom to top
    data += String.fromCharCode(i)
}

//out(data);
out(data.length)

new Job({name: "my_job",
    do_list: [out(Dexter.write_file(data, "/srv/samba/share/test.txt"))]})
*/

Dexter$1.read_file = function(source, destination="read_file_content"){
    return new Instruction$1.Dexter.read_file(source, destination)
};
//examples pf path input:
//  ./foo.txt =>  /srv/samba/share/foo.txt
// ../foo.txt =>  /srv/samba/foo.txt
//    foo.txt => /srv/samba/share/foo.txt
Dexter$1.srv_samba_share_default_to_absolute_path = function(path){
    if      (path.startsWith("/"))   { return path }
    else if (path.startsWith("#"))   { return path }
    else if (path.startsWith("./"))  { return "/srv/samba/share/" + path.substring(2) }
    else if (path.startsWith("../")) { return "/srv/samba/"       + path.substring(3) }
    else                             { return "/srv/samba/share/" + path }
};

Dexter$1.read_from_robot =  function (source, destination="read_file_content"){ //deprecated. simlar to read_file but differs in that srv_sama_share is the default folder
    source = Dexter$1.srv_samba_share_default_to_absolute_path(source);
    return Dexter$1.read_file(source, destination)
};

Dexter$1.prototype.read_file = function (source, destination="read_file_content"){
    return new Instruction$1.Dexter.read_file(source, destination, this)
};

Dexter$1.prototype.read_from_robot = Dexter$1.prototype.read_file;


//See James N email Jul 14, 2021
Dexter$1.turn_off_j6_and_j7_torque  = function(){
    return [Dexter$1.set_parameter("ServoSet", 3, 24, 0), //J6, for XL-320 motors
            Dexter$1.set_parameter("ServoSet", 1, 24, 0)] //J7, for XL-320 motors
};

Dexter$1.prototype.turn_off_j6_and_j7_torque  = function(){
    return [this.set_parameter("ServoSet", 3, 24, 0), //J6, for XL-320 motors
            this.set_parameter("ServoSet", 1, 24, 0)] //J7, for XL-320 motors
};

Dexter$1.turn_on_j6_and_j7_torque  = function(){
    return [Dexter$1.set_parameter("ServoSet", 3, 24, 1), //J6, for XL-320 motors
            Dexter$1.set_parameter("ServoSet", 1, 24, 1)] //J7, for XL-320 motors
};

Dexter$1.prototype.turn_on_j6_and_j7_torque  = function(){
    return [this.set_parameter("ServoSet", 3, 24, 1), //J6, for XL-320 motors
            this.set_parameter("ServoSet", 1, 24, 1)] //J7, for XL-320 motors
};


//from Dexter_Modes.js (these are instructions. The fns return an array of instructions
Dexter$1.set_follow_me                = function(){ return [make_ins$1("S", "RunFile", "setFollowMeMode.make_ins"),
                                                          Dexter$1.turn_off_j6_and_j7_torque()]};
Dexter$1.prototype.set_follow_me      = function(){ return [make_ins$1("S", "RunFile", "setFollowMeMode.make_ins", this),
                                                          this.turn_off_j6_and_j7_torque()]};

Dexter$1.set_force_protect            = function(){ return [make_ins$1("S", "RunFile", "setForceProtectMode.make_ins"),
                                                          Dexter$1.turn_on_j6_and_j7_torque()]};
Dexter$1.prototype.set_force_protect  = function(){ return [make_ins$1("S", "RunFile", "setForceProtectMode.make_ins", this),
                                                          this.turn_on_j6_and_j7_torque()]};

Dexter$1.set_keep_position            = function(){ return [make_ins$1("S", "RunFile", "setKeepPositionMode.make_ins"),
                                                          Dexter$1.turn_on_j6_and_j7_torque()]};
Dexter$1.prototype.set_keep_position  = function(){ return [make_ins$1("S", "RunFile", "setKeepPositionMode.make_ins", this),
                                                          this.turn_on_j6_and_j7_torque()]};

Dexter$1.set_open_loop                = function(){ return [make_ins$1("S", "RunFile", "setOpenLoopMode.make_ins"),
                                                          Dexter$1.turn_on_j6_and_j7_torque()]};
Dexter$1.prototype.set_open_loop      = function(){ return [make_ins$1("S", "RunFile", "setOpenLoopMode.make_ins", this),
                                                          this.turn_on_j6_and_j7_torque()]};


//End Dexter Instructions
//____________Dexter Database______________
//Note: often you should use Robot.instruction_type_to_
Dexter$1.instruction_type_to_function_name_map = {
    a:"move_all_joints",
    //b:"move_to",           //fry  obsolete
    B:"set_boundries", //10 args: j1BoundryHigh, j1Boundrylow,  j2BoundryHigh, j2Boundrylow, j3BoundryHigh, j3Boundrylow, j4BoundryHigh, j4Boundrylow, j5BoundryHigh, j5Boundrylow,
    C:"pid_move_to",
    c:"capture_ad",
    D:"pid_move_to_straight",
    d:"dma_read",
    e:"cause_dexter_error", //fry
    //E:"empty_instruction_queue_immediately", //new Sept 1, 2016
    F:"empty_instruction_queue",   //new Sept 1, 2016
    G:"get_robot_status_immediately",        //new Sept 1, 2016. Deprecated Dec 8, 2020
    g:"get_robot_status",   //fry
    h:"get_robot_status_heartbeat", //fry
    i:"capture_points",
    l:"load_tables",
    m:"record_movement",
    n:"find_index",
    o:"replay_movement",
    P:"pid_move_all_joints",
    R:"move_all_joints_relative",
    r:"read_file",
    s:"slow_move",
    S:"set_parameter",
    t:"dma_write",
    T:"move_to_straight",
    w:"write_fpga",
    W:"write_file",
    x:"exit",
    z:"sleep"
};

/*
var cache_of_dexter_instance_files = {}

//returns undefined or value of prop_name
//errors if the robot file is not valid json format
//first checks dexter instance, then file prop, then Dexter class prop

//returns a string if error, or literal name-value pairs object.
Dexter.prototype.get_dexter_props_file_object = function(){
    let file_path  = "//" + this.ip_address + "/share/robot_props.json" //todo needs verificatin
    if (file_exists(file_path)) {
        let content = read_file(file_path)
        try {
            const result = JSON.parse(content)
            return result
            //cache_of_dexter_instance_files[this.name] = result
        }
        catch(err) {
            return "The file: " + __dirname + "/" + file_name +
                "<br/>is not valid jason format: " + err.message
        }
    }
    else { return null }
}

Dexter.prototype.prop = function(prop_name, get_from_dexter=false){
    if (get_from_dexter){
        const file_result = this.get_dexter_props_file_object()
        if (typeof(file_result) == "string") { dde_error(file_result) }
        else { return file_result[prop_name] }
    }
    else {
        var val = this[prop_name]
        if(val !== undefined) { return val }
        else if (cache_of_dexter_instance_files[this.name] === undefined){ //fill up cache_of_dexter_instance_files or error, but don't even attempt to get actual result yet
            const file_result = this.get_dexter_props_file_object()
            if (typeof(file_result) == "string") {
                dde_error(file_result)
            }
            else if (file_result === null){
                let file_path  = "//" + this.ip_address + "/share/robot_props.json"
                warning("The file: " + file_path + " does not exist.")
                cache_of_dexter_instance_files[this.name] = false
            }
        }
        const obj = cache_of_dexter_instance_files[this.name] //obj will NOT be undefined. Its eitehr false or is a lit obj
        if (obj !== false){
            const result = obj[prop_name]
            if (result !== undefined) { return result }
        }
        return Dexter[prop_name]  //get the typical "class value" of the prop
    }
}
*/

//Dexter constants
//values in microns, pivot point to pivot point, not actual link length.
//Dexter manufacturing tolerance is about 5 microns for these link lengths.

//             HDI         ORIG DEX              ORIG DEX
Dexter$1.LINK1 = 0.235200;    //0.228600   //meters   6.5 inches,
Dexter$1.LINK2 = 0.339092;   //0.320676   //meters  12 5/8 inches
Dexter$1.LINK3 = 0.307500;    //0.330201   //meters  13 inches
Dexter$1.LINK4 = 0.059500;    //0.050801   //meters  2 inches
Dexter$1.LINK5 = 0.082440;   //0.082551   //meters  3.25 inches  // from pivot point to tip of the end-effector
//Dexter.LINKS = [0, Dexter.LINK1, Dexter.LINK2, Dexter.LINK3, Dexter.LINK4, Dexter.LINK5]

/*These are the HDI Link Lengths as of Jan 1, 2020:
Dexter.LINK1 = 0.2352
Dexter.LINK2 = 0.339092
Dexter.LINK3 = 0.3075
Dexter.LINK4 = 0.0595
Dexter.LINK5 = 0.08244
*/

Dexter$1.LINK1_v1 = Dexter$1.LINK1 * 1000000; //in microns
Dexter$1.LINK2_v1 = Dexter$1.LINK2 * 1000000; //in microns
Dexter$1.LINK3_v1 = Dexter$1.LINK3 * 1000000; //in microns
Dexter$1.LINK4_v1 = Dexter$1.LINK4 * 1000000; //in microns
Dexter$1.LINK5_v1 = Dexter$1.LINK5 * 1000000; //in microns

Dexter$1.LINK1_AVERAGE_DIAMETER =  0.090000; //meters
Dexter$1.LINK2_AVERAGE_DIAMETER =  0.120000; //meters
Dexter$1.LINK3_AVERAGE_DIAMETER =  0.050000; //meters
Dexter$1.LINK4_AVERAGE_DIAMETER =  0.035000; //meters
Dexter$1.LINK5_AVERAGE_DIAMETER =  0.030000; //meters

//gets called regardless of whether simulate = true or not because
//even if we're simulating, we like to get that actual link lengths from
//the dexter IF its available
/*Dexter.prototype.set_link_lengths = function(job_to_start_when_done = null){
    let job_to_start = job_to_start_when_done //for closure
    let the_robot  = this //for closure
    let sim_actual = Robot.get_simulate_actual(this.simulate)
    if(this.Link1 &&
      (sim_actual !== true) && //ie "real"
      (this.link_lengths_set_from_dde_computer == true)){
        this.Link1 = undefined  //we want to get vals from Dexter.
        this.Link2 = undefined
        this.Link3 = undefined
        this.Link4 = undefined
        this.Link5 = undefined
    }
    if(!this.Link1 &&
       (!job_to_start || (job_to_start.name != "set_link_lengths"))){
       //we're going to set link lengths.
        if(sim_actual !== true) { //get link lengths from Dexter
            if(node_server_supports_editor(this)) {
                this.set_link_lengths_using_node_server(job_to_start)
            }
            else {
                warning("Dexter." + the_robot.name + "'s node server is not responding.<br/>" +
                        "Now attempting to get link lengths via a Job.")
                this.set_link_lengths_using_job(job_to_start)
            }
        }
        else { //get link lengths from dde computer
            this.set_link_lengths_using_dde_db(job_to_start)
        }
    }
    else {
        this.start_aux(job_to_start)
    }
}*/

//note that
Dexter$1.prototype.set_link_lengths = function(job_to_start_when_done = null){
    let sim_actual = Robot$1.get_simulate_actual(this.simulate);
    if(job_to_start_when_done && (job_to_start_when_done.name === "set_link_lengths")) {
        this.start_aux(job_to_start_when_done);
    }
    else if(!this.Link1) { //no values set since dde launch
        if(sim_actual !== true) { //ie "real"
            if(node_server_supports_editor(this)) {
                this.set_link_lengths_using_node_server(job_to_start_when_done);
            }
            else {
                warning("Dexter." + this.name + "'s node server is not responding.<br/>" +
                    "Setting link lengths via DDE's internal defaults.");
                //this.set_link_lengths_using_job(job_to_start_when_done)
                this.set_link_lengths_using_dde_db(job_to_start_when_done);
            }
        }
        else { //simulating
            this.set_link_lengths_using_dde_db(job_to_start_when_done);
        }
    }
    //already set the Link lengths once, but ...
    else if((sim_actual !== true) && //ie real
            (this.link_lengths_set_from_dde_computer === true)) { //the only time we read link_lengths_set_from_dde_computer
        if(node_server_supports_editor(this)) {
            this.set_link_lengths_using_node_server(job_to_start_when_done);
        }
        else {
            warning("Dexter." + this.name + "'s node server is not responding.<br/>" +
                    "Setting link lengths via DDE's internal defaults.");
            //this.set_link_lengths_using_job(job_to_start_when_done)
            this.set_link_lengths_using_dde_db(job_to_start_when_done);
        }
    }
    else {//link lengths already set correctly
        this.start_aux(job_to_start_when_done);
    }
};

/*
Dexter.prototype.set_link_lengths_using_node_server = function(job_to_start){
    let path = //"https://" + this.ip_address + "/srv/samba/share/Defaults.make_ins"
              "http://192.168.1.142/edit?edit=/srv/samba/share/Defaults.make_ins"
    let the_dexter = this
    let callback = function(err, data){
        if(err){
            dde_error("in set_link_lengths_using_node_server, could not get content of:<br/>" +
                       path)
        }
        else {
            if(typeof(data) !== "string") {
                data = data.body
            }
            the_dexter.set_link_lengths_from_file_content(data)
            if(job_to_start) { job_to_start.start }
        }
    }
    read_file_async(path, undefined, callback)
}
*/

Dexter$1.prototype.set_link_lengths_using_node_server = function(job_to_start){
    let ip = job_to_start.robot.ip_address;
    let path = "http://" + ip + "/edit?edit=/srv/samba/share/Defaults.make_ins";
    let content = get_page(path);
    if(content.startsWith("Error: ")) {
        warning("set_link_lengths_using_node_server with path: " + path +
                " got error: " + content +
                "<br/> so now setting link lengths using a DDE Job.");
        this.set_link_lengths_using_dde_db(job_to_start); //this will deal with link_lengths_set_from_dde_computer
    }
    else {
        this.set_link_lengths_from_file_content(content);
        delete this.link_lengths_set_from_dde_computer;
        if(job_to_start) {
            this.start_aux(job_to_start);
        }
    }
};
/*
Dexter.prototype.set_link_lengths_using_job = function(job_to_start){
    let the_robot = this
    let callback = function() {
        if(Job.set_link_lengths) {
            out("in sll cbb")
        }
        the_robot.start_aux(job_to_start)
    }
    let ssl_job =  new Job({name: "set_link_lengths",
                            robot: this,
                            show_instructions: false,
                            when_stopped: (job_to_start ? callback : "stop"),
                            if_dexter_connect_error: function(robot_name){
                                 warning("Can't connect to Dexter." + robot_name + " executing Job." + "set_link_lengths")
                                if(job_to_start.if_dexter_connect_error){
                                    job_to_start.if_dexter_connect_error(robot_name)
                                }
                                job_to_start.stop_for_reason("errored", "Can't connect to robot: " + robot_name)
                            },
                            do_list: [
                                Dexter.read_file("../Defaults.make_ins", "default_content"), //gets file from Dexter
                                function() {
                                    if(typeof(this.user_data.default_content) == "string"){
                                        this.robot.set_link_lengths_from_file_content(this.user_data.default_content)
                                        delete the_robot.link_lengths_set_from_dde_computer //because link lengths set from Dexter
                                    }
                                    else { //no file because we got an error code integer in this.user_data.default_content
                                        this.robot.set_link_lengths_using_dde_db(job_to_start) //will deal with link_lengths_set_from_dde_computer
                                    }
                                }
                            ]})
    ssl_job.start()
}
*/

Dexter$1.prototype.set_link_lengths_using_dde_db = function(job_to_start){
    let path = dde_apps_folder + "/dexter_file_systems/"  + this.name + "/Defaults.make_ins";
    if(file_exists$1(path)) {
        let content = read_file$1(path);
        this.set_link_lengths_from_file_content(content);
    }
    else {
        this.Link1 = Dexter$1.LINK1;
        this.Link2 = Dexter$1.LINK2;
        this.Link3 = Dexter$1.LINK3;
        this.Link4 = Dexter$1.LINK4;
        this.Link5 = Dexter$1.LINK5;

        this.J1_angle_min = Dexter$1.J1_ANGLE_MIN;
        this.J2_angle_min = Dexter$1.J2_ANGLE_MIN;
        this.J3_angle_min = Dexter$1.J3_ANGLE_MIN;
        this.J4_angle_min = Dexter$1.J4_ANGLE_MIN;
        this.J5_angle_min = Dexter$1.J5_ANGLE_MIN;
        this.J6_angle_min = Dexter$1.J6_ANGLE_MIN;
        this.J7_angle_min = Dexter$1.J7_ANGLE_MIN;

        this.J1_angle_max = Dexter$1.J1_ANGLE_MAX;
        this.J2_angle_max = Dexter$1.J2_ANGLE_MAX;
        this.J3_angle_max = Dexter$1.J3_ANGLE_MAX;
        this.J4_angle_max = Dexter$1.J4_ANGLE_MAX;
        this.J5_angle_max = Dexter$1.J5_ANGLE_MAX;
        this.J6_angle_max = Dexter$1.J6_ANGLE_MAX;
        this.J7_angle_max = Dexter$1.J7_ANGLE_MAX;
    }
    this.link_lengths_set_from_dde_computer = true;
    if(job_to_start) {
        this.start_aux(job_to_start);
    }
};

//content is the content of a Defaults.make_ins file
//sets link lengths as well as any other params in the file.
Dexter$1.prototype.set_link_lengths_from_file_content = function(content){
    for(let line of content.split("\n")){
        //first get rid of comment, if any, at line end.
        let semi_pos = line.indexOf(";");
        if (semi_pos > -1) { line = line.substring(0, semi_pos); }
        line = line.trim();
        if(line.length > 0) {
            let line_elts = line.split(",");
            let oplet = line_elts[0].trim();
            if(oplet == "S"){
                let param_name = line_elts[1].trim();
                if(line_elts.length == 3){
                    let val = parseFloat(line_elts[2].trim());
                    let new_param_name = param_name;
                    if(param_name.includes("Boundry")) {
                        val = val * _arcsec;
                        new_param_name = "J";
                        new_param_name += param_name[1];
                        new_param_name = new_param_name + "_angle_"; //+= fails here. JS bug
                        if(param_name.endsWith("Low")) {new_param_name += "min";}
                        else                           {new_param_name += "max";}
                    }
                    this[new_param_name] = val;
                }
                //the rest have more than one val
                else if (param_name == "LinkLengths") { //link5 length is in the array first. }
                    for(let i = 2; i < line_elts.length; i++){
                        let i_val = parseFloat(line_elts[i].trim()) * _um;  //convert from string of microns to meters.
                        if     (i == 2) { this.Link5 = i_val; }
                        else if(i == 3) { this.Link4 = i_val; }
                        else if(i == 4) { this.Link3 = i_val; }
                        else if(i == 5) { this.Link2 = i_val; }
                        else if(i == 6) { this.Link1 = i_val; }
                        else { shouldnt$1("set_parameter of: " + param_name + " got more than 5 link lengths."); }
                    }
                }
                else {
                    val = line_elts.slice(2, line_elts.length - 1);
                    this[param_name] = val;
                }
            }
        }
    }
    if(!this.J6_angle_min) { //not included in some defaults.makeins files
        this.J6_angle_min = Dexter$1.J6_ANGLE_MIN;
    }
    if(!this.J6_angle_max) { //not included in some defaults.makeins files
        this.J6_angle_max = Dexter$1.J6_ANGLE_MAX;
    }
    if(!this.J7_angle_min) { //not included in some defaults.makeins files
        this.J7_angle_min = Dexter$1.J7_ANGLE_MIN;
    }
    if(!this.J7_angle_max) { //not included in some defaults.makeins files
        this.J7_angle_max = Dexter$1.J7_ANGLE_MAX;
    }
};

Dexter$1.LEG_LENGTH = 0.152400; //meters  6 inches

//values in degrees, Dexter HDI
Dexter$1.J1_ANGLE_MIN = -185;
Dexter$1.J1_ANGLE_MAX = 185;
Dexter$1.J2_ANGLE_MIN = -105;
Dexter$1.J2_ANGLE_MAX = 105;
Dexter$1.J3_ANGLE_MIN = -150;
Dexter$1.J3_ANGLE_MAX = 150;
Dexter$1.J4_ANGLE_MIN = -120; //-100
Dexter$1.J4_ANGLE_MAX = 120;  //100
Dexter$1.J5_ANGLE_MIN = -185;
Dexter$1.J5_ANGLE_MAX = 185;
Dexter$1.J6_ANGLE_MIN = -150; //0
Dexter$1.J6_ANGLE_MAX = 150; //296
Dexter$1.J7_ANGLE_MIN = 0;
Dexter$1.J7_ANGLE_MAX = 296;

Dexter$1.MAX_SPEED    = 30;  //degrees per second. NOT the max speed of the robot,
                         //but rather for a given instruction's envelope of speed,
                         //its the max speed that will be attined by that instruction.
                         //The JOINT that this is the max speed for is
                         //the joint that changes the most in a given call to move_all_joints.
Dexter$1.START_SPEED  = 0.5; //degrees per second
Dexter$1.ACCELERATION = 0.000129; //degrees/(second^2)

Dexter$1.RIGHT_ANGLE    = 90; // 90 degrees
Dexter$1.HOME_ANGLES    = [0, 0, 0, 0, 0, 0, 50];  //j2,j3,j4 straight up, link 5 horizontal pointing frontwards. If J7 is 0 it will overtorque, turning on the red light as it closes too tightly. James W likes 50 degrees.
Dexter$1.NEUTRAL_ANGLES = [0, 45, 90, -45, 0, 0, 0]; //lots of room for Dexter to move from here.
Dexter$1.PARKED_ANGLES  = [0, 0, 135, 45, 0, 0, 0]; //all folded up, compact.

Dexter$1.HOME_POSITION    = [[0, 0.08255, 0.866775],[0, 1, 0], [1, 1, 1]]; //meters, j5 direction, config
Dexter$1.NEUTRAL_POSITION = [[0, 0.5,     0.075],   [0, 0, -1],[1, 1, 1]];    //meters, j5 direction, config
//don't define   Dexter.PARKED_POSITION = [0, 0.151, 0.20],  [0, -1, 0],   [1, 1, 1]

    /*Dexter.robot_status_labels = [
        "ds_instruction_id",    // = 0
        "ds_instruction_type",  // = 1 //helps in debugging
        "ds_error_code",        // = 2 //0 means no error.

        "ds_j0_angle", //  = 3
        "ds_j1_angle", //  = 4
        "ds_j2_angle", //  = 5
        "ds_j3_angle", //  = 6
        "ds_j4_angle", //  = 7

        "ds_j0_x", //  = 8
        "ds_j0_y", //  = 9
        "ds_j0_z", //  = 10

        "ds_j1_x", //  = 11
        "ds_j1_y", //  = 12
        "ds_j1_z", //  = 13

        "ds_j2_x", //  = 14
        "ds_j2_y", //  = 15
        "ds_j2_z", //  = 16

        "ds_j3_x", //  = 17
        "ds_j3_y", //  = 18
        "ds_j3_z", //  = 19

        "ds_j4_x", //  = 20
        "ds_j4_y", //  = 21
        "ds_j4_z", //  = 22

        "ds_j5_x", //  = 23
        "ds_j5_y", //  = 24
        "ds_j5_z", //  = 25

        "ds_tool_type"   //  = 26
    ]*/
/*
Dexter.robot_status_labels = [
    "INSTRUCTION_ID",       // = 0
    "INSTRUCTION_TYPE",     // = 1 //the "oplet". helps in debugging
    "ERROR_CODE",           // = 2 //0 means no error.

    "BASE_POSITION_AT",     // 3  j0  means angle degrees.  base is bottom
    "END_POSITION_AT",      // 4  j2
    "PIVOT_POSITION_AT",    // 5  j1
    "ANGLE_POSITION_AT",    // 6  j3
    "ROTATE_POSITION_AT",   // 7  j4

//TABLE CALCULATED DELTA
    "BASE_POSITION_DELTA",   // 8   delta diff between where commanded to go and where optical encoder says.
    "END_POSITION_DELTA",    // 9
    "PIVOT_POSITION_DELTA",  // 10
    "ANGLE_POSITION_DELTA",  // 11
    "ROTATE_POSITION_DELTA", // 12

//PID CALCULATED DELTA
    "BASE_POSITION_PID_DELTA",   // 13     proportion integraded d.... math fn. helps hone in, reducing ocillation. closest to the force
    "END_POSITION_PID_DELTA",    // 14
    "PIVOT_POSITION_PID_DELTA",  // 12
    "ANGLE_POSITION_PID_DELTA",  // 13
    "ROTATE_POSITION_PID_DELTA", // 14

// FORCE CALCULATED POSITION MODIFICATION
    "BASE_POSITION_FORCE_DELTA",    // 15   hair
    "END_POSITION_FORCE_DELTA",     // 16
    "PIVOT_POSITION_FORCE_DELTA",   // 17
    "ANGLE_POSITION_FORCE_DELTA",   // 18
    "ROT_POSITION_FORCE_DELTA",     // 19

// RAW ANALOG TO DIGITAL VALUES from A 2 D converter
    "BASE_SIN", //  20
    "BASE_COS", //  21
    "END_SIN",  //  22
    "END_COS",  //  23
    "PIVOT_SIN",//  24
    "PIVOT_COS",//  25
    "ANGLE_SIN",//  26
    "ANGLE_COS",//  27
    "ROT_SIN",  //  28
    "ROT_COS",  //  29

    "DMA_READ_DATA",    //  30   // PROB SHOULD NOT BE USED WITH DDE

// RECORD AND PLAYBACK
    "RECORD_BLOCK_SIZE",        //  31
    "READ_BLOCK_COUNT",         //  32
    "PLAYBACK_BASE_POSITION",   //  33
    "PLAYBACK_END_POSITION",    //  34
    "PLAYBACK_PIVOT_POSITION",  //  35
    "PLAYBACK_ANGLE_POSITION",  //  36
    "PLAYBACK_ROT_POSITION",    //  37

    "END_EFFECTOR_IO_IN",   //  38   32 bits coming from the end effector.

    "SENT_BASE_POSITION",   //  39  where we told joint to go, - 250k to + 250k fixed
    "SENT_END_POSITION",    //  40
    "SENT_PIVOT_POSITION",  //  41
    "SENT_ANGLE_POSITION",  //  42
    "SENT_ROT_POSITION",    //  43

    "SLOPE_BASE_POSITION",  //  44   where at in acell curve. minimize jerk
    "SLOPE_END_POSITION",   //  45
    "SLOPE_PIVOT_POSITION", //  46
    "SLOPE_ANGLE_POSITION", //  47
    "SLOPE_ROT_POSITION"    //  48
] */
//for acknowledgement
/* obsolete Jan 2021
Dexter.robot_ack_labels = [
//new name   old name                   array index
// misc block
    "JOB_ID",              //0
    "INSTRUCTION_ID",      //1
    "START_TIME",          //2 //ms since jan 1, 1970? From Dexter's clock
    "STOP_TIME",           //3 //ms since jan 1, 1970? From Dexter's clock
    "INSTRUCTION_TYPE",    //4 "oplet"
    "ERROR_CODE"           //5   0 means ok
]*/

//call this from most code
Dexter$1.robot_status_labels_sm = function(sm=0){
    if(sm === 0) { return Dexter$1.robot_status_labels }
    else {
        let labels_name = "robot_status_labels_g" + sm;
        let actual_labels_array = Dexter$1[labels_name];
        if(actual_labels_array) { return actual_labels_array}
        else { return Dexter$1.robot_status_labels_g_other }
    }
};

Dexter$1.robot_status_labels = [
//new name             old name
// misc block                    array index
"JOB_ID",              //new field                    0 //for commmanded instruction (when added to queue)
"INSTRUCTION_ID",      //same name                    1 //for cmd ins
"START_TIME",          //new field                    2 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
"STOP_TIME",           //new field                    3 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
"INSTRUCTION_TYPE",    //same name                    4 //for cmd ins  //"oplet"

"ERROR_CODE",          //same name                    5 //for any error      //0 means no error. 1 means an error
"DMA_READ_DATA",       //                             6 // deprecated DMA_READ_DATA  then deprecated  "JOB_ID_OF_CURRENT_INSTRUCTION"
"READ_BLOCK_COUNT",    //                             7 // deprecated READ_BLOCK_COUNT then deprecated CURRENT_INSTRUCTION_ID
"STATUS_MODE",         //same name                    8 //was RECORD_BLOCK_SIZE and was unused
"END_EFFECTOR_IO_IN",     //END_EFFECTOR_IO_IN        9 // was END_EFFECTOR_IN for a while, 0, 1, or 2 indicating type of io for end effector
//J1 block
"J1_ANGLE",            // BASE_POSITION_AT           10 //means commanded stepped angle, not commanded_angle and not current_angle
"J1_DELTA",            // BASE_POSITION_DELTA        11
"J1_PID_DELTA",        // BASE_POSITION_PID_DELTA    12
null,                  // BASE_POSITION_FORCE_DELTA  13 //was J1_FORCE_CALC_ANGLE
"J1_A2D_SIN",          // BASE_SIN                   14
"J1_A2D_COS",          // BASE_COS                   15
"J1_MEASURED_ANGLE",   // PLAYBACK_BASE_POSITION     16 //deprecated J1_PLAYBACK
"J1_SENT",             // SENT_BASE_POSITION         17 //unused. angle sent in the commanded angle of INSTRUCTION_ID
"J7_MEASURED_ANGLE",   // SLOPE_BASE_POSITION        18 //deprecated J1_SLOPE
 null,                 //                            19 //was J1_MEASURED_ANGLE. not used, get rid of, now don't compute on dde side,
//J2 block of 10
"J2_ANGLE",            // END_POSITION_AT            20
"J2_DELTA",            // END_POSITION_DELTA         21
"J2_PID_DELTA",        // END_POSITION_PID_DELTA     22 was J2_FORCE_CALC_ANGLE
null,                  // END_POSITION_FORCE_DELTA   23
"J2_A2D_SIN",          // END_SIN                    24
"J2_A2D_COS",          // END_COS                    25
"J2_MEASURED_ANGLE",   // PLAYBACK_END_POSITION      26 //deprecated J2_PLAYBACK
"J2_SENT",             // SENT_END_POSITION          27 //unused
"J7_MEASURED_TORQUE",  // SLOPE_END_POSITION         28 //deprecated J2_SLOPE
 null,                 // new field                  29 //was J2_MEASURED_ANGLE, not used, get rid of,
//J2 block of 10
"J3_ANGLE",            // PIVOT_POSITION_AT           30
"J3_DELTA",            // PIVOT_POSITION_DELTA        31
"J3_PID_DELTA",        // PIVOT_POSITION_PID_DELTA    32
null,                  // PIVOT_POSITION_FORCE_DELTA  33  was "J3_FORCE_CALC_ANGLE"
"J3_A2D_SIN",          // PIVOT_SIN                   34
"J3_A2D_COS",          // PIVOT_SIN                   35
"J3_MEASURED_ANGLE",   // PLAYBACK_PIVOT_POSITION     36 //deprecated J3_PLAYBACK
"J3_SENT",             // SENT_PIVOT_POSITION         37 //unused
"J6_MEASURED_ANGLE",   // SLOPE_PIVOT_POSITION        38 //deprecated  J3_SLOPE
 null,                 // new field                   39 //was J3_MESURED_ANGLE not used get rid of
//J4 block of 10
"J4_ANGLE",            // ANGLE_POSITION_AT           40
"J4_DELTA",            // ANGLE_POSITION_DELTA        41
"J4_PID_DELTA",        // ANGLE_POSITION_PID_DELTA    42
null,                  // ANGLE_POSITION_FORCE_DELTA  43 was "J4_FORCE_CALC_ANGLE"
"J4_A2D_SIN",          // ANGLE_SIN                   44
"J4_A2D_COS",          // ANGLE_SIN                   45
"J4_MEASURED_ANGLE",   // PLAYBACK_ANGLE_POSITION     46 //deprecated J4_PLAYBACK
"J4_SENT",             // SENT_ANGLE_POSITION         47 //unused
"J6_MEASURED_TORQUE",  // SLOPE_ANGLE_POSITION        48 //deprecated J4_SLOPE
null,                  // new field                   49 //not used get rid of
//J4 block of 10
"J5_ANGLE",            // ROTATE_POSITION_AT          50
"J5_DELTA",            // ROTATE_POSITION_DELTA       51
"J5_PID_DELTA",        // ROTATE_POSITION_PID_DELTA   52
null,                  // ROT_POSITION_FORCE_DELTA    53 was "J5_FORCE_CALC_ANGLE"
"J5_A2D_SIN",          // ROT_SIN                     54
"J5_A2D_COS",          // ROT_SIN                     55
"J5_MEASURED_ANGLE",   // PLAYBACK_ROT_POSITION       56 //deprecated J5_PLAYBACK
"J5_SENT",             // SENT_ROT_POSITION           57 //unused
null,                  // SLOPE_ROT_POSITION          58 //deprecated J5_SLOPE  unusued
null                   // new field                   59 //was J5_MEASURED_ANGLE, not used get rid of
];


//its inefficient to have effectively 3 lists, but the sans-index list is good for
//short labels used in tables, and the index is nice and explicit
//for robot.robot_status[Dexter.foo_index] access
//The explicit Dexter.robot_status_index_labels is needed for a series.
Dexter$1.make_robot_status_indices = function(labels = Dexter$1.robot_status_labels, index_array=Dexter$1.robot_status_index_labels){
    for(var i = 0; i < labels.length; i++){
        var label = labels[i]; //could be null
        if (label) {
            var index_label = "Dexter." + label; //+ "_INDEX"
            Dexter$1[label] = i;
            index_array.push(index_label);
        }
    }
};

Dexter$1.robot_status_index_labels = [];
Dexter$1.make_robot_status_indices();

Dexter$1.make_backward_compatible_robot_status_indices = function(){
    Dexter$1.DMA_READ_DATA    = 6;
    Dexter$1.READ_BLOCK_COUNT = 7;
    Dexter$1.RECORD_BLOCK_SIZE = 8;
    Dexter$1.END_EFFECTOR_IN  = 9;

    Dexter$1.J1_PLAYBACK = 16;
    Dexter$1.J1_SLOPE    = 18;

    Dexter$1.J2_PLAYBACK = 26;
    Dexter$1.J2_SLOPE    = 28;

    Dexter$1.J3_PLAYBACK = 36;
    Dexter$1.J3_SLOPE    = 38;

    Dexter$1.J4_PLAYBACK = 46;
    Dexter$1.J4_SLOPE    = 48;

    Dexter$1.J5_PLAYBACK = 56;
    Dexter$1.J5_SLOPE    = 58;

    Dexter$1.J1_FORCE_CALC_ANGLE = Dexter$1.J1_MEASURED_ANGLE;
    Dexter$1.J2_FORCE_CALC_ANGLE = Dexter$1.J2_MEASURED_ANGLE;
    Dexter$1.J3_FORCE_CALC_ANGLE = Dexter$1.J3_MEASURED_ANGLE;
    Dexter$1.J4_FORCE_CALC_ANGLE = Dexter$1.J4_MEASURED_ANGLE;
    Dexter$1.J5_FORCE_CALC_ANGLE = Dexter$1.J5_MEASURED_ANGLE;
};

Dexter$1.make_backward_compatible_robot_status_indices();


Dexter$1.make_default_status_array = function(){
    let result = new Array(Dexter$1.robot_status_labels.length).fill(0);
    result[Dexter$1.INSTRUCTION_ID]   = -1;
    result[Dexter$1.INSTRUCTION_TYPE] = "g";
    result[Dexter$1.J6_MEASURED_ANGLE] = (0 - 512) * Socket$1.DEGREES_PER_DYNAMIXEL_UNIT;  //should result in degrees
    return result
};

Dexter$1.make_default_status_array_g1 = function(){
    let result = new Array(Dexter$1.robot_status_labels_g1.length).fill(0);
    result[Dexter$1.INSTRUCTION_ID]   = -1;
    result[Dexter$1.INSTRUCTION_TYPE] = "g";
    result[Dexter$1.STATUS_MODE] = 1;
    let index_j6_ma = Dexter$1.robot_status_labels_g1.indexOf("J6_MEASURED_ANGLE_G1");
    result[index_j6_ma] = -512;
    return result
};

Dexter$1.make_default_status_array_g_other = function(sm){
    let result = new Array(Dexter$1.robot_status_labels.length).fill(0);
    result[Dexter$1.INSTRUCTION_ID]   = -1;
    result[Dexter$1.INSTRUCTION_TYPE] = "g";
    result[Dexter$1.STATUS_MODE] = sm;
    return result
};

//call this from most code
Dexter$1.make_default_status_array_g_sm = function(sm=0){
    let meth_name = "make_default_status_array_g" + sm;
    let meth = Dexter$1[meth_name];
    if(meth) { return  meth.call(this) }
    else     { return Dexter$1.make_default_status_array_g_other(sm) }
};

Dexter$1.robot_status_labels_g1 = [
    // misc block
    "JOB_ID",              //new field  0 //for commmanded instruction (when added to queue)
    "INSTRUCTION_ID",      //same name  1 //for cmd ins
    "START_TIME",          //new field  2 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "STOP_TIME",           //new field  3 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "INSTRUCTION_TYPE",    //same name  4 //for cmd ins  //"oplet"

    "ERROR_CODE",          //same name  5 //for any error      //0 means no error. 1 means an error
    "DMA_READ_DATA",       //           6 // deprecated DMA_READ_DATA then deprecated JOB_ID_OF_CURRENT_INSTRUCTION
    "READ_BLOCK_COUNT",    //           7 // deprecated READ_BLOCK_COUNT then deprecated CURRENT_INSTRUCTION_ID
    "STATUS_MODE",   //same name        8
    "END_EFFECTOR_IO_IN",  //END_EFFECTOR_IO_IN 9 // was END_EFFECTOR_IN for a while, 0, 1, or 2 indicating type of io for end effector

    "J1_MEASURED_ANGLE_G1", //10
    "J2_MEASURED_ANGLE_G1", //11
    "J3_MEASURED_ANGLE_G1", //12
    "J4_MEASURED_ANGLE_G1", //13
    "J5_MEASURED_ANGLE_G1", //14
    "J6_MEASURED_ANGLE_G1", //15
    "J7_MEASURED_ANGLE_G1", //16
    null,                   //17
    null,                   //18
    null,                   //19

    "J1_TORQUE_G1", //20
    "J2_TORQUE_G1", //21
    "J3_TORQUE_G1", //22
    "J4_TORQUE_G1", //23
    "J5_TORQUE_G1", //24
    "J6_TORQUE_G1", //25
    "J7_TORQUE_G1", //26
    null,           //27
    null,           //28
    null,           //29

    "J1_VELOCITY_G1", //30
    "J2_VELOCITY_G1", //31
    "J3_VELOCITY_G1", //32
    "J4_VELOCITY_G1", //33
    "J5_VELOCITY_G1", //34
    "J6_VELOCITY_G1", //35
    "J7_VELOCITY_G1", //36
    null,             //37
    null,             //38
    null,             //39

    null,            //40
    null,            //41
    null,            //42
    null,            //43
    null,            //44
    null,            //45
    null,            //46
    null,            //47
    null,            //48
    null,            //49

    null,            //50
    null,            //51
    null,            //52
    null,            //53
    null,            //54
    null,            //55
    null,            //56
    null,            //57
    null,            //58
    null             //59
];

Dexter$1.robot_status_index_labels_g1 = [];
Dexter$1.make_robot_status_indices(Dexter$1.robot_status_labels_g1, Dexter$1.robot_status_index_labels_g1);

/* changes from g0 to g2:
DONE Replace *_AT (presumably ANGLE as in J1_ANGLE) with *_RAW_ENCODER_ANGLE_FXP
DONE Replace *_DELTA with *_EYE_NUMBER
NO CHANGE Keep *_PID_DELTA
DON'T DO: Replace *_FORCE_DELTA with AdcCenter  What's FORCE_DELTA?
NO CHANGE Keep *_SIN
NO CHANGE Keep *_COS
NO CHANGE Keep MEASURED_ANGLE
*/
Dexter$1.robot_status_labels_g2 = [
//new name             old name
// misc block                    array index
    "JOB_ID",              //new field                    0 //for commmanded instruction (when added to queue)
    "INSTRUCTION_ID",      //same name                    1 //for cmd ins
    "START_TIME",          //new field                    2 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "STOP_TIME",           //new field                    3 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "INSTRUCTION_TYPE",    //same name                    4 //for cmd ins  //"oplet"

    "ERROR_CODE",          //same name                    5 //for any error      //0 means no error. 1 means an error
    "DMA_READ_DATA",       //                             6 // deprecated DMA_READ_DATA  then deprecated  "JOB_ID_OF_CURRENT_INSTRUCTION"
    "READ_BLOCK_COUNT",    //                             7 // deprecated READ_BLOCK_COUNT then deprecated CURRENT_INSTRUCTION_ID
    "STATUS_MODE",   //same name                    8 //was RECORD_BLOCK_SIZE and was unused
    "END_EFFECTOR_IO_IN",     //END_EFFECTOR_IO_IN           9 // was END_EFFECTOR_IN for a while, 0, 1, or 2 indicating type of io for end effector

//J1 block
    "J1_RAW_ENCODER_ANGLE_FXP_G2",            // BASE_POSITION_AT           10 //means commanded stepped angle, not commanded_angle and not current_angle
    "J1_EYE_NUMBER_G2",            // BASE_POSITION_DELTA        11
    "J1_PID_DELTA_G2",        // BASE_POSITION_PID_DELTA    12
    null,                  // BASE_POSITION_FORCE_DELTA  13 //was J1_FORCE_CALC_ANGLE
    "J1_A2D_SIN_G2",          // BASE_SIN                   14
    "J1_A2D_COS_G2",          // BASE_COS                   15
    "J1_MEASURED_ANGLE_G2",   // PLAYBACK_BASE_POSITION     16 //deprecated J1_PLAYBACK
    "J1_SENT_G2",             // SENT_BASE_POSITION         17 //unused. angle sent in the commanded angle of INSTRUCTION_ID
    "J7_MEASURED_ANGLE_G2",   // SLOPE_BASE_POSITION        18 //deprecated J1_SLOPE
    null,                 //                            19 //was J1_MEASURED_ANGLE. not used, get rid of, now don't compute on dde side,
//J2 block of 10
    "J2_RAW_ENCODER_ANGLE_FXP_G2",            // END_POSITION_AT            20
    "J2_EYE_NUMBER_G2",            // END_POSITION_DELTA         21
    "J2_PID_DELTA_G2",        // END_POSITION_PID_DELTA     22 was J2_FORCE_CALC_ANGLE
    null, // END_POSITION_FORCE_DELTA   23
    "J2_A2D_SIN_G2",          // END_SIN                    24
    "J2_A2D_COS_G2",          // END_COS                    25
    "J2_MEASURED_ANGLE_G2",   // PLAYBACK_END_POSITION      26 //deprecated J2_PLAYBACK
    "J2_SENT_G2",             // SENT_END_POSITION          27 //unused
    "J7_MEASURED_TORQUE_G2",  // SLOPE_END_POSITION         28 //deprecated J2_SLOPE
    null,                 // new field                  29 //was J2_MEASURED_ANGLE, not used, get rid of,
//J2 block of 10
    "J3_RAW_ENCODER_ANGLE_FXP_G2",            // PIVOT_POSITION_AT           30
    "J3_EYE_NUMBER_G2",            // PIVOT_POSITION_DELTA        31
    "J3_PID_DELTA_G2",        // PIVOT_POSITION_PID_DELTA    32
    null,                  // PIVOT_POSITION_FORCE_DELTA  33  was "J3_FORCE_CALC_ANGLE"
    "J3_A2D_SIN_G2",          // PIVOT_SIN                   34
    "J3_A2D_COS_G2",          // PIVOT_SIN                   35
    "J3_MEASURED_ANGLE_G2",   // PLAYBACK_PIVOT_POSITION     36 //deprecated J3_PLAYBACK
    "J3_SENT_G2",             // SENT_PIVOT_POSITION         37 //unused
    "J6_MEASURED_ANGLE_G2",   // SLOPE_PIVOT_POSITION        38 //deprecated  J3_SLOPE
    null,                 // new field                   39 //was J3_MESURED_ANGLE not used get rid of
//J4 block of 10
    "J4_RAW_ENCODER_ANGLE_FXP_G2",            // ANGLE_POSITION_AT           40
    "J4_EYE_NUMBER_G2",            // ANGLE_POSITION_DELTA        41
    "J4_PID_DELTA_G2",        // ANGLE_POSITION_PID_DELTA    42
    null,                  // ANGLE_POSITION_FORCE_DELTA  43 was "J4_FORCE_CALC_ANGLE"
    "J4_A2D_SIN_G2",          // ANGLE_SIN                   44
    "J4_A2D_COS_G2",          // ANGLE_SIN                   45
    "J4_MEASURED_ANGLE_G2",   // PLAYBACK_ANGLE_POSITION     46 //deprecated J4_PLAYBACK
    "J4_SENT_G2",             // SENT_ANGLE_POSITION         47 //unused
    "J6_MEASURED_TORQUE_G2",  // SLOPE_ANGLE_POSITION        48 //deprecated J4_SLOPE
    null,                  // new field                   49 //not used get rid of
//J4 block of 10
    "J5_RAW_ENCODER_ANGLE_FXP_G2",            // ROTATE_POSITION_AT          50
    "J5_EYE_NUMBER_G2",            // ROTATE_POSITION_DELTA       51
    "J5_PID_DELTA_G2",        // ROTATE_POSITION_PID_DELTA   52
    null,                  // ROT_POSITION_FORCE_DELTA    53 was "J5_FORCE_CALC_ANGLE"
    "J5_A2D_SIN_G2",          // ROT_SIN                     54
    "J5_A2D_COS_G2",          // ROT_SIN                     55
    "J5_MEASURED_ANGLE_G2",   // PLAYBACK_ROT_POSITION       56 //deprecated J5_PLAYBACK
    "J5_SENT_G2",             // SENT_ROT_POSITION           57 //unused
    null,                  // SLOPE_ROT_POSITION          58 //deprecated J5_SLOPE  unusued
    null                   // new field                   59 //was J5_MEASURED_ANGLE, not used get rid of
];
Dexter$1.robot_status_index_labels_g2 = [];
Dexter$1.make_robot_status_indices(Dexter$1.robot_status_labels_g2, Dexter$1.robot_status_index_labels_g2);

Dexter$1.robot_status_labels_g_other = [
    // misc block
    "JOB_ID",              //new field                    0 //for commmanded instruction (when added to queue)
    "INSTRUCTION_ID",      //same name                    1 //for cmd ins
    "START_TIME",          //new field                    2 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "STOP_TIME",           //new field                    3 //for cmd ins//ms since jan 1, 1970? From Dexter's clock
    "INSTRUCTION_TYPE",    //same name                    4 //for cmd ins  //"oplet"

    "ERROR_CODE",          //same name                    5 //for any error      //0 means no error. 1 means an error
    "DMA_READ_DATA",       //                             6 // deprecated DMA_READ_DATA then deprecated JOB_ID_OF_CURRENT_INSTRUCTION
    "READ_BLOCK_COUNT",    //                             7 // deprecated READ_BLOCK_COUNT then deprecated CURRENT_INSTRUCTION_ID
    "STATUS_MODE",   //same name                    8
    "END_EFFECTOR_IO_IN",  //END_EFFECTOR_IO_IN           9 // was END_EFFECTOR_IN for a while, 0, 1, or 2 indicating type of io for end effector

    "RS_10_G_OTHER", //10
    "RS_11_G_OTHER", //11
    "RS_12_G_OTHER", //12
    "RS_13_G_OTHER", //13
    "RS_14_G_OTHER", //14
    "RS_15_G_OTHER", //15
    "RS_16_G_OTHER", //16
    "RS_17_G_OTHER", //17
    "RS_18_G_OTHER", //18
    "RS_19_G_OTHER", //19

    "RS_20_G_OTHER", //20
    "RS_21_G_OTHER", //21
    "RS_22_G_OTHER", //22
    "RS_23_G_OTHER", //23
    "RS_24_G_OTHER", //24
    "RS_25_G_OTHER", //25
    "RS_26_G_OTHER", //26
    "RS_27_G_OTHER", //27
    "RS_28_G_OTHER", //28
    "RS_29_G_OTHER", //29

    "RS_30_G_OTHER", //30
    "RS_31_G_OTHER", //31
    "RS_32_G_OTHER", //32
    "RS_33_G_OTHER", //33
    "RS_34_G_OTHER", //34
    "RS_35_G_OTHER", //35
    "RS_36_G_OTHER", //36
    "RS_37_G_OTHER", //37
    "RS_38_G_OTHER", //38
    "RS_39_G_OTHER", //39

    "RS_40_G_OTHER", //40
    "RS_41_G_OTHER", //41
    "RS_42_G_OTHER", //42
    "RS_43_G_OTHER", //43
    "RS_44_G_OTHER", //44
    "RS_45_G_OTHER", //45
    "RS_46_G_OTHER", //46
    "RS_47_G_OTHER", //47
    "RS_48_G_OTHER", //48
    "RS_49_G_OTHER", //49

    "RS_50_G_OTHER", //50
    "RS_51_G_OTHER", //51
    "RS_52_G_OTHER", //52
    "RS_53_G_OTHER", //53
    "RS_54_G_OTHER", //54
    "RS_55_G_OTHER", //55
    "RS_56_G_OTHER", //56
    "RS_57_G_OTHER", //57
    "RS_58_G_OTHER", //58
    "RS_59_G_OTHER"  //59
];

Dexter$1.robot_status_index_labels_g_other = [];
Dexter$1.make_robot_status_indices(Dexter$1.robot_status_labels_g_other, Dexter$1.robot_status_index_labels_g_other);


Dexter$1.tool_names = [
    "no_tool",      //0
    "unknown_tool" //1
];

Dexter$1.error_code_strings = [
    "OK",   //0
    "error" //1
];

//____________END of Dexter Database______________
Dexter$1.tool_type_to_name = function(tool_type){
    if(tool_type < Dexter$1.tool_names.length){
        return Dexter$1.tool_names[tool_type]
    }
    else { return "unknown_tool" }
};

Dexter$1.error_code_to_string = function(error_code){
    if(error_code < Dexter$1.error_code_strings.length){
        return Dexter$1.error_code_strings[error_code]
    }
    else { return "error" }
};

Dexter$1.robot_status_to_html = function(rs, where_from = ""){
    if (rs === null) { return "robot_status " + where_from + " : null,<br/>" }
    else {
        let html_table = Dexter$1.robot_status_to_html_table(rs);
        return "<details><summary>robot_status fields " + where_from + "</summary>" + html_table + "</details>"
    }
};
//also called by Job.show_robot_status_history_item
Dexter$1.robot_status_to_html_table = function(ds){
        //setting table class and using css to set fonts in th and td cells fails
        //let cs = " style='font-size:10pt;' " //cell style
        let oplet = ds[Dexter$1.INSTRUCTION_TYPE];
        let long_start_time_string = date_integer_to_long_string(ds[Dexter$1.START_TIME]);
        let long_stop_time_string = date_integer_to_long_string(ds[Dexter$1.STOP_TIME]);
        let result =
        "<table class='robot_status_table'>" +
        "<tr><th></th>                        <th>JOB_ID</th>                           <th>INSTRUCTION_ID</th>                                                            <th>START_TIME</th>                                                         <th>STOP_TIME</th>                                                                              <th>INSTRUCTION_TYPE</th> </tr>" +
        "<tr><td></td><td>"           + ds[Dexter$1.JOB_ID]         + "</td><td>" + ds[Dexter$1.INSTRUCTION_ID]   + "</td><td title='" + long_start_time_string + "'>" + ds[Dexter$1.START_TIME] + "</td><td title='" + long_stop_time_string + "'>" + ds[Dexter$1.STOP_TIME] + "</td><td title='" + Robot$1.instruction_type_to_function_name(oplet)  + "'>" + oplet +        "</td></tr>" +

        "<tr><th></th>              <th>ERROR_CODE</th>                          <th>DMA_READ_DATA</th>                    <th>READ_BLOCK_COUNT</th>                   <th>STATUS_MODE</th>                                                                 <th>END_EFFECTOR_IO_IN</th></tr>"      +
        "<tr><td></td><td>" + ds[Dexter$1.ERROR_CODE] + "</td> <td>"       + ds[Dexter$1.DMA_READ_DATA]  + "</td><td>" + ds[Dexter$1.READ_BLOCK_COUNT] + "</td><td>" + ds[Dexter$1.STATUS_MODE]                                               + "</td><td>" + ds[Dexter$1.END_EFFECTOR_IO_IN] + "</td></tr>" +

        "<tr><th></th>                   <th>Joint 1</th>                          <th>Joint 2</th>                          <th>Joint 3</th>                          <th>Joint 4</th>                          <th>Joint 5</th></tr>" +
        "<tr><th>ANGLE</th><td>"      + ds[Dexter$1.J1_ANGLE]       + "</td><td>" + ds[Dexter$1.J2_ANGLE]       + "</td><td>" + ds[Dexter$1.J3_ANGLE]       + "</td><td>" + ds[Dexter$1.J4_ANGLE]       + "</td><td>" + ds[Dexter$1.J5_ANGLE]     + "</td></tr>" +
        "<tr><th>DELTA</th><td>"      + ds[Dexter$1.J1_DELTA]       + "</td><td>" + ds[Dexter$1.J2_DELTA]       + "</td><td>" + ds[Dexter$1.J3_DELTA]       + "</td><td>" + ds[Dexter$1.J4_DELTA]       + "</td><td>" + ds[Dexter$1.J5_DELTA]     + "</td></tr>" +
        "<tr><th>PID_DELTA</th><td>"  + ds[Dexter$1.J1_PID_DELTA]   + "</td><td>" + ds[Dexter$1.J2_PID_DELTA]   + "</td><td>" + ds[Dexter$1.J3_PID_DELTA]   + "</td><td>" + ds[Dexter$1.J4_PID_DELTA]   + "</td><td>" + ds[Dexter$1.J5_PID_DELTA] + "</td></tr>" +
        "<tr><th>FORCE_CALC_ANGLE</th><td>"     + ds[Dexter$1.J1_FORCE_CALC_ANGLE]      + "</td><td>" + ds[Dexter$1.J2_FORCE_CALC_ANGLE]      + "</td><td>" + ds[Dexter$1.J3_FORCE_CALC_ANGLE]      + "</td><td>" + ds[Dexter$1.J4_FORCE_CALC_ANGLE]      + "</td><td>" + ds[Dexter$1.J5_FORCE_CALC_ANGLE]    + "</td></tr>" +
        "<tr><th>A2D_SIN</th><td>"    + ds[Dexter$1.J1_A2D_SIN]     + "</td><td>" + ds[Dexter$1.J2_A2D_SIN]     + "</td><td>" + ds[Dexter$1.J3_A2D_SIN]     + "</td><td>" + ds[Dexter$1.J4_A2D_SIN]     + "</td><td>" + ds[Dexter$1.J5_A2D_SIN]   + "</td></tr>" +
        "<tr><th>A2D_COS</th><td>"    + ds[Dexter$1.J1_A2D_COS]     + "</td><td>" + ds[Dexter$1.J2_A2D_COS]     + "</td><td>" + ds[Dexter$1.J3_A2D_COS]     + "</td><td>" + ds[Dexter$1.J4_A2D_COS]     + "</td><td>" + ds[Dexter$1.J5_A2D_COS]   + "</td></tr>" +
        "<tr><th>PLAYBACK</th><td>"   + ds[Dexter$1.J1_PLAYBACK]    + "</td><td>" + ds[Dexter$1.J2_PLAYBACK]    + "</td><td>" + ds[Dexter$1.J3_PLAYBACK]    + "</td><td>" + ds[Dexter$1.J4_PLAYBACK]    + "</td><td>" + ds[Dexter$1.J5_PLAYBACK]  + "</td></tr>" +
        "<tr><th>SENT</th><td>"       + ds[Dexter$1.J1_SENT]        + "</td><td>" + ds[Dexter$1.J2_SENT]        + "</td><td>" + ds[Dexter$1.J3_SENT]        + "</td><td>" + ds[Dexter$1.J4_SENT]        + "</td><td>" + ds[Dexter$1.J5_SENT]      + "</td></tr>" +
        "<tr><th>SLOPE</th><td>"      + ds[Dexter$1.J1_SLOPE]       + "</td><td>" + ds[Dexter$1.J2_SLOPE]       + "</td><td>" + ds[Dexter$1.J3_SLOPE]       + "</td><td>" + ds[Dexter$1.J4_SLOPE]       + "</td><td>" + ds[Dexter$1.J5_SLOPE]     + "</td></tr>" +
        "</table>";
        return result
};


Dexter$1.sent_instructions_to_html = function(sent_ins){
    var result = "<table><tr>" +
        "<th>JOB_ID</th>" +
        "<th title='The instruction_id is the same as the program counter at send time.'>INS ID</th>" +
        "<th>START_TIME</th>" +
        "<th>STOP_TIME</th>" +
        "<th>INSTRUCTION_TYPE</th>" +
        "<th>Instruction arguments</th></tr>";
    for(var ins of sent_ins){
        var instruction_type = Instruction$1.extract_instruction_type(ins);
        var instruction_name = " (" + Robot$1.instruction_type_to_function_name(instruction_type) + ")";
        result +=  "<tr><td>" + Instruction$1.extract_job_id(ins)          + "</td><td>" +
                                Instruction$1.extract_instruction_id(ins)  + "</td><td>" +
                                Instruction$1.extract_start_time(ins)      + "</td><td>" +
                                Instruction$1.extract_stop_time(ins)       + "</td><td>" +
                                instruction_type + instruction_name      + "</td><td>" +
                                Instruction$1.extract_args(ins)            + "</td></tr>";
    }
    result += "</table>";
    return "<details style='display:inline-block;'><summary></summary>" + result + "</details>"
};
//called from utils stringify_value
Dexter$1.make_show_rs_history_button_html = function(job_id){
    return "<button class='onclick_via_data' data-onclick='Dexter.show_rs_history,," + job_id + "'>Show robot status history</button>"

};
//called from inspect
Dexter$1.make_show_rs_history_button_html2 = function(job_id){
    return "<button onclick='Dexter.show_rs_history(" + job_id + ")'>Show robot status history</button>"

};

//start the process in ui
Dexter$1.show_rs_history = function(job_id){
    job_id = parseInt(job_id); //coming from UI so job_id likely a string to start with.
    Dexter$1.show_rs_history_get_rs_history(job_id);
};

Dexter$1.show_rs_history_get_rs_history = function(job_id){
    var the_job = Job$1.job_id_to_job_instance(job_id);
    var rob     = the_job.robot;
    var rs_history = the_job.rs_history;
    var rs_labels  = rob.constructor.robot_status_labels;
    if (rob instanceof Dexter$1) { //shove the xyz on the end of every rs, and append xyz to the labels too.
         rs_labels = rs_labels.concat(["End_Effector_X", "End_Effector_Y","End_Effector_Z"]);
         let new_rs_history = [];
         for (let i = 0; i < rs_history.length; i++){
            let rs = rs_history[i];
            let robot_status_instance = new RobotStatus$1({robot_status: rs});
            let sm = robot_status_instance.status_mode();
            if((sm === 0) || (sm === 1)) {
                //let angles = [rs[Dexter.J1_MEASURED_ANGLE], rs[Dexter.J2_MEASURED_ANGLE], rs[Dexter.J3_MEASURED_ANGLE], rs[Dexter.J4_MEASURED_ANGLE], rs[Dexter.J5_MEASURED_ANGLE]]
                let a_xyz  = robot_status_instance.xyz()[0];
                new_rs_history.push(rs.concat(a_xyz));
            }
            else { new_rs_history.push(rs); }
        }
        rs_history = new_rs_history;
    }
    Dexter$1.show_rs_history_display(the_job.name, the_job.robot.name, the_job.status_code,
                 the_job.highest_completed_instruction_id,
                 the_job.sent_instructions,  rs_history, rs_labels
                );
};

Dexter$1.show_rs_history_display = function(job_name, robot_name, status, highest_completed_instruction_id, sent_instructions, rs_history, rs_labels){
    //var job_instance = Job.job_id_to_instance(job_id) //won't work cause we'er in the UI.
    //out("in show_rs_history_display: " + sent_instructions)
    var highest_sent_instruction = "null";
    if (sent_instructions.length > 0) {
        highest_sent_instruction = sent_instructions[sent_instructions.length - 1][1];
    }
    var top_info = "<div> " + status + ". highest_sent_instruction: " + highest_sent_instruction +
        " &nbsp;&nbsp;highest completed instruction: " + highest_completed_instruction_id + "</div>";
    show_window({content: top_info + "<div id='rs_history_table'/>",
        title: "Job: " + job_name + ",&nbsp;&nbsp; Robot: " + robot_name + ", &nbsp;&nbsp; Status History",
        width:  725,
        height: 300});
    Dexter$1.rs_history_populate_window(sent_instructions, rs_history, rs_labels);
};

Dexter$1.make_rs_history_dataFields = function(rs_labels){
    var result = [];
    for(var i  = 0; i < rs_labels.length; i++){
        result.push({name: i, type:"string"});
    }
    return result
};

Dexter$1.make_rs_history_columns = function(rs_labels, sent_instructions){
    var result = [];
    let label;
    let width;
    let cells_renderer = null; //function(row, column, value, rowData){
                                  //try { value =  JSON.stringify(value) }
                                  //catch (e) {}
                                 // return value}
    for(var i  = 0; i < rs_labels.length; i++){
        label  = rs_labels[i];
        width=90;
        cells_renderer = null;
        if      (label === null) { label = "unused"; }
        else if (label == "JOB_ID")   {
            label = "<span title='The Job this instruction is in.'>JOB_ID</span>"; //doesn't work. tooltip doesn't show up
            width=70;
        }
        else if (label == "INSTRUCTION_ID")   {
            label = "<span title='instruction_id in the Job of JOB_ID.'>INS_ID</span>"; //doesn't work. tooltip doesn't show up
            width=80;
            cells_renderer = function (row, column, value, rowData) {
                    let ins_id = parseInt(value);
                    let ins = Dexter$1.get_instruction_from_sent_instructions(sent_instructions, ins_id);
                    let ins_html = "Instruction Fields&#013;";
                    let label_index = 0;
                    for(let lab of Instruction$1.labels){
                        ins_html += lab +  ": " + ins[label_index] + "&#013";
                        label_index += 1;
                    }
                    let args_html = ins.slice(label_index);
                    try { args_html = JSON.stringify(args_html); }
                    catch (e) {}
                    ins_html += "args: " + args_html;
                    return "<div title='" + ins_html + "' style='width:100%;color:blue;'>" + value + "</div>"
                    };
        }
        else if (label == "START_TIME") {
            label = "<span title='In milliseconds since Jan 1, 1970.'>START_TIME</span>";
            width=120;
        }
        else if (label == "STOP_TIME") {
            label = "<span title='In milliseconds since Jan 1, 1970.'>STOP_TIME</span>";
            width=120;
        }
        else if (label == "INSTRUCTION_TYPE") { //beware, usually this tooltip doesn't show. Maybe a jqxwidget bug?
            label = "<span title='instruction_type, a.k.a oplet.'>Type</span>"; // setting title doesn't give tooltip
            width=54;
            cells_renderer = function (row, column, value, rowData) {
                let fn_name = Robot$1.instruction_type_to_function_name(value[1]); //value will be a string of 3 chars, an oplet surounded by double quots.
                return "<div title='" + fn_name + "' style='width:100%;color:blue;'>" + value + "</div>"
            };
        }
        else if (label == "ERROR_CODE") {  //beware, usually this tooltip doesn't show. Maybe a jqxwidget bug?
            label = "<span title='error_code. Zero means no error.'>Error</span>"; // setting title doesn't give tooltip
            width=60;
        }
        else if (label.startsWith("End_Effector")) {
            width = 170;
        }
        else { //other labels
           width = (Math.max(label.length, 8) * 10);
           if(i < 60) { width += 15; } //room for the array index number.
        }
        var pinned = (i < 3);
        if(i < 60) { label = i + ". " + label; }
        let col_obj = {text: label, dataField: i, width: width, pinned: pinned,
                        draggable: true, cellsRenderer: cells_renderer }; //draggable is supposed to make the column draggable but it doesn't
        result.push(col_obj);
    }
    return result
};

Dexter$1.get_instruction_from_sent_instructions = function(sent_instructions, instruction_id){
    for(var ins of sent_instructions){
        if(ins[Dexter$1.INSTRUCTION_ID] == instruction_id){
            return ins
        }
    }
    return null
};

Dexter$1.prepare_rses_for_display = function(rs_history){
    let result = [];
    for (let row of rs_history){
        let new_row = [];
        result.push(new_row);
        for(let elt of row){
            if (typeof(elt) != "number"){
                try{ elt = JSON.stringify(elt); }
                catch (e) {}
            }
            new_row.push(elt);
        }
    }
    return result
};

Dexter$1.rs_history_populate_window = function(sent_instructions, rs_history, rs_labels){
    // prepare the data
    var data = Dexter$1.prepare_rses_for_display(rs_history); // [] // rs_history //looks like all html formatting & tooltips in the data are just trhown out bu jqdatatable
    var source =
    {   localData: data,
        dataType: "array",
        dataFields: Dexter$1.make_rs_history_dataFields(rs_labels)
    };
    var dataAdapter = new $.jqx.dataAdapter(source);
    $("#rs_history_table").jqxDataTable(
        {   width:  700,
            height: 225,
            //columnsHeight: "32px", //jqx bug: when including this field, it causes the vertical scroll bar to disappear rendering scorlling of long tables impossible.
            // need 2 rows of text
            altRows:  true,
            sortable: true,
            //theme: 'energyblue',
            pageable: false, //true,
            //pagerButtonsCount: 10,
            source: dataAdapter,
            columnsResize: true,
            columns: Dexter$1.make_rs_history_columns(rs_labels, sent_instructions)
        });
};

/*Created by Fry on 7/4/16.*/



//_______PERSISTENT: store name-value pairs in a file. Keep a copy of hte file in JS env, persistent_values
//and write it out every time its changed.

persistent_values = {};

//returns undefined if key doesn't exist
function persistent_get$1(key="get_all"){
    if (key == "get_all") { return persistent_values }
    else { return persistent_values[key] }
}


//FILE SYSTEM

function read_file$1(path, encoding="utf8"){
    path = make_full_path(path);
    try{ return fs.readFileSync(path, encoding) }
    catch(err){
        if(err.message.startsWith("Access denied")){
            dde_error("You are not permitted to access files<br/>" +
                      " outside of Documents/dde_apps such as<br/>" +
                      path);
        }
        else {
            dde_error("read_file could not get the content of:<br/><code title='unEVALable'>" + path + "</code>");
        }
    }
}


//for paths starting with "dexter0:" and other dexters, this will always return false.
//you have to use read_file_async for that and pass it a callback that
//handles the err when the file doesn't exist.
function file_exists$1(path){
    path = make_full_path(path);
    return fs.existsSync(path)
}



//only works for dde computer, not dexter computer paths.
//is syncrhonous
function make_folder(path){
    path = make_full_path(path); //now parh is os_specific
    let path_array = path.split(folder_separator());
    let path_being_built = "";
    for(let path_part of path_array){
        if(path_part != ""){ //often the first and last path_part will be ""
            path_being_built += (folder_separator() + path_part);
            path_being_built = adjust_path_to_os(path_being_built);

            if(!file_exists$1(path_being_built)){
               try{
                    fs.mkdirSync(path_being_built);
               }
               catch(err){
                   dde_error("In make_folder, could not make: " + path_being_built + "<br/>" +
                             err.message);
               }
            }
        }
    }
    return true
}

function folder_separator(){
    if (operating_system == "win") { return "\\" }
    else                           { return "/"  }
}
//within dde, paths should have slashes.
//I convert "incomming paths to have slashes.
//but when we have to access the OS, the
//files have to be convered to be OS specific, ie for windows, have backslashes.
//for that we call adjust_path_to_os
function convert_backslashes_to_slashes(a_string){
    return a_string.replace(/\\/g, "/")
}

function add_default_file_prefix_maybe(path){
    if (is_root_path(path)) { return path }
    //else if (path.startsWith(dde_apps_folder)) { return path } //redundant with the above
    else if (path.includes(":")) { return path }
    else if (path.startsWith("dde_apps/")) {
        path = path.substring(8);
        return dde_apps_folder + path
    }
    else if(path.startsWith("./")) {  //return "dde_apps/" + path.substring(2)
        return dde_apps_folder + path.substring(1)
    }
    else if (path.startsWith("../")) {
        let core_path = path.substring(3);
        let last_slash_pos = dde_apps_folder.lastIndexOf("/");

        let up_from_dde_apps = dde_apps_folder.substring(0, last_slash_pos + 1);
        new_path = up_from_dde_apps + core_path;
        return new_path
    }
    else { return dde_apps_folder + "/" + path }
}


function adjust_path_to_os(path){
    if (path.includes("://")) { //looks like a url so leave it alone
       return path
    }
    else {//dde standard is to use / between separators and that's what users should use
          // But for windows compatibility we need backslash,. This fn called by dde utils like
          //read_file. Note if user passes in a path with backslashes,
          //this will do nothing. So on a windows machine, that's ok,
          //but on a mac or linux, that's bad. But this is unlikely to
          //happen on a mac or linus, esp since dde standard is slash.
        let result = path.replace(/\//g, folder_separator());
        //we might have  a path like \C:\foo.txt in which case, take off the initial backslash
        if(result.startsWith("\\") && //looks like we've got WindowsOS path
            //(result.length == 3) && //unnecessarily restrictive
            (result[2] == ":")) {
            result = result.substring(1);
        }
        return result
    }
}

function make_full_path(path, adjust_to_os=true){
    path = add_default_file_prefix_maybe(path);
    if (adjust_to_os) { path = adjust_path_to_os(path); }
    return path
}

function is_root_path(path){
    if(path.startsWith("/")) { return true }
    else if ((path.length > 1) && (path[1] == ":")){
        let first_char = path[0];
        return ((first_char >= "A") && (first_char <= "Z"))
    }
    else { return false }
    //return starts_with_one_of(path, ["/", "C:", "D:", "E:", "F:", "G:"]) //C: etc. is for Windows OS.
}

//returns boolean
//this can be called many times a session, but
//the first time its called, it actually does the work
//to figure out if the dexter really supports sending files or not,
//and that result is cached and used on all subsequent calls,
//until dde is booted.
function node_server_supports_editor(dexter_instance){
    if(dexter_instance.supports_editor !== undefined) {
        return dexter_instance.supports_editor
    }
    else {
        let url = "http://" + dexter_instance.ip_address + "/edit/folder.png";
        let content;
        try{
            content = get_page({url: url,
                                method: "GET",
                                timeout: 500 //no need for a long timeout here since should
                             //be a local wired connection.
            });
        }
        catch(err) { //could be timeout or just no node server on Dexter.
            dexter_instance.supports_editor = false;
            return false
        }
        if(content.startsWith("Error:")){
            dexter_instance.supports_editor = false;
            return false
        }
        else {
            dexter_instance.supports_editor = true;
            return true
        }
    }
}


//______new load_files synchronous______
//verify all paths first before loading any of them because we want to error early.
/*function load_files(...paths) {
   let prefix = dde_apps_folder + "/"
   let resolved_paths = []
   for (let path of paths){
       path = convert_backslashes_to_slashes(path) //use slashes throughout.
       if (is_root_path(path)){  //path.startsWith("/")
           let last_slash_pos = path.lastIndexOf("/")
           prefix = path.substring(0, last_slash_pos + 1) // prefix always starts and ends with a slash
       }
       else { path = prefix + path }
       if (path.endsWith(".js")){resolved_paths.push(path)}
       else if (path.endsWith("/")){ //this path is not loadable, its just to setup prefix for the next path
           if (is_root_path(path)) { //we've got a new prefix
               prefix = path
           }
           else {
               out("load_files passed a file path: " + path + " that ended in slash<br/>" +
                   "indicating that it should be a new  prefix for subsequent file names<br/>" +
                   "but it did not start with / <br/>" +
                   "so the prefix is incomplete.<br/>" +
                   "None of the files have been loaded.",
                   "red")
               dde_error("load_files could not resolve path: " + path + " into a proper file path.")
           }
       }
       else {
           out("load_files passed a file: " + path + "<br/>" +
               "that did not end in slash indicating a new url prefix<br/>" +
               "nor did it end with '.js' indicating a file to load.<br/>" +
               "None of the files have been loaded.",
               "red")
           dde_error("load_files could not resolve path: " + path + " into a proper file patn.")
       }
   }
   //now make sure we can get all the contents before actually loading any
   let contents = []
   for (let path of resolved_paths){
        let content = read_file(path) //might error
        contents.push(content)
   }
   //finally if we get to this point, we've got all the contents so time to load
    let result
    for (let resolved_paths_index = 0;
             resolved_paths_index < resolved_paths.length;
             resolved_paths_index ++){
        let resolved_path = resolved_paths[resolved_paths_index]
        let content = contents[resolved_paths_index]
        out("loading file: " + resolved_path, "green")
        result = window.eval(content)
    }
    return result
}*/
//simplied from above. ending in slash resets the default "prefix".
function load_files$1(...paths) {
    console.log("load_files called with: " + paths);
    let prefix = dde_apps_folder + "/"; //prefix always starts with slash and ends with slash
    let resolved_paths = [];
    for (let path of paths){
        //console.log("working on " + path)
        path = convert_backslashes_to_slashes(path); //use slashes throughout.
        if (path === "/"){ //just reset prefix to the default
            prefix = dde_apps_folder + "/";
        }
        else if (is_root_path(path)){  //path.startsWith("/")
            if (path.endsWith("/")) { prefix = path; }
            else { resolved_paths.push(path); }
        }
        else if (path.endsWith("/")) { //path does not start with slash.
            prefix = dde_apps_folder + "/" + path; //assumes path is intended to be under dde_apps/
        }
        /*kent doesn't like restriction. Sending filesin email need not tto have the .js extension
               and some pure data files maybe shouldn't have .js extnsions.
        else if (!path.endsWith(".js")){
            dde_error("loading_file got path: " + path + ' which does not end in ".js"'  +
                        "<br/>No files were loaded.")
        }*/
        else { //path does not start or end with slash.
            path = prefix + path;
            resolved_paths.push(path);
        }
    }
    //now make sure we can get all the contents before actually loading any
    let contents = [];
    for (let path of resolved_paths){
        //console.log("getting content for: " + path)
        let content;
        if(path.endsWith(".py") || path.endsWith(".pyc")){
            content = [path];
        }
        else {
            content = read_file$1(path); //might error
        }
        //onsole.log("got content: " + content)
        contents.push(content);
    }
    //finally if we get to this point, we've got all the contents so time to eval
    let result;
    for (let resolved_paths_index = 0;
         resolved_paths_index < resolved_paths.length;
         resolved_paths_index ++){
        let resolved_path = resolved_paths[resolved_paths_index];
        let content = contents[resolved_paths_index];
        out("&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;loading file: " + resolved_path, "green");
          //the commented out code below uses window.eval(content), which returns the value of the
          // last epxression in the file much less often than eval_js_part2, so use eval_js_part2 instead.
          //I must use eval and not eval_js_part2 because the later is not in core/job engine s
          //so that prevents loadiing files in job engine, which is a show stopper.
        try{let prev_loading_file =  window["loading_file"];
            window["loading_file"] = resolved_path;
            window.Job = Job$1; //needed if content has "Job" in it.
            if(Array.isArray(content)){
                Py.load_file(content[0]);
                result = "Loading Python files doesn't return a result.";
            }
            else {
                result = window.eval(content);
            }
            window["loading_file"] = prev_loading_file;
        }
        catch(err){
            let file_mess = prepend_file_message_maybe(err.message); //do before undefining loading_file
            window["loading_file"] = undefined; //must do before calling dde_error or
                                               //it won't get done BUT need dde_error to print out the loading file message.
            dde_error(file_mess);
        }
        out("Done loading file: " + resolved_path, "green");
    }
    return result
}

debugger;
console.log("top of ready.js");
/*
//stream bug above here.
//in the general folder, as is ready.js
import {Editor}     from "./editor.js"
import {DDE_NPM}    from "./DDE_NPM.js"
//import {SSH}        from "./ssh.js" //todo
import {Series}     from "./series.js"
import {open_doc}   from "./doc_code.js"
import {PatchDDE}   from "./patch_dde.js"
*/

//todo const {google} = require('googleapis');


var dde_version      = "not inited";
var dde_release_date = "not inited";
var myCodeMirror; //inited inside of ready

var js_cmds_array = [];
var js_cmds_index = -1;

function open_dev_tools$1(){
    let dde_ipc;    //todo  = require('electron').ipcRenderer
    dde_ipc.sendSync('open_dev_tools');
}

function close_dev_tools(){
    let dde_ipc;    //todo  = require('electron').ipcRenderer
    dde_ipc.sendSync('close_dev_tools');
}

function set_menu_string(elt, label, key){
    let modifier;
    let max_spaces;
    { //"win" and "linux"
        modifier = "Ctrl ";
        max_spaces = 14;
    }
    let needed_spaces = Math.max(max_spaces - label.length, 1);
    elt.innerHTML = label + "&nbsp;".repeat(needed_spaces) + modifier + key;
}
//called by both the eval button and the step button
function eval_button_action(step=false){ //used by both clicking on the eval button and Cmd-e
    if(step) { Metrics.increment_state("Step button clicks"); }
    else     { Metrics.increment_state("Eval button clicks"); }
    if(step instanceof CodeMirror) { step = false; } //means Cmd E was typed in the editor and we don't want to step in this case
    if((Editor.current_file_path != "new buffer") && persistent_get("save_on_eval")) {
        if (window.HCA && (Editor.view === "HCA")){
            HCA.save_current_file();
            eval_button_action_aux(step);
            return
        }
        else {
            Editor.save_current_file(function(err) {
                if(err) {
                    dde_error("In eval_button_action, got error while auto-saving file of: " + err.message);
                }
                else {
                    eval_button_action_aux(step);
                }
            });
        }
    }
    else { eval_button_action_aux(step); }
}
function eval_button_action_aux(step){
    eval_js_part1(step);
    //if (Editor.view == "Blocks") {
    eval_id.blur();
    //} //to get rid of the Eval button being "selected" when we're evaling in blocks view
}

function play_simulation_demo(){
    sim.enable_rendering = true;
    render_demo();
    //out("Demo just moves Dexter randomly.")
}

//call this on startup after peristent loaded AND after user clicks the menu item checkbox
function adjust_animation(){
    let animate_dur = (persistent_get("animate_ui") ? 300 : 0);
    $('#js_menubar_id').jqxMenu({ animationShowDuration: animate_dur });
    $('#js_menubar_id').jqxMenu({ animationHideDuration: animate_dur });
}

// document.body.addEventListener('onload', on_ready)

function on_ready() {
        debugger;
        //open_dev_tools() //FAILS! dev_tools opens but too late. so that break points in on_ready calls will actually break
        //const os = require('os');
        console.log("top of on_ready");
        //serial_port_init() //now does nothing, No longer necessary to use serial port.
        //window.Root      = Root //should work but doesn't jan 13, 2019


        //Coor.init()//todo dde4 can't import Coor.js yet
        //see also ./core/index.js that has this same code
        Dexter$1.calibrate_build_tables = calibrate_build_tables;
        window.calibrate_build_tables = undefined;
        Dexter$1.prototype.calibrate_build_tables = function() {
            let result = Dexter$1.calibrate_build_tables();
            for(let oplet_array of result){
                if(Array.isArray(oplet_array)){
                    oplet_array.push(this);
                }
            }
            return result
        };

        Job.class_init();
        Dexter$1.class_init();
        setTimeout(function(){
            window.document.title = "Dexter Development Environment " + dde_version;
            //dde_version_id.innerHTML      = dde_version //do this by hand because these matic values are NOT getting display in this doc's version on hdrobotic.com/software
            //dde_release_date_id.innerHTML = dde_release_date
        }, 1000);
   // window.$ = require('jquery'); //Now done in index.html   after doing npm install --save jquery, we still need this
    //onload_fn()
    Dexter$1.draw_dxf = DXF.dxf_to_instructions; //see Robot.js
    Dexter$1.prototype.draw_dxf = function({robot = null}={}) {
            let obj_args;
            if (arguments.length == 0) { obj_args = {}; } //when no args are passed, I must do this
            else { obj_args = arguments[0]; }
            obj_args.robot = this;
            return Dexter$1.draw_dxf(obj_args)
    };

    $('#outer_splitter_id').jqxSplitter({
        width: '98%', height: '97%', //was 93%
        orientation: 'vertical',
        panels: [ { size: "70%", collapsible: false}, //, min: "0%"}, //collapsible: false }, //collapsible: false fails in DDE v 3, so see below for setTimeout on a fn to do this
                  { size: '30%', collapsible: true}] //, min: "0%"}] //, collapsible: true}]
    });

    $('#outer_splitter_id').on('resize',
        function (event) {
            let new_size = event.args.panels[0].size;
            persistent_set("left_panel_width", new_size);
            event.stopPropagation();
        });

    init_outer_splitter_expand_event();

    $('#left_splitter_id').jqxSplitter({orientation: 'horizontal', width: "100%", height: "100%",
        panels: [{ size: "60%", min: "5%", collapsible: false },
                 { size: '40%', min: "5%", collapsible: true}]
    });

    $('#left_splitter_id').on('resize',
        function (event) {
            let new_size = event.args.panels[0].size;
            persistent_set("top_left_panel_height", new_size);
            event.stopPropagation(); //must have or outer_splitter_id on resize is called
        });


    $('#right_splitter_id').jqxSplitter({ orientation: 'horizontal', width: "100%", height: "100%",
        panels: [{ size: "50%"}, { size: "50%"}]
    });

    $('#right_splitter_id').on('resize',
        function (event) {
            let new_size = event.args.panels[0].size;
            persistent_set("top_right_panel_height", new_size);
            event.stopPropagation(); //must have or outer_splitter_id on resize is called
        });

    setTimeout(function(){
                $('#outer_splitter_id').jqxSplitter('panels')[0].collapsible = false;
                $('#left_splitter_id').jqxSplitter('panels')[0].collapsible = false;
                $('#right_splitter_id').jqxSplitter('panels')[0].collapsible = false;
            }, 100);
        //TestSuite.make_suites_menu_items() //doesn't work

        //see near bottom for animation.
    $("#js_menubar_id").jqxMenu({autoOpen: false, clickToOpen: false, height: '25px' }); //autoOpen: false, clickToOpen: true,

        //to open a menu, click. Once it is open, if you slide to another menu, it DOESN'T open it. oh well.
    //$("#js_edit_menu").jqxMenu(    { width: '50px', height: '25px' });
    //$("#js_learn_js_menu").jqxMenu({ width: '90px', height: '25px' });
    //$("#js_insert_menu").jqxMenu(  { width: '65px', height: '25px' });
    //$("#js_jobs_menu").jqxMenu(    { width: '55px', height: '25px' });

   // $("#ros_menu_id").jqxMenu({ width: '50px', height: '25px', animationHideDelay: 1000, animationShowDelay: 1000, autoCloseInterval: 1000  });
   $("#cmd_menu_id").jqxMenu({ width: '50px', height: '25px', animationHideDelay: 1000, animationShowDelay: 1000, autoCloseInterval: 1000  });

        //$("#jqxwindow").jqxWindow({ height:400, width:400, showCloseButton: true});
    //$('#jqxwindow').jqxWindow('hide');
    $("#cmd_input_id").keyup(function(event){ //output pane  type in
        if(event.keyCode == 13){ //ENTER key
            let src = Editor.get_cmd_selection(); //will return "" if no selection
            if(src.length == 0) { src = cmd_input_id.value;} //get full src if no selection
            src = src.trim();
            if (src.length == 0) { warning("no code to eval.");}
            else if(cmd_lang_id.value == "JS"){
                js_cmds_array.push(src);
                js_cmds_index = js_cmds_array.length - 1;
                eval_js_part2(src);
            }
            else if(cmd_lang_id.value == "Python"){
                Py.eval(src);
            }
            else if (cmd_lang_id.value == "SSH"){
                cmd_input_id.placeholder = "Type in a shell 'bash' command & hit the Enter key to run.";
                //but the above probably never get's seen because the src of the actual default cmd gets shown instead
                SSH.run_command({command: src});  //use defaults which makes formatted dir listing
               //call_cmd_service_custom(src) /ROS selected
            }
            //else if (cmd_lang_id.value == "ROS"){
            //    /call_cmd_service_custom(src) /ROS selected
            //}
        }
        else if(event.keyCode == 38){ //up arrow
           if      (js_cmds_index == -1 ) { out("No JavaScript commands in history"); }
           else if (js_cmds_index == 0 )  { out("No more JavaScript command history."); }
           else {
               js_cmds_index = js_cmds_index - 1;
               var new_src = js_cmds_array[js_cmds_index];
               cmd_input_id.value = new_src;
           }

        }
        else if(event.keyCode == 40){ //down arrow
            if      (js_cmds_index == -1 ) { out("No JavaScript commands in history"); }
            else if (js_cmds_index == js_cmds_array.length - 1) {
                if(cmd_input_id.value == "") {
                    out("No more JavaScript command history.");
                }
                else { cmd_input_id.value = ""; }
            }
            else {
                js_cmds_index = js_cmds_index + 1;
                var new_src = js_cmds_array[js_cmds_index];
                cmd_input_id.value = new_src;
            }
        }
        cmd_input_id.focus();
    });
    //cmd_input_id.onblur = function(){
    //        window.getSelection().collapse(cmd_input_id)
    //}

    //cmd_input_clicked_on_last = false //global var. Also set below and by Editor.init_editor

    cmd_input_id.onclick = function(event) {
        var full_src = event.target.value;
        if (full_src) {
            if(full_src.length > 0){
                let pos = event.target.selectionStart;
                if(pos < (full_src.length - 1)){
                    if(cmd_lang_id.value == "JS"){
                        onclick_for_click_help(event);
                    }
                    else if(cmd_lang_id.value == "SSH"){
                        let space_pos = full_src.indexOf(" ");
                        if((space_pos == -1) || (pos < space_pos)){
                            onclick_for_click_help(event);
                        }
                        //else don't do click help because clicking on the args of a bash cmd
                        //doesn't yield meaningful man help
                    }
                    else if (cmd_lang_id.value == "Python"){
                        out(`<a href='#' onclick='browse_page("https://docs.python.org/3/reference/index.html")' >Python doc</a>`,
                            undefined, true);
                    }
                    else {
                        shouldnt("cmd_input_id got menu item: " + cmd_lang_id.value +
                                 " that has no help.");
                    }
                }
                //else don't give help if clicking at very end.
                //because often that is to edit the cmd and if
                //we're in SSH, printout out a long man page is
                //disruptive
            }
        }
    };

    //js_radio_button_id.onclick  = function() { ros_menu_id.style.display = "none"}
    //ros_radio_button_id.onclick = function() { ros_menu_id.style.display = "inline-block"}

    cmd_lang_id.onchange = function(){
            if(cmd_lang_id.value === "JS"){
                SSH.close_connection();  //if no connection. that's ok
                cmd_menu_id.style.display = "none";
                cmd_input_id.placeholder = "Type in JS & hit the Enter key to eval";
                open_doc(JavaScript_guide_id);
            }
            else if(cmd_lang_id.value === "Python"){
                open_doc(python_doc_id);
                cmd_input_id.placeholder = "Type in Python3 & hit the Enter key to eval";
            }
            else if(cmd_lang_id.value === "SSH"){
                open_doc(ssh_doc_id);
                cmd_input_id.placeholder = "Type in Bash & hit the Enter key to eval";
                SSH.show_config_dialog();
                //cmd_menu_id.style.display = "inline-block"
                //cmd_input_id.value = SSH.show_dir_cmd
                //SSH.init_maybe_and_write("cd /srv/samba/share;" + SSH.show_dir_cmd, false)
            }
    };

    //init_simulation() now in video.js show_in_misc_pane

    init_doc();

    dde_version_id.innerHTML      = dde_version;
    dde_release_date_id.innerHTML = dde_release_date;

    Series.init_series();
    FPGA.init(); //does not depend on Series.
    Gcode.init(); //must be after init_series which calls init_units()

    $('#js_textarea_id').focus(); //same as myCodeMirror.focus()  but  myCodeMerror not inited yet

    doc_prev_id.onclick        = open_doc_prev;
    doc_next_id.onclick        = open_doc_next;
    find_doc_button_id.onmousedown = function() {
        Editor.get_any_selection();
    };
    find_doc_button_id.onclick = function(event) {
            find_doc();
            event.target.blur();
    };
    find_doc_input_id.onclick = onclick_for_click_help;
    find_doc_input_id.onchange = find_doc;
    $("#find_doc_input_id").jqxComboBox({ source: [], width: '150px', height: '25px',}); //create


        //eval_doc_button_id.onclick = function(){
    //      let sel = window.getSelection().toString().trim()
    //      if (sel.length == 0) {out("There is no selection in the Doc pane to eval.", "orange", true) }
    //      else { eval_js_part2(sel) }
    //      } obsolete now that Out pane Eval button evals selection in any pane.

    //doc_pane_content_id.onclick = //doesn't get called when I click in doc pane, so do the below.
    //click help for all text inside the code tag (white).
    $('code').click(function(event) {
                         const full_src = window.getSelection().focusNode.data;
                         const pos      = window.getSelection().focusOffset;
                         Editor.show_identifier_info(full_src, pos);
                    });
        //for results of code examples.
    $('samp').click(function(event) {
                        const full_src = window.getSelection().focusNode.data;
                        const pos      = window.getSelection().focusOffset;
                        Editor.show_identifier_info(full_src, pos);
    });

    /*catches all clicks,  but then if you click on an input elt it defocuses it so
     //you can't type in it.
      document.addEventListener("click",
                               function(event){
                                    out(document.activeElement.id)
                                    clearSelection()
                                    onclick_for_click_help(event)
                                    setTimeout(function(){ out(document.activeElement.id), event.target.focus(), out(document.activeElement.id)}, 1000)
                                }
    )*/
    /* does not get called when user clicks on an input when those inputs are dynamically
       generated AFTER onready is called.
       $('input').click(function(event) {
        const full_src = window.getSelection().focusNode.data
        const pos      = window.getSelection().focusOffset
        Editor.show_identifier_info(full_src, pos)
    }) */
    /* does not get called when user clicks on an input
        $('textarea').click(function(event) {
            const full_src = window.getSelection().focusNode.data
            const pos      = window.getSelection().focusOffset
            Editor.show_identifier_info(full_src, pos)
        })
    */
        output_div_id.onclick = onclick_for_click_help;

        //handles the button clicks and menu selects that chrome Apps prevent in HTML where they belong

        eval_id.onmousedown = function() {
                Editor.get_any_selection();
         };

        eval_id.onclick = function(event){
                            event.stopPropagation();
                            eval_button_action();
                          };

        step_button_id.onclick = function(event){
                                    event.stopPropagation();
                                    open_dev_tools$1();
                                    setTimeout(function(){
                                                   eval_button_action(true); //cause stepping
                                               }, 500);
                                    step_button_id.blur();
                                 };

        step_button_id.onmousedown = function() {
            Editor.get_any_selection();
        };

    js_debugger_checkbox_id.onclick = function(event) {
        event.stopPropagation();
        if(event.target.checked) {
            open_dev_tools$1();
        }
        else {
            close_dev_tools();
        }
    };

    easter_egg_joke_id.onclick = Metrics.easter_egg_joke;

    misc_pane_expand_checkbox_id.onclick=toggle_misc_pane_size;

    email_bug_report_id.onclick=email_bug_report;

    //File Menu

    new_id.onclick = function() {
        if (window.HCA && (Editor.view === "HCA")){
            HCA.clear();
            Editor.add_path_to_files_menu("new buffer");
        }
        else {
            Editor.edit_new_file();
        }
    };
    set_menu_string(new_id, "New", "n");

    file_name_id.onchange = function(e){ //similar to open
        let orig_path = Editor.current_file_path;
        const inner_path = e.target.value; //could be "new buffer" or an actual file
        const path = Editor.files_menu_path_to_path(inner_path);
        if (window.HCA && (Editor.view === "HCA")){
            try{
                HCA.edit_file(path);
            }
            catch(err){
                Editor.add_path_to_files_menu(orig_path);
                dde_error(path + " doesn't contain vaild HCA object(s).<br/>" + err.message);
            }
        }
        else { //presume JS
            Editor.edit_file(path);
        }
    };

    open_id.onclick = function(){
        if (window.HCA && (Editor.view === "HCA")){
            const path = choose_file({title: "Choose a file to edit", properties: ['openFile']});
            if (path){
                try{
                    HCA.edit_file(path);
                }
                catch(err){
                    dde_error(path + " doesn't contain vaild HCA object(s).<br/>" + err.message);
                }
                //Editor.add_path_to_files_menu(path) //now down in edit_file because edit_file is called
                //from more places than ready.
            }
        }
        else {
            Editor.open_on_dde_computer(); //Editor.open
        }
    };
    set_menu_string(open_id, "Open...", "o");

    open_from_dexter_id.onclick = Editor.open_from_dexter_computer;

    open_system_file_id.onclick = Editor.open_system_file;

    load_file_id.onclick=function(e) {
        if (window.HCA && (Editor.view === "HCA")){
            HCA.load_node_definition();
        }
        else { //presume JS
            const path = choose_file({title: "Choose a file to load"});
            if (path){
                if(path.endsWith(".py")){
                   Py.load_file_ask_for_as_name(path);
                }
                else {
                    out(load_files(path));
                }
            }
        }
    };

    load_and_start_job_id.onclick = function(){
        const path = choose_file({title: "Choose a file to load"});
        if (path){
            Job.define_and_start_job(path);
        }
    };

    DDE_NPM.init();
    install_npm_pkg_id.onclick = DDE_NPM.show_ui;

    insert_file_content_id.onclick=function(e) {
        const path = choose_file({title: "Choose a file to insert into DDE's editor"});
        if (path){
            const content = read_file(path);
            Editor.insert(content);
        }
    };
    insert_file_path_into_editor_id.onclick=function(e){
        const path = choose_file({title: "Choose a file to insert into DDE's editor"});
        if (path){
            Editor.insert('"' + path + '"');
        }
    };
    insert_file_path_into_cmd_input_id.onclick=function(e){
    const path = choose_file({title: "Choose a file to insert into DDE's editor"});
    if (path){
        Editor.insert_into_cmd_input('"' + path + '"');
    }
};

    save_id.onclick = function() {
        if (window.HCA && (Editor.view === "HCA")){
            if (Editor.current_file_path == "new buffer"){
                HCA.save_as();
            }
            else {
                HCA.save_current_file();
            }
        }
        else {
            Editor.save();
        }
    };
    set_menu_string(save_id, "Save", "s");

    save_as_id.onclick = function(){
        if (window.HCA && (Editor.view === "HCA")){
            HCA.save_as();
        }
        else {
            Editor.save_as();
        }
    }; //was: Editor.save_on_dde_computer //only for saving on dde computer

    save_to_dexter_as_id.onclick = Editor.save_to_dexter_as;

    remove_id.onclick = function(){ Editor.remove(); }; //don't simply use Editor.remove as ther value  for onclick because we want to default its arg as the Editor.remove method does
    update_id.onclick = function(){ check_for_latest_release(); };

    //Edit menu  (see editor.js for the Edit menu items
    Editor.init_editor();

    //Insert menu
  /*  js_example_1_id.onclick=function(){Editor.insert(
`//Click the Eval button to define and call the function 'foo'.
function foo(a, b){ //define function foo with 2 args
    out("foo called with a=" + a) //print 1st arg to Output pane.
    for(var item of b){ //loop over items in array b
        if (item > 9.9){
            out("got a big one: " + item)
        }
    }
    return b.length //foo returns the length of its 2nd arg.
                    //After calling, observe '4' in the Output pane.
}

foo("hello", [7, 10, 20, -3.2]) //call function foo with 2 args
                                //a string and an array of numbers.
`)}*/

   alert_id.onclick   = function(){Editor.wrap_around_selection(  "alert(", ')', '"Hi."');};
   confirm_id.onclick = function(){Editor.wrap_around_selection("confirm(", ')', '"Do it?"');};
   prompt_id.onclick  = function(){Editor.wrap_around_selection( "prompt(", ')', '"Price?"');};

    out_black_id.onclick =function(){Editor.wrap_around_selection("out(", ')', '"Hello"');};
    out_purple_id.onclick=function(){Editor.wrap_around_selection("out(", ', "blue")', '"Hello"');};
    out_brown_id.onclick =function(){Editor.wrap_around_selection("out(", ', "rgb(255, 100, 0)")', '"Hello"');};

    editor_insert_id.onclick = function(){Editor.insert(
`Editor.insert(
    "text to insert",
    "replace_selection", //insertion_pos.   "replace_selection" is the default. Other options: "start", "end", "selection_start", "selection_end", "whole", an integer
    false)               //select_new_text. false is the default.
`);};


   show_window_help_id.onclick = function(){open_doc(show_window_doc_id);};

    window_simple_message_id.onclick=function(){Editor.insert(
`//show_window simple message
//Pop up a window with content of the given HTML.
show_window("hi <i style='font-size:100px;'>wizard</i>")
`
);};
    insert_color_id.onclick = insert_color;
window_options_id.onclick=function(){Editor.insert('//show_window  Window Options\n' +
                                                     'show_window({\n' +
                                                              '    content: "hi",      // Any HTML OK here.\n' +
                                                              '    title: "Greetings", // Appears above the content. Any HTML OK.\n' +
                                                              '    width: 180, // 100 to window.outerWidth\n' +
                                                              '    height: 70, //  50 to window.outerHeight\n' +
                                                              "    x: 0,       // Distance from left of DDE window to this window's left\n" +
                                                              "    y: 100,     // Distance from top  of DDE window to this window's top\n" +
                                                              '    is_modal: false, // If true, prevents you from interacting with other windows. Default false.\n' +
                                                              '    show_close_button: true,    // Default true.\n' +
                                                              '    show_collapse_button: true, // Allow quick shrink of window. Default true.\n' +
                                                              '    resizable: true,            // Drag lower right corner to change dialog size.\n' +
                                                              '    draggable: true,            // Mouse down and drag on title bar to move dialog.\n' +
                                                              '    trim_strings: true,         // Remove whitespace from beginning and end of values from inputs of type text and texareas. Default true.\n' +
                                                              '    background_color: "ivory"   // Default is "rgb(238, 238, 238)" (light gray). White is "rgb(255, 255, 255)"\n' +
                                                              '})\n');};
    window_buttons_id.onclick=function(){Editor.insert(
`//show_window  Buttons  Example
//The below function is called when a button is clicked in the shown window.
function count_up(vals){ //vals contains name-value pairs for each
                         //html elt in show_window's content with a name.
    if(vals.clicked_button_value == "Count"){ // Clicked button value holds the name of the clicked button.
        if(window.demo_counter == undefined) { 
            window.demo_counter = 10           // Initialize the demo_counter global variable.
        }
        window.demo_counter = window.demo_counter + 1 // Increment demo_counter upon each button click.
        count_id.innerHTML = window.demo_counter
        count_id.style["font-size"] = demo_counter + "px"
    }
    else if (vals.clicked_button_value == "Done"){   // When a 'submit' button is clicked, its 'value' can be used as its name.
        out("outta here at: " + window.demo_counter) // Last thing printed to the Output pane.
    }
}\n` +
'show_window({\n' +
'    content:\n' +
'`<input type="button" value="Count"/> <!-- Regular button. Does not close window.-->\n' +
' <span  name="count_display" id="count_id">10</span><br/><br/>\n' +
' <input type="submit" value="Done"/>`, // submit button closes window\n' +
'    callback: count_up})      // This function called when either button is clicked.\n'
);}; //done with window buttons

window_sliders_id.onclick=function(){Editor.insert(
`function handle_cb(vals){
    if(vals.clicked_button_value === "submit_slow") {
        out("slide_slow: " + vals.slide_slow)
    }
    else if(vals.clicked_button_value === "slide_fast"){
        out("slide_fast: " + vals.slide_fast, "green", true)
    }
}

show_window({title: "show_window sliders demo",
    content: "Fast: 0<input name='slide_fast' type='range' min='0', max='100' data-oninput='true'/>100<br/>" +
    "Slow: 0<input id='slide_slow' type='range' min='0', max='10' step='0.1' />10<br/>" +
    "<input type='button' value='submit_slow'> </input>",
    height: 130,
    callback: handle_cb})`
);};


let show_window_menu_body =
`Choose:
<div class="menu" style="display:inline-block;">
   <ul>
      <li>TopMenu&#9660;
        <ul>
          <li title="this is a tooltip">item1</li>
          <li data-name="ITEM two">item2</li> <!-- if there's a data-name, use it, otherwise use the innerHTML-->
          <li>SubMenu
            <ul>
              <li>sub1</li>
              <li>sub2</li>
            </ul>
          </li>
        </ul>
      </li>
    </ul>
</div>
<span  name="menu_choice">pick menu item</span><br/><br/>
<input type="submit" value="Done"/>`;

    window_menu_id.onclick=function(){Editor.insert(
`//show_winow   Menu example
//Called whenever user chooses a menu item or clicks a button.
function menu_choice_cb(vals){
        if (vals.clicked_button_value != "Done"){ // True when menu item chosen.
            var clicked_item = vals.clicked_button_value
            out("You picked: " + clicked_item)
        }
}

show_window({content: ` + "`" + show_window_menu_body + "`," +
` // submit closes window
        callback: menu_choice_cb // Called when menu item or button is clicked
        })
`);};

    window_many_inputs_id.onclick=function(){Editor.insert(
`//show_window   Many Inputs Example.
//show_vals called only when a button is clicked.
function show_vals(vals){ inspect(vals) }

show_window(
    {content:\n` +
"`" +
`text: <input type="text" name="my_text" value="Dexter"><br/><br/>
textarea: <textarea name="my_textarea">Hi Rez</textarea><br/><br/>
checkbox: <input name="my_checkbox" type="checkbox" checked="checked"/>heated bed?<br/><br/>
<!-- you can add the checked="checked" attribute to make it initially checked. -->
radio:
<input type="radio" name="my_radio_group" value="abs" />ABS
<input type="radio" name="my_radio_group" value="carbon"/>Carbon Fiber
<input type="radio" name="my_radio_group" value="pla" checked="checked"/>PLA<br/><br/>
    <!-- At most, only 1 radio button can be checked. If none are checked,
         the return value for the group will be undefined . -->
number: <input type="number" name="my_number" value="0.4" min="0" max="1" step="0.2"/><br/>
range:  <input type="range"  name="my_range"  value="33"  min="0" max="100"/><br/>
color:  <input type="color"  name="my_color"  value="#00FF88"/><br/>
date:   <input type="date"   name="my_date"   value="2017-01-20"/><br/>
select: <select name="size">
    <option>Gihugeic</option>
    <option selected="selected">Ginormace</option> <!--the inital value-->
    <option>Gilossal</option>
</select><br/>
combo_box: <div id="my_combo_box" class="combo_box" style="display:inline-block;vertical-align:middle;"> <!-- Can't use 'name' attribute. Must use 'id'. -->
        <option>one</option>
        <option selected="selected">two</option>
</div><br/>
file:   <input type="file" name="my_file"/><br/><br/>
button: <input type="button" value="Show settings"/><br/><br/>
submit: <input type="submit" value="OK"/>` + "`" +
',\n     width:380, height:450, title:"Printer Config", x:100, y:100,\n     callback: show_vals})\n');};

//______window_onchange_____________________
    var window_onchange_top_comments =
`/* show_window   onchange calls
    In most uses of show_window, its callback is called only
    when an input of type 'submit' or 'button' is clicked. 
    But you CAN have the callback called whenever the value
    of an input element changes. 
   
    An HTML property of data-onchange='true' will cause the 
    callback method to be called for an element when
    you change its value and select another elememt.
   
    An HTML property of data-oninput='true' causes the
    callback to be called as soon as a new value is entered.
    For input type="text" this is upon each character entered.
    For input type="radio" this is when any radio button in
    the group is clicked on.
    For select menus, this is when the value is changed.
    For input type="range" (sliders) this is upon every
    little move of the slider.
   
    The value of the "clicked_button_value" property of the
    object passed to the callback will be the 'name' of the
    changed input element, even though "clicked_button_value" 
    implies the 'value' of a 'button'.
   
    To see all this behavior, click the Eval button and play 
    with the controls in the window that pops up.
    Carefully observe the values printed in the output pane.
*/
`;
     var window_onchange_content =
`Text input with <samp>data-onchange='true'</samp> calls the callback<br/>
    when user clicks on another input.<br/>
    <input type="text"  name="my_onchange_text"  value="33"  min="0" max="100"
    data-onchange='true'/>
        <hr/>
        Text input with <samp>data-oninput='true'</samp> calls the callback<br/>
        after each keystroke entering text.<br/>
    <input type="text" name="my_oninput_text" value="33"  min="0" max="100"
    data-oninput='true'/>
        <hr/>

        Range "slider" with <samp>data-onchange='true'</samp> calls the callback<br/>
        after user stops moving the slider.<br/>
    <input type="range"  name="my_onchange_range"  value="33"  min="0" max="100"
    data-onchange='true'/><br/>
        <hr/>
        Range "slider" with <samp>data-oninput='true'</samp> calls the callback<br/>
        often as user moves the slider.<br/>
    <input type="range"  name="my_oninput_range"  value="33"  min="0" max="100"
    data-oninput='true'/>
        <hr/>      
        Radio button group input with each input having<br/>
        <samp>data-onchange='true'</samp> calls the callback<br/>
        whenever a radio button is clicked.<br/>
    <input type="radio" name="my_radio_group" value="abs"    data-onchange="true"/>ABS
        <input type="radio" name="my_radio_group" value="carbon" data-onchange="true"/>Carbon Fiber
    <input type="radio" name="my_radio_group" value="pla"    data-onchange="true" checked="checked"/>PLA
`;
    window_onchange_id.onclick = function(){Editor.insert(
        window_onchange_top_comments +
`function the_cb(vals){ //vals contains name-value pairs for each input
     out(vals.clicked_button_value + " = " +
         vals[vals.clicked_button_value])
}
show_window({content:
`       + "`" +
        window_onchange_content + "`" +
`,           title: "show_window onchange & oninput",
             width: 440, height: 440, x: 500, y: 100, 
             callback: the_cb})
` );};
    window_svg_id.onclick=function(){Editor.insert(
`//SVG Example 1: lots of shapes
function handle1(arg) { 
    if((arg.clicked_button_value === "background_id") ||
       (arg.clicked_button_value === "svg_id")) {
        append_in_ui("svg_id", svg_circle({cx: arg.offsetX, cy: arg.offsetY, r: 7}))    
    }
    else if (arg.clicked_button_value === "circ_id") {
        out("clicked on circ_id")
    }
    else if (arg.clicked_button_value === "ellip_id") {
        out("The user clicked on ellip_id")
    }
}

show_window({
    title: "SVG Example 1: Lots of shapes. Click to interact",
    content: svg_svg({id: "svg_id", height: 300, width: 500, html_class: "clickable", child_elements: 
       [//svg_rect({id: "background_id", html_class: "clickable", style:"position: relative; top: 0; right: 0; x: 0, y: 0, width: 500, height: 500, color: "white", border_width: 3, border_color: "yellow"}),
        svg_circle({id: "circ_id", html_class: "clickable", cx: 20, cy: 20, r: 30, color: "purple"}),  
        svg_ellipse({id: "ellip_id", html_class: "clickable", cx: 270, cy: 50, rx: 60, ry: 30, color: "orange"}),
        svg_line({x1: 30, y1: 30, x2: 100, y2: 200, color: "blue", width: 5}),
        svg_rect({x: 50, y: 50, width: 40, height: 100, color: "green", border_width: 3, border_color: "yellow", rx: 20, ry: 5}),
        svg_polygon({points: [[400, 10], [500, 10], [450, 100]], color: "lime", border_width: 3, border_color: "yellow"}),
        svg_polyline({points: [[400, 100], [480, 100], [450, 200], [480, 250]], color: "brown", width: 10}),
        svg_text({text: "this is a really long string", x: 50, y: 50, size: 30, color: "red", border_width: 2, border_color: "black", style: 'font-weight:bold;'}),
        svg_html({html: "<i style='font-size:30px;'>yikes</i>", x: 60, y: 100})
                      ]}),
    width: 610,  // window width
    height: 200, // window height
    x: 0,        // Distance from left of DDE window to this window's left
    y: 100,      // Distance from top  of DDE window to this window's top
    callback: handle1
})

//SVG Example 2: draw circle then move it to clicked position.
function handle2 (vals){ 
    if(window.c_id) {
        set_in_ui("c_id.cx", vals.offsetX)
        set_in_ui("c_id.cy", vals.offsetY)
    }
    else {
        append_in_ui(
            "s2_id", 
            svg_circle({id: "c_id", cx: vals.offsetX, cy: vals.offsetY, 
                        r: 15, color: "blue"}))
  }
}

show_window({
    title: "SVG Example 2: Click to draw and move circle",
    content: svg_svg({id: "s2_id", width: 600, height: 200, html_class: "clickable"}),
    x: 0,
    y: 330,
    width: 600,
    height: 200,
    callback: handle2
})

//SVG Example 3: draw line segments
var linex = null
var liney = null
function handle3 (vals){ 
    if(linex) {
        append_in_ui(
            "s3_id", 
            svg_line({x1: linex, y1: liney, x2: vals.offsetX, y2: vals.offsetY}))
    }
   else {
       append_in_ui(
           "s3_id", 
           svg_circle({cx: vals.offsetX, cy: vals.offsetY, 
                       r: 5, color: "blue"})) 
   }
   linex = vals.offsetX
   liney = vals.offsetY
}

show_window({
    title: "SVG Example 3: Click to draw lines",
    content: svg_svg({id: "s3_id", width: 400, height: 350, html_class: "clickable",
                      child_elements: [
                          svg_rect({x: 100, y: 100, width: 200, height: 50, color: "yellow"})
           ]}),
    width: 470, x: 620, y: 100,
    callback: handle3
})
`);};

    window_modify_id.onclick=function(){Editor.insert(
`function modify_window_cb(vals){
   let color = "rgb(" + Math.round(Math.random() * 255) + "," +
                        Math.round(Math.random() * 255) + "," +
                        Math.round(Math.random() * 255) + ")"
   selector_set_in_ui("#" + vals.show_window_elt_id + " [name=the_in] [style] [background]",
                      color
                      )
   selector_set_in_ui("#" + vals.show_window_elt_id + " [name=the_in] [afterend]",
                      "<br/>" + color)
}

show_window({title: "Modify Window",
             x:300, y:20, width:300, height:200, 
             callback: modify_window_cb,
             content: '<input type="button" name="the_in" value="click to colorize"/>'
  })
`
    );};

    build_window_id.onclick=ab.launch;

    opencv_gray_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_gray.js");
        Editor.insert(code);
    };
    opencv_blur_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_blur.js");
        Editor.insert(code);
    };

    opencv_in_range_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_in_range.js");
        Editor.insert(code);
    };

    opencv_blob_detector_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_blob_detector.js");
        Editor.insert(code);
        open_doc("Picture.detect_blobs_doc_id");
    };

    opencv_process_webcam_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_process_webcam.js");
        Editor.insert(code);
    };

    opencv_face_reco_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_face_reco.js");
        Editor.insert(code);
    };

    opencv_locate_object_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_locate_object.js");
        Editor.insert(code);
        open_doc("Picture.locate_object_doc_id");
    };

    opencv_picture_similarity_id.onclick=function(){
        const code = read_file(__dirname + "/examples/opencv_picture_similarity.js");
        Editor.insert(code);
        open_doc("Picture.mats_similarity_by_color_doc_id");
    };

    window_close_all_id.onclick=function(){ SW.close_all_show_windows(); };

    machine_vision_help_id.onclick = function(){open_doc(machine_vision_doc_id);};

    show_page_id.onclick=function(){
        Editor.wrap_around_selection('show_page(', ')\n', '"hdrobotic.com"');
        open_doc(show_page_doc_id);};

    get_page_id.onclick=function(){
             open_doc(get_page_doc_id);
             Editor.insert('get_page("http://www.ibm.com")');
    };

    beep_id.onclick = function(){
          Editor.insert("beep()\n");
          open_doc(beep_doc_id);};
    beep_options_id.onclick = function(){Editor.insert(
`beep({
    dur: 0.5,  //the default,, 
    frequency: 440, //the default, in Hertz. This is A above middle C.    
    volume: 1,      //the default, 0 to 1
    waveform: "triangle", //the default, other choices: "sine", "square", "sawtooth"
    callback: function(){beep({frequency: 493.88})} //default=null, run at end of the beep
    })
`
    );};
    beeps_id.onclick = function(){
        open_doc(beeps_doc_id);
       Editor.insert(
`beeps(3, //default=1. number of times to beep using the default beep.
      function(){speak({speak_data: "Third Floor, home robots"})}) //default=null. callback when done
`);};
    speak_id.onclick=function(){
        open_doc(speak_doc_id);
        Editor.wrap_around_selection(
        "speak({speak_data: ", "})\n", '"Hello Dexter"');};

    speak_options_id.onclick=function(){Editor.wrap_around_selection(
`speak({
    speak_data: ` , //default="hello"  can be a string, number, boolean, date, array, etc.
`,\n    volume: 1.0,   //default=1.0   0 to 1.0,
    rate: 1.0,     //default=1.0   0.1 to 10,
    pitch: 1.0,    //default=1.0   0 to 2,
    lang: "en-US", //default="en-US"
    voice: 0,      //default=0     0, 1, 2, or 3
    callback: function(event) {out('Dur in nsecs: ' + event.elapsedTime)}  //default=null  called when speech is done.
})\n`, '[true, "It is", new Date()]'
        );
        open_doc(speak_doc_id);};
    /*recognize_speech_id.onclick = function(){Editor.insert(
`recognize_speech(
    {prompt: "Say something funny.", //Instructions shown to the speaker. Default "".
     click_to_talk: false,           //If false, speech recognition starts immediately. Default true.
     only_once: false,               //If false, more than one phrase (after pauses) can be recognized. Default true.
     phrase_callback: undefined,     //Passed text and confidence score when user pauses. Default (undefined) prints text and confidence. If only_once=true, only this callback is called.
     finish_phrase: "finish",        //Say this to end speech reco when only_once=false.
     finish_callback: out})          //Passed array of arrays of text and confidence when user says "finish". Default null.
`)}*/

    music_help_id.onclick=function(){ open_doc(music_with_midi_doc_id); };
    phrase_examples_id.onclick=function(){
        const code = read_file(__dirname + "/music/phrase_examples.js");
        Editor.insert(code);
    };
    midi_init_id.onclick = Midi.init;

   //eval_and_start_button_id.onclick = eval_and_start

    make_dictionary_id.onclick=function(){
        const code = read_file(__dirname + "/examples/make_dictionary.js");
        Editor.insert(code);
    };
    nat_lang_reasoning_id.onclick=function(){
        const code = read_file(__dirname + "/examples/nat_lang_reasoning.js");
        Editor.insert(code);
    };


    ez_teach_id.onclick=function(){
        Editor.edit_new_file();
        Editor.insert(read_file(__dirname + "/user_tools/ezTeach_template.js"));
        open_doc(ez_teach_doc_id);
    };

    jobs_help_id.onclick          = function(){ open_doc(Job_doc_id); };
    //start_job_id.onclick        = Job.start_job_menu_item_action
    //start_job_help_id.onclick = function(){ open_doc(start_job_help_doc_id) } //nw help is simply under theh Output pane help, and users see it by clicking on the "Output" pane title.

    test_suites_help_id.onclick = function(){ open_doc(TestSuite_doc_id); };

    insert_all_test_suites_id.onclick  = function(){TestSuite.insert_all();};

     run_all_test_suites_id.onclick     = function(){TestSuite.run_all();};
    // show_all_test_suites_id.onclick  = function(){TestSuite.show_all()}  //functionality obtained with Find and no selection
     run_test_suite_file_id.onclick     =  TestSuite.run_ts_in_file_ui;

    //obsoleted by increased functionality in doc pane Find button. find_test_suites_id.onclick        = function(){TestSuite.find_test_suites(Editor.get_any_selection())}
    selection_to_test_id.onclick=function(){
       TestSuite.selection_to_test(Editor.get_javascript(true), Editor.get_javascript(), Editor.selection_start());
       };
    show_suite_statistics_id.onclick=TestSuite.statistics;
    insert_test_suite_example_id.onclick=function(){
                    Editor.insert( //below the same as the first test suite in the main test suites except that
                                   //its name is different so that the "summary" doesn't subtract the
                                   //usual 2 unknown failures and thus the summary of runnign this
                                   //will be consistent with the errors it shows.
`new TestSuite(
    "example_test_suite",
    ["2 + 3", "5", "1st elt (source) evals to same as 2nd elt (expected) and the test passes."],
    ['similar(2.05, 2, 0.1)', "true", "tolerance of 0.1 permits 2.05 and 2 to be similar"],
    ["var foo = 4 + 1"],
    ["foo", "5", "The side effect of the above 'set up' test, sets foo. Foo's value is tested here."],
    ['"hi" + " dexter"', '"hi dex"', "known failures are declared with this description string starting with 'known'."],
    ['foo961', '123', "This is an 'unknown failure' for demo purposes"],
    ['foo723', 'TestSuite.error', 'Tests with expected of TestSuite.error pass if the source errors.'],
    ['out(TestSuite.run("similarX"))', 'TestSuite.dont_care', "Run another test suite. This one errors because its not defined."]
)
`, null, true);};
    //TestSuite.make_suites_menu_items() //because the ones that are defined from TestSuite.js can't make their menu items until dom is ready

    //Learn Javascript menu
    learn_js_help_id.onclick = function (){open_doc(learning_js_doc_id);};
      // Debugging menu
    dev_tools_id.onclick      = function(){show_window({content:
         "To see the output of <code>console.log</code> calls,<br/>" +
         "and for using the <code>debugger</code> breakpoint,<br/>" +
         "you must first open <i>Chrome Dev Tools</i> by:<br/>" +
         "clicking right anywhere and choosing <b>Inspect</b>.<p/>" +
         "Note: The <b>out</b> call is more useful in most cases than <code>console.log</code>. " +
         "It doesn't require <i>Chrome Dev Tools</i>.<br/>See <button>Insert&#9660;</button> <i>Print to output</i>.<br/><br/>" +
         "There's more help in the Documentation pane under <b>Debugging</b>.",
         title: "Debugging Help", width:430, height:270});
         open_doc(debugging_id);
          //WORKS! 800 is milliseconds for the animation to take.
         //$('#doc_contents_id').animate({scrollTop: $('#d ebugging_id').offset().top}, 800); //jquery solution that fails.
         //d ebugging_id.scrollIntoView(true) //does so instantaneously but it at least works.
         //However, it causes the DDE header to scroll off the top of the window
         //and a user can't get it back. If the user has not expanded any triangles
         //in the doc pane, then NOT calling scrollIntoView is fine, but if they have.
         //they likely won't see the Debugging content. Probably an interaction between
         //this new HTML5 stuff and jqwidgets
        // the below fail.
                                      //poitions the top of the elt at the top of the pane, which is good.
        //d ebugging_id.scrollIntoView({behavior:"smooth"});//doesn't  smooth scroll in chrome
        //$("#d ebugging_id").parent().animate({scrollTop: $("#debugging_id").offset().top}, 1000) //doesn't work
         }; //fails: window.open("chrome://inspect/#apps")
    console_log_id.onclick     = function(){Editor.wrap_around_selection("console.log(", ")", '"Hello"');};

    step_instructions_id.onclick = function(){
        open_doc("Control.step_instructions_doc_id");
        let cursor_pos = Editor.selection_start();
        let src = Editor.get_javascript();
        let prev_char = ((cursor_pos == 0) ? null : src[cursor_pos - 1]);
        let prefix;
        if (Editor.selection_start() == 0)     {prefix = "";}
        else if ("[, \n]".includes(prev_char)) {prefix = "";}
        else                                   {prefix = ",";}
        Editor.insert(prefix + 'Control.step_instructions(),nnll'); //ok if have comma after last list item in new JS.
    };

    debugger_id.onclick        = function(){Editor.insert("debugger;nnll");}; ////LEAVE THIS IN RELEASED CODE

    debugger_instruction_id.onclick = function(){
         open_doc("Control.debugger_doc_id");
         let cursor_pos = Editor.selection_start();
         let src = Editor.get_javascript();
         let prev_char = ((cursor_pos == 0) ? null : src[cursor_pos - 1]);
         let prefix;
         if (Editor.selection_start() == 0)     {prefix = "";}
         else if ("[, \n]".includes(prev_char)) {prefix = "";}
         else                                   {prefix = ",";}
         Editor.insert(prefix + 'Control.debugger(),nnll'); //ok if have comma after last list item in new JS.
    };

    comment_out_id.onclick     = function(){Editor.wrap_around_selection("/*", "*/");};
    comment_eol_id.onclick     = function(){Editor.insert("//");};
      //true & false menu
    true_id.onclick          = function(){Editor.insert(" true ");};
    false_id.onclick         = function(){Editor.insert(" false ");};
    and_id.onclick           = function(){Editor.insert(" && ");};
    or_id.onclick            = function(){Editor.insert(" || ");};
    not_id.onclick           = function(){Editor.insert("!");};

      //Math menu
    math_example_id.onclick = function(){Editor.insert("(-1.75 + 3) * 2\n");};
    plus_id.onclick         = function(){Editor.insert("+");};
    minus_id.onclick        = function(){Editor.insert("-");};
    times_id.onclick        = function(){Editor.insert("*");};
    divide_id.onclick       = function(){Editor.insert("/");};
    pi_id.onclick           = function(){Editor.insert("Math.PI");};
    parens_id.onclick       = function(){Editor.wrap_around_selection("(", ")");};

       //Compare Numbers menu
    compare_example_id.onclick = function(){Editor.insert("Math.PI >= 3\n");};
    less_id.onclick            = function(){Editor.insert("<");};
    less_or_equal_id.onclick   = function(){Editor.insert("<=");};
    equal_id.onclick           = function(){Editor.insert("==");};
    more_or_equal_id.onclick   = function(){Editor.insert(">=");};
    more_id.onclick            = function(){Editor.insert(">");};
    not_equal_id.onclick       = function(){Editor.insert("!=");};

       //Strings menu
    double_quote_id.onclick   = function(){Editor.wrap_around_selection('"', '"');};
    single_quote_id.onclick   = function(){Editor.wrap_around_selection("'", "'");};
    back_quote_id.onclick     = function(){Editor.wrap_around_selection('`', '`');};
    add_strings_id.onclick    = function(){Editor.insert("+");};

    string_length_id.onclick  = function(){Editor.insert(".length");};
    get_char_id.onclick       = function(){Editor.insert("[0]");};
    slice_id.onclick          = function(){Editor.insert(".slice(0, 3)");};
    split_id.onclick          = function(){Editor.insert('.split(" ")');};
    string_equal_id.onclick   = function(){Editor.insert('==');};
    starts_with_id.onclick    = function(){Editor.insert('.startsWith("ab")');};
    ends_with_id.onclick      = function(){Editor.insert('.endsWith("yz")');};
    replace_string_id.onclick = function(){Editor.insert('.replace(/ab/g, "AB")');};

       //Arrays menu
    make_array_id.onclick         = function(){Editor.insert('[5, "ab", 2 + 2]');};
    array_length_id.onclick       = function(){Editor.insert('.length');};
    get_array_element_id.onclick  = function(){Editor.insert('[0]');};
    set_array_element_id.onclick  = function(){Editor.insert('[0] = 42');};
    push_array_element_id.onclick = function(){Editor.insert('.push(9)');};

    //DATE
    new_date_day_id.onclick       = function(){Editor.insert('new Date("' + new Date().toString().slice(4, 15) + '")');};
    new_date_time_id.onclick      = function(){Editor.insert('new Date("' + new Date().toString().slice(4, 24) + '")');};
    new_date_ms_id.onclick        = function(){Editor.insert('new Date(3000)');};
    date_now_id.onclick           = function(){Editor.insert('Date.now()');};
    date_valueOf_id.onclick       = function(){Editor.insert('new Date().valueOf()');};
    date_toString_id.onclick      = function(){Editor.insert('new Date().toString()');};
    duration_hms_id.onclick       = function(){Editor.insert('new Duration("01:14:05")');};
    duration_hmsms_id.onclick     = function(){Editor.insert('new Duration(1, 2, 5, 10)');};
    duration_get_ms_id.onclick    = function(){Editor.insert('new Duration(0, 0, 1, 500).milliseconds');};
      //Variables menu
    variable_examples_id.onclick = function(){Editor.insert('var foo = 5 //initialize variable\nfoo //evals to 5\nfoo = "2nd" + " " + "val" ///set existing variable to new value\nfoo //now evals to "2nd val"\n');};
    init_variable_id.onclick     = function(){Editor.insert('var foo = ');};
    set_variable_id.onclick      = function(){Editor.insert('=');};

     //JS Objects menu
    js_object_example_id.onclick = function(){Editor.insert(
`var foo = {sam: 2, joe: 5 + 1} //make a JS object
foo      //evals to the new object
foo.sam  //evals to 2
foo.joe  //evals to 6
foo.joe = 99 //within foo, sets the value of joe to 99
foo.joe  //now evals to 99
foo["jo" + "e"] //compute the name to lookup. evals to 99
foo["jo" + "e"] = "jones" //set computed name to new value
foo.joe  //NOW evals to "jones"
foo.ted = 3 / 2  //adds a new name:value pair to foo.
foo //eval to see the latest values\n`);};
        js_object_cheat_sheet_id.onclick = function(){show_window({content:
`<pre>var foo = {sam: 2, joe: 5 + 1} //make a JS object
foo      //evals to the new object
foo.sam  //evals to 2
foo.joe  //evals to 6
foo.joe = 99    //within foo, sets the value of joe to 99
foo.joe  //now evals to 99
foo["jo" + "e"] //compute the name to lookup. evals to 99
foo["jo" + "e"] = "jones" //set computed name to new value
foo.joe         //NOW evals to "jones"
foo.ted = 3 / 2 //adds a new name:value pair to foo.
foo      //eval to see the latest values</pre>`,
            title: "JavaScript Object Cheat Sheet",
            width:  550,
            height: 280,
            x:      440,
            y:      370});};

    // Control Flow menu
    if_single_armed_id.onclick = function(){Editor.wrap_around_selection('if (1 + 1 == 2) {\n    ', '\n}');};
    if_multi_armed_id.onclick  = function(){Editor.wrap_around_selection('if (1 + 1 == 2) {\n    ', '\n}\nelse if (2 + 2 == 4){\n    \n}\nelse {\n    \n}\n');};
    for_number_of_times_id.onclick    = function(){Editor.wrap_around_selection('for(let i = 0; i < 10; i++){\n', '\n}\n');};
    for_through_array_elts_id.onclick = function(){Editor.wrap_around_selection('for(let x of [7, 4, 6]){\n', '\n}\n');};
    try_id.onclick             = function(){Editor.wrap_around_selection('try{\n', '\n} catch(err){handle errors here}');};
    dde_error_id.onclick       = function(){Editor.wrap_around_selection('dde_error(', ')', '"busted!"');};
    setTimeout_id.onclick=function(){Editor.insert('setTimeout(function(){console.log("waited 3 seconds")}, 3000)nnll');};

    // Function menu
    function_example_id.onclick   = function(){Editor.insert("function my_add(a, b){ // define the function 'my_add'\n    var sum = a + b\n    return sum\n}\nmy_add(2, 3) // run my_add's code with a=2 and b=3\n");};
    named_function_id.onclick     = function(){Editor.wrap_around_selection('function foo(x, y) {\n', '\n}\n');};
    anonymous_function_id.onclick = function(){Editor.wrap_around_selection('function(x, y) {\n', '\n}\n');};
    return_id.onclick             = function(){Editor.insert("return ");};
    //End of Learn JS menu

    //series Menu
     units_system_help_id.onclick = function(){ open_doc(units_system_help_doc_id); };

     //jobs menu
    show_robot_status_id.onclick   = RobotStatusDialog.show;
    jobs_report_id.onclick         = function(){Job.report(); };
    stop_all_jobs_id.onclick       = function(){
                                         Job.stop_all_jobs();
                                         if(!TestSuite.status) {
                                             TestSuite.immediate_stop = true;
                                         }
                                     };
    undefine_jobs_id.onclick       = function(event){
        Job.clear_stopped_jobs();
        event.target.blur();
    }; //use individual X (close) marks instead

    /*$("#real_time_sim_checkbox_id").jqxCheckBox({ checked: true })
    real_time_sim_checkbox_id.onclick = function(event) {
        if ($("#real_time_sim_checkbox_id").val()){
            $("#real_time_sim_checkbox_id").jqxCheckBox({ checked: true })
        }
        else {
            $("#real_time_sim_checkbox_id").jqxCheckBox({ checked: false })
        }
        event.stopPropagation() //causes menu to not shrink up, so you can see the effect of your click
                            //AND causes the onclick for simulate_id to NOT be run.
    }*/
    insert_new_job_id.onclick = Editor.insert_new_job;
    set_menu_string(insert_new_job_id, "New Job", "j");

    eval_and_start_job_id.onclick = function(){
           open_doc(eval_and_start_job_doc_id);
           Job.start_job_menu_item_action();
    };


    insert_job_example0_id.onclick = function(){Editor.insert(job_examples[0]);};
    insert_job_example1_id.onclick = function(){Editor.insert(job_examples[1]);};
    insert_job_example2_id.onclick = function(){Editor.insert(job_examples[2]);};
    insert_job_example3_id.onclick = function(){Editor.insert(job_examples[3]);};
    insert_job_example4_id.onclick = function(){Editor.insert(job_examples[4]);};
    insert_job_example5_id.onclick = function(){Editor.insert(job_examples[5]);};
    insert_job_example6_id.onclick = function(){Editor.insert(job_examples[6]);};
    insert_job_example7_id.onclick = function(){Editor.insert(job_examples[7]);};
    insert_job_example8_id.onclick = function(){Editor.insert(job_examples[8]);};
    insert_job_example9_id.onclick = function(){Editor.insert(job_examples[9]);};
    insert_job_example10_id.onclick = function(){Editor.insert(job_examples[10]);};
    insert_job_example11_id.onclick = function(){Editor.insert(job_examples[11]);};
    insert_job_example12_id.onclick = function(){Editor.insert(job_examples[12]);};
    insert_job_example13_id.onclick = function(){Editor.insert(job_examples[13]);
                                                 open_doc("Control.loop_doc_id");};
    insert_job_example14_id.onclick = function(){Editor.insert(job_examples[14]);};

        //RUN INSTRUCTION
    move_to_home_id.onclick    = function(){ Robot.dexter0.move_all_joints_fn(); };
    move_to_neutral_id.onclick = function(){ Robot.dexter0.move_all_joints_fn(Dexter$1.NEUTRAL_ANGLES); };
    //move_to_parked_id.onclick  = function(){ Robot.dexter0.move_all_joints_fn(Dexter.PARKED_ANGLES) }  //not useful, sometimes Dexter runs into itself
    move_to_selection_id.onclick = Editor.move_to_instruction;
    /*function(){
         var sel = Editor.get_any_selection().trim()
         if (sel === "") {
            warning("There is no selection for a dexter0 instruction.")
            return
         }
         //selection could be [asdf] or 123 or 123,456 or foo or bar()
         //if it looks like numbers, wrap [] around them
         if (sel[0] !== "[") {
             if (is_digit(sel[0])) {
                sel = "[" + sel
                if (sel[sel.length - 1] !== "]") { sel = sel + "]" }
             }
         }
         try{  sel = eval(sel) }
         catch (err) { warning("The selection did not evaluate to an array.") }
         if (Array.isArray(sel)){
             if (sel.length == 0){
                warning("The selection is an empty array meaning it would have no effect.")
             }
             else if ((sel.length <= 3) && (typeof(sel[0]) == "number")){
                 Robot.dexter0.move_to_fn(sel)
             }
             else if ((sel.length <= 5) && (typeof(sel[0]) == "number")){
                 Robot.dexter0.move_all_joints_fn(sel)
             }
             else { Robot.dexter0.run_instruction_fn(sel) }
         }
         else if ((sel === undefined) ||
                  (sel === null) ||
                  (typeof(sel) == "boolean")){
             warning("The selection evals to undefined, null, or a boolean,<br/>" +
                     "neither of which are valid Job instructions.")
         }
         else { Robot.dexter0.run_instruction_fn(sel) }
    }*/
    set_menu_string(move_to_selection_id, "selection", "r");

    run_instruction_dialog_id.onclick = run_instruction;

    init_dxf_drawing_id.onclick = function(){
        var content =
`DXF.init_drawing({
    dxf_filepath: "choose_file",    //image to draw
    three_points: 
        [[0,  .55, 0.05],  //Point1 locates the drawing plane
         [0,   .4, 0.05],  //Point2
         [.15, .4, 0.05]], //Point3
    plane_normal_guess: [0, 0, 1],
    calc_plane_normal: false,
    tool_height: 5.08 * _cm,
    tool_length: 8.255 * _cm,
    DXF_units: undefined, //0.001 means each DXF distance unit is worth 1mm
                          //undefined means scale drawing to fit the three_points
    draw_speed:  1 * _cm/_s,
    draw_res:  0.5 * _mm, //Max step size of straight line
    lift_height: 1 * _cm, //distance above surface when pen is not drawing
    tool_action: false,
    tool_action_on_function: 
        function(){
		    return [make_ins("w", 64, 2),
					Dexter.dummy_move()]
		},
        tool_action_off_function: 
            function(){
                return [make_ins("w", 64, 0),
                        Dexter.dummy_move()]
        }})
`;
        Editor.insert(content);
        open_doc("DXF.init_drawing_doc_id");
    };

    //Jobs/Dexter Tools menu.
    browse_dexter_id.onclick     = function() {
        let url = "http://" + Dexter$1.default.ip_address;
        browse_page(url);
    };
    calibrate_id.onclick         = function() { init_calibrate(); };//defines 2 jobs and brings up calibrate dialog box

    dui2_id.onclick              = function() {
        Job.define_and_start_job(__dirname + "/user_tools/dexter_user_interface2.js");
    };
    ping_dexter_id.onclick       = function() { ping_a_dexter(); open_doc(ping_doc_id); };

    reboot_joints_id.onclick  = function(){
        open_doc("Dexter.reboot_joints_doc_id");
        Dexter$1.default.reboot_joints_fn(); //not an instruction, a function that creates a job and starts it
    };

    show_errors_log_id.onclick = function(){
        let path = "Dexter." + Dexter$1.default.name + ":/srv/samba/share/errors.log";
        read_file_async(path, undefined, function(err, data){
            if(err){
                dde_error("While attempting to get the content of " + path + "<br>" + err.message);
            }
            else {
                let content = data.toString();
                out("The content of " + path + " is:<pre>" + content + "</pre>");
            }
        });
    };
    dexter_start_options_id.onclick = show_dexter_start_options;

    update_firmware_id.onclick = FileTransfer.show_dialog;

    run_job_on_dexter_id.onclick = function() {
        let job_src = Editor.get_any_selection(); //we want to be able to select a Job def in
            //the doc pane and send it to Dexter.
        if(job_src == "") {
            job_src = Editor.get_javascript("auto"); //the normal case, get the whole editor buffer
        }
        Job.start_and_monitor_dexter_job(job_src);
    };

    show_messaging_dialog_id.onclick = function(){
        Messaging.show_dialog();
        open_doc("Messaging_id");
    };

    //cmd menu
    cd_up_id.onclick = function(){
        cmd_input_id.value = "cd ..";
        SSH.run_command({command:"cd ..;echo 'The new current directory is: ';pwd"});
    };
    date_id.onclick = function(){
        cmd_input_id.value = "date";
        SSH.run_command({command:"date"});
    };
    ssh_find_id.onclick = function(){
        out("<i>SSH <b>find</b> from / takes about 10 seconds.<br/>" +
            "The <b>-iname</b> option makes <b>find</b> case-insensitive,<br/>" +
            "whereas <b>-name</b> makes it case-sensitive.</i>");
        cmd_input_id.value = 'find / -iname "*partial_file_name_here*" -print';
        cmd_input_id.focus();
    };
    make_directory_id.onclick = function(){
        cmd_input_id.value = "mkdir " + SSH.dir_for_ls + "/[new dir name]";
        cmd_input_id.focus();
    };
    make_file_id.onclick = function(){
            cmd_input_id.value = "touch " + SSH.dir_for_ls + "/[new file name]";
        cmd_input_id.focus();
    };
    man_id.onclick = function(){
        cmd_input_id.value = "man -P cat [cmd name]";
        cmd_input_id.focus();
    };
    pwd_id.onclick = function(){
        cmd_input_id.value = "pwd";
        SSH.run_command({command:"pwd"});
    };
    show_directory_id.onclick = function(){
        cmd_input_id.value = SSH.show_dir_cmd;
        SSH.run_command({command:SSH.show_dir_cmd});
    };
    reboot_id.onclick = function() {
        cmd_input_id.value = "shutdown -r now";
        cmd_input_id.focus();
    };
    run_selected_cmd_id.onclick = function(){
        let cmds = Editor.get_javascript("auto").trim();
        if(cmds == ""){
            warning("There are no commands selected.");
        }
        else {
            let end_pos = cmds.indexOf(";");
            if (end_pos == -1) { end_pos = cmds.indexOf("\n"); }
            else { end_pos = cmds.length; }
            let cmd_to_show = cmds.substring(0, end_pos);
            cmd_input_id.value = cmd_to_show;
            SSH.run_command({command:cmds});
        }
    };
    whoami_id.onclick = function(){
        cmd_input_id.value = "whoami";
        SSH.run_command({command:"whoami"});
    };

    /*ping_id.onclick          = function(){ rde.ping()}
    cat_etc_hosts_id.onclick = function(){ rde.shell('cat /etc/hosts')}
    rosversion_id.onclick    = function(){ rde.shell('rosversion -d')}
    roswtf_id.onclick        = function(){ rde.shell('roswtf')}
    printenv_id.onclick      = function(){ rde.shell('printenv | grep ROS')}
    rqt_graph_id.onclick     = function(){ rde.shell('rqt_graph')}

    rosmsg_id.onclick        = function(){rde.shell('rosmsg list')}
    rosnode_id.onclick       = function(){rde.shell('rosnode list')}
    rospack_id.onclick       = function(){rde.shell('rospack list')}
    rosparam_id.onclick      = function(){rde.shell('rosparam list')}
    rosservice_is.onclick    = function(){rde.shell('rosservice list')}
    rostopic_id.onclick      = function(){rde.shell('rostopic list')}
    */
    clear_output_id.onclick  = function(){clear_output(); myCodeMirror.focus();};

    javascript_pane_help_id.onclick    = function(){ open_doc(javascript_pane_doc_id);  };
    output_pane_help_id.onclick        = function(){ open_doc(output_pane_doc_id);  };
    documentation_pane_help_id.onclick = function(){ open_doc(documentation_pane_doc_id);  };
    misc_pane_help_id.onclick          = function(){ open_doc(misc_pane_doc_id);  };

    //simulate pane
    demo_id.onclick          = function() {
                                    if (demo_id.innerHTML == "Demo") {
                                        demo_id.innerHTML = "Stop";
                                        show_in_misc_pane("Simulate Dexter");
                                        play_simulation_demo();
                                    }
                                    else {
                                          sim.enable_rendering = false;
                                          demo_id.innerHTML = "Demo";
                                    }
                               };
    inspect_dexter_details_id.onclick = function() { inspect(Dexter$1.default); };

    pause_id.onclick         = function (){
                                    if (pause_id.checked) { //it just got checked
                                           Job.go_button_state = false;
                                    }
                                    else { Job.go_button_state = true; }
                                 };
    go_id.onclick                 = Job.go;
    show_queue_id.onclick = Simqueue.show_queue_for_default_dexter;

    //misc_pane_menu_id.oninput            = show_in_misc_pane
    let misc_items = ['Simulate Dexter',
                      'Make Instruction',
                      'Dexter Photo',
                      'Haddington Website',
                      'Dexter Architecture',
                      'Reference Manual',
                      'Choose File',
                      'Reward Board'];
    $("#misc_pane_menu_id").jqxComboBox({ source: misc_items, width: '85%', height: '20px', dropDownHeight: '235px'});
    $('#misc_pane_menu_id').on('keypress', function (event) {
        if(event.code == "Enter"){
            var val = event.target.value;
            show_in_misc_pane(val);
        }
    });
    $('#misc_pane_menu_id').on('select', function (event) { //fired when user types a char, or chooses a menu item
        let args = event.args;
        if(args) {
            let item = $('#misc_pane_menu_id').jqxComboBox('getItem', args.index);
            if(item) {
                let val = item.value;
                if(val && (val !== misc_pane_menu_selection)) {
                    setTimeout(function() {
                        show_in_misc_pane(val);
                    }, 100);
                }
            }
        }
    });
   /* $('#misc_pane_menu_id').on('change', function (event) { //fired when programmatically the comb box value is set
        let args = event.args;
        if(args) {
            let item = $('#misc_pane_menu_id').jqxComboBox('getItem', args.index)
            if(item) {
                let val = item.value
                if(val) {
                    show_in_misc_pane(val)
                }
            }
        }
    })*/

    font_size_id.onclick = function(){
                             $(".CodeMirror").css("font-size", this.value + "px");
                             persistent_set("editor_font_size", this.value);
                           };
    $("#font_size_id").keyup(function(event){
            if(event.keyCode == 13){
                $(".CodeMirror").css("font-size", this.value + "px");
                persistent_set("editor_font_size", this.value);
            }
    });

    persistent_initialize(); //called before loading dde_init.js by design.
    Metrics.init();
    //set_dde_window_size_to_persistent_values() //obsolete now that main.js does this

    let val = persistent_get("save_on_eval");
    $("#save_on_eval_id").jqxCheckBox({ checked: val});

    //if(val) { //have to do this because, unlike the DOM doc, chrome/electron checks the box if you set it to false.
    //    save_on_eval_id.setAttribute("checked", val)
    //}
    //similar to animate ui
    save_on_eval_id.onclick = function(event){
        let val = $("#save_on_eval_id").val();
        persistent_set("save_on_eval", val);
        event.stopPropagation(); //causes menu to not shrink up, so you can see the effect of your click
    };

    save_on_eval_wrapper_id.onclick = function(event){
        let old_val = $("#save_on_eval_id").val();
        let new_val = !old_val;
        $("#save_on_eval_id").val(new_val);
        persistent_set("save_on_eval", new_val);
        event.stopPropagation();
    };

    val = persistent_get("default_out_code");
    if(val) { //have to do this because, unlike the DOM doc, chrome/electron checks the box if you set it to false.
        format_as_code_id.setAttribute("checked", val);
    }
    format_as_code_id.onclick = function(event) {
                                    let val = format_as_code_id.checked;
                                    persistent_set("default_out_code", val);
    };

    //this must be before dde_init_dot_js_initialize() so that when a robot is defined, it can go on the menu
    default_robot_name_menu_container_id.innerHTML = make_dexter_default_menu_html();

    PatchDDE.init();

    dde_init_dot_js_initialize();//must occcur after persistent_initialize
    copy_file_async(__dirname + "/core/main_eval.py", "main_eval.py"); //because using __dirname + "/core/main_eval.py"
        // in 2nd arg to spawn fails because spawn can't get a file out of the asar "folder".
        //So I need to call spawn with a normal path when the Python process is launched.
        //do this here so it will be ready by the time Py.init needs it.
    Dexter$1.default = (Dexter$1.dexter0 ?  Dexter$1.dexter0 : null );
    //initialize the checkbox state
    $("#animate_ui_checkbox_id").jqxCheckBox({ checked: persistent_get("animate_ui")});

    animate_ui_checkbox_id.onclick = function(event) {
        let val = $("#animate_ui_checkbox_id").val();
        persistent_set("animate_ui", val);
        event.stopPropagation(); //causes menu to not shrink up, so you can see the effect of your click
        //AND causes the onclick for simulate_id to NOT be run.
        adjust_animation();
    };
    //so that you don't have to hit the checkbox, just anywhere in the menu item to check/uncheck it
    animate_ui_checkbox_wrapper_id.onclick = function(event){
        let old_val = $("#animate_ui_checkbox_id").val();
        let new_val = !old_val;
        $("#animate_ui_checkbox_id").val(new_val);
        persistent_set("animate_ui", new_val);

        event.stopPropagation(); //causes menu to not shrink up, so you can see the effect of your click
        //AND causes the onclick for simulate_id to NOT be run.
        adjust_animation();
    };
    adjust_animation(); //to the peristent flag


    const editor_font_size = persistent_get("editor_font_size");
    $(".CodeMirror").css("font-size", editor_font_size + "px");
    font_size_id.value = editor_font_size;


    //init_ros_id.onclick = function(){
    //         init_ros_service_if_url_changed()
    //} //must occur after dde_init_doc_js_initialize  init_ros_service($("#dexter_url").val())
    // rde.ping() //rde.shell("date") //will show an error message
    Editor.restore_files_menu_paths_and_last_file();
     //simulate_help_id.onclick=function(){ open_doc(simulate_doc_id) }



    simulate_radio_true_id.onclick  = function(){
          persistent_set("default_dexter_simulate", true);   event.stopPropagation();
     };
     simulate_radio_false_id.onclick = function(){ persistent_set("default_dexter_simulate", false);  event.stopPropagation();};
     simulate_radio_both_id.onclick  = function(){ persistent_set("default_dexter_simulate", "both"); event.stopPropagation();};

     const sim_val = persistent_get("default_dexter_simulate");
     if      (sim_val === true)   { simulate_radio_true_id.checked  = true; }
     else if (sim_val === false)  { simulate_radio_false_id.checked = true; }
     else if (sim_val === "both") { simulate_radio_both_id.checked  = true; }

     set_left_panel_width(persistent_get("left_panel_width"));
     set_top_left_panel_height(persistent_get("top_left_panel_height"));
     set_top_right_panel_height(persistent_get("top_right_panel_height"));



     help_system_id.onclick = function(){
        //open_doc(help_system_doc_id)
         SplashScreen.show();
     };
     setTimeout(check_for_latest_release, 200);
     //setTimeout(function(){ out("For help on using DDE, click <b style='color:blue;font-size:20px;'>?</b> in the upper right <b style='font-size:24px;'>&#x279A;</b> .") }, 400)

     setTimeout(function() { SplashScreen.show_maybe(); }, 400);
     close_all_details(); //doc pane just show top level items.
     setTimeout(function(){
         show_in_misc_pane(persistent_get("misc_pane_content"));
     }, 200);
} //end of on_ready

function set_left_panel_width(width=700){
    $('#outer_splitter_id').jqxSplitter({ panels: [{ size: width }], splitBarSize: 8 }); //default splitbarsize is 5
}

function set_top_left_panel_height(height=600){
    $('#left_splitter_id').jqxSplitter({ panels: [{ size: height }], splitBarSize: 8 });
}

function set_top_right_panel_height(height=600){
    //out("set top right:" + height)
    $('#right_splitter_id').jqxSplitter({ panels: [{ size: height }], splitBarSize: 8  });
}

function check_for_latest_release(){
    let dde_version_html = "<a href='#' title='Click to scroll the doc pane to the release notes.' onclick='open_doc(release_notes_doc_id)'>" +
                            dde_version +
                            "</a>";
    latest_release_version_and_date(function(err, response, body){
        if(err){
            out("You're running DDE version: " + dde_version_html +
                " released: " + dde_release_date +
                "<br/>DDE can't reach the web to check for the latest release.");
        }
        else {
            const the_obj = JSON.parse(body);
            let ver       = the_obj.name;
            if (ver.startsWith("v")) { ver = ver.substring(1); }
            var ver_date  = the_obj.published_at;
            if (ver != dde_version){
                ver_date       = date_to_mmm_dd_yyyy(ver_date); //ver_date.substring(0, ver_date.indexOf("T"))
                out("The latest public beta version of DDE is: " + ver +
                        " released: " + ver_date +
                        "<div style='margin-left:135px;'>You're running version: " + dde_version_html +
                        " released: " + dde_release_date +
                        "</div><a href='#' onclick='open_doc(update_doc_id)'>How to update.</a>",
                        "#900dff");
                //open_doc(update_doc_id) //no real need to do this. user can already get to it
                //by clicking on the a tag in the above printout.
            }
            else { out("DDE is up to date with version: " + dde_version_html +
                        " released: " + dde_release_date);
            }
        }
    });
}

function make_dde_status_report(){
    let top = "Please describe your issue with DDE here:\n\n\n" +
              "__________________________________________________\n" +
              "Below are the contents of your Editor and Output panes\n"+
              "to help us with the context of your comment.\n" +
              "We won't use any software you send us without your permission,\n" +
              "but delete below whatever you want to protect or\n" +
              "what you think is not relevant to the issue.";
    let jobs_report = Job.active_jobs_report(); //ends with blank line
    let latest_eval_src = latest_eval_button_click_source;
    if(!latest_eval_src) { latest_eval_src = "The Eval button hasn't been clicked since DDE was launched."; }

    let editor_pane_content = Editor.get_javascript();

    let output = get_output();
    output = output.replace(/<br>/g, "\n");
    output = output.replace(/<p>/g,  "\n\n");
    output = output.replace(/<hr>/g, "_____________________________________\n");


    let result =
        "Dexter Development Environment Status Report\n" +
        "Date: " + date_to_human_string() + "\n" +
        "DDE Version: " + dde_version + "\n" +
        top +
        "\n\n________Active Jobs______________________________\n" +
        jobs_report +
        "\n\n________Latest Eval Button Click Source______________\n" +
        latest_eval_src +
        "\n\n________Editor Pane______________________________\n" +
        editor_pane_content +
        "\n\n________Output Pane_______________________________\n" +
        output;
    return result
}

/* never called
function quit_dde(){
    require('electron').remote.getCurrentWindow().close()
} */

//misc fns called in ready.js
function email_bug_report(){
    subj = "DDE Suggestion " + date_to_human_string();
    bod = encodeURIComponent(make_dde_status_report());
    window.open("mailto:cfry@hdrobotic.com?subject=" + subj + "&body=" + bod);
}
console.log("bottom of ready.js");
on_ready();

/*
var {get_output} = require("./core/out.js")
//var {Root} = require("./core/object_system.js") //should work but doesn't jan 13, 2019
var {convert_backslashes_to_slashes} = require("./core/storage.js")
var Coor  = require("./math/Coor.js")
var calibrate_build_tables = require("./low_level_dexter/calibrate_build_tables.js")
var Job   = require("./core/job.js")
var Gcode = require("./core/gcode.js")
var DXF   = require("./math/DXF.js")
var {date_to_human_string, date_to_mmm_dd_yyyy, is_digit} = require("./core/utils.js")
var {FPGA} = require("./core/fpga.js")
var {Simqueue} = require("./core/simqueue.js")
*/

//packages for package sake.
//pkg names that contain hyphens or dots have those chars converted to underscore

//var fs = require("fs_path")  //already declared
//the below boosts DDE memory usage on startup from 88MB to 237MB
//mac activity monitor with this installed:
// electron         49 +
// electron helper  36 +
// electron helper 315
/*
var fs_path = require("fs-path")
var is_base64 = require("is-base64")
var js_beautify = require("js-beautify")
var mathjs = require("mathjs")
var modbus_serial = require("modbus-serial")
var multicast_dns = require("multicast-dns")
var nano_time = require("nano-time")
var opencv_js = require("opencv.js")
// var ping = require("ping")  //already declared
var plotly_js_dist = require("plotly.js-dist")
//var pump = require("pump")  //already declared
//var request = require("request")  //already declared
var scp2 = require("scp2")
var semver = require("semver")
var serialport = require("serialport")
var simple_get = require("simple-get")
var ssh2_promise = require("ssh2-promise")
*/
//var three = require("three") doesn't increase mem usable, is UI

export { on_ready };
//# sourceMappingURL=bundle.js.map
